<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Du Yao&#39;s blog</title>
  <subtitle>Make progress step by step</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://duyao.github.io/"/>
  <updated>2017-06-17T04:17:01.000Z</updated>
  <id>http://duyao.github.io/</id>
  
  <author>
    <name>Du Yao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>zookeeper基础</title>
    <link href="http://duyao.github.io/2017/05/28/zookeeper%E5%9F%BA%E7%A1%80/"/>
    <id>http://duyao.github.io/2017/05/28/zookeeper基础/</id>
    <published>2017-05-28T08:40:02.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="zk介绍"><a href="#zk介绍" class="headerlink" title="zk介绍"></a>zk介绍</h1><blockquote>
<p>Zookeeper是Apache Hadoop的一个子项目，本质是一个分布式小文件系统，主要解决分布式系统应用中遇到的数据管理问题（一致性问题）：统一命名服务，状态同步服务，集群管理，分布式应用配置项的管理。</p>
</blockquote>
<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">stat path [watch]</td>
<td style="text-align:center">f</td>
</tr>
<tr>
<td style="text-align:center">set path data [version]</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">ls path [watch]</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">delquota [-n/-b] path</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">ls2 path [watch]</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">setAcl path acl</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">setquota -n/-b val path</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">history</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">redo cmdno</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">printwatches on/off</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">delete path [version]</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">sync path</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">listquota path</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">rmr path</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">get path [watch]</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">create [-s] [-e] path data acl</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">addauth scheme auth</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">quit</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">getAcl path</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">close</td>
<td style="text-align:center">stat</td>
</tr>
<tr>
<td style="text-align:center">connect host:port</td>
<td style="text-align:center">stat</td>
</tr>
</tbody>
</table>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/zk.png" alt="zk中的数据结构" title="">
                </div>
                <div class="image-caption">zk中的数据结构</div>
            </figure>
<ol>
<li>每个子目录项（比如图中的NameService）都被称为znode。<br>znode可以有子节点目录，并且每个znode都可以保存数据，但注意<code>EPHEMERAL</code>类型的目录节点不能有子节点目录。</li>
<li>znode是有版本的，每个znode中存储的数据可以有多个版本，也就是同一访问路径可以存储多份数据。</li>
<li>对于临时的znode，一旦创建这个znode的客户端与服务器失去联系，这个znode也将自动删除，Zookeeper的客户端和服务器通信采用长链接方式，每个客户端和服务器通过心跳来保持连接。</li>
<li>znode可以被监控，包括这个节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知监听的客户端，这个是Zookeeper的重要特性。</li>
</ol>
<h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><p>Zookeeper节点在创建后其类型不能被修改，有四种类型的节点:</p>
<ul>
<li><code>PERSISTENT</code><br>所谓持久节点，是指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点——不会因为创建该节点的客户端会话失效而消失。</li>
<li><code>PERSISTENT_SEQUENTIAL</code><br>这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在ZK中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的上限是整型的最大值。</li>
<li><code>EPHEMERAL</code><br>和持久节点不同的是，临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。</li>
<li><code>EPHEMERAL_SEQUENTIAL</code><br>ZK会自动为给定节点名的临时节点加上一个数字后缀，作为新的节点名。同持久顺序节点。</li>
</ul>
<h2 id="节点信息"><a href="#节点信息" class="headerlink" title="节点信息"></a>节点信息</h2><p>zookeeper目录中的每一个节点对应着一个znode，每个znode维护着一个属性结构，它包含数据的版本号、时间戳、等信息，同时每个Znode由3部分组成:<br>① stat：此为状态信息, 描述该Znode的版本, 权限等信息<br>② data：与该Znode关联的数据<br>③ children：该Znode下的子节点</p>
<p>Zookeeper就是通过这些属性来实现它特定的功能。每当znode的数据改变时，相应的版本号会增加，每当客户端查询、更新和删除数据时，也必须提供要被操作的znode版本号，如果所提供的数据版本号与实际的不匹配，那么将会操作失败。<br>节点属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 2] get /test</div><div class="line">123</div><div class="line">cZxid = 0x6</div><div class="line">ctime = Sun May 28 15:24:48 CST 2017</div><div class="line">mZxid = 0x6</div><div class="line">mtime = Sun May 28 15:24:48 CST 2017</div><div class="line">pZxid = 0x6</div><div class="line">cversion = 0</div><div class="line">dataVersion = 0</div><div class="line">aclVersion = 0</div><div class="line">ephemeralOwner = 0x0</div><div class="line">dataLength = 3</div><div class="line">numChildren = 0</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">cZxid</td>
<td style="text-align:center">节点被创建的zxid值</td>
</tr>
<tr>
<td style="text-align:center">ctime</td>
<td style="text-align:center">节点创建的时间</td>
</tr>
<tr>
<td style="text-align:center">mZxid</td>
<td style="text-align:center">节点被修改时zxid值</td>
</tr>
<tr>
<td style="text-align:center">mtime</td>
<td style="text-align:center">节点最后一次的修改时间</td>
</tr>
<tr>
<td style="text-align:center">pZxid</td>
<td style="text-align:center">最后一次更改该节点孩子的事务id</td>
</tr>
<tr>
<td style="text-align:center">cvesion</td>
<td style="text-align:center">节点所拥有的子节点被修改的版本号</td>
</tr>
<tr>
<td style="text-align:center">dataVersion</td>
<td style="text-align:center">数据版本</td>
</tr>
<tr>
<td style="text-align:center">aclVersion</td>
<td style="text-align:center">访问控制版本</td>
</tr>
<tr>
<td style="text-align:center">ephemeralOwner</td>
<td style="text-align:center">如果节点为临时节点，那么它的值为这个节点拥有者的session ID；负责它的值为0</td>
</tr>
<tr>
<td style="text-align:center">dataLength</td>
<td style="text-align:center">节点数据的长度</td>
</tr>
<tr>
<td style="text-align:center">numChildren</td>
<td style="text-align:center">节点拥有子节点的个数</td>
</tr>
</tbody>
</table>
<h2 id="watcher"><a href="#watcher" class="headerlink" title="watcher"></a>watcher</h2><h3 id="watcher监听器"><a href="#watcher监听器" class="headerlink" title="watcher监听器"></a>watcher监听器</h3><p>ZooKeeper中所有的读操作<code>getData()</code>,<code>getChildren()</code>和 <code>exists()</code>可以选择设置一个watcher。<br>还有在创建客户端对象实例时也可以设置watcher，<code>ZooKeeper(String connectString, int sessionTimeout, Watcher watcher)</code><br>ZooKeeper有两个监听器列表：数据监听和子节点监听:<code>getData()</code>和<code>exists()</code>设置数据监听器; <code>getChildren()</code>设置子节点监听器。<br>只能二选一，根据返回数据的类型来设置监听器。<code>getData()</code>和<code>exists()</code>返回节点的数据信息，然而<code>getChildren()</code>返回一个子节点列表。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/watcheraction.png" alt="设置监视器的操作及对应的触发器" title="">
                </div>
                <div class="image-caption">设置监视器的操作及对应的触发器</div>
            </figure><br>因此，setData()会触发数据监听器。一个成功的 create()会触发一个数据监听器。一个delete()会触发数据监听器和子节点监听器。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/watcherchanged.png" alt="wathcer的触发及改变" title="">
                </div>
                <div class="image-caption">wathcer的触发及改变</div>
            </figure></p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>1.<strong>Watches通知是一次性的</strong>，必须重复注册.<br>2.同一个ZK客户端，反复对同一个ZK节点（znode）注册相同的watcher，是无效的，<strong>最终只会有一个生效</strong>。<br>3.发生<code>CONNECTIONLOSS</code>之后，只要在<code>session_timeout</code>之内再次连接上（即不发生<code>SESSIONEXPIRED</code>），那么这个连接注册的watches依然在。<br>4.客户端会话失效之后，所有这个会话中创建的Watcher都会被移除。<br>5.节点数据的版本变化会触发<code>NodeDataChanged</code>，注意，这里特意说明了是版本变化。存在这样的情况，<strong>只要成功执行了setData()方法，无论内容是否和之前一致，都会触发NodeDataChanged事件</strong>。<br>6.对某个节点注册了watcher，但是<strong>节点被删除了，那么注册在这个节点上的watcher都会被移除</strong>。</p>
<h3 id="注册过程"><a href="#注册过程" class="headerlink" title="注册过程"></a>注册过程</h3><p>总体来说.可以概括为以下几个过程:<br>（1）客户端注册Watcher<br>（2）服务端处理Watcher<br>（3）客户端回调Watcher<br>首先需要了解一下zookeeper中的watchedevent结构，其包括三个基本属性：通知状态（keepstate）、事件类型（eventType）和节点路径（path）。<br>zookeeper使用watchedevent对象来封装服务端事件并传递给watcher，而实际传递的是watcherevent，其结构和watchedevent一样，<br><code>WatcherEvent</code> 实体实现了序列化接口，因此可以用于网络传输。数据结构如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Class WatcherEvent&#123;</div><div class="line">  type:int</div><div class="line">  state:int</div><div class="line">  path:String</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从这里可以看出，<strong>watcher事件只是一个简单的事件说明，并不包含事件的数据变更内容</strong>，这样能保证网络传输的高效性。<br>这里也体现出观察者模式中推拉结合，发生的变化被推送到观察者，此时观察者只知道发生了变化，只有靠拉才能知道到底发生了什么变化。</p>
<p><a href="http://blog.csdn.net/lionaiying/article/details/53915878" target="_blank" rel="external">http://blog.csdn.net/lionaiying/article/details/53915878</a></p>
<p><code>process()</code> 是 Watch 接口中的回调方法。当 ZooKeeper 向客户端发送一个 Watcher 时间通知时，客户端就会对相应的 process 方法进行回调，从而实现对事件的处理。 like this：syncNodes（）方法。<br><code>abstract public  void process ( WatchedEvent event )</code></p>
<p><a href="http://www.cnblogs.com/rocky24/p/4859206.html" target="_blank" rel="external">http://www.cnblogs.com/rocky24/p/4859206.html</a><br><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-apache-zookeeper-watcher/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/opensource/os-cn-apache-zookeeper-watcher/</a></p>
<h4 id="ServerCnxn类及cnxn对象"><a href="#ServerCnxn类及cnxn对象" class="headerlink" title="ServerCnxn类及cnxn对象"></a>ServerCnxn类及cnxn对象</h4><ul>
<li>Zk客户端与服务器之间的tcp连接</li>
<li>实现了watcher接口<br>总结：既包含了连接信息又包了watcher信息<h4 id="watchManager"><a href="#watchManager" class="headerlink" title="watchManager"></a>watchManager</h4></li>
<li>Zk服务器端Watcher的管理者</li>
<li>从两个维度维护watcher<br>• watchTable:从数据节点的粒度来维护<br>• watch2Paths从watcher的粒度来维护</li>
<li>负责watcher事件的触发<h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><code>Scheme:id:permission</code><br>比如<code>world:anyone:crdwa</code></li>
<li>Scheme:验证过程中使用的检验策略</li>
<li>Id:权限被赋予的对象，比如ip或者某个用户</li>
<li>Permission:权限，Ї面的crdwa，表示五个权限组合<br>通过<code>setAcl</code>命令置节点的权限,<code>getAcl</code>可以查看节点的Acl信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[zk: localhost:2181(CONNECTED) 8] setAcl /test world:anyone:ca</div><div class="line">cZxid = 0x6</div><div class="line">ctime = Sun May 28 15:24:48 CST 2017</div><div class="line">mZxid = 0x6</div><div class="line">mtime = Sun May 28 15:24:48 CST 2017</div><div class="line">pZxid = 0xa</div><div class="line">cversion = 1</div><div class="line">dataVersion = 0</div><div class="line">aclVersion = 1</div><div class="line">ephemeralOwner = 0x0</div><div class="line">dataLength = 3</div><div class="line">numChildren = 1</div><div class="line">[zk: localhost:2181(CONNECTED) 9] getAcl /test</div><div class="line">&apos;world,&apos;anyone</div><div class="line">: ca</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>节点的acl不具有继承关系</strong></p>
<h3 id="Scheme类型"><a href="#Scheme类型" class="headerlink" title="Scheme类型"></a>Scheme类型</h3><h4 id="world"><a href="#world" class="headerlink" title="world"></a>world</h4><p>Id的固定值为anyone，表示任何用户<br><code>world:anyone:crdwa</code>表示任何用户都Ӏ有crdwa权限</p>
<h4 id="auth"><a href="#auth" class="headerlink" title="auth"></a>auth</h4><p><code>auth:username:password:crdwa</code><br>表示给<strong>认证通过的所有用户</strong>设置acl权限，同时可以添加多个用户<br>通过addauth命令进行认证用户的添加<code>addauth digest &lt;username&gt;:&lt;password&gt;</code><br>Auth策略的本质就是digest<br>如果通过addauth创建多组用户和密码，当使用setAcl修改权限时，所有的用户和密码的权限都会跟着修改<br>通过addauth新创建的用户和密码组需要重新调用setAcl才会加入到权限组中去</p>
<h4 id="digest"><a href="#digest" class="headerlink" title="digest"></a>digest</h4><p><code>Scheme:id:permission</code>，比如 <code>digest:username:password:crdwa</code><br>指定某个用户及它的密码可以访问<br>这里的<code>username:password</code>必须<strong>经过SHA-1和BASE64编码</strong>，即<code>BASE64(SHA1(username:password))</code><br>通过addauth命令进行认证用户的添加<code>addauth digest &lt;username&gt;:&lt;password&gt;</code></p>
<h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p><code>Scheme:id:permission</code> ，比如 <code>ip:127.0.0.1:crdwa</code><br>指定某个ip地址可以访问</p>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4><p>供运维人员维护节点使用<br>有权限操作任何节点<br>启动时，在命令参数中配置</p>
<ul>
<li><code>-Dzookeeper.DigestAuthenticationProvider.superDigest=admin:015uTByzA4zSglcmseJsxTo7n3c=</code></li>
<li>打开zkCli.cmd，在java命令后添加以上配置<br>用户名和密码也需要通过sha1和base64编码<br><a href="https://holynull.gitbooks.io/zookeeper/content/cao_zuo_operations.html" target="_blank" rel="external">https://holynull.gitbooks.io/zookeeper/content/cao_zuo_operations.html</a><h1 id="zk用途"><a href="#zk用途" class="headerlink" title="zk用途"></a>zk用途</h1><h1 id="zk原理"><a href="#zk原理" class="headerlink" title="zk原理"></a>zk原理</h1>Zookeeper集群的特点</li>
<li>是一种对等集群，所有节点的数据都一样</li>
<li>集群节点之间靠心跳感知彼此的存在</li>
<li>所有写操作都在主节点，其他节点只能读，虽然可以接收写请求，但是内部会把写操作转给主节点</li>
<li>通过选举机制选出主节点，从而保障了主节点的高可用</li>
<li>至少少3个节点，必须是奇数个节点(与选举算法相关)</li>
<li>当一半以上的节点数据写入ۨ成功，则返回写入ۨ成功，是最终一致性的策略</li>
</ul>
<h2 id="ZAB协议"><a href="#ZAB协议" class="headerlink" title="ZAB协议"></a>ZAB协议</h2><p>ZooKeeper Atomic Broadcast即ZooKeeper原子消息广播协议，简称ZAB</p>
<ul>
<li>选举过程需要依赖ZAB协议</li>
<li>数据写入过程也需要ZAB协议</li>
<li>ZAB的核心是定义了那些会改变zk服务器数据状态的请求的处理方式</li>
</ul>
<p>所有事物请求必须由一个全局唯一的服务器来协调处理，该服务器被称Leader服务器，而剩余的其它服务器则称为Follower服务器。<br>Leader服务器负责将一个客户端事物请求转换成那个一个事物Proposa，并将该Proposal分发给集群中所有的Follower服务器。<br>之后Leader服务器需要等待所有Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，那么Leader就会再次向所有的Follower服务器分发Commit消息，要求其将前一个Proposal进行提交。</p>
<h3 id="服务器角色"><a href="#服务器角色" class="headerlink" title="服务器角色"></a>服务器角色</h3><p>Leader</p>
<ul>
<li>事物请求的唯一调度和处理者，保证集群事物处理的顺序性</li>
<li>集群内部各服务器的调度者<br>Follower</li>
<li>处理客户端非事物请求，转发事物请求给Leader服务器</li>
<li>参与事物请求Proposal的投票</li>
<li>参与Leader选举投票<br>Observer</li>
<li>处理客户端非事物请求，转发事物请求给Leader服务器</li>
<li>不参与任何形式的投票，包括选举和事物投票超过半数确认</li>
<li>此角色在通常是为了提高读性能</li>
</ul>
<p>服务器状态<br>LOOKING</p>
<ul>
<li>寻找Leader状态</li>
<li>当服务器处于此状态时，表示当前没有Leader，需要进入选举流程<br>FOLLOWING</li>
<li>跟随者状态，表明当前服务器角色是Follower<br>OBSERVING</li>
<li>观察者状态，表明当前服务器角色ОObserver<br>LEADING</li>
<li>领导者状态，表明当前服务器角色ОLeader<h3 id="ZAB协议三阶段"><a href="#ZAB协议三阶段" class="headerlink" title="ZAB协议三阶段"></a>ZAB协议三阶段</h3></li>
<li>发现Discovery，即选举Leader过程</li>
<li>同步Synchronization，选举出新的Leader后，Follwer或者Observer从Leader同步最新的数据</li>
<li>广播，同步完成后，就可以接收客户端新的事物请求，并进行消息广播，实现数据在集群节点的副本存储<h3 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h3>基于TCP协议</li>
<li>О了避免୍复创建两个节点之间的tcp连接，zk按照myid数值方向来建立连接，即小数的节点发起大的<br>节点连接，比如idО1的向idО2的发起tcp连接<br> 多端口</li>
<li>配置中第一个端口是通信和数据同࠵端口，默认是2888</li>
<li>第и个端口是投票端口，默认是3888</li>
</ul>
<p>只支持FastLeaderElection的tcp协议版本的选举算法</p>
<h2 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h2><h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>Curator介绍</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;zk介绍&quot;&gt;&lt;a href=&quot;#zk介绍&quot; class=&quot;headerlink&quot; title=&quot;zk介绍&quot;&gt;&lt;/a&gt;zk介绍&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Zookeeper是Apache Hadoop的一个子项目，本质是一个分布式小文件系统，主要解决分
    
    </summary>
    
      <category term="note" scheme="http://duyao.github.io/categories/note/"/>
    
    
      <category term="zookeeper" scheme="http://duyao.github.io/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>多线程面试题目</title>
    <link href="http://duyao.github.io/2017/05/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE/"/>
    <id>http://duyao.github.io/2017/05/24/多线程面试题目/</id>
    <published>2017-05-24T14:25:04.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h1><blockquote>
<p>Q1 如何让两个线程按照指定方式有序交叉运行<br>假设有两个线程，一个是线程 A，另一个是线程 B，两个线程分别依次打印 1-3 三个数字即可</p>
<p>Q2 编写程序实现,子线程循环10次,接着主线程循环20次,接着再子线程循环10次,主线程循环20次,如此反复,循环50次.</p>
</blockquote>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><blockquote>
<p>Q3 设计四个线程,其中两个线程每次对变量i加1,另外两个线程每次对i减1.</p>
<h1 id="生产者-消费者"><a href="#生产者-消费者" class="headerlink" title="生产者-消费者"></a>生产者-消费者</h1><p>#<br>现有的程序代码模拟产生了16个日志对象，并且需要运行16秒才能打印完这些日志，请在程序中增加4个线程去调用parseLog()方法来分头打印这16个日志对象，程序只需要运行4秒即可打印完这些日志对象。</p>
<h1 id="编写死锁"><a href="#编写死锁" class="headerlink" title="编写死锁"></a>编写死锁</h1><h1 id="join"><a href="#join" class="headerlink" title="join"></a>join</h1><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p><a href="http://www.importnew.com/12773.html" target="_blank" rel="external">http://www.importnew.com/12773.html</a><br><a href="http://ifeve.com/15-java-faq/" target="_blank" rel="external">http://ifeve.com/15-java-faq/</a><br><a href="http://www.cnblogs.com/fingerboy/p/5352880.html" target="_blank" rel="external">http://www.cnblogs.com/fingerboy/p/5352880.html</a><br><a href="http://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/" target="_blank" rel="external">http://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;wait和notify&quot;&gt;&lt;a href=&quot;#wait和notify&quot; class=&quot;headerlink&quot; title=&quot;wait和notify&quot;&gt;&lt;/a&gt;wait和notify&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Q1 如何让两个线程按照指定方式有序交叉运
    
    </summary>
    
      <category term="note" scheme="http://duyao.github.io/categories/note/"/>
    
    
      <category term="java" scheme="http://duyao.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>背包问题</title>
    <link href="http://duyao.github.io/2017/05/15/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://duyao.github.io/2017/05/15/背包问题/</id>
    <published>2017-05-15T02:50:12.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。</p>
<p>用子问题定义状态：即<code>f[i][v]</code>表示<strong>前i件物品恰放入一个容量为v的背包可以获得的最大价值</strong>。则其状态转移方程便是：<br><code>f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}</code></p>
<p>“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。<br>如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为f[i-1][v]；<br>如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，此时能获得的最大价值就是f[i-1][v-c[i]]再加上通过放入第i件物品获得的价值w[i]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//O(NV)</div><div class="line">f[0][0 ~ V] = 0;</div><div class="line">for(int i = 1; i &lt;= n; ++i)</div><div class="line">    for(int j = 0; j &lt;= V; ++j)</div><div class="line">        if(j &lt; w[i]) f[i][j] = f[i - 1][j];</div><div class="line">        else f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]);</div></pre></td></tr></table></figure></p>
<h2 id="优化空间复杂度"><a href="#优化空间复杂度" class="headerlink" title="优化空间复杂度"></a>优化空间复杂度</h2><p>以上方法的时间和空间复杂度均为O(VN)，其中时间复杂度应该已经不能再优化了，但空间复杂度却可以优化到O。</p>
<p>先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。<br>那么，如果只用一个数组f[0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？<br>f[i][v]是由f[i-1][v]和f[i-1][v-c[i]]两个子问题递推而来，能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v-c[i]]的值呢？<br>事实上，这要求在每次主循环中我们以<strong>v=V..0</strong>的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i-1][v-c[i]]的值。伪代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for i=1..N</div><div class="line">    for v=V..0</div><div class="line">        f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</div></pre></td></tr></table></figure></p>
<p>其中的<code>f[v]=max{f[v],f[v-c[i]]}</code>一句恰就相当于我们的转移方程<code>f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]}</code>，因为现在的<code>f[v-c[i]]</code>就相当于原来的<code>f[i-1][v-c[i]]</code>。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了<code>f[i][v]</code>由<code>f[i][v-c[i]]</code>推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//O(NV) 滚动数组</div><div class="line">f[0 ~ V] = 0;</div><div class="line">for(int i = 1; i &lt;= n; ++i)</div><div class="line">    for(int j = V; j &gt;= w[i]; --j)</div><div class="line">        f[j] = max(f[j], f[j - w[i]] + v[i]);</div></pre></td></tr></table></figure></p>
<h2 id="一个常数优化"><a href="#一个常数优化" class="headerlink" title="一个常数优化"></a>一个常数优化</h2><p>前面的伪代码中有 for v=V..1，可以将这个循环的下限进行改进。</p>
<p>由于只需要最后f[v]的值，倒推前一个物品，其实只要知道f[v-w[n]]即可。以此类推，对以第j个背包，其实只需要知道到f[v-sum{w[j..n]}]即可，即代码中的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for i=1..N</div><div class="line">    for v=V..0</div></pre></td></tr></table></figure></p>
<p>可以改成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for i=1..n</div><div class="line">    bound=max&#123;V-sum&#123;w[i..n]&#125;,c[i]&#125;</div><div class="line">    for v=V..bound</div></pre></td></tr></table></figure></p>
<p>这对于V比较大时是有用的。</p>
<h2 id="例题及代码"><a href="#例题及代码" class="headerlink" title="例题及代码"></a>例题及代码</h2><p><a href="http://www.lintcode.com/zh-cn/problem/backpack-ii/" target="_blank" rel="external">http://www.lintcode.com/zh-cn/problem/backpack-ii/</a><br>二维数组法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ZeroOnePack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span> V[])</span> </span>&#123;</div><div class="line">    <span class="comment">//m背包体积,A体积，V价值</span></div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length + <span class="number">1</span>][m + <span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.length; i++) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</div><div class="line">            <span class="keyword">if</span> (j &gt;= A[i - <span class="number">1</span>]) &#123;</div><div class="line">                dp[i][j] = Math.max(V[i - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j - A[i - <span class="number">1</span>]], dp[i - <span class="number">1</span>][j]);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// System.out.println(Arrays.deepToString(dp));</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> dp[A.length][m];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一维数组法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ZeroOnePack</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span>[] A, <span class="keyword">int</span> V[])</span> </span>&#123;</div><div class="line">    <span class="comment">//m背包体积,A体积，V价值</span></div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m + <span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.length; i++) &#123;</div><div class="line">      <span class="comment">//逆序</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = m; j &gt;= <span class="number">0</span>; j--) &#123;</div><div class="line">            <span class="keyword">if</span> (j &gt;= A[i - <span class="number">1</span>]) &#123;</div><div class="line">                dp[j] = Math.max(V[i - <span class="number">1</span>] + dp[j - A[i - <span class="number">1</span>]], dp[j]);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">              <span class="comment">//这里后面的dp[j]代表的是dp[i-1][j]，即没有上一行的数值</span></div><div class="line">                dp[j] = dp[j];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// System.out.println(Arrays.deepToString(dp));</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> dp[m];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<h2 id="基本思路-1"><a href="#基本思路-1" class="headerlink" title="基本思路"></a>基本思路</h2><p>这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令<code>f[i][v]</code>表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：</p>
<p><code>f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;=v}</code></p>
<p>这跟01背包问题一样有O(VN)个状态需要求解，但求解每个状态的时间已经不是常数了，求解状态<code>f[i][v]</code>的时间是O(v/c[i])，总的复杂度可以认为是O(V*Σ(V/c[i]))，是比较大的。</p>
<h2 id="转化为01背包问题求解"><a href="#转化为01背包问题求解" class="headerlink" title="转化为01背包问题求解"></a>转化为01背包问题求解</h2><p>既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选V/c[i]件，于是可以把第i种物品转化为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。</p>
<p>更高效的转化方法是：把第i种物品拆成费用为<code>c[i]*2^k</code>、价值为<code>w[i]*2^k</code>的若干件物品，其中k满足<code>c[i]*2^k&lt;=V</code>。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个<code>2^k</code>件物品的和。这样把每种物品拆成O(log V/c[i])件物品，是一个很大的改进。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//O(NVK)</span></div><div class="line">f[<span class="number">0</span>][<span class="number">0</span> ~ V] = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; ++j)</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k * w[i] &lt;= j; ++k)</div><div class="line">            f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - k * w[i]] + k * v[i]);</div></pre></td></tr></table></figure></p>
<h2 id="O-VN-的算法"><a href="#O-VN-的算法" class="headerlink" title="O(VN)的算法"></a>O(VN)的算法</h2><p>这个算法使用一维数组，先看伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for i=1..N</div><div class="line">    for v=0..V</div><div class="line">        f[v]=max&#123;f[v],f[v-cost]+weight&#125;</div></pre></td></tr></table></figure></p>
<p>你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态<code>f[i][v]</code>是由状态<code>f[i-1][v-c[i]]</code>递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果<code>f[i-1][v-c[i]]</code>。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果<code>f[i][v-c[i]]</code>，所以就可以并且必须采用v=0..V的顺序循环。这就是这个简单的程序为何成立的道理。</p>
<p>值得一提的是，上面的伪代码中两层for循环的次序可以颠倒。这个结论有可能会带来算法时间常数上的优化。</p>
<p>这个算法也可以以另外的思路得出。例如，将基本思路中求解<code>f[i][v-c[i]]</code>的状态转移方程显式地写出来，代入原方程中，会发现该方程可以等价地变形成这种形式：<br><code>f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}</code><br>将这个方程用一维数组实现，便得到了上面的伪代码。</p>
<p>最后抽象出处理一件完全背包类物品的过程伪代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//O(NV)</div><div class="line">f[0][0 ~ V] = 0;</div><div class="line">for(int i = 1; i &lt;= n; ++i)</div><div class="line">    for(int j = 0; j &lt;= V; ++j)</div><div class="line">        if(j &lt; w[i]) f[i][j] = f[i - 1][j];</div><div class="line">        else f[i][j] = max(f[i - 1][j], f[i][j - w[i]] + v[i]);</div><div class="line"></div><div class="line">//O(NV) 滚动数组</div><div class="line">f[0 ~ V] = 0;</div><div class="line">for(int i = 1; i &lt;= n; ++i)</div><div class="line">    for(int j = w[i]; j &lt;= V; ++j)</div><div class="line">        f[j] = max(f[j], f[j - w[i]] + v[i]);</div></pre></td></tr></table></figure></p>
<h1 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。</p>
<h2 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h2><p>这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有n[i]+1种策略：取0件，取1件……取n[i]件。令<code>f[i][v]</code>表示前i种物品恰放入一个容量为v的背包的最大权值，则有状态转移方程：</p>
<p><code>f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k&lt;=n[i]}</code></p>
<p>复杂度是O(V*Σn[i])。</p>
<h2 id="转化为01背包问题"><a href="#转化为01背包问题" class="headerlink" title="转化为01背包问题"></a>转化为01背包问题</h2><p>另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成n[i]件01背包中的物品，则得到了物品数为Σn[i]的01背包问题，直接求解，复杂度仍然是O(V*Σn[i])。</p>
<p>但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//O(NVK)</div><div class="line">f[0][0 ~ V] = 0;</div><div class="line">for(int i = 1; i &lt;= n; ++i)</div><div class="line">    for(int j = 0; j &lt;= V; ++j)</div><div class="line">        for(int k = 0; k &lt;= c[i] &amp;&amp; k * w[i] &lt;= j; ++k)</div><div class="line">            f[i][j] = max(f[i][j], f[i - 1][j - k * w[i]] + k * v[i]);</div><div class="line"></div><div class="line">//O(NVK)</div><div class="line">f[0 ~ V] = 0;</div><div class="line">for(int i = 1; i &lt;= n; ++i)</div><div class="line">    for(int j = V; j &gt;= 0; --j)</div><div class="line">        for(int k = 1; k &lt;= c[i] &amp;&amp; k * w[i] &lt;= j; ++k)</div><div class="line">            f[j] = max(f[j], f[j - k * w[i]] + k * v[i]);</div></pre></td></tr></table></figure>
<h2 id="多重背包的优化"><a href="#多重背包的优化" class="headerlink" title="多重背包的优化"></a>多重背包的优化</h2><p>二进制优化</p>
<p>ci=1+2+4+⋯+2^k+a, 0≤a<2^k+1 1,="" 2,="" 4,="" ⋯,="" 2k可以表示0∼2k+1−1的整数，基于二进制表示1,="" 2^k可以表示0∼2^(k+1)−1的整数，基于二进制表示="" 再由a即可得到0∼ci的所有整数了再由a即可得到0∼ci的所有整数了="" 这样物品个数由ci个变为logci个，时间复杂度即为o(nvlogk)="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//O(NVlogK)</div><div class="line">f[0 ~ V] = 0;</div><div class="line">for(int i = 1; i &lt;= n; ++i)&#123;</div><div class="line">    int num = c[i];</div><div class="line">    for(int k = 1; num &gt; 0; k &lt;&lt;= 1)&#123;</div><div class="line">        int mul = min(k, num);</div><div class="line">        for(int j = V; mul * w[i] &lt;= j; --j)&#123;</div><div class="line">            f[i] = max(f[j], f[j - mul * w[i]] + mul * v[i])</div><div class="line">        &#125;</div><div class="line">        num -= mul;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></2^k+1></p>
<h1 id="初始化的细节问题"><a href="#初始化的细节问题" class="headerlink" title="初始化的细节问题"></a>初始化的细节问题</h1><p>我们看到的求最优解的背包问题题目中，事实上有两种不太相同的问法。<br>有的题目要求“恰好装满背包”时的最优解，有的题目则并没有要求必须把背包装满。<br>一种区别这两种问法的实现方法是在初始化的时候有所不同。</p>
<p><strong>如果要求恰好装满背包，那么在初始化时除了f[0]为0其它f[1..V]均设为-∞，这样就可以保证最终得到的f[N]是一种恰好装满背包的最优解。</strong></p>
<p><strong>如果并没有要求必须把背包装满，而是只希望价格尽量大，初始化时应该将f[0..V]全部设为0。</strong></p>
<p>为什么呢？可以这样理解：初始化的f数组事实上就是在没有任何物品可以放入背包时的合法状态。如果要求背包恰好装满，那么此时只有容量为0的背包可能被价值为0的nothing“恰好装满”，其它容量的背包均没有合法的解，属于未定义的状态，它们的值就都应该是-∞了。如果背包并非必须被装满，那么任何容量的背包都有一个合法解“什么都不装”，这个解的价值为0，所以初始时状态的值也就全部为0了。</p>
<p><a href="http://love-oriented.com/pack/" target="_blank" rel="external">http://love-oriented.com/pack/</a><br><a href="http://taosama.com/2016/05/18/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%8801%E8%83%8C%E5%8C%85%E3%80%81%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E3%80%81%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%EF%BC%89/" target="_blank" rel="external">http://taosama.com/2016/05/18/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%8801%E8%83%8C%E5%8C%85%E3%80%81%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E3%80%81%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85%EF%BC%89/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;01背包问题&quot;&gt;&lt;a href=&quot;#01背包问题&quot; class=&quot;headerlink&quot; title=&quot;01背包问题&quot;&gt;&lt;/a&gt;01背包问题&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;
    
    </summary>
    
      <category term="note" scheme="http://duyao.github.io/categories/note/"/>
    
    
      <category term="algorithm" scheme="http://duyao.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="http://duyao.github.io/2017/05/12/Java%E6%B3%A8%E8%A7%A3/"/>
    <id>http://duyao.github.io/2017/05/12/Java注解/</id>
    <published>2017-05-12T10:59:43.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="源码注解"><a href="#源码注解" class="headerlink" title="源码注解"></a>源码注解</h2><p>只存在于源码中，编译时就没有了，即class文件无注解</p>
<h2 id="编译时注解"><a href="#编译时注解" class="headerlink" title="编译时注解"></a>编译时注解</h2><p>注解在源码和class文件都在,比如<code>Override</code></p>
<h2 id="运行时注解"><a href="#运行时注解" class="headerlink" title="运行时注解"></a>运行时注解</h2><p>运行阶段起作用，甚至影响运行时的逻辑，比如<code>Autowired</code></p>
<h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><h2 id="语法要求"><a href="#语法要求" class="headerlink" title="语法要求"></a>语法要求</h2><p>必须使用<code>@interface</code>关键字<br>成员函数无参数无异常，同时可以指定默认值，形式类似于接口声明方法<br>成员类型是受限制的，只能是原始数据类型或者String、Class、Annotation、Enumerattion<br>如果只有一个成员，那么成员必须是<code>String value();</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//作用域</span></div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD,ElementType.FIELD&#125;)</div><div class="line"><span class="comment">//声明周期</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="comment">//可以继承，但是只用类，不用于接口</span></div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="comment">//生成javadoc中存在该注解</span></div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Description &#123;</div><div class="line">    String desc = <span class="keyword">null</span>;</div><div class="line">    <span class="function">String <span class="title">author</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 18</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//使用</span></div><div class="line"><span class="meta">@Description</span>(desc=<span class="string">"desc"</span>,author=<span class="string">"amy"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> fun &#123;</div><div class="line">    String desc = <span class="keyword">null</span>;</div><div class="line">    <span class="function">String <span class="title">author</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 18</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分类&quot;&gt;&lt;a href=&quot;#分类&quot; class=&quot;headerlink&quot; title=&quot;分类&quot;&gt;&lt;/a&gt;分类&lt;/h1&gt;&lt;h2 id=&quot;源码注解&quot;&gt;&lt;a href=&quot;#源码注解&quot; class=&quot;headerlink&quot; title=&quot;源码注解&quot;&gt;&lt;/a&gt;源码注解&lt;/h
    
    </summary>
    
      <category term="note" scheme="http://duyao.github.io/categories/note/"/>
    
    
      <category term="java" scheme="http://duyao.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-策略模式和模板方法模式</title>
    <link href="http://duyao.github.io/2017/05/08/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://duyao.github.io/2017/05/08/设计模式-策略模式和模板方法模式/</id>
    <published>2017-05-08T09:10:19.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>策略模式就是要应对规则变化和新规则加入对程序带来的影响。<br>比如实现一个fly方法有很多种方式，可以做火箭飞、可以带翅膀飞等，那么当添加新的方式的时候可有选择以下方案：<br>1、继承：<br>即将设计一个抽象类，里面有这个fly的抽象方法</p>
<ul>
<li>父类提供该实现方法，简单易用，不具有灵活性，支持性差，因为子类需要重写该父类方法，有可能忘记重写</li>
<li>父类中实现一个抽象方法，每个类都要实现，不能复用代码</li>
</ul>
<p>2、组合：<br>将fly设计成为接口，使得父类持有该接口， 并由接口代理飞行</p>
<ul>
<li>多用组合少用继承</li>
<li>has-a的概念</li>
<li>足够灵活，复用代码</li>
</ul>
<p>可以得到结论：优先使用组合方式，将不变部分抽象为接口，面向接口而不是面向继承，从而达到多用组合少用继承的目的</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>1、分离变化得到接口<br>2、策略的实现类：实现一些不同的策略<br>3、客户端持有该策略的对象<br>4、在客户端正确的组合和这些策略<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/strategy.jpg" alt="策略模式" title="">
                </div>
                <div class="image-caption">策略模式</div>
            </figure></p>
<h2 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h2><p>优点：</p>
<ul>
<li>使用组合，架构灵活</li>
<li>富有弹性，较好的应对变化</li>
<li>代码复用性好（相对继承）</li>
<li>消除大量的条件语句</li>
</ul>
<p>缺点：</p>
<ul>
<li>客户端需要了解每个策略细节，因为每个客户端要选择自己适合的策略</li>
<li>增加策略就要增加对象，这样就增加了对象的数目</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>什么情况适合策略模式：</p>
<ul>
<li>许多相关的类仅仅是行为差异</li>
<li>运行时选取不同的算法变体</li>
<li>通过条件语句在多个分支中选取一个</li>
</ul>
<p>在java中以下方法使用了策略模式：</p>
<h3 id="sort方法"><a href="#sort方法" class="headerlink" title="sort方法"></a>sort方法</h3><ul>
<li>Java.util.Collections#sort(List list, Comparator &lt; ? super T &gt; c)</li>
<li>java.util.Arrays#sort(T[], Comparator &lt; ? super T &gt; c)</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/javasort.png" alt="sort方法" title="">
                </div>
                <div class="image-caption">sort方法</div>
            </figure>
<p>Context：是实际调用排序的代码，即Collections的类。可以看到，默认使用了TimSort进行排序，排序的算法与对象的compare具体实现无关。<br>Strategy：即具体的对象比较接口，Comparator。<br>ConcreteStrategy：具体的比较算法，通过Comparator实现。例如实现大小写敏感、大小写不敏感或任意规则的比对。</p>
<h3 id="线程池的排队和拒绝策略"><a href="#线程池的排队和拒绝策略" class="headerlink" title="线程池的排队和拒绝策略"></a>线程池的排队和拒绝策略</h3><ul>
<li>ThreadPoolExecutor中的ThreadFactory和RejectedExecutionHandler</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/javaexecutor.png" alt="线程池的排队和拒绝策略" title="">
                </div>
                <div class="image-caption">线程池的排队和拒绝策略</div>
            </figure>
<p>Context：ThreadPoolExecutor实际执行的方法execute()。按照用户设定的排队策略和拒绝任务的处理策略执行。<br>Strategy：这里排队策略和拒绝任务的处理策略提供了各自的接口，分别是BlockingQueue<e>和RejectedExecutionHandler。<br>ConcreteStrategy：具体的排队策略和拒绝任务的处理策略，JDK中都提供了默认的实现方法。可以实现接口自定义策略进行扩展。</e></p>
<p><a href="http://www.importnew.com/12690.html" target="_blank" rel="external">http://www.importnew.com/12690.html</a><br><a href="http://www.importnew.com/12853.html" target="_blank" rel="external">http://www.importnew.com/12853.html</a><br><a href="http://www.cnblogs.com/zuoxiaolong/p/pattern8.html" target="_blank" rel="external">http://www.cnblogs.com/zuoxiaolong/p/pattern8.html</a></p>
<h1 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h1><p>所谓模板方法模式就是在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。<br>模板方法模式就是基于继承的代码复用技术的。在模板方法模式中，我们可以将相同部分的代码放在父类中，而将不同的代码放入不同的子类中。</p>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/template.jpg" alt="模板方法模式" title="">
                </div>
                <div class="image-caption">模板方法模式</div>
            </figure>
<p>抽象基类：定义了一个算法的步骤，这个方法一定是final的，因为所有的子类都是这么实现的，不允许子类改变，还有：定义了基本方法(每个子类都是这么实现的)和抽象方法(每个子类实现方式不同，abstract修饰无方法体)以及钩子函数(这个方法有个默认实现，同时也可以由子类实现，用于判断是否执行某些方法，protect修饰有方法体)<br>实现子类：重写抽象基类的protect方法，即抽象方法和钩子函数<br><a href="http://www.importnew.com/23467.html" target="_blank" rel="external">http://www.importnew.com/23467.html</a></p>
<h2 id="点评-1"><a href="#点评-1" class="headerlink" title="点评"></a>点评</h2><p>缺点：继承单继承</p>
<h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><p>类加载器classloader<br>在ClassLoader中定义的算法顺序是：<br>1，首先看是否有已经加载好的类。<br>2，如果父类加载器不为空，则首先从父类类加载器加载。<br>3，如果父类加载器为空，则尝试从启动加载器加载。<br>4，如果两者都失败，才尝试从findClass方法加载。<br>findClass这个方法，并不是必须实现的，所以JDK选择留给程序员们自己选择是否要覆盖</p>
<p><a href="http://www.cnblogs.com/zuoxiaolong/p/pattern10.html" target="_blank" rel="external">http://www.cnblogs.com/zuoxiaolong/p/pattern10.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;策略模式&quot;&gt;&lt;a href=&quot;#策略模式&quot; class=&quot;headerlink&quot; title=&quot;策略模式&quot;&gt;&lt;/a&gt;策略模式&lt;/h1&gt;&lt;p&gt;策略模式就是要应对规则变化和新规则加入对程序带来的影响。&lt;br&gt;比如实现一个fly方法有很多种方式，可以做火箭飞、可以带翅膀
    
    </summary>
    
      <category term="note" scheme="http://duyao.github.io/categories/note/"/>
    
    
      <category term="设计模式" scheme="http://duyao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-观察者模式和责任链模式</title>
    <link href="http://duyao.github.io/2017/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://duyao.github.io/2017/05/05/设计模式-观察者模式和责任链模式/</id>
    <published>2017-05-05T12:45:43.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="观察模式"><a href="#观察模式" class="headerlink" title="观察模式"></a>观察模式</h1><p>观察者模式（有时又被称为发布-订阅模式、模型-视图模式、源-收听者模式或从属者模式）是软件设计模式的一种。<br>在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。<br>此种模式通常被用来实作事件处理系统。<br>简单点概括成通俗的话来说，就是一个类管理着所有依赖于它的观察者类，并且它状态变化时会主动给这些依赖它的类发出通知。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/Obeserver.jpg" alt="观察者模式" title="">
                </div>
                <div class="image-caption">观察者模式</div>
            </figure><br>我们的被观察者类Observable只关联了一个Observer的列表，然后在自己状态变化时，使用notifyObservers方法通知这些Observer，具体这些Observer都是什么，被观察者是不关心也不需要知道的。</p>
<p>一对多的方法，当一个对象的状态发生改变，那么依赖这个状态的相应对象都会发生改变。<br>目标与观察者的关系，可以多目标一个观察者，也可以多个观察者一个目标<br>单向依赖：只有目标什么更新观察者<br>命名：目标subject，观察者observer，更新方法update<br>触发通知的时机：先设置值再更新<br>观察者实现的顺序：<br>通知顺序：顺序不确定</p>
<h2 id="推模型和拉模型"><a href="#推模型和拉模型" class="headerlink" title="推模型和拉模型"></a>推模型和拉模型</h2><blockquote>
<p>推模型：</p>
</blockquote>
<p>目标对象主动向观察者推送目标的详细信息，推送的信息通常是目标对象的全部或者部分数据，广播方式，在update方法中传递的是定制的内容</p>
<blockquote>
<p>拉模型：</p>
</blockquote>
<p>目标对象在通知观察着的时候，只传递少量信息<br>如果观察者需要更具体的信息，有观察者主动到目标对象中去获取，相当于观察者从目标对象中拉数据<br>一般这种模型的实现中，会把目标对象自身通过update方法传递给观察者</p>
<blockquote>
<p>比较：</p>
</blockquote>
<p>推模型假定目标是知道自己想要什么的，因此update中传递的是定制的值，同时这样做会使得代码难以复用<br>拉模型是目标对象不知道自己想要什么值，因此要把对象本身给观察者，由观察者来取值</p>
<h2 id="java中对观察者模式的实现"><a href="#java中对观察者模式的实现" class="headerlink" title="java中对观察者模式的实现"></a>java中对观察者模式的实现</h2><p>由于JDK中为了方便开发人员，已经写好了现成的观察者接口和被观察者类<br>观察者接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//观察者接口，每一个观察者都必须实现这个接口</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">   <span class="comment">//这个方法是观察者在观察对象产生变化时所做的响应动作，从中传入了观察的对象和一个预留参数</span></div><div class="line">   <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>被观察者类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Vector;</div><div class="line"></div><div class="line"><span class="comment">//被观察者类</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</div><div class="line">    <span class="comment">//这是一个改变标识，来标记该被观察者有没有改变</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//持有一个观察者列表</span></div><div class="line">    <span class="keyword">private</span> Vector obs;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</div><div class="line">      obs = <span class="keyword">new</span> Vector();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//添加观察者，添加时会去重</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;</div><div class="line">            obs.addElement(o);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//删除观察者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObserver</span><span class="params">(Observer o)</span> </span>&#123;</div><div class="line">        obs.removeElement(o);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//notifyObservers(Object arg)的重载方法</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</div><div class="line">      notifyObservers(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//通知所有观察者，被观察者改变了，你可以执行你的update方法了。</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</div><div class="line">        <span class="comment">//一个临时的数组，用于并发访问被观察者时，留住观察者列表的当前状态，这种处理方式其实也算是一种设计模式，即备忘录模式。</span></div><div class="line">        Object[] arrLocal;</div><div class="line">        <span class="comment">//注意这个同步块，它表示在获取观察者列表时，该对象是被锁定的</span></div><div class="line">        <span class="comment">//也就是说，在我获取到观察者列表之前，不允许其他线程改变观察者列表</span></div><div class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">            <span class="comment">//如果没变化直接返回</span></div><div class="line">            <span class="keyword">if</span> (!changed)</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">            <span class="comment">//这里将当前的观察者列表放入临时数组</span></div><div class="line">            arrLocal = obs.toArray();</div><div class="line">            <span class="comment">//将改变标识重新置回未改变</span></div><div class="line">            clearChanged();</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//注意这个for循环没有在同步块，此时已经释放了被观察者的锁，其他线程可以改变观察者列表</span></div><div class="line">        <span class="comment">//但是这并不影响我们当前进行的操作，因为我们已经将观察者列表复制到临时数组</span></div><div class="line">        <span class="comment">//在通知时我们只通知数组中的观察者，当前删除和添加观察者，都不会影响我们通知的对象</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</div><div class="line">            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//删除所有观察者</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">deleteObservers</span><span class="params">()</span> </span>&#123;</div><div class="line">        obs.removeAllElements();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//标识被观察者被改变过了</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</div><div class="line">        changed = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//标识被观察者没改变</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clearChanged</span><span class="params">()</span> </span>&#123;</div><div class="line">        changed = <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//返回被观察者是否改变</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">hasChanged</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> changed;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//返回观察者数量</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">countObservers</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> obs.size();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="点评"><a href="#点评" class="headerlink" title="点评"></a>点评</h2><p>观察者和目标之间是松耦合；观察者实现了动态联动；观察者支持广播通信<br>可能会引起无谓的操作<br>何时使用观察者模式<br><a href="http://www.runoob.com/design-pattern/observer-pattern.html" target="_blank" rel="external">http://www.runoob.com/design-pattern/observer-pattern.html</a><br><a href="http://www.cnblogs.com/zuoxiaolong/p/pattern7.html" target="_blank" rel="external">http://www.cnblogs.com/zuoxiaolong/p/pattern7.html</a><br><a href="http://www.cnblogs.com/fingerboy/p/6393644.html" target="_blank" rel="external">http://www.cnblogs.com/fingerboy/p/6393644.html</a><br><a href="http://abc08010051.iteye.com/blog/1972960" target="_blank" rel="external">http://abc08010051.iteye.com/blog/1972960</a></p>
<h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p><a href="http://www.cnblogs.com/heshuchao/p/5376298.html" target="_blank" rel="external">http://www.cnblogs.com/heshuchao/p/5376298.html</a><br><a href="https://www.zhihu.com/question/19801131" target="_blank" rel="external">https://www.zhihu.com/question/19801131</a><br><a href="http://blog.csdn.net/xiaanming/article/details/8703708" target="_blank" rel="external">http://blog.csdn.net/xiaanming/article/details/8703708</a></p>
<h1 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h1><p><a href="https://my.oschina.net/u/923324/blog/792857" target="_blank" rel="external">https://my.oschina.net/u/923324/blog/792857</a></p>
<h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><p>责任链模式是一种对象的行为模式。<br>在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。<br>发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/chainResponsibility.jpg" alt="责任链模式" title="">
                </div>
                <div class="image-caption">责任链模式</div>
            </figure>
<p>责任链模式涉及到的角色如下所示：<br>抽象处理者(Handler)角色：定义一个处理请求的抽象类。如果需要，可以定义一个方法以设定和返回对下家的引用。<br>具体处理者(ConcreteHandler)角色：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。</p>
<h2 id="纯的与不纯的责任链模式"><a href="#纯的与不纯的责任链模式" class="headerlink" title="纯的与不纯的责任链模式"></a>纯的与不纯的责任链模式</h2><p>一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又把责任向下传的情况。<br>在一个纯的责任链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。<br>纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。</p>
<h2 id="点评-1"><a href="#点评-1" class="headerlink" title="点评"></a>点评</h2><p>不用职责链的结构，我们需要和公司中的每一个层级都发生耦合关系。<br>如果反映在代码上即使我们需要在一个类中去写上很多丑陋的if….else语句。<br>如果用了职责链，相当于我们面对的是一个黑箱，我们只需要认识其中的一个部门，然后让黑箱内部去负责传递就好了</p>
<p>缺点：构造大量的对象，但是最终只有一个对象响应请求，因此内存中的性能会有所损耗，可以使用观察者模式代替<br>还有就是责任链必须遍历整条链才能找到响应，比较耗时</p>
<p>应用：异常处理，filter(多个filter可以响应，不止是一个)<br><a href="http://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html" target="_blank" rel="external">http://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html</a></p>
<p><a href="http://blog.csdn.net/zuoxiaolong8810/article/category/1434962/2" target="_blank" rel="external">http://blog.csdn.net/zuoxiaolong8810/article/category/1434962/2</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;观察模式&quot;&gt;&lt;a href=&quot;#观察模式&quot; class=&quot;headerlink&quot; title=&quot;观察模式&quot;&gt;&lt;/a&gt;观察模式&lt;/h1&gt;&lt;p&gt;观察者模式（有时又被称为发布-订阅模式、模型-视图模式、源-收听者模式或从属者模式）是软件设计模式的一种。&lt;br&gt;在此种模式
    
    </summary>
    
      <category term="note" scheme="http://duyao.github.io/categories/note/"/>
    
    
      <category term="设计模式" scheme="http://duyao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式原则和UML图</title>
    <link href="http://duyao.github.io/2017/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99%E5%92%8CUML%E5%9B%BE/"/>
    <id>http://duyao.github.io/2017/04/30/设计模式原则和UML图/</id>
    <published>2017-04-30T08:46:35.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SOLID设计原则"><a href="#SOLID设计原则" class="headerlink" title="SOLID设计原则"></a>SOLID设计原则</h1><p>SRP：单一指责，每个类，每个方法专注一件事，小方法构成大功能。但是拆分到何种程度？取决于业务，当某个业务变更时发现会同时修改几个方法，那么可以考虑合并。<br>OCP： 对修改关闭，对扩展开放，尽量不修改原有功能，原有功能已经上线，修改有风险，所以设计时考虑可扩展性，能通过扩展实现新的需求。实现OCP的思路有：多态，不要硬编码<br>LSP：里氏替换，对于有继承关系的类，使用子类替换父类。<br>ISP：接口隔离，一个大接口不如多个小接口，粒度小，灵活性好，使用小功能组装成大功能，使用一个小功能没有必要引入过多的其他功能。那么接口小到何种程度？也值得思考。<br>DIP：依赖抽象，接口，而不是依赖具体实现。Spring中体现的很明显。</p>
<h1 id="uml图"><a href="#uml图" class="headerlink" title="uml图"></a>uml图</h1><p>类的关系有泛化(Generalization)、实现（Realization）、依赖(Dependency)和关联(Association)。<br>其中关联又分为一般关联关系和聚合关系(Aggregation)，组合关系(Composition)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">类的关系</div><div class="line">====泛华(继承)</div><div class="line">====实现(接口)</div><div class="line">====依赖(方法参数、返回值)</div><div class="line">====关联</div><div class="line">========关联关系(成员变量)</div><div class="line">========聚合关系(弱依赖)</div><div class="line">========组合关系(强依赖)</div></pre></td></tr></table></figure></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/uml_class_struct.jpg" alt="UML类图" title="">
                </div>
                <div class="image-caption">UML类图</div>
            </figure>
<ul>
<li>车的类图结构为&lt;<abstract>&gt;，表示车是一个抽象类；</abstract></li>
<li>它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；</li>
<li>小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；</li>
<li>小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；</li>
<li>学生与班级之间是聚合关系，使用带空心箭头的实线表示；</li>
<li>学生与身份证之间为关联关系，使用一根实线表示；</li>
<li>学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；</li>
</ul>
<h2 id="泛化-generalization"><a href="#泛化-generalization" class="headerlink" title="泛化(generalization)"></a>泛化(generalization)</h2><p>表示is-a的关系，是对象之间耦合度最大的一种关系，子类继承父类的所有细节。直接使用语言中的继承表达。在类图中使用带三角箭头的实线表示，箭头从子类指向父类。</p>
<h2 id="实现（Realization）"><a href="#实现（Realization）" class="headerlink" title="实现（Realization）"></a>实现（Realization）</h2><p>在类图中就是接口和实现的关系。这个没什么好讲的。在类图中使用带三角箭头的虚线表示，箭头从实现类指向接口。</p>
<h2 id="依赖-Dependency"><a href="#依赖-Dependency" class="headerlink" title="依赖(Dependency)"></a>依赖(Dependency)</h2><p>对象之间最弱的一种关联方式，是临时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。<br>在最终代码中，依赖关系体现为<strong>类构造方法及类方法的传入参数</strong>，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性；</p>
<h2 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h2><h3 id="关联关系-association"><a href="#关联关系-association" class="headerlink" title="关联关系(association)"></a>关联关系(association)</h3><p>关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系，通常与运行状态无关，一般由常识等因素决定的；<br>它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；<br>比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；<br>关联关系默认不强调方向，表示对象间相互知道；<br>在最终代码中，<strong>关联对象通常是以成员变量的形式实现的</strong></p>
<h2 id="聚合关系-Aggregation"><a href="#聚合关系-Aggregation" class="headerlink" title="聚合关系(Aggregation)"></a>聚合关系(Aggregation)</h2><p>表示has-a的关系，是一种不稳定的包含关系。较强于一般关联,有整体与局部的关系,并且没有了整体,局部也可单独存在。如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司。在类图使用空心的菱形表示，菱形从局部指向整体。</p>
<h2 id="组合关系-Composition"><a href="#组合关系-Composition" class="headerlink" title="组合关系(Composition)"></a>组合关系(Composition)</h2><p>表示contains-a的关系，是一种<strong>强烈</strong>的包含关系。组合类负责被组合类的生命周期。是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了；调查问卷中问题和选项的关系；订单和订单选项的关系。在类图使用实心的菱形表示，菱形从局部指向整体。<br><a href="http://www.uml.org.cn/oobject/201104212.asp" target="_blank" rel="external">http://www.uml.org.cn/oobject/201104212.asp</a><br><a href="http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html" target="_blank" rel="external">http://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html</a></p>
<h1 id="设计模式6个原则"><a href="#设计模式6个原则" class="headerlink" title="设计模式6个原则"></a>设计模式6个原则</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SOLID设计原则&quot;&gt;&lt;a href=&quot;#SOLID设计原则&quot; class=&quot;headerlink&quot; title=&quot;SOLID设计原则&quot;&gt;&lt;/a&gt;SOLID设计原则&lt;/h1&gt;&lt;p&gt;SRP：单一指责，每个类，每个方法专注一件事，小方法构成大功能。但是拆分到何种程度？
    
    </summary>
    
      <category term="note" scheme="http://duyao.github.io/categories/note/"/>
    
    
      <category term="设计模式" scheme="http://duyao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据库-范式</title>
    <link href="http://duyao.github.io/2017/04/25/%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%8C%83%E5%BC%8F/"/>
    <id>http://duyao.github.io/2017/04/25/数据库-范式/</id>
    <published>2017-04-25T02:23:30.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。<br>实际上你可以把它粗略地理解为一张数据表的表结构所符合的某种设计标准的级别。</p>
<h1 id="第一范式1NF"><a href="#第一范式1NF" class="headerlink" title="第一范式1NF"></a>第一范式1NF</h1><p>定义为：<strong>符合1NF的关系中的每个属性都不可再分</strong>。<br>1NF是所有关系型数据库的最基本要求</p>
<table>
<thead>
<tr>
<th style="text-align:center">编号</th>
<th style="text-align:center">商品</th>
<th style="text-align:center">进货</th>
<th style="text-align:center">销售</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">数量+单价</td>
<td style="text-align:center">数量+单价</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>但是仅仅符合1NF的设计，仍然会存在<strong>数据冗余过大，插入异常，删除异常，修改异常</strong>的问题，例如对于图1中的设计：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/2nf.jpg" alt="图1" title="">
                </div>
                <div class="image-caption">图1</div>
            </figure></p>
<h1 id="第二范式（2NF）"><a href="#第二范式（2NF）" class="headerlink" title="第二范式（2NF）"></a>第二范式（2NF）</h1><p>对1NF进行了一些改进。其改进是，<strong>2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖</strong>。<br>接下来对这句话中涉及到的四个概念——“函数依赖”、“码”、“非主属性”、与“部分函数依赖”进行一下解释。</p>
<h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><p>我们可以这么理解（但并不是特别严格的定义）：<strong>若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y。</strong><br>也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。<br>这也就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。<br>例如，对于图1中的数据，找不到任何一条记录，它们的学号相同而对应的姓名不同。所以我们可以说姓名函数依赖于学号，写作 <code>学号 → 姓名</code>。<br>但是反过来，因为可能出现同名的学生，所以有可能不同的两条学生记录，它们在姓名上的值相同，但对应的学号不同，所以我们不能说学号函数依赖于姓名。<br>表中其他的函数依赖关系还有如：</p>
<ul>
<li><code>系名 → 系主任</code></li>
<li><code>学号 → 系主任</code></li>
<li><code>（学号，课名） → 分数</code></li>
</ul>
<p>但以下函数依赖关系则不成立：</p>
<ul>
<li><code>学号 → 课名</code></li>
<li><code>学号 → 分数</code></li>
<li><code>课名 → 系主任</code></li>
<li><code>（学号，课名） → 姓名</code></li>
</ul>
<p>从“函数依赖”这个概念展开，还会有三个概念：</p>
<blockquote>
<p>完全函数依赖</p>
</blockquote>
<p>在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ‘ → Y 不成立，那么我们称 Y 对于 X 完全函数依赖，记作 X F→ Y。（那个F应该写在箭头的正上方）<br>例如： 学号 F→ 姓名 （学号，课名） F→ 分数  （注：因为同一个的学号对应的分数不确定，同一个课名对应的分数也不确定）</p>
<blockquote>
<p>部分函数依赖</p>
</blockquote>
<p>假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 X  P→ Y（P在箭头上方）<br>例如：（学号，课名） P→ 姓名</p>
<blockquote>
<p>传递函数依赖</p>
</blockquote>
<p>假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （严格来说还有一个X 不包含于Y，且 Y 不函数依赖于Z的前提条件），那么我们就称 Z 传递函数依赖于 X ，记作 X T→ Z(T在箭头上方)</p>
<h2 id="码"><a href="#码" class="headerlink" title="码"></a>码</h2><p>设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都<strong>完全</strong>函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为候选码，简称为码。<br>在实际中我们通常可以理解为：<strong>假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。</strong><br>一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为主码）<br>例如：对于图1，（学号、课名）这个属性组就是码。该表中有且仅有这一个码。（假设所有课没有重名的情况）</p>
<h2 id="非主属性"><a href="#非主属性" class="headerlink" title="非主属性"></a>非主属性</h2><p>包含在任何一个码中的属性成为主属性。例如：对于图1，主属性就有两个，学号 与 课名。</p>
<p>终于可以回过来看2NF了。首先，我们需要判断，图1是否符合2NF的要求？根据2NF的定义，<strong>判断的依据实际上就是看数据表中是否存在非主属性对于码的部分函数依赖</strong>。<br>若存在，则数据表最高只符合1NF的要求，若不存在，则符合2NF的要求。<br>判断的方法是：<br>第一步：找出数据表中所有的码。<br>第二步：根据第一步所得到的码，找出所有的主属性。<br>第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。<br>第四步：查看是否存在非主属性对码的部分函数依赖。<br>对于图1，根据前面所说的四步，我们可以图中所有的函数依赖关系：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/dependency.jpg" alt="函数依赖" title="">
                </div>
                <div class="image-caption">函数依赖</div>
            </figure><br>这一步完成以后，可以得到，图1的码只有一个，就是（学号、课名）。<br>第二步：主属性有两个：学号 与 课名<br>第三步：非主属性有四个：姓名、系名、系主任、分数<br>第四步：<br>对于<code>（学号，课名） → 姓名</code>，有 <code>学号 → 姓名</code>，存在非主属性 <code>姓名</code> 对码<code>（学号，课名）</code>的部分函数依赖。<br>对于<code>（学号，课名） → 系名</code>，有 <code>学号 → 系名</code>，存在非主属性 <code>系名</code> 对码<code>（学号，课名）</code>的部分函数依赖。<br>对于<code>（学号，课名） → 系主任</code>，有<code>学号 → 系主任</code>，存在非主属性 <code>系主任</code>  对码<code>（学号，课名）</code>的部分函数依赖。<br>所以图1存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要求。</p>
<p>为了让图1符合2NF的要求，我们必须消除这些部分函数依赖，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”模式分解“。<br>模式分解的方法不是唯一的，以下是其中一种方法：<br>选课（学号，课名，分数）<br>学生（学号，姓名，系名，系主任）<br>新的函数依赖如下图所示：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/dependency1.jpg" alt="新的函数依赖" title="">
                </div>
                <div class="image-caption">新的函数依赖</div>
            </figure><br>对于选课表，其码是（学号，课名），主属性是学号和课名，非主属性是分数，学号确定，并不能唯一确定分数，课名确定，也不能唯一确定分数，所以不存在非主属性分数对于码 （学号，课名）的部分函数依赖，所以此表符合2NF的要求。<br>对于学生表，其码是学号，主属性是学号，非主属性是姓名、系名和系主任，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求</p>
<h1 id="第三范式（3NF）"><a href="#第三范式（3NF）" class="headerlink" title="第三范式（3NF）"></a>第三范式（3NF）</h1><p>3NF在2NF的基础之上，<strong>消除了非主属性对于码的传递函数依赖</strong>。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。</p>
<p>对于上面新的函数依赖，可以分析：<br>对于选课表，主码为（学号，课名），主属性为学号和课名，非主属性只有一个，为分数，不可能存在传递函数依赖，所以选课表的设计，符合3NF的要求。<br>对于学生表，主码为学号，主属性为学号，非主属性为姓名、系名和系主任。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性系主任对于码学号的传递函数依赖，所以学生表的设计，不符合3NF的要求。。</p>
<p>为了让数据表设计达到3NF，我们必须进一步进行模式分解为以下形式：<br>选课（学号，课名，分数）<br>学生（学号，姓名，系名）<br>系（系名，系主任）<br>对于选课表，符合3NF的要求，之前已经分析过了。<br>对于学生表，码为学号，主属性为学号，非主属性为系名，不可能存在非主属性对于码的传递函数依赖，所以符合3NF的要求。<br>对于系表，码为系名，主属性为系名，非主属性为系主任，不可能存在非主属性对于码的传递函数依赖（至少要有三个属性才可能存在传递函数依赖关系），所以符合3NF的要求。</p>
<p>结论<br>由此可见，符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF，但是作为数据库设计人员，至少应该知道，3NF的要求是怎样的。</p>
<h2 id="BCNF范式"><a href="#BCNF范式" class="headerlink" title="BCNF范式"></a>BCNF范式</h2><p>要了解 BCNF 范式，那么先看这样一个问题：若：某公司有若干个仓库；每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。<br>那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？<br>答：<br>已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量<br>码：（管理员，物品名），（仓库名，物品名）<br>主属性：仓库名、管理员、物品名<br>非主属性：数量<br>∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。</p>
<p>因此BCNF就是解决存在着主属性对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。<br>解决办法就是要在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。</p>
<p>仓库（仓库名，管理员）<br>库存（仓库名，物品名，数量）</p>
<p><a href="https://www.zhihu.com/question/24696366/answer/29189700" target="_blank" rel="external">https://www.zhihu.com/question/24696366/answer/29189700</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。&lt;br&gt;实际上你可以把它粗略地理解为一张数据表的表结构所符合的某种设计标准的级别。&lt;/p&gt;
&lt;h1 id=&quot;第一范式1NF&quot;&gt;&lt;a href=&quot;#第一范式1NF&quot; class=&quot;head
    
    </summary>
    
      <category term="note" scheme="http://duyao.github.io/categories/note/"/>
    
    
      <category term="数据库" scheme="http://duyao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="http://duyao.github.io/2017/04/21/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://duyao.github.io/2017/04/21/数据库/</id>
    <published>2017-04-21T01:55:53.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/mysqlStructure.png" alt="mysql架构" title="">
                </div>
                <div class="image-caption">mysql架构</div>
            </figure>
<p>MySQL最重要的、最与众不同的特性是它的存储引擎架构，这种构架的设计将查询处理及其它系统任务和数据的存储/提取相分离。</p>
<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>为什么需要锁？因为数据库要解决并发控制问题。<br>在同一时刻，可能会有多个客户端对表中同一行记录进行操作，比如有的在读取该行数据，其他的尝试去删除它。为了保证数据的一致性，数据库就要对这种并发操作进行控制，因此就有了锁的概念。</p>
<h2 id="乐观锁和悲观锁以及时间戳"><a href="#乐观锁和悲观锁以及时间戳" class="headerlink" title="乐观锁和悲观锁以及时间戳"></a>乐观锁和悲观锁以及时间戳</h2><p>并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳</p>
<p>乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据；</p>
<p>悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；<br>悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。</p>
<p><strong>并发量较大时候选择悲观锁，并发量较小的时候选择乐观锁</strong></p>
<p>时间戳就是不加锁，通过时间戳来控制并发出现的问题。时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量，因为这种方法可以避免了长事务中的数据库加锁开销（操作员A 和操作员B操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系 统整体性能表现。</p>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>以上悲观锁所说的加“锁”，其实分为3种锁</p>
<p>共享（S)锁：多个事务可封锁一个共享页；任何事务都不能修改该页； 通常是该页被读取完毕，S锁立即被释放。</p>
<p>排它（X)锁：仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到事务结束才能被释放。</p>
<p>更新（U)锁：更新锁在修改操作的初始化阶段用来锁定可能要被修改的资源，这样可以避免使用共享锁造成的死锁现象。</p>
<p>因为使用共享锁时，修改数据的操作分为两步，首先获得一个共享锁，读取数据，然后将共享锁升级为排它锁，然后再执行修改操作。<br>这样如果同时有两个或多个事务同时对一个事务申请了共享锁，在修改数据的时候，这些事务都要将共享锁升级为排它锁。这时，这些事务都不会释放共享锁而是一直等待对方释放，这样就造成了死锁。在update语句中很容易出现死锁现象，比如t1和t2都要更新id=100的记录，那么可能存在t1先获取读锁，然后t2再获取读锁，然后t1要得写锁，同时t2也要获得写锁，这时候就会产生死锁。因为t1获得写锁的前提是t2释放读锁，而t2获得写锁的前提是t1释放读锁。<br>所以为了防止这种情的发生，一个数据在修改前直接申请更新锁，在数据修改的时候再升级为排它锁，就可以避免死锁。</p>
<p>更新锁有如下特征：</p>
<ul>
<li>加锁的条件：当一个事务执行update语句时，数据库系统会先为事务分配一把更新锁。</li>
<li>解锁的条件：当读取数据完毕，执行更新操作时，会把更新锁升级为独占锁。</li>
<li>与其他锁的兼容性：更新锁与共享锁是兼容的，也就是说，一个资源可以同时放置更新锁和共享锁，但是最多放置一把更新锁。这样，当多个事务更新相同的数据时，只有一个事务能获得更新锁，然后再把更新锁升级为独占锁，其他事务必须等到前一个事务结束后，才能获取得更新锁，这就避免了死锁。</li>
</ul>
<p>默认来说，当sql脚本修改更新某条记录的时候，会给该条记录加X锁，读的话加的是S锁<br>对于 UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；<br>对于普通SELECT语句，InnoDB不会加任何锁；<br>事务可以通过显式给记录集加共享锁或排他锁。</p>
<h2 id="锁粒度（Lock-granularity）"><a href="#锁粒度（Lock-granularity）" class="headerlink" title="锁粒度（Lock granularity）"></a>锁粒度（Lock granularity）</h2><p>为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。</p>
<p>一种提高共享资源并发发性的方式是让锁定对象更有选择性。<br>尽量只锁定需要修改的部分数据，而不是所有的资源。<br>更理想的方式是，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。<br>但是，加锁也需要消耗资源。锁的各种操作，包括获得锁、检查锁和是否已经解除、释放锁等，都会增加系统的开销。<br>所谓锁策略，就是在锁的开销和数据的安全性之间寻求平衡。</p>
<h3 id="表锁与行锁"><a href="#表锁与行锁" class="headerlink" title="表锁与行锁"></a>表锁与行锁</h3><p>表锁：管理锁的开销最小，同时允许的并发量也最小的锁机制。<br><strong>MyIsam存储引擎使用表锁</strong>。当要写入数据时，把整个表都锁上，此时其他读、写动作一律等待。<br>在MySql中，除了MyIsam存储引擎使用这种锁策略外，MySql本身也使用表锁来执行某些特定动作，比如alter table.</p>
<p>另外，写锁比读锁有更高的优先级，因此一个写锁可能会被插入到读锁队列的前面。</p>
<p>行锁：可以支持最大并发的锁策略（同时也带来了最大的锁开销）。<br><strong>InnoDB和Falcon两张存储引擎都采用行锁</strong>。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。服务器层完全不了解存储引擎中的锁实现。</p>
<p>MySql是一种开放的架构，你可以实现自己的存储引擎，并实现自己的锁粒度策略，不像Oracle，你没有机会改变锁策略，Oracle采用的是行锁。</p>
<h3 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制 MVCC"></a>多版本并发控制 MVCC</h3><p>在并发读写数据库时，读操作可能会不一致的数据（脏读）。为了避免这种情况，需要实现数据库的并发访问控制，最简单的方式就是加锁访问。<br>由于，加锁会将读写操作串行化，所以不会出现不一致的状态。但是，读操作会被写操作阻塞，大幅降低读性能。<br>在Java concurrent包中，有copyonwrite系列的类，专门用于优化读远大于写的情况。而其优化的手段就是，在进行写操作时，将数据copy一份，不会影响原有数据，然后进行修改，修改完成后原子替换掉旧的数据，而读操作只会读取原有数据。通过这种方式实现写操作不会阻塞读操作，从而优化读效率。而写操作之间是要互斥的，并且每次写操作都会有一次copy，所以只适合读大于写的情况。</p>
<p>MVCC的原理与copyonwrite类似，全称是Multiversion Concurrency Controll，即多版本并发控制。在MVCC协议下，<strong>每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读</strong>。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。<br>由此可以看出MVCC是一种用来解决读-写冲突的无锁并发控制.</p>
<p>MVCC策略：<br>MVCC并不是MySql独有的，Oracle，PostgreSQL等都在使用。<br>MVCC并没有简单地使用行锁，而是使用“行级别锁”（row-level locking）。</p>
<p>MVCC的基本原理是：<br>MVCC的实现，通过<strong>保存数据在某个时间点的快照</strong>来实现的。<br>这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。<br>根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。</p>
<p>MVCC的基本特征：<br>每行数据都存在一个版本，每次数据更新时都更新该版本。<br>修改时Copy出当前版本随意修改，各个事务之间无干扰。<br>保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）</p>
<p>InnoDB存储引擎MVCC的实现策略：<br>在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空）。<br>这里的版本号并不是实际的时间值，而是系统版本号。<br>每开始个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。<br>每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/mvcc.jpg" alt="MVCC" title="">
                </div>
                <div class="image-caption">MVCC</div>
            </figure>
<p>MVCC具体的操作如下：</p>
<p>SELECT:InnoDB会根据以下两个条件检查每行记录，只有满足两个条件才会返回：</p>
<p>1）InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，只么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</p>
<p>2）行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</p>
<p>INSERT:InnoDB为新插入的每一行保存当前系统版本号作为行版本号。</p>
<p>DELETE:InnoDB为删除的每一行保存当前系统版本号作为行删除标识。</p>
<p>UPDATE:InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当系统的版本号为原来的行作为删除标识。</p>
<p>保存这两个额外系统版本号，使大多数操作都可以不用加锁。这样设计使得计数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</p>
<p>MVCC只在REPEATABLE READ和READ COMMITED两个隔离级别下工作，其它两个隔离级别和MVCC不兼容。</p>
<p>Innodb的实现算不上MVCC，因为并没有实现核心的多版本共存，undo log中的内容只是串行化的结果，记录了多个事务的过程，不属于多版本共存。但理想的MVCC是难以实现的，当事务仅修改一行记录使用理想的MVCC模式是没有问题的，可以通过比较版本号进行回滚；但当事务影响到多行数据时，理想的MVCC据无能为力了。</p>
<p>比如，如果Transaciton1执行理想的MVCC，修改Row1成功，而修改Row2失败，此时需要回滚Row1，但因为Row1没有被锁定，其数据可能又被Transaction2所修改，如果此时回滚Row1的内容，则会破坏Transaction2的修改结果，导致Transaction2违反ACID。</p>
<p>理想MVCC难以实现的根本原因在于企图通过乐观锁代替二段提交。修改两行数据，但为了保证其一致性，与修改两个分布式系统中的数据并无区别，而二段提交是目前这种场景保证一致性的唯一手段。二段提交的本质是锁定，乐观锁的本质是消除锁定，二者矛盾，故理想的MVCC难以真正在实际中被应用，Innodb只是借了MVCC这个名字，提供了读的非阻塞而已。<br><a href="http://blog.csdn.net/chen77716/article/details/6742128" target="_blank" rel="external">http://blog.csdn.net/chen77716/article/details/6742128</a><br><a href="http://blog.csdn.net/xifeijian/article/details/45230053" target="_blank" rel="external">http://blog.csdn.net/xifeijian/article/details/45230053</a></p>
<h3 id="两阶段封锁"><a href="#两阶段封锁" class="headerlink" title="两阶段封锁"></a>两阶段封锁</h3><p>InnoDB采用两阶段锁协议(2PL：Two-phase Locking Protocol)实现串行化。<br><strong>在事务内任意时刻加锁，最后提交或回滚时一起释放所有锁</strong>。</p>
<p>一次性锁协议：事务开始时，一次性申请所有的锁，之后不会再申请任何锁。如果其中某个锁不可用，则整个申请就不成功，事务就不会执行，在事务尾端，一次性释放所有的锁。一次性锁协议不会产生死锁的问题，但事务的并发度不高。</p>
<p>两阶段锁协议(跟分布式事务XA的两阶段提交)具体如下：<br>两阶段锁协议：整个事务分为两个阶段，前一个阶段为加锁，后一个阶段为解锁。在加锁阶段，事务只能加锁，也可以操作数据，但不能解锁。直到事务释放第一个锁，就进入解锁阶段，此过程中事务只能解锁，也可以操作数据，不能再加锁。<br>两阶段锁协议使得事务具有较高的并发度，因为解锁不必发生在事务结尾。它的不足是没有解决死锁的问题，因为它在加锁阶段没有顺序要求。如两个事务分别申请了A, B锁，接着又申请对方的锁，此时进入死锁状态。</p>
<h3 id="加锁的情况"><a href="#加锁的情况" class="headerlink" title="加锁的情况"></a>加锁的情况</h3><p>在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：</p>
<p>快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)<br>select * from table where ?;<br>当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。<br>select * from table where ? lock in share mode;<br>select * from table where ? for update;<br>insert into table values (…);<br>update table set ? where ?;<br>delete from table where ?;<br>所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</p>
<p>分析加锁<br>SQL1：select * from t1 where id = 10;<br>SQL2：delete from t1 where id = 10;</p>
<p>在RC，RR隔离级别下，SQL1：select操作均不加锁，采用的是快照读，因此在下面的讨论中就忽略了，主要讨论SQL2：delete操作的加锁。</p>
<p>组合一：id主键+RC<br>结论：id是主键时，此SQL只需要在id=10这条记录上加X锁即可。</p>
<p>组合二：id唯一索引+RC<br>若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录。</p>
<p>组合三：id非唯一索引+RC<br>结论：若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。</p>
<p>组合四：id无索引+RC<br>结论：若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了2PL的约束。</p>
<p>组合五：id主键+RR<br>组合五，id列是主键列，Repeatable Read隔离级别，针对delete from t1 where id = 10; 这条SQL，加锁与组合一：[id主键，Read Committed]一致。</p>
<p>组合六：id唯一索引+RR<br>与组合五类似，组合六的加锁，与组合二：[id唯一索引，Read Committed]一致。两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。</p>
<p>组合七：id非唯一索引+RR<br>结论：Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：delete from t1 where id = 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。</p>
<p>组合八：id无索引+RR<br>结论：在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。</p>
<p>组合九：Serializable<br>针对前面提到的简单的SQL，最后一个情况：Serializable隔离级别。对于SQL2：delete from t1 where id = 10; 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致，因此不做介绍。<br>Serializable隔离级别，影响的是SQL1：select * from t1 where id = 10; 这条SQL，在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。<br>结论：在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。</p>
<p>认真读：<a href="http://hedengcheng.com/?p=771#_组合二：id唯一索引+RC" target="_blank" rel="external">什么情况加锁</a></p>
<h2 id="死锁（Dead-Lock）"><a href="#死锁（Dead-Lock）" class="headerlink" title="死锁（Dead Lock）"></a>死锁（Dead Lock）</h2><p>死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的假象。多个事务同时锁定同一个资源时，也会产生死锁。<br>数据库系统实现了各种死锁检测和死锁超时的机制，<strong>InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。</strong></p>
<p>并发控制会造成活锁和死锁，就像操作系统那样，会因为互相等待而导致。<br>活锁指的是T1封锁了数据R，T2同时也请求封锁数据R，T3也请求封锁数据R，当T1释放了锁之后，T3会锁住R，T4也请求封锁R，则T2就会一直等待下去，这种处理方法就是采用“先来先服务”策略；<br>死锁就是我等你，你又等我，双方就会一直等待下去，比如：T1封锁了数据R1，正请求对R2封锁，而T2封住了R2,正请求封锁R1，这样就会导致死锁，死锁这种没有完全解决的方法，只能尽量预防.</p>
<p>预防死锁的方法有：<br>①一次封锁发，指的是一次性把所需要的数据全部封锁住，但是这样会扩大了封锁的范围，降低系统的并发度；<br>②顺序封锁发，指的是事先对数据对象指定一个封锁顺序，要对数据进行封锁，只能按照规定的顺序来封锁，但是这个一般不大可能的。<br>另外，系统如何判断出现死锁，毕竟出现死锁不能一直干等下去，要及时发现死锁同时尽快解决出现的死锁，</p>
<p>诊断和判断死锁有两种方法:<br>1）超时法：超时法就是如果某个事物的等待时间超过指定时限，则判定为出现死锁；<br>2）等待图法：等待图法指的是如果事务等待图中出现了回路，则判断出现了死锁。</p>
<p>对于解决死锁的方法，只能是撤销一个处理死锁代价最小的事务，释放此事务持有的所有锁，同时对撤销的事务所执行的数据修改操作必须加以恢复。</p>
<p>数据库系统实现了各种死锁检测和死锁超时的机制，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。</p>
<h1 id="事务（Transaction）"><a href="#事务（Transaction）" class="headerlink" title="事务（Transaction）"></a>事务（Transaction）</h1><h2 id="事务ACID原则"><a href="#事务ACID原则" class="headerlink" title="事务ACID原则"></a>事务ACID原则</h2><p>从业务角度出发，对数据库的一组操作要求保持4个特征：</p>
<p>Atomicity（原子性）：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。</p>
<p>Consistency（一致性）：一致性保证能看到系统内的所有改变。<br>一致性是指事务使得系统从一个一致的状态转换到另一个一致状态。事务的一致性决定了一个系统设计和实现的复杂度。事务可以不同程度的一致性：<br>强一致性：读操作可以立即读到提交的更新操作。<br>弱一致性：提交的更新操作，不一定立即会被读操作读到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。<br>最终一致性：是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样的值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等。<br>其他一致性变体还有：<br>单调一致性：如果一个进程已经读到一个值，那么后续不会读到更早的值。<br>会话一致性：保证客户端和服务器交互的会话过程中，读操作可以读到更新操作后的最新值。</p>
<p>Isolation（隔离性）：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。注意这里的“通常来说”，后面的事务隔离级级别会说到。<br>可以将隔离性理解为以性能为理由，对一致性进行破坏。</p>
<p>Durability（持久性）：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。（持久性的安全性与刷新日志级别也存在一定关系，不同的级别对应不同的数据安全级别。）<br>数据为了保证持久性使用raid技术来冗余数据，raid主要解决了两个问题：①如何保证数据同时写到两个磁盘上去②由于每次请求都要刷磁盘会导致性能下降，因此要将请求打包同意发送到存储 。<br>down机恢复，要进入recovery模式，不能读写</p>
<h2 id="隔离级别（Isolation-Level）"><a href="#隔离级别（Isolation-Level）" class="headerlink" title="隔离级别（Isolation Level）"></a>隔离级别（Isolation Level）</h2><p>SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。<br>低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。</p>
<p>Read Uncommitted（未提交读）<br>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。</p>
<p>Read Committed（提交读）<br>这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p>
<p>Repeatable Read（可重复读）<br><strong>这是MySQL的默认事务隔离级别</strong>，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。<br>一种更易理解的说法是：在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据。那么，在第一个事务的两次读数据之间。由于第二个事务的修改，那么第一个事务读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复。</p>
<p>不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。<br>InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。</p>
<p>Serializable（可串行化）<br>这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/clipboard.png" alt="事务的隔离级别" title="">
                </div>
                <div class="image-caption">事务的隔离级别</div>
            </figure>
<p>这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：</p>
<p>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</p>
<p>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</p>
<p>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</p>
<p>不可重复读重点在于update和delete，而幻读的重点在于insert。<br>例子：<a href="http://www.hollischuang.com/archives/900" target="_blank" rel="external">http://www.hollischuang.com/archives/900</a></p>
<p>在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>未提交读</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td>提交读</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td>可重复读</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">Y</td>
</tr>
<tr>
<td>可串行化</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
<td style="text-align:center">N</td>
</tr>
</tbody>
</table>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是在存储引擎中实现的，而不是在服务器层中实现的。所以，每种存储引擎的索引都不一定完全相同，并不是所有的存储引擎都支持所有的索引类型</p>
<h2 id="b树索引"><a href="#b树索引" class="headerlink" title="b树索引"></a>b树索引</h2><p>B－Tree：每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。B－Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同，很适合查找范围数据。</p>
<h3 id="不同的b树索引实现"><a href="#不同的b树索引实现" class="headerlink" title="不同的b树索引实现"></a>不同的b树索引实现</h3><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。<br>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/myisamindex.png" alt="MyISAM索引" title="">
                </div>
                <div class="image-caption">MyISAM索引</div>
            </figure><br>在InnoDB中完全不同：<br>第一个重大区别是InnoDB的数据文件本身就是索引文件。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/innodbindex.png" alt="InnoDB索引" title="">
                </div>
                <div class="image-caption">InnoDB索引</div>
            </figure><br>这张图中的主键索引就是聚集索引</p>
<p>注意：辅助索引搜索需要检索两遍索引：<strong>首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录</strong>。</p>
<h3 id="索引的查询"><a href="#索引的查询" class="headerlink" title="索引的查询"></a>索引的查询</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/mysql1.jpg" alt="b树索引" title="">
                </div>
                <div class="image-caption">b树索引</div>
            </figure>
<p>其索引包含表中每一行的last_name、first_name和dob列。</p>
<p>索引存储的值按索引列中的顺序排列。<strong>可以利用B-Tree索引进行全关键字、关键字范围和关键字前缀查询</strong><br>如果想使用索引，你必须保证按索引的<strong>最左边前缀(leftmost prefix of the index)</strong> 来进行查询。<br>(1)匹配全值(Match the full value)：对索引中的所有列都指定具体的值。例如，上图中索引可以帮助你查找出生于1960-01-01的Cuba Allen。<br>(2)匹配最左前缀(Match a leftmost prefix)：你可以利用索引查找last name为Allen的人，仅仅使用索引中的第1列。<br>(3)匹配列前缀(Match a column prefix)：例如，你可以利用索引查找last name以J开始的人，这仅仅使用索引中的第1列。<br>(4)匹配值的范围查询(Match a range of values)：可以利用索引查找last name在Allen和Barrymore之间的人，仅仅使用索引中第1列。<br>(5)匹配部分精确而其它部分进行范围匹配(Match one part exactly and match a range on another part)：可以利用索引查找last name为Allen，而first name以字母K开始的人。<br>(6)仅对索引进行查询(Index-only queries)：如果查询的列都位于索引中，则不需要读取元组的值。(覆盖索引)</p>
<p>由于B-树中的节点都是顺序存储的，所以可以利用索引进行查找(找某些值)，也可以对查询结果进行ORDER BY。<br>当然，使用B-tree索引有以下一些限制：<br>(1) 查询必须从索引的最左边的列开始，否则无法使用索引。关于这点已经提了很多遍了。例如你不能利用索引查找在某一天出生的人。<br>(2) 不能跳过某一索引列。例如，你不能利用索引查找last name为Smith且出生于某一天的人。<br>(3) <strong>存储引擎不能使用索引中范围条件右边的列</strong>。例如，如果你的查询语句为WHERE last_name=”Smith” AND first_name LIKE ‘J%’ AND dob=’1976-12-23’，则该查询只会使用索引中的前两列，因为LIKE是范围查询。</p>
<h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引(Clustered Indexes)<br>聚簇索引保证<strong>关键字的值相近的元组存储的物理位置也相同</strong>（所以字符串类型不宜建立聚簇索引，特别是随机字符串，会使得系统进行大量的移动操作），且<strong>一个表只能有一个聚簇索引</strong>。<br>因为由存储引擎实现索引，所以，并不是所有的引擎都支持聚簇索引。目前，只有solidDB和InnoDB支持。<br>聚簇索引的结构大致如下：<br><strong>叶子页包含了行的全部数据，但是节点页只包含了索引列。</strong><br>二级索引叶子节点保存的不是指行的物理位置的指针，而是行的主键值。这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获取对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。这里做了重复的工作：两次B－TREE查找而不是一次。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/mysql2.jpg" alt="b树索引" title="">
                </div>
                <div class="image-caption">b树索引</div>
            </figure><br><strong>InnoDB对主键建立聚簇索引</strong>。如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。</p>
<p><a href="http://blog.csdn.net/xifeijian/article/details/20312557" target="_blank" rel="external">http://blog.csdn.net/xifeijian/article/details/20312557</a></p>
<h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/mysqlselect.png" alt="mysql查询过程" title="">
                </div>
                <div class="image-caption">mysql查询过程</div>
            </figure>
<p>MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）</p>
<h2 id="sql语句方面的优化"><a href="#sql语句方面的优化" class="headerlink" title="sql语句方面的优化"></a>sql语句方面的优化</h2><ul>
<li>join做索引</li>
<li>尽量不用null，全部设置为not null，避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</li>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>
<li>尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描<br>如<code>select id from t where num/2=100</code>应改为:<code>select id from t where num=100*2</code></li>
<li>应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。<br>如：<code>select id from t where substring(name,1,3)=’abc’</code>或<code>select id from t where datediff(day,createdate,’2005-11-30′)=0–’2005-11-30′</code>应改为:<br><code>select id from t where name like ‘abc%’</code>和<code>select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′</code></li>
</ul>
<p>索引失效情况：</p>
<ul>
<li>like语句中%前置可能会导致索引失效</li>
<li>如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)</li>
<li>对于多列索引，不是使用的第一部分，则不会使用索引</li>
<li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li>
</ul>
<p><a href="http://www.uml.org.cn/sjjm/201610184.asp" target="_blank" rel="external">http://www.uml.org.cn/sjjm/201610184.asp</a></p>
<h2 id="使用查询缓存"><a href="#使用查询缓存" class="headerlink" title="使用查询缓存"></a>使用查询缓存</h2><p>大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。<br>使用函数时要注意，因为像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。<br><a href="http://blog.csdn.net/xifeijian/article/details/45320605" target="_blank" rel="external">http://blog.csdn.net/xifeijian/article/details/45320605</a></p>
<h2 id="经常查询的做索引"><a href="#经常查询的做索引" class="headerlink" title="经常查询的做索引"></a>经常查询的做索引</h2><p>索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：<br><code>Index Selectivity = Cardinality / #T</code><br>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。<br><code>SELECT count(DISTINCT(title))/count(*) AS Selectivity FROM employees.titles;</code><br><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>
<h2 id="使用explain做优化"><a href="#使用explain做优化" class="headerlink" title="使用explain做优化"></a>使用explain做优化</h2><p>explain的含义，type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.<br>通常来说, 不同的 type 类型的性能关系如下:<br>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system<br>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.</p>
<p><a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="external">https://segmentfault.com/a/1190000008131735</a></p>
<h2 id="使用正确的索引引擎"><a href="#使用正确的索引引擎" class="headerlink" title="使用正确的索引引擎"></a>使用正确的索引引擎</h2><p>MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 <code>SELECT COUNT(*)</code>这类的计算是超快无比的。</p>
<p>InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。</p>
<p><a href="http://blog.csdn.net/xifeijian/article/details/45287139" target="_blank" rel="external">http://blog.csdn.net/xifeijian/article/details/45287139</a><br><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="external">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>
<h1 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h1><h2 id="DQL-DML-DDL-DCL"><a href="#DQL-DML-DDL-DCL" class="headerlink" title="DQL,DML,DDL,DCL"></a>DQL,DML,DDL,DCL</h2><p>DQL数据查询语言：其语句，也称为“数据检索语句”，用以从表中获得数据，确定数据怎样在应用程序给出。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有WHERE，ORDER BY，GROUP BY和HAVING。这些DQL保留字常与其他类型的SQL语句一起使用。</p>
<p>DML（data manipulation language）是数据操纵语言：UPDATE、INSERT、DELETE，当执行DML命令如果没有提交，将不会被其他会话看到。除非在DML命令之后执行了DDL命令或DCL命令，或用户退出会话，或终止实例，此时系统会自动发出commit命令，使未提交的DML命令提交。</p>
<p>DDL（data definition language）是数据定义语言：DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。当执行DDL语句时，在每一条语句前后，oracle都将提交当前的事务。如果用户使用insert命令将记录插入到数据库后，执行了一条DDL语句(如create table)，此时来自insert命令的数据将被提交到数据库。当DDL语句执行完成时，DDL语句会被自动提交，不能回滚。</p>
<p>DCL（Data Control Language）是数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。</p>
<p>因为DDL没有事务性，所以DDL不能回滚。要实现自动回滚。(begin,commit,rollback)，则SQL语句中只能包括DML。</p>
<p><strong>MySQL默认操作模式就是autocommit自动提交模式。这就表示除非显式地开始一个事务，否则每个查询都被当做一个单独的事务自动执行。</strong></p>
<p>mysqldump导出数据库</p>
<h2 id="SQL-truncate-、delete与drop区别"><a href="#SQL-truncate-、delete与drop区别" class="headerlink" title="SQL truncate 、delete与drop区别"></a>SQL truncate 、delete与drop区别</h2><p>相同点：<br>1.truncate和不带where子句的delete、以及drop都会删除表内的数据。<br>2.drop、truncate都是DDL语句(数据定义语言),执行后会自动提交。</p>
<p>不同点：<br>1.truncate 和 delete 只删除数据不删除表的结构(定义)<br>drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。<br>2.delete 语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。<br>truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。<br>3.速度，一般来说: drop&gt; truncate &gt; delete<br>DELETE语句执行删除操作的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。<br>TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。<br>4.安全性：小心使用 drop 和 truncate，尤其没有备份的时候.否则哭都来不及<br>使用上,想删除部分数据行用 delete，注意带上where子句. 回滚段要足够大.<br>想删除表,当然用 drop<br>想保留表而将所有数据删除，如果和事务无关，用truncate即可。如果和事务有关,或者想触发trigger,还是用delete。</p>
<h2 id="primary-key-key-index-unique"><a href="#primary-key-key-index-unique" class="headerlink" title="primary key,key,index,unique"></a><code>primary key</code>,<code>key</code>,<code>index</code>,<code>unique</code></h2><p>primary key是主键，一个表中只能有一个主键，mysql会为其建造聚集索引<br>unique表示不会重复，有唯一约束，一个表中可以有多个unique<br>mysql中key和index是同义的，是索引的意思，没有唯一约束<br><code>key</code>,<code>index</code>,<code>unique</code>建造的都是B+树索引</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图可以定义在多张表上，因此定义功能比表强。<br>视图中数据更新受到诸多限制，例如不能有聚集函数，不能是定义在多张表上等，因此操作功能弱于表。<br>视图的数据控制功能和表的数据控制功能相当，都有GRANT、REVOKE。</p>
<h2 id="连接-join"><a href="#连接-join" class="headerlink" title="连接 join"></a>连接 join</h2><p>左外连接的结果集包括 LEFT OUTER 子句中指定的左表的所有行，而不仅仅是连接列所匹配的行<br>右外连接是左向外连接的反向连接。将返回右表的所有行。<br>全外连接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。 (类似于求并集)<br>内连接使用比较运算符根据每个表共有的列的值匹配两个表中的行。(类似于求交集)<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/mysqljoin.jpg" alt="mysql中的join" title="">
                </div>
                <div class="image-caption">mysql中的join</div>
            </figure></p>
<p>join的原则：小表驱动大表，即小表放在外层<br><a href="http://www.kuqin.com/database/20081206/29717.html" target="_blank" rel="external">http://www.kuqin.com/database/20081206/29717.html</a><br><a href="http://www.cnblogs.com/zhengyun_ustc/p/slowquery1.html" target="_blank" rel="external">http://www.cnblogs.com/zhengyun_ustc/p/slowquery1.html</a></p>
<h2 id="having、group-by、"><a href="#having、group-by、" class="headerlink" title="having、group by、"></a>having、group by、</h2><p>● 聚合语句avg，min等必须要和group联合使用</p>
<p>● 需要注意having和where的用法区别：<br>1.having只能用在group by之后，对分组后的结果进行筛选(即使用having的前提条件是分组)。<br>2.where肯定在group by 之前<br>3.where后的条件表达式里不允许使用聚合函数，而having可以。</p>
<blockquote>
<p>SELECT COUNT(CustomerID), Country<br>FROM Customers<br>where City like ‘_o%’<br>GROUP BY Country<br>HAVING COUNT(CustomerID) &gt; 5 limit 10;</p>
</blockquote>
<p>● 当一个查询语句同时出现了where,group by,having,order by的时候，执行顺序和编写顺序是：<strong>wghso我哥好帅哦</strong><br>1.执行where xx对全表数据做筛选，返回第1个结果集。<br>2.针对第1个结果集使用group by分组，返回第2个结果集。<br>3.针对第2个结果集中的每1组数据执行select xx，有几组就执行几次，返回第3个结果集。<br>4.针对第3个结集执行having xx进行筛选，返回第4个结果集。<br>5.针对第4个结果集排序。</p>
<p>FROM &amp; JOINs determine &amp; filter rows<br>WHERE more filters on the rows<br>GROUP BY combines those rows into groups<br>HAVING filters groups<br>ORDER BY arranges the remaining rows/groups<br>LIMIT filters on the remaining rows/groups</p>
<p><a href="http://stackoverflow.com/questions/1130062/what-is-the-execution-sequence-of-group-by-having-and-where-clause-in-sql-server" target="_blank" rel="external">http://stackoverflow.com/questions/1130062/what-is-the-execution-sequence-of-group-by-having-and-where-clause-in-sql-server</a></p>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>1NF:原子性 字段不可再分,否则就不是关系数据库;<br>2NF:唯一性 一个表只说明一个事物;<br>3NF:每列都与主键有直接关系，不存在传递依赖;<br><a href="https://www.zhihu.com/question/24696366" target="_blank" rel="external">https://www.zhihu.com/question/24696366</a></p>
<h2 id="分页功能"><a href="#分页功能" class="headerlink" title="分页功能"></a>分页功能</h2><p>利用limit关键字<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">mysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15  </div><div class="line">//为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：   </div><div class="line">mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.  </div><div class="line">//如果只给定一个参数，它表示返回最大的记录行数目：   </div><div class="line">mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行  </div><div class="line">//换句话说，LIMIT n 等价于 LIMIT 0,n。</div></pre></td></tr></table></figure></p>
<h2 id="事务调优原则"><a href="#事务调优原则" class="headerlink" title="事务调优原则"></a>事务调优原则</h2><p>1、尽可能较小锁的覆盖范围<br>2、尽可能让多线程并发访问数据<br>3、并发度不高使用乐观锁，并发度较高使用悲观锁</p>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
    
    </summary>
    
      <category term="note" scheme="http://duyao.github.io/categories/note/"/>
    
    
      <category term="数据库" scheme="http://duyao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>nio</title>
    <link href="http://duyao.github.io/2017/04/18/nio/"/>
    <id>http://duyao.github.io/2017/04/18/nio/</id>
    <published>2017-04-18T08:16:57.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="io模型"><a href="#io模型" class="headerlink" title="io模型"></a>io模型</h1><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><p>现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。<br>操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全。<br>操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。<br>针对Linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/linuxkernel.png" alt="用户空间和内核空间" title="">
                </div>
                <div class="image-caption">用户空间和内核空间</div>
            </figure></p>
<h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。<br>因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<ol>
<li>保存处理机上下文，包括程序计数器和其他寄存器。</li>
<li>更新PCB信息。</li>
<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其PCB。</li>
<li>更新内存管理的数据结构。</li>
<li>恢复处理机上下文。</li>
</ol>
<h3 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h3><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。<br>可见，进程的阻塞是进程自身的一种主动行为，也因此<strong>只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态</strong>。<strong>当进程进入阻塞状态，是不占用CPU资源的</strong>。</p>
<h3 id="文件描述符fd"><a href="#文件描述符fd" class="headerlink" title="文件描述符fd"></a>文件描述符fd</h3><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。<strong>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符</strong>。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<h3 id="缓存-I-O"><a href="#缓存-I-O" class="headerlink" title="缓存 I/O"></a>缓存 I/O</h3><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。<br>在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，<strong>数据会先被拷贝到操作系统内核的缓冲区中</strong>，<strong>然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</strong>。</p>
<p>缓存 I/O 的缺点：<br>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<h2 id="io模型-1"><a href="#io模型-1" class="headerlink" title="io模型"></a>io模型</h2><p>刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<ol>
<li>等待数据准备 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ol>
<p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。</p>
<ul>
<li>阻塞I/O（blocking IO）</li>
<li>非阻塞I/O（nonblocking IO）</li>
<li>I/O多路复用（ IO multiplexing）</li>
<li>异步I/O（asynchronous IO）</li>
</ul>
<h3 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h3><p>在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/blockingio.png" alt="阻塞I/O" title="">
                </div>
                <div class="image-caption">阻塞I/O</div>
            </figure><br>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>
<blockquote>
<p>blocking IO的特点就是在IO执行的两个阶段都被block了。</p>
</blockquote>
<h3 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h3><p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/nonblockingio.png" alt="非阻塞I/O" title="">
                </div>
                <div class="image-caption">非阻塞I/O</div>
            </figure><br>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<blockquote>
<p>nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</p>
</blockquote>
<h3 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I/O 多路复用"></a>I/O 多路复用</h3><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。<br>select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/iomultiplexing.png" alt="I/O" title="">
                </div>
                <div class="image-caption">I/O</div>
            </figure><br>当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<blockquote>
<p>所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
</blockquote>
<h4 id="select，poll，epoll区别"><a href="#select，poll，epoll区别" class="headerlink" title="select，poll，epoll区别"></a>select，poll，epoll区别</h4><p>1、支持一个进程所能打开的最大连接数<br>select有上限，poll没有上限、epoll基本没有上限<br>2、FD剧增后带来的IO效率问题<br>select和poll每次调用都要线性遍历，而epoll使用callback回调函数<br>3、消息传递方式<br>select和poll消息要从内核空间传递到用户空间，需要内核拷贝，epoll通过内核和用户空间共享一块内存空间来实现消息传递</p>
<p>select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善<br><strong>java nio包是select模型</strong></p>
<p><a href="https://my.oschina.net/xianggao/blog/663655" target="_blank" rel="external">https://my.oschina.net/xianggao/blog/663655</a><br><a href="http://blog.sae.sina.com.cn/archives/5042" target="_blank" rel="external">http://blog.sae.sina.com.cn/archives/5042</a></p>
<h3 id="异步-I-O"><a href="#异步-I-O" class="headerlink" title="异步 I/O"></a>异步 I/O</h3><p>Linux下的asynchronous IO其实用得很少。先看一下它的流程：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/asynchronousio.png" alt="异步" title="">
                </div>
                <div class="image-caption">异步</div>
            </figure><br>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<p><a href="http://blog.csdn.net/ywcpig/article/details/52540853?locationNum=1&amp;fps=1" target="_blank" rel="external">http://blog.csdn.net/ywcpig/article/details/52540853?locationNum=1&amp;fps=1</a></p>
<h3 id="几种-I-O-模型的比较"><a href="#几种-I-O-模型的比较" class="headerlink" title="几种 I/O 模型的比较"></a>几种 I/O 模型的比较</h3><p>前三种模型的区别是阶段1不相同，阶段2基本相同，都是将数据从内核拷贝到调用者的缓冲区。而异步 I/O 的两个阶段都不同于三四个模型。<br>同步 I/O 操作引起请求进程阻塞，直到 I/O 操作完成。异步 I/O 操作不引起请求进程阻塞。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/ComparisonIOmodels.png" alt="I/O" title="">
                </div>
                <div class="image-caption">I/O</div>
            </figure><br>阻塞与非阻塞指的的是当不能进行读写（网卡满时的写/网卡空的时候的读）的时候，I/O 操作立即返回还是阻塞；同步异步指的是，当数据已经ready的时候，读写操作是同步读还是异步读，阶段不同而已。</p>
<h2 id="java中的io模型"><a href="#java中的io模型" class="headerlink" title="java中的io模型"></a>java中的io模型</h2><p>阻塞I/O：服务器启动后，等待客户端连接。在客户端连接服务器后，服务器就阻塞读写取数据流。就是普通的serversocket，这种情况一个客户端连接之后，只能accept一个客户端，其他的是连接不到的</p>
<p>阻塞I/O+多线程：每次接收到新的连接都要新建一个线程，处理完成后销毁线程，但是这样做代价大，当有大量地短连接出现时，性能比较低。</p>
<p>阻塞I/O+线程池：针对上面多线程的模型中，出现的线程重复创建、销毁带来的开销，可以采用线程池来优化。每次接收到新连接后从池中取一个空闲线程进行处理，处理完成后再放回池中，重用线程避免了频率地创建和销毁线程带来的开销。<br>存在着问题：在大量短连接的场景中性能会有提升，因为不用每次都创建和销毁线程，而是重用连接池中的线程。但在大量长连接的场景中，因为线程被连接长期占用，不需要频繁地创建和销毁线程，因而没有什么优势。虽然这种方法可以适用于小到中度规模的客户端的并发数，如果连接数超过 100,000或更多，那么性能将很不理想。</p>
<p>“阻塞I/O+线程池”网络模型虽然比”阻塞I/O+多线程”网络模型在性能方面有提升，但这两种模型都存在一个共同的问题：读和写操作都是同步阻塞的,面对大并发（持续大量连接同时请求）的场景，需要消耗大量的线程来维持连接。CPU 在大量的线程之间频繁切换，性能损耗很大。一旦单机的连接超过1万，甚至达到几万的时候，服务器的性能会急剧下降。</p>
<p>而 NIO 的 Selector 却很好地解决了这个问题，用主线程（一个线程或者是 CPU 个数的线程）保持住所有的连接，管理和读取客户端连接的数据，将读取的数据交给后面的线程池处理，线程池处理完业务逻辑后，将结果交给主线程发送响应给客户端，少量的线程就可以处理大量连接的请求。<br>Java NIO 由以下几个核心部分组成：</p>
<ul>
<li>Channel</li>
<li>Buffer</li>
<li>Selector</li>
</ul>
<p>要使用 Selector，得向 Selector 注册 Channel，然后调用它的 select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。</p>
<p>异步I/O”模式<br>Java SE 7 版本之后，引入了异步 I/O （NIO.2） 的支持，为构建高性能的网络应用提供了一个利器。</p>
<p><a href="https://waylau.com/java-io-model-evolution/#" target="_blank" rel="external">https://waylau.com/java-io-model-evolution/#</a><br><a href="https://github.com/waylau/essential-java/blob/master/docs/io-model.md" target="_blank" rel="external">https://github.com/waylau/essential-java/blob/master/docs/io-model.md</a></p>
<h2 id="两种IO多路复用方案-Reactor-and-Proactor"><a href="#两种IO多路复用方案-Reactor-and-Proactor" class="headerlink" title="两种IO多路复用方案:Reactor and Proactor"></a>两种IO多路复用方案:Reactor and Proactor</h2><p>一般情况下，I/O 复用机制需要事件分享器(event demultiplexor )。 事件分享器的作用，即将那些读写事件源分发给各读写事件的处理者，就像送快递的在楼下喊: 谁的什么东西送了， 快来拿吧。开发人员在开始的时候需要在分享器那里注册感兴趣的事件，并提供相应的处理者(event handlers)，或者是回调函数; 事件分享器在适当的时候会将请求的事件分发给这些handler或者回调函数。<br>涉及到事件分享器的两种模式称为：Reactor and Proactor 。<br><strong>Reactor模式是基于同步I/O的，而Proactor模式是和异步I/O相关的</strong>。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/reactor.png" alt="Reactor" title="">
                </div>
                <div class="image-caption">Reactor</div>
            </figure><br>在Reactor模式中，事件分离者等待某个事件或者可应用或个操作的状态发生（比如文件描述符可读写，或者是socket可读写），事件分离者就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。</p>
<p>而在Proactor模式中，事件处理者(或者代由事件分离者发起)直接发起一个异步读写操作(相当于请求)，而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区，读的数据大小，或者用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分离者得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。举例来说，在Windows上事件处理者投递了一个异步IO操作(称有overlapped的技术)，事件分离者等IOCompletion事件完成。 这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可称之为“系统级别”的或者“真正意义上”的异步，因为具体的读写是由操作系统代劳的。<br><a href="http://blog.jobbole.com/59676/" target="_blank" rel="external">http://blog.jobbole.com/59676/</a></p>
<h1 id="nio"><a href="#nio" class="headerlink" title="nio"></a>nio</h1><p>Java NIO（ New IO） 是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。<br>NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同， NIO支持面向缓冲区的、基于通道的IO操作。 NIO将以更加高效的方式进行文件的读写操作。</p>
<table>
<thead>
<tr>
<th>IO</th>
<th style="text-align:center">NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td>面向流(Stream Oriented)</td>
<td style="text-align:center">面向缓冲区(Buffer Oriented)</td>
</tr>
<tr>
<td>阻塞IO(Blocking IO)</td>
<td style="text-align:center">非阻塞IO(Non Blocking IO)</td>
</tr>
<tr>
<td>(无)</td>
<td style="text-align:center">选择器(Selectors)</td>
</tr>
</tbody>
</table>
<p>Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。<br>Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/nio.png" alt="Java" title="">
                </div>
                <div class="image-caption">Java</div>
            </figure>
<p>Java NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。<br>通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。<br>然后操作缓冲区，对数据进行处理。</p>
<h2 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h2><p>缓冲区（ Buffer） ：一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。<br>Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的。<br>Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下 Buffer 常用子类：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<p>上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。都是通过如下方法获取一个 Buffer对象：<br>static XxxBuffer allocate(int capacity) : 创建一个容量为 capacity 的 XxxBuffer 对象</p>
<h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><p>容量 (capacity) ： 表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。<br>限制 (limit)： 第一个不应该读取或写入的数据的索引，即位于 limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量。<br>位置 (position)： 下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制<br>标记 (mark)与重置 (reset)： 标记是一个索引，通过 Buffer 中的 mark() 方法指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这个 position.<br>标记、 位置、 限制、 容量遵守不变式：<strong>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</strong><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/buufer.png" alt="I/O" title="">
                </div>
                <div class="image-caption">I/O</div>
            </figure></p>
<p>Buffer 所有子类提供了两个用于数据操作的方法： get()与 put() 方法<br>获取 Buffer 中的数据</p>
<ul>
<li>get() ：读取单个字节</li>
<li>get(byte[] dst)：批量读取多个字节到 dst 中</li>
<li>get(int index)：读取指定索引位置的字节(不会移动 position)<br>放入数据到 Buffer 中</li>
<li>put(byte b)：将给定单个字节写入缓冲区的当前位置</li>
<li>put(byte[] src)：将 src 中的字节写入缓冲区的当前位置</li>
<li>put(int index, byte b)：将指定字节写入缓冲区的索引位置(不会移动 position)</li>
</ul>
<p>equals()与compareTo()方法<br>可以使用equals()和compareTo()方法两个Buffer。</p>
<p>equals()当满足下列条件时，表示两个Buffer相等：</p>
<ul>
<li>有相同的类型（byte、char、int等）。</li>
<li>Buffer中剩余的byte、char等的个数相等。</li>
<li>Buffer中所有剩余的byte、char等都相同。<br>如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。</li>
</ul>
<p>compareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：</p>
<ul>
<li>第一个不相等的元素小于另一个Buffer中对应的元素 。</li>
<li>所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。<br><strong>剩余元素是从 position到limit之间的元素</strong></li>
</ul>
<p>compact()和clear()<br>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。<br>如果调用的是clear()方法，position将被设回0，limit被设置成 capacity的值。换句话说，Buffer相当于 被清空了（实际上Buffer中的内容并未真正被清空，此时如果调用rewind()或者设置position=0仍然可读取旧的数据）。该方法实际上只是重设了position和limit的值，进而告诉我们可以从哪里开始往Buffer里写数据。如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。</p>
<h3 id="Buffer常用方法"><a href="#Buffer常用方法" class="headerlink" title="Buffer常用方法"></a>Buffer常用方法</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/bufferfun.png" alt="Buffer常用方法" title="">
                </div>
                <div class="image-caption">Buffer常用方法</div>
            </figure>
<h3 id="直接缓冲区和非直接缓冲区"><a href="#直接缓冲区和非直接缓冲区" class="headerlink" title="直接缓冲区和非直接缓冲区"></a>直接缓冲区和非直接缓冲区</h3><p>字节缓冲区要么是直接的，要么是非直接的。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/allocateDirect.png" alt="直接缓冲区和非直接缓冲区" title="">
                </div>
                <div class="image-caption">直接缓冲区和非直接缓冲区</div>
            </figure><br>非直接缓冲区：通过 allocate() 方法分配缓冲区，将缓冲区建立在 JVM 的内存中<br>直接缓冲区：通过 allocateDirect() 方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高效率</p>
<p>如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），<strong>虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）</strong>。<br>直接字节缓冲区可以通过调用此类的 <code>allocateDirect()</code> 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。</p>
<p><code>public abstract MappedByteBuffer map(MapMode mode,long position, long size)</code><br>直接字节缓冲区还可以通过 <code>FileChannel</code> 的 <code>map()</code> 方法 将<strong>文件区域直接映射到物理内存中来创建</strong>。该方法返回<code>MappedByteBuffer</code> 。 Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。</p>
<p>字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 <code>isDirect()</code> 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。</p>
<h4 id="HeapByteBuffer和DirectByteBuffer以及MappedByteBuffer区别"><a href="#HeapByteBuffer和DirectByteBuffer以及MappedByteBuffer区别" class="headerlink" title="HeapByteBuffer和DirectByteBuffer以及MappedByteBuffer区别"></a>HeapByteBuffer和DirectByteBuffer以及MappedByteBuffer区别</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/mapdirectheap.png" alt="三者的关系" title="">
                </div>
                <div class="image-caption">三者的关系</div>
            </figure>
<p>在<code>ByteBuffer.allocate(int capacity)</code>和<code>ByteBuffer.wrap(byte[] array)</code>中，通过实例化<code>HeapByteBuffer</code>来创建的ByteBuffer对象就是heap buffer.<br>在<code>ByteBuffer.allocateDirect(int capacity)</code>方法中调用<code>DirectByteBuffer(capacity)</code>这个类创建的是direct buffer</p>
<p>Direct Buffer则是通过JNI(native方法)在Java的虚拟机外的内存中分配了一块缓冲区(所以即使在运行时通过-Xmx指定了Java虚拟机的最大堆内存，还是可以实例化超出该大小的Direct ByteBuffer),该块并不直接由Java虚拟机负责垃圾回收收集，但是在direct buffer包装类<code>DirectByteBuffer</code>被回收时，会通过Java Reference机制来释放该内存块。(但Direct Buffer的JAVA对象<code>DirectByteBuffer</code>是归GC管理的，只要GC回收了它的JAVA对象，操作系统才会释放Direct Buffer所申请的空间)。<br>DirectByteBuffer 自身是一个Java对象，在Java堆中；而这个对象中有个long类型字段address，记录着一块调用 malloc() 申请到的native memory。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">		 Java        |      native</div><div class="line">                  |</div><div class="line">DirectByteBuffer  |     malloc&apos;d</div><div class="line">[    address   ] -+-&gt; [   data    ]</div><div class="line">                  |</div></pre></td></tr></table></figure></p>
<p><strong>DirectByteBuffer 自身是（Java）堆内的，它背后真正承载数据的buffer是在（Java）堆外——native memory中的</strong>。这是 malloc() 分配出来的内存，是用户态的。<br><a href="https://www.zhihu.com/question/57374068/answer/152691891" target="_blank" rel="external">https://www.zhihu.com/question/57374068/answer/152691891</a></p>
<p><strong>heap buffer这种缓冲区是分配在堆上面的，直接由Java虚拟机负责垃圾回收</strong>，可以直接想象成一个字节数组的包装类。<br>FileChannel 的read(ByteBuffer dst)函数,write(ByteBuffer src)函数中，<strong>如果传入的参数是HeapBuffer类型,则会临时申请一块DirectBuffer,进行数据拷贝，而不是直接进行数据传输.</strong></p>
<p>劣势：创建和释放Direct Buffer的代价比Heap Buffer得要高；<br>优势：当我们把一个Direct Buffer写入Channel的时候，就好比是“内核缓冲区”的内容直接写入了Channel，这样显然快了，减少了数据拷贝（因为我们平时的read/write都是需要在I/O设备与应用程序空间之间的“内核缓冲区”中转一下的）。而当我们把一个Heap Buffer写入Channel的时候，实际上底层实现会先构建一个临时的Direct Buffer，然后把Heap Buffer的内容复制到这个临时的Direct Buffer上，再把这个Direct Buffer写出去。当然，如果我们多次调用write方法，把一个Heap Buffer写入Channel，底层实现可以重复使用临时的Direct Buffer，这样不至于因为频繁地创建和销毁Direct Buffer影响性能。</p>
<p>结论：Direct Buffer创建和销毁的代价很高，所以要用在尽可能重用的地方。 比如周期长传输文件大采用direct buffer，不然一般情况下就直接用heap buffer 就好。<br><a href="http://eyesmore.iteye.com/blog/1133335" target="_blank" rel="external">http://eyesmore.iteye.com/blog/1133335</a></p>
<blockquote>
<p>The difference between the buffer types is that MappedByteBuffers are allocated in virtual-memory space in the operating system. R/W done with MappedByteBuffers is managed at the OS level by the VM paging logic. Direct ByteBuffers are just a solid slab of free memory (e.g. malloc) in RAM that you can utilize from within Java and treated by the OS as a standard memory allocation.<br>A MappedByteBuffer represents a section of memory allocated using mmap call, which is used to perform memory mapped I/O. Therefore MappedByteBuffers won’t register their use of memory in the same way a Direct ByteBuffer will.</p>
</blockquote>
<p><a href="http://www.developersite.org/903-129308-file" target="_blank" rel="external">http://www.developersite.org/903-129308-file</a><br><a href="http://stackoverflow.com/questions/1229037/difference-between-bytebuffer-allocatedirect-and-mappedbytebuffer-load" target="_blank" rel="external">http://stackoverflow.com/questions/1229037/difference-between-bytebuffer-allocatedirect-and-mappedbytebuffer-load</a><br>DirectByteBuffers是操作系统中真实的区域，通过malloc在用户空间申请的内存区域，并不是在jvm中<br>MappedByteBuffers申请了操作系统中的虚拟内存，当这块buffer进行读写操作的时候，需要操作系统进行页的置换，并没有真正的申请内存，只是调用了mmap()方法</p>
<p><strong>内存映射文件和标准IO操作最大的不同之处就在于它虽然最终也是要从磁盘读取数据，但是它并不需要将数据读取到OS内核缓冲区，而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系</strong>，就好像直接从内存中读、写文件一样，速度当然快了<br>Linux只能怪有块区域叫做“Memory mapped region for shared libraries” ，这段区域就是在内存映射文件的时候将某一段的虚拟地址和文件对象的某一部分建立起映射关系，此时并没有拷贝数据到内存中去，而是当进程代码第一次引用这段代码内的虚拟地址时，触发了缺页异常，这时候OS根据映射关系直接将文件的相关部分数据拷贝到进程的用户私有空间中去，当有操作第N页数据的时候重复这样的OS页面调度程序操作。注意啦，原来内存映射文件的效率比标准IO高的重要原因就是因为少了把数据拷贝到OS内核缓冲区这一步</p>
<p><a href="http://blog.csdn.net/fcbayernmunchen/article/details/8635427" target="_blank" rel="external">http://blog.csdn.net/fcbayernmunchen/article/details/8635427</a></p>
<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/bufferchannel.png" alt="数据的传输过程" title="">
                </div>
                <div class="image-caption">数据的传输过程</div>
            </figure>
<p>通道（ Channel）：由 java.nio.channels 包定义的。 Channel 表示 IO 源与目标打开的连接。Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据， Channel 只能与Buffer 进行交互。</p>
<p>Java 为 Channel 接口提供的最主要实现类如下：</p>
<ul>
<li>FileChannel：用于读取、写入、映射和操作文件的通道。</li>
<li>DatagramChannel：通过 UDP 读写网络中的数据通道。</li>
<li>SocketChannel：通过 TCP 读写网络中的数据。</li>
<li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<p>获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下：</p>
<ul>
<li>FileInputStream</li>
<li>FileOutputStream</li>
<li>RandomAccessFile</li>
<li>DatagramSocket</li>
<li>Socket</li>
<li>ServerSocket</li>
</ul>
<p>获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获取字节通道。<br><code>FileChannel channel = new RandomAccessFile(&quot;1.txt&quot;, &quot;rw&quot;).getChannel()</code><br>或者通过通道的静态方法 open() 打开并返回指定通道。<br><code>public static FileChannel open(Path path, OpenOption... options) throws IOException</code><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/filechannel.png" alt="FileChannel常见用法" title="">
                </div>
                <div class="image-caption">FileChannel常见用法</div>
            </figure></p>
<h3 id="通道的数据传输"><a href="#通道的数据传输" class="headerlink" title="通道的数据传输"></a>通道的数据传输</h3><p>通道将数据传输给ByteBuffer对象或者从ByteBuffer对象获取数据进行传输<br>通道可以是单向(unidirectional)或者双向的(bidirectional)。一个channel类可能实现定义read()方法的ReadableByteChannel接口，而另一个channel类也许实现WritableByteChannel接口以提供write()方法。实现这两种接口其中之一的类都是单向的，只能在一个方向上传输数据。如果一个类同时实现这两个接口，那么它是双向的，可以双向传输数据。</p>
<p>标准io<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">	FileInputStream fis = <span class="keyword">null</span>;</div><div class="line">	FileOutputStream fos = <span class="keyword">null</span>;</div><div class="line">	<span class="comment">//①获取通道</span></div><div class="line">	FileChannel inChannel = <span class="keyword">null</span>;</div><div class="line">	FileChannel outChannel = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		fis = <span class="keyword">new</span> FileInputStream(<span class="string">"d:/1.mkv"</span>);</div><div class="line">		fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"d:/2.mkv"</span>);</div><div class="line"></div><div class="line">		inChannel = fis.getChannel();</div><div class="line">		outChannel = fos.getChannel();</div><div class="line"></div><div class="line">		<span class="comment">//②分配指定大小的缓冲区</span></div><div class="line">		ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line"></div><div class="line">		<span class="comment">//③将通道中的数据存入缓冲区中</span></div><div class="line">		<span class="keyword">while</span>(inChannel.read(buf) != -<span class="number">1</span>)&#123;</div><div class="line">			buf.flip(); <span class="comment">//切换读取数据的模式</span></div><div class="line">			<span class="comment">//④将缓冲区中的数据写入通道中</span></div><div class="line">			outChannel.write(buf);</div><div class="line">			buf.clear(); <span class="comment">//清空缓冲区</span></div><div class="line">		&#125;</div><div class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">		e.printStackTrace();</div><div class="line">	&#125; <span class="keyword">finally</span> &#123;</div><div class="line">		<span class="keyword">if</span>(outChannel != <span class="keyword">null</span>)&#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				outChannel.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(inChannel != <span class="keyword">null</span>)&#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				inChannel.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(fos != <span class="keyword">null</span>)&#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				fos.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(fis != <span class="keyword">null</span>)&#123;</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				fis.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>直接io<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line"></div><div class="line">	FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">"d:/1.mkv"</span>), StandardOpenOption.READ);</div><div class="line">	FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">"d:/2.mkv"</span>), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);</div><div class="line"></div><div class="line">	<span class="comment">//内存映射文件</span></div><div class="line">	MappedByteBuffer inMappedBuf = inChannel.map(MapMode.READ_ONLY, <span class="number">0</span>, inChannel.size());</div><div class="line">	MappedByteBuffer outMappedBuf = outChannel.map(MapMode.READ_WRITE, <span class="number">0</span>, inChannel.size());</div><div class="line"></div><div class="line">	<span class="comment">//直接对缓冲区进行数据的读写操作</span></div><div class="line">	<span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[inMappedBuf.limit()];</div><div class="line">	inMappedBuf.get(dst);</div><div class="line">	outMappedBuf.put(dst);</div><div class="line"></div><div class="line">	inChannel.close();</div><div class="line">	outChannel.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="分散-Scatter-和聚集-Gather"><a href="#分散-Scatter-和聚集-Gather" class="headerlink" title="分散(Scatter)和聚集(Gather)"></a>分散(Scatter)和聚集(Gather)</h3><p>分散读取（ Scattering Reads）是指从 Channel 中读取的数据“分散” 到多个 Buffer 中。<br>注意：按照缓冲区的顺序，从 Channel 中读取的数据依次将 Buffer 填满。<br><code>public final long read(ByteBuffer[] dsts) throws IOException</code><br>聚集写入（ Gathering Writes）是指将多个 Buffer 中的数据“聚集”到 Channel。<br>注意：按照缓冲区的顺序，写入 position 和 limit 之间的数据到 Channel 。<br><code>public final long write(ByteBuffer[] srcs) throws IOException</code></p>
<h3 id="通道之间的传输"><a href="#通道之间的传输" class="headerlink" title="通道之间的传输"></a>通道之间的传输</h3><p><code>public abstract long transferFrom(ReadableByteChannel src, long position, long count)</code><br><code>public abstract long transferTo(long position, long count, WritableByteChannel target)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">	FileChannel inChannel = FileChannel.open(Paths.get(<span class="string">"d:/1.mkv"</span>), StandardOpenOption.READ);</div><div class="line">	FileChannel outChannel = FileChannel.open(Paths.get(<span class="string">"d:/2.mkv"</span>), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);</div><div class="line"></div><div class="line"><span class="comment">//		inChannel.transferTo(0, inChannel.size(), outChannel);</span></div><div class="line">	outChannel.transferFrom(inChannel, <span class="number">0</span>, inChannel.size());</div><div class="line"></div><div class="line">	inChannel.close();</div><div class="line">	outChannel.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="网络channel"><a href="#网络channel" class="headerlink" title="网络channel"></a>网络channel</h3><p>ServerSocketChannel： Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道，就像标准IO中的ServerSocket一样。</p>
<p>SocketChannel：Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。<br>操作步骤：① 打开 SocketChannel ② 读写数据 ③ 关闭 SocketChanne</p>
<p>DatagramChannel：Java NIO中的DatagramChannel是一个能收发UDP包的通道。<br>操作步骤： ① 打开 DatagramChannel ② 接收/发送数据</p>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>选择器（ Selector） 是 <code>SelectableChannle</code> 对象的多路复用器， Selector 可以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector可使一个单独的线程管理多个 Channel。 Selector 是非阻塞 IO 的核心。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/selectablechannel.png" alt="SelectableChannle" title="">
                </div>
                <div class="image-caption">SelectableChannle</div>
            </figure><br>由此可见selector只能监控网络channel</p>
<p>Selector 的常用方法<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/selector.png" alt="Selector" title="">
                </div>
                <div class="image-caption">Selector</div>
            </figure></p>
<h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>SelectionKey： 表示 SelectableChannel 和 Selector 之间的注册关系。<br>每次向选择器注册通道时就会选择一个事件(选择键)。 选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作。<br>可以监听的事件类型（ 可使用 SelectionKey 的四个常量表示）：<br>读 : SelectionKey.OP_READ （ 1）<br>写 : SelectionKey.OP_WRITE （ 4）<br>连接 : SelectionKey.OP_CONNECT （ 8）<br>接收 : SelectionKey.OP_ACCEPT （ 16）<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/selelctablekey.png" alt="SelectionKey" title="">
                </div>
                <div class="image-caption">SelectionKey</div>
            </figure></p>
<h3 id="选择器（-Selector）的应用"><a href="#选择器（-Selector）的应用" class="headerlink" title="选择器（ Selector）的应用"></a>选择器（ Selector）的应用</h3><p>1.创建 Selector ：通过调用 <code>Selector selector = Selector.open()</code> 方法创建一个 Selector。<br>2.向选择器注册通道： <code>SelectableChannel.register(Selector sel, int ops)</code><br>当调用 <code>register(Selector sel, int ops)</code> 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定。</p>
<p>若注册时不止监听一个事件，则可以使用“位或”操作符连接。<br><code>SelectableChannel.register(selector, SelectionKey.OP_ACCEPT|SelectionKey.OP_READ)</code></p>
<h3 id="NIO中的server"><a href="#NIO中的server" class="headerlink" title="NIO中的server"></a>NIO中的server</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">	<span class="comment">//1. 获取通道</span></div><div class="line">	ServerSocketChannel ssChannel = ServerSocketChannel.open();</div><div class="line"></div><div class="line">	<span class="comment">//2. 切换非阻塞模式</span></div><div class="line">	ssChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">	<span class="comment">//3. 绑定连接</span></div><div class="line">	ssChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9898</span>));</div><div class="line"></div><div class="line">	<span class="comment">//4. 获取选择器</span></div><div class="line">	Selector selector = Selector.open();</div><div class="line"></div><div class="line">	<span class="comment">//5. 将通道注册到选择器上, 并且指定“监听接收事件”</span></div><div class="line">	ssChannel.register(selector, SelectionKey.OP_ACCEPT);</div><div class="line"></div><div class="line">	<span class="comment">//6. 轮询式的获取选择器上已经“准备就绪”的事件</span></div><div class="line">	<span class="keyword">while</span>(selector.select() &gt; <span class="number">0</span>)&#123;</div><div class="line"></div><div class="line">		<span class="comment">//7. 获取当前选择器中所有注册的“选择键(已就绪的监听事件)”</span></div><div class="line">		Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();</div><div class="line"></div><div class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">			<span class="comment">//8. 获取准备“就绪”的是事件</span></div><div class="line">			SelectionKey sk = it.next();</div><div class="line"></div><div class="line">			<span class="comment">//9. 判断具体是什么事件准备就绪</span></div><div class="line">			<span class="keyword">if</span>(sk.isAcceptable())&#123;</div><div class="line">				<span class="comment">//10. 若“接收就绪”，获取客户端连接</span></div><div class="line">				SocketChannel sChannel = ssChannel.accept();</div><div class="line"></div><div class="line">				<span class="comment">//11. 切换非阻塞模式</span></div><div class="line">				sChannel.configureBlocking(<span class="keyword">false</span>);</div><div class="line"></div><div class="line">				<span class="comment">//12. 将该通道注册到选择器上</span></div><div class="line">				sChannel.register(selector, SelectionKey.OP_READ);</div><div class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(sk.isReadable())&#123;</div><div class="line">				<span class="comment">//13. 获取当前选择器上“读就绪”状态的通道</span></div><div class="line">				SocketChannel sChannel = (SocketChannel) sk.channel();</div><div class="line"></div><div class="line">				<span class="comment">//14. 读取数据</span></div><div class="line">				ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line"></div><div class="line">				<span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">				<span class="keyword">while</span>((len = sChannel.read(buf)) &gt; <span class="number">0</span> )&#123;</div><div class="line">					buf.flip();</div><div class="line">					System.out.println(<span class="keyword">new</span> String(buf.array(), <span class="number">0</span>, len));</div><div class="line">					buf.clear();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">//15. 取消选择键 SelectionKey</span></div><div class="line">			it.remove();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="管道-Pipe"><a href="#管道-Pipe" class="headerlink" title="管道 (Pipe)"></a>管道 (Pipe)</h1><p>Java NIO 管道是2个线程之间的单向数据连接。<br>Pipe有一个source通道和一个sink通道。<strong>数据会被写到sink通道，从source通道读取</strong>。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/pipe.png" alt="SelectionKey" title="">
                </div>
                <div class="image-caption">SelectionKey</div>
            </figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</div><div class="line">	<span class="comment">//1. 获取管道</span></div><div class="line">	Pipe pipe = Pipe.open();</div><div class="line"></div><div class="line">	<span class="comment">//2. 将缓冲区中的数据写入管道</span></div><div class="line">	ByteBuffer buf = ByteBuffer.allocate(<span class="number">1024</span>);</div><div class="line"></div><div class="line">	Pipe.SinkChannel sinkChannel = pipe.sink();</div><div class="line">	buf.put(<span class="string">"通过单向管道发送数据"</span>.getBytes());</div><div class="line">	buf.flip();</div><div class="line">	sinkChannel.write(buf);</div><div class="line"></div><div class="line">	<span class="comment">//3. 读取缓冲区中的数据</span></div><div class="line">	Pipe.SourceChannel sourceChannel = pipe.source();</div><div class="line">	buf.flip();</div><div class="line">	<span class="keyword">int</span> len = sourceChannel.read(buf);</div><div class="line">	System.out.println(<span class="keyword">new</span> String(buf.array(), <span class="number">0</span>, len));</div><div class="line"></div><div class="line">	sourceChannel.close();</div><div class="line">	sinkChannel.close();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="Path、-Paths、-Files、CharSet"><a href="#Path、-Paths、-Files、CharSet" class="headerlink" title="Path、 Paths、 Files、CharSet"></a>Path、 Paths、 Files、CharSet</h1><p><a href="http://www.365mini.com/page/tag/java-nio" target="_blank" rel="external">http://www.365mini.com/page/tag/java-nio</a><br><a href="http://ifeve.com/?x=0&amp;y=0&amp;s=nio" target="_blank" rel="external">http://ifeve.com/?x=0&amp;y=0&amp;s=nio</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;io模型&quot;&gt;&lt;a href=&quot;#io模型&quot; class=&quot;headerlink&quot; title=&quot;io模型&quot;&gt;&lt;/a&gt;io模型&lt;/h1&gt;&lt;h2 id=&quot;一些概念&quot;&gt;&lt;a href=&quot;#一些概念&quot; class=&quot;headerlink&quot; title=&quot;一些概念&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="note" scheme="http://duyao.github.io/categories/note/"/>
    
    
      <category term="java nio" scheme="http://duyao.github.io/tags/java-nio/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://duyao.github.io/2017/04/17/%E6%8E%92%E5%BA%8F/"/>
    <id>http://duyao.github.io/2017/04/17/排序/</id>
    <published>2017-04-17T06:57:47.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="各种排序算法"><a href="#各种排序算法" class="headerlink" title="各种排序算法"></a>各种排序算法</h1><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/sort.png" alt="排序算法比较" title="">
                </div>
                <div class="image-caption">排序算法比较</div>
            </figure>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">     <span class="keyword">if</span> (low &lt; high) &#123;<span class="comment">//这里要判断</span></div><div class="line">         <span class="comment">//先找出pivot</span></div><div class="line">         <span class="keyword">int</span> pivot = partition(arr, low, high);</div><div class="line">         <span class="comment">//分别排序</span></div><div class="line">         quicksort(arr, low, pivot);</div><div class="line">         quicksort(arr, pivot + <span class="number">1</span>, high);</div><div class="line"></div><div class="line">     &#125;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">     <span class="comment">//每次都要和flag进行比较</span></div><div class="line">     <span class="keyword">int</span> flag = arr[low];</div><div class="line">     <span class="keyword">while</span> (low &lt; high) &#123;</div><div class="line">         <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[high] &gt;= flag) &#123;</div><div class="line">             high--;</div><div class="line">         &#125;</div><div class="line"></div><div class="line">         <span class="comment">//交换low和high的位置</span></div><div class="line">         swap(arr, low, high);</div><div class="line"></div><div class="line">         <span class="keyword">while</span> (low &lt; high &amp;&amp; arr[low] &lt;= flag) &#123;</div><div class="line">             low++;</div><div class="line">         &#125;</div><div class="line">         swap(arr, low, high);</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//返回的是下标</span></div><div class="line">     <span class="keyword">return</span> low;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="双轴快排"><a href="#双轴快排" class="headerlink" title="双轴快排"></a>双轴快排</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Partitioning:</div><div class="line"></div><div class="line"> left part           center part                   right part</div><div class="line">+--------------------------------------------------------------+</div><div class="line">|  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</div><div class="line">+--------------------------------------------------------------+</div><div class="line">             ^                          ^       ^</div><div class="line">             |                          |       |</div><div class="line">            less                        k     great</div><div class="line"></div><div class="line">Invariants:</div><div class="line"></div><div class="line">            all in (left, less)   &lt; pivot1</div><div class="line">  pivot1 &lt;= all in [less, k)     &lt;= pivot2</div><div class="line">            all in (great, right) &gt; pivot2</div><div class="line"></div><div class="line">Pointer k is the first index of ?-part.</div></pre></td></tr></table></figure>
<p>一般的快速排序采用一个枢轴来把一个数组划分成两半，然后递归之。<br>大量经验数据表面，采用两个枢轴来划分成3份的算法更高效，这就是DualPivotQuicksort。<br>动画：<a href="https://learnforeverlearn.com/yaro_web/" target="_blank" rel="external">https://learnforeverlearn.com/yaro_web/</a><br><a href="http://www.tuicool.com/articles/BfY7Nz" target="_blank" rel="external">http://www.tuicool.com/articles/BfY7Nz</a></p>
<h2 id="bfprt"><a href="#bfprt" class="headerlink" title="bfprt"></a>bfprt</h2><p>Median of medians<br>时间复杂度O(N)<br>其精髓是选择pivot，不是任意的选,<br>而是选择中位数中的中位数-Median of medians<br>步骤：<br>5个数分一组，分为n/5一组<br>组内插入排序，选择所有的上中位数，单独组成一个数组arrm[]<br>求所有中位数的中位数，即arrm[]的中位数，使用递归调用，求出次中位数pivot<br>然后快排使用pivot来划分区域，看k是否是中间区域<br><a href="http://blog.duyaokeep.cn/2015/11/05/5.2/" target="_blank" rel="external">http://blog.duyaokeep.cn/2015/11/05/5.2/</a></p>
<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">    <span class="comment">//初次建堆</span></div><div class="line">    <span class="comment">//这里是以0开头的数组，因此最后一个非子节点是arr.length / 2 - 1，如果序号是1就是arr.length / 2</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        heapy(arr, i, arr.length);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//每次堆排都把最大的放在0的位置，然后把排好的放在最后</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</div><div class="line">        swap(arr, <span class="number">0</span>, i);</div><div class="line">        heapy(arr, <span class="number">0</span>, i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapy</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> parent, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">     <span class="comment">//每次都和这个值比较，即使parent变化</span></div><div class="line">     <span class="keyword">int</span> tmp = arr[parent];</div><div class="line">     <span class="keyword">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">     <span class="keyword">while</span> (child &lt; len) &#123;</div><div class="line">         <span class="keyword">if</span> (child + <span class="number">1</span> &lt; len &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>]) &#123;</div><div class="line">             child++;</div><div class="line">         &#125;</div><div class="line">         <span class="keyword">if</span> (tmp &gt; arr[child]) &#123;</div><div class="line">             <span class="keyword">break</span>;</div><div class="line">         &#125;</div><div class="line">         arr[parent] = arr[child];</div><div class="line">         parent = child;</div><div class="line">         child = parent * <span class="number">2</span> + <span class="number">1</span>;</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//因为上面已经将父节点下移，所以tmp相当于与给子节点赋值了</span></div><div class="line">     arr[parent] = tmp;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>初次建立堆的过程是O(n)，heapy的过程是O(logn)<br>堆排总的时间复杂度是O(nlogn)因为一共n个数字每个数字都要堆化heapyO(logn)</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="comment">//仍然要加条件</span></div><div class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</div><div class="line">        <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</div><div class="line">        mergesort(arr, low, mid);</div><div class="line">        mergesort(arr, mid + <span class="number">1</span>, high);</div><div class="line">        mergeArray(arr, low, mid, high);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeArray</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</div><div class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> i = low, j = mid + <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</div><div class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</div><div class="line">            tmp[cnt++] = arr[i];</div><div class="line">            i++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            tmp[cnt++] = arr[j];</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</div><div class="line">        tmp[cnt++] = arr[i++];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (j &lt;= high) &#123;</div><div class="line">        tmp[cnt++] = arr[j++];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (cnt = <span class="number">0</span>; cnt + low &lt;= high; cnt++) &#123;</div><div class="line">        arr[cnt + low] = tmp[cnt];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>又称为桶排序，将数字按照位数拆分为若干个关键字，每次对一位进行排序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line"></div><div class="line">      <span class="keyword">int</span> max = array[<span class="number">0</span>];</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;  <span class="comment">//找到数组中的最大值</span></div><div class="line">          <span class="keyword">if</span> (array[i] &gt; max) &#123;</div><div class="line">              max = array[i];</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">int</span> keysNum = <span class="number">0</span>;  <span class="comment">//关键字的个数，我们使用个位、十位、百位...当做关键字，所以关键字的个数就是最大值的位数</span></div><div class="line">      <span class="keyword">while</span> (max &gt; <span class="number">0</span>) &#123;</div><div class="line">          max /= <span class="number">10</span>;</div><div class="line">          keysNum++;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      List&lt;ArrayList&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  <span class="comment">//每位可能的数字为0~9，所以设置10个桶</span></div><div class="line">          buckets.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());  <span class="comment">//桶由ArrayList&lt;Integer&gt;构成</span></div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keysNum; i++) &#123;  <span class="comment">//由最次关键字开始，依次按照关键字进行分配</span></div><div class="line"></div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length; j++) &#123;  <span class="comment">//扫描所有数组元素，将元素分配到对应的桶中</span></div><div class="line">              <span class="comment">//取出该元素对应第i+1位上的数字，比如258，现在要取出十位上的数字，258%100=58,58/10=5</span></div><div class="line">              <span class="keyword">int</span> key = array[j] % (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, i + <span class="number">1</span>) / (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, i);</div><div class="line">              buckets.get(key).add(array[j]);  <span class="comment">//将该元素放入关键字为key的桶中</span></div><div class="line">          &#125;</div><div class="line"></div><div class="line">          <span class="comment">//分配完之后，将桶中的元素依次复制回数组</span></div><div class="line">          <span class="keyword">int</span> counter = <span class="number">0</span>;  <span class="comment">//元素计数器</span></div><div class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</div><div class="line">              ArrayList&lt;Integer&gt; bucket = buckets.get(j);  <span class="comment">//关键字为j的桶</span></div><div class="line">              <span class="keyword">while</span> (bucket.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">                  array[counter++] = bucket.remove(<span class="number">0</span>);  <span class="comment">//将桶中的第一个元素复制到数组，并移除</span></div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h1 id="其它排序"><a href="#其它排序" class="headerlink" title="其它排序"></a>其它排序</h1><p>冒泡排序<a href="http://blog.csdn.net/u012152619/article/details/47305859" target="_blank" rel="external">http://blog.csdn.net/u012152619/article/details/47305859</a><br>选择排序<a href="http://blog.csdn.net/u012152619/article/details/47306053" target="_blank" rel="external">http://blog.csdn.net/u012152619/article/details/47306053</a><br>插入排序<a href="http://blog.csdn.net/u012152619/article/details/47306209" target="_blank" rel="external">http://blog.csdn.net/u012152619/article/details/47306209</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;各种排序算法&quot;&gt;&lt;a href=&quot;#各种排序算法&quot; class=&quot;headerlink&quot; title=&quot;各种排序算法&quot;&gt;&lt;/a&gt;各种排序算法&lt;/h1&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=
    
    </summary>
    
      <category term="note" scheme="http://duyao.github.io/categories/note/"/>
    
    
      <category term="java" scheme="http://duyao.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer</title>
    <link href="http://duyao.github.io/2017/04/12/%E5%89%91%E6%8C%87offer/"/>
    <id>http://duyao.github.io/2017/04/12/剑指offer/</id>
    <published>2017-04-12T13:26:22.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h1><p><a href="http://www.lintcode.com/zh-cn/problem/count-1-in-binary/" target="_blank" rel="external">http://www.lintcode.com/zh-cn/problem/count-1-in-binary/</a><br>原理是n&amp;(n-1)就能把最右边的1变成0<br>比如：n=5的二进制是101,n-1=4二进制是100，n&amp;(n-1)=101&amp;100=100，这样5中最右边的1就变成了0<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countOnes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</div><div class="line">        cnt++;</div><div class="line">        n = n &amp; (n - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还可以判断一个是是不是2的指数(2的指数中只有1位是1)<br>还可以判断一个二进制数变为另一个二进制数需要转换几位(先异或，再求)</p>
<h1 id="在O-1-时间复杂度删除链表节点"><a href="#在O-1-时间复杂度删除链表节点" class="headerlink" title="在O(1)时间复杂度删除链表节点"></a>在O(1)时间复杂度删除链表节点</h1><p><a href="http://www.lintcode.com/zh-cn/problem/delete-node-in-the-middle-of-singly-linked-list/" target="_blank" rel="external">http://www.lintcode.com/zh-cn/problem/delete-node-in-the-middle-of-singly-linked-list/</a><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/deletenode.png" alt="删除链表节点" title="">
                </div>
                <div class="image-caption">删除链表节点</div>
            </figure><br>a图是一个链表<br>b图是已知先序删除链表的过程<br>c图是只知道要删除节点，那么需要将该删除节点和后继换位置，然后删除后继就可以完成删除节点的过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</div><div class="line">    ListNode next = node.next;</div><div class="line">    <span class="keyword">if</span>(next != <span class="keyword">null</span>)&#123;</div><div class="line">        <span class="keyword">int</span> a = next.val;</div><div class="line">        next.val = node.val;</div><div class="line">        node.val = a;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        node = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    node.next = next.next;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><h1 id="搜索二维矩阵"><a href="#搜索二维矩阵" class="headerlink" title="搜索二维矩阵"></a>搜索二维矩阵</h1><p><a href="http://www.lintcode.com/zh-cn/problem/search-a-2d-matrix-ii/" target="_blank" rel="external">http://www.lintcode.com/zh-cn/problem/search-a-2d-matrix-ii/</a><br>在每行每列的矩阵中寻找元素个数<br>这道题目应该在矩阵右上角开始查找，然后划线删除法<br>下图是查找数字7的过程<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/findinsort.png" alt="搜索二维矩阵" title="">
                </div>
                <div class="image-caption">搜索二维矩阵</div>
            </figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = matrix[<span class="number">0</span>].length-<span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; matrix.length &amp;&amp; j&gt;=<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(matrix[i][j] &gt; target)&#123;</div><div class="line">            j--;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &lt; target)&#123;</div><div class="line">            i++;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            cnt++;</div><div class="line">            j--;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> cnt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="是否是子树"><a href="#是否是子树" class="headerlink" title="是否是子树"></a>是否是子树</h1><p><a href="http://www.lintcode.com/zh-cn/problem/subtree/" target="_blank" rel="external">http://www.lintcode.com/zh-cn/problem/subtree/</a><br>首先从t1中的每一个值对比t2的根节点，<br>如果值不相同，就要继续比较t1中的值和t2<br>如果值相同，就可以比较是不是完全相同的子树了<br>==如果完全相同的子树返回<br>==如果不完全相同就继续比较的！！！，即t1.left和t1.right于t2比较<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode T1, TreeNode T2)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (T2 == <span class="keyword">null</span> || T1 == <span class="keyword">null</span> &amp;&amp; T2 == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T1 == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">if</span> (T1.val != T2.val) &#123;</div><div class="line">              <span class="keyword">return</span> isSubtree(T1.left, T2) || isSubtree(T1.right, T2);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//这里不能直接返回isSame(T1, T2)，不相同要继续比较</span></div><div class="line">              <span class="keyword">if</span> (isSame(T1, T2)) &#123;</div><div class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">              &#125; <span class="keyword">else</span> &#123;</div><div class="line">                  <span class="keyword">return</span> isSubtree(T1.left, T2) || isSubtree(T1.right, T2);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSame</span><span class="params">(TreeNode T1, TreeNode T2)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (T1 == <span class="keyword">null</span> &amp;&amp; T2 != <span class="keyword">null</span> || T2 == <span class="keyword">null</span> &amp;&amp; T1 != <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T1 == <span class="keyword">null</span> &amp;&amp; T2 == <span class="keyword">null</span>) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T1.val != T2.val) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">return</span> isSame(T1.left, T2.left) &amp;&amp; isSame(T1.right, T2.right);</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二进制中1的个数&quot;&gt;&lt;a href=&quot;#二进制中1的个数&quot; class=&quot;headerlink&quot; title=&quot;二进制中1的个数&quot;&gt;&lt;/a&gt;二进制中1的个数&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.lintcode.com/zh-cn/problem
    
    </summary>
    
      <category term="algorithm" scheme="http://duyao.github.io/categories/algorithm/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="http://duyao.github.io/2017/04/10/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://duyao.github.io/2017/04/10/操作系统/</id>
    <published>2017-04-10T06:42:30.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>程序是指令的集合，进程是程序的真正运行。<br>同一个程序对应多个进程，允许多个用户云运行同一程序。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/jincheng.jpg" alt="进程状态图" title="">
                </div>
                <div class="image-caption">进程状态图</div>
            </figure></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程被称为轻量级进程，是程序执行流的最小单元。<br>线程是进程中的一个实体，是系统独立调度和执行的最小单位。<br>线程自己不拥有资源，只拥有一点必不可少的资源。可以与同一进程的其他线程共享资源。<br>进程与线程的区别：<a href="https://duyao.github.io/2017/02/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/">https://duyao.github.io/2017/02/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/</a></p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>（1）管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。<br>（2）命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。<br>（3）信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送 信号给进程本身；Linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。<br>（4）消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺<br>（5）共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。<br>（6）内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。<br>（7）信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。<br>（8）套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。</p>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="调度的基本准则"><a href="#调度的基本准则" class="headerlink" title="调度的基本准则"></a>调度的基本准则</h3><p>不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法所具有的特性。为了比较处理机调度算法的性能，人们提出很多评价准则，下面介绍主要的几种：<br>1) CPU利用率。CPU是计算机系统中最重要和昂贵的资源之一，所以应尽可能使CPU 保持“忙”状态，使这一资源利用率最髙。<br>2) 系统吞吐量。表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理机时间，因此会降低系统的吞吐量。而对于短作业，它们所需要消耗的处理机时间较短，因此能提高系统的吞吐量。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。<br>3) 周转时间。是指从<strong>作业提交到作业完成</strong>所经历的时间，包括<strong>作业等待、在就绪队列中排队、在处理机上运行以及进行输入/输出操作所花费时间</strong>的总和。</p>
<p>作业的周转时间可用公式表示如下：</p>
<blockquote>
<p>周转时间 = 作业完成时间 - 作业提交时间 = 等待时间 + 实际运行时间</p>
</blockquote>
<p>平均周转时间是指多个作业周转时间的平均值：</p>
<blockquote>
<p>平均周转时间 = (作业1的周转时间 + … + 作业 n 的周转时间) / n</p>
</blockquote>
<p>带权周转时间是指<strong>作业周转时间与作业实际运行时间的比值</strong>，<br>平均带权周转时间是指多个作业带权周转时间的平均值：</p>
<blockquote>
<p>平均带权周转时间 = (作业1的带权周转时间 + … + 作业 n 的带权周转时间) / n</p>
</blockquote>
<p>4) 等待时间。=开始时间—提交时间。<br>是指进程处于等处理机状态时间之和，等待时间越长，用户满意度越低。处理机调度算法实际上并不影响作业执行或输入/输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，衡量一个调度算法优劣常常只需简单地考察等待时间。</p>
<p>5) 响应时间。是指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不可能是最好的评价准则，一般釆用响应时间作为衡量调度算法的重要准则之一。从用户角度看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内。</p>
<p>要想得到一个满足所有用户和系统要求的算法几乎是不可能的。设计调度程序，一方面要满足特定系统用户的要求（如某些实时和交互进程快速响应要求)，另一方面要考虑系统整体效率（如减少整个系统进程平均周转时间），同时还要考虑调度算法的开销。</p>
<h3 id="调度算法-1"><a href="#调度算法-1" class="headerlink" title="调度算法"></a>调度算法</h3><h4 id="先来先服务-FCFS-调度算法"><a href="#先来先服务-FCFS-调度算法" class="headerlink" title="先来先服务(FCFS)调度算法"></a>先来先服务(FCFS)调度算法</h4><p>FCFS调度算法是一种最简单的调度算法，该调度算法既可以用于作业调度也可以用于进程调度。</p>
<p>FCFS调度算法属于<strong>不可剥夺算法</strong>。从表面上看，它对所有作业都是公平的，但若一个长作业先到达系统，就会使后面许多短作业等待很长时间，因此它不能作为分时系统和实时系统的主要调度策略。但它常被结合在其他调度策略中使用。例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程按FCFS原则处理。</p>
<p>FCFS调度算法的特点是算法简单，但效率低；<strong>对长作业比较有利，但对短作业不利</strong>（相对SJF和高响应比）；<strong>有利于CPU繁忙型作业，而不利于I/O繁忙型作业</strong>。</p>
<h4 id="短作业优先-SJF-调度算法"><a href="#短作业优先-SJF-调度算法" class="headerlink" title="短作业优先(SJF)调度算法"></a>短作业优先(SJF)调度算法</h4><p>短作业（进程）优先调度算法（Shortest Job First ）是指对短作业（进程）优先调度的算法。该调度算法既可以用于作业调度也可以用于进程调度。</p>
<p>SJF调度算法也存在不容忽视的缺点：<br>该算法对长作业不利，容易对长作业产生饥饿现象。<br>该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理。<br>注意，<strong>SJF调度算法的平均等待时间、平均周转时间最少</strong>。</p>
<h4 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h4><p>优先级调度算法又称优先权调度算法，该算法既可以用于作业调度，也可以用于进程调度，该算法中的优先级用于描述作业运行的紧迫程度。</p>
<p>根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为：</p>
<p>1)非剥夺式优先级调度算法:<br>当某一个进程正在处理机上运行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在运行的进程继续运行，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件），才把处理机分配给更为重要或紧迫的进程。<br>2)剥夺式优先级调度算法:<br>当一个进程正在处理机上运行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给更重要或紧迫的进程。</p>
<p>而根据进程创建后其优先级是否可以改变，可以将进程优先级分为以下两种：<br>1)静态优先级。优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。<br>2)动态优先级。在进程运行过程中，根据进程情况的变化动态调整优先级。动态调整优先级的主要依据为进程占有CPU时间的长短、就绪进程等待CPU时间的长短。</p>
<h4 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h4><p>高响应比优先调度算法主要用于作业调度，该算法是<strong>对FCFS调度算法和SJF调度算法的一种综合平衡</strong>，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</p>
<p>响应比的变化规律可描述为：</p>
<blockquote>
<p>响应比=(等待时间+要求服务时间)/要求服务时间</p>
</blockquote>
<p>根据公式可知：<br>当作业的等待时间相同时，则要求服务时间越短，其响应比越高，有利于短作业。<br>当要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而它实现的是先来先服务。<br>对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。克服了饥饿状态，兼顾了长作业。</p>
<h4 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h4><p>时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。</p>
<p>在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。如果时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法。如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少。因此时间片的大小应选择适当。</p>
<p>时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力。</p>
<h4 id="多级反馈队列调度算法（集合了前几种算法的优点）"><a href="#多级反馈队列调度算法（集合了前几种算法的优点）" class="headerlink" title="多级反馈队列调度算法（集合了前几种算法的优点）"></a>多级反馈队列调度算法（集合了前几种算法的优点）</h4><p>多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展。通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。例如，为提高系统吞吐量和缩短平均周转时间而照顾短进程；为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程；同时，也不必事先估计进程的执行时间。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/duojifankui.png" alt="多级反馈队列" title="">
                </div>
                <div class="image-caption">多级反馈队列</div>
            </figure>
<p>多级反馈队列调度算法的实现思想如下：<br>应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。<br>赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍， ……第i+1级队列的时间片要比第i级队列的时间片长一倍。<br>当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列……如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，<strong>在第 n 级队列中便釆用时间片轮转的方式运行</strong>。<br>仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ (i-1)中的任何一个队列），则此时<strong>新进程将抢占正在运行进程的处理机</strong>，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。</p>
<p>多级反馈队列的优势有：<br>终端型作业用户：短作业优先。<br>短批处理作业用户：周转时间较短。<br>长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理。</p>
<p><a href="http://blog.csdn.net/bigpudding24/article/details/48608483" target="_blank" rel="external">http://blog.csdn.net/bigpudding24/article/details/48608483</a></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>资源的竞争和进程推进顺序的不合理</p>
<h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><p>互不请环<br>（1） 互斥条件：一个资源每次只能被一个进程使用。<br>（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br>（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。<br>（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<h2 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h2><h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><p>破坏必要条件</p>
<h3 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h3><p>（1）有序资源分配法<br>这种算法资源按某种规则系统中的所有资源统一编号（例如打印机为1、磁带机为2、磁盘为3、等等），申请时必须以上升的次序。系统要求申请进程：<br>　　1、对它所必须使用的而且属于同一类的所有资源，必须一次申请完；<br>　　2、在申请不同类资源时，必须按各类设备的编号依次申请。例如：进程PA，使用资源的顺序是R1，R2； 进程PB，使用资源的顺序是R2，R1；若采用动态分配有可能形成环路条件，造成死锁。</p>
<p>采用有序资源分配法：R1的编号为1，R2的编号为2；<br>PA：申请次序应是：R1，R2<br>PB：申请次序应是：R1，R2<br>这样就破坏了环路条件，避免了死锁的发生<br>（2）银行算法<br>避免死锁算法中最有代表性的算法是Dijkstra E.W 于1968年提出的银行家算法：<br><strong>系统处于安全状态时，一定不会发生死锁；系统处于不安全状态时，不一定会发生死锁；</strong><br>该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。<br>这样申请者就可很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生。<br><a href="http://blog.csdn.net/only06/article/details/53381153" target="_blank" rel="external">http://blog.csdn.net/only06/article/details/53381153</a></p>
<h3 id="检测和解除"><a href="#检测和解除" class="headerlink" title="检测和解除"></a>检测和解除</h3><p>可以通过<strong>资源分配图检测</strong>检测死锁的存在<br><a href="http://c.biancheng.net/cpp/html/2607.html" target="_blank" rel="external">http://c.biancheng.net/cpp/html/2607.html</a></p>
<p>死锁的解除方法主要有：<br>资源剥夺、撤销进程、进程回退</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>某系统中有11台打印机，N个进程共享打印机资源，每个进程要求3台，当N的取值不超过（）时系统不会发生死锁。<br>设有m个资源，n个进程，每个进程要调用k个资源，一次只能调用一个，则：<br><code>m&gt;n(k-1)</code> 对应找满足条件的值即可。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>内存管理主要包括虚地址、地址变换、内存分配和回收、内存扩充、内存共享和保护等功能。</p>
<h2 id="逻辑地址和物理地址"><a href="#逻辑地址和物理地址" class="headerlink" title="逻辑地址和物理地址"></a>逻辑地址和物理地址</h2><p>程序编译后，每个目标模块都是从0号单元开始编址，成为该目标模块的相对地址(逻辑地址)。当连接程序将每个模块连接成一个完整的可执行目标程序是，连接程序顺序依次按各个模块的相对地址构成同一的从0号单元开始编制的逻辑地址空间。<br>物理地址空间是内存中物理单元的集合，是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址来存取主存。当转入程序将可执行代码装入到内存中的时候，必须通过地址转换将逻辑地址转换为物理地址。这个过程叫做重定位。</p>
<p><a href="http://blog.csdn.net/yusiguyuan/article/details/9664887" target="_blank" rel="external">http://blog.csdn.net/yusiguyuan/article/details/9664887</a></p>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>内存分配分为连续分配和不连续分配。<br>连续分配是指为用户分配一个连续的内存空间，主要包括单一连续分配、分区管理（固定分区分配和动态分区分配）<br>不连续分配允许一个程序分散的转入到不相邻的内存空间中：根据分区大小是否<strong>分页</strong>和<strong>分段</strong>存储管理两种方式；<br>在分页管理中，又根据运行作业时是否要把作业的所有页面装入到内存才能运行分为<strong>基本分页</strong>和<strong>请求分业</strong>。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/mmemory.png" alt="内存分配分类" title="">
                </div>
                <div class="image-caption">内存分配分类</div>
            </figure><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/cunchubijiao.png" alt="存储方法的比较" title="">
                </div>
                <div class="image-caption">存储方法的比较</div>
            </figure></p>
<h3 id="碎片"><a href="#碎片" class="headerlink" title="碎片"></a>碎片</h3><p>在内存管理中，<strong>内部碎片是已经被分配出去的的内存空间大于请求所需的内存空间</strong>。<br>外部碎片是指还没有分配出去，但是<strong>由于大小太小而无法分配给申请空间的新进程的内存空间空闲块</strong>。</p>
<h2 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h2><p>连续分配是指为一个用户程序分配连续的内存空间。连续分配有单一连续存储管理和分区式储管理两种方式。</p>
<h3 id="单一连续存储管理"><a href="#单一连续存储管理" class="headerlink" title="单一连续存储管理"></a>单一连续存储管理</h3><p>在这种管理方式中，内存被分为两个区域：系统区和用户区。<br>应用程序装入到用户区，可使用用户区全部空间。<br>其特点是，最简单，适用于单用户、单任务的操作系统。CP／M和 DOS 2．0以下就是采用此种方式。<br>这种方式的最大优点就是易于管理。但也存在着一些问题和不足之处，例如对要求内存空间少的程序，造成内存浪费；程序全部装入，使得很少使用的程序部分也占用—定数量的内存。</p>
<h3 id="分区式存储管理"><a href="#分区式存储管理" class="headerlink" title="分区式存储管理"></a>分区式存储管理</h3><p>为了支持多道程序系统和分时系统，支持多个程序并发执行，引入了分区式存储管理。<br>分区式存储管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区。<br>分区式存储管理虽然可以支持并发，但难以进行内存分区的共享。<br>分区式存储管理引人了两个新的问题：内碎片和外碎片。<br>内碎片是占用分区内未被利用的空间，外碎片是占用分区之间难以利用的空闲分区(通常是小空闲分区)。<br>为实现分区式存储管理，操作系统应维护的数据结构为分区表或分区链表。表中各表项一般包括每个分区的起始地址、大小及状态(是否已分配)。<br>分区式存储管理常采用的一项技术就是内存紧缩(compaction)。</p>
<h4 id="固定分区-nxedpartitioning-。"><a href="#固定分区-nxedpartitioning-。" class="headerlink" title="固定分区(nxedpartitioning)。"></a>固定分区(nxedpartitioning)。</h4><p>固定式分区的特点是把内存划分为若干个固定大小的连续分区。分区大小可以相等：这种作法只适合于多个相同程序的并发执行(处理多个类型相同的对象)。分区大小也可以不等：有多个小分区、适量的中等分区以及少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。<br>优点：易于实现，开销小。<br>缺点主要有两个：内碎片造成浪费；分区总数固定，限制了并发执行的程序数目。</p>
<h4 id="动态分区-dynamic-partitioning-。"><a href="#动态分区-dynamic-partitioning-。" class="headerlink" title="动态分区(dynamic partitioning)。"></a>动态分区(dynamic partitioning)。</h4><p>动态分区的特点是动态创建分区：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。<br>与固定分区相比较其优点是：<strong>没有内碎片，有外碎片</strong>。<br>动态分区的分区分配就是寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。<br>分区分配的先后次序通常是从内存低端到高端。<br>动态分区的分区释放过程中有一个要注意的问题是，将相邻的空闲分区合并成一个大的空闲分区。</p>
<p>下面列出了几种常用的分区分配算法：</p>
<blockquote>
<p>首次适应算法</p>
</blockquote>
<p>最自然的过程，只是按照空闲分区表(空闲区链)中的空闲分区的地址从低到高找到第一个可以满足需要的空闲分区即可。<br>该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。但随着低端分区不断划分会产生较多小分区，每次分配时查找时间开销便会增大。</p>
<blockquote>
<p>循环首次适应算法(next fit)</p>
</blockquote>
<p>按分区在内存的先后次序，从<strong>上次分配的分区起</strong>查找(到最后{区时再从头开始}，找到符合要求的第一个分区进行分配)。该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大空闲分区不易保留。</p>
<blockquote>
<p>最佳适配法(best-fit)</p>
</blockquote>
<p>按分区在内存的先后次序从头查找，找到其大小与要求相差最小的空闲分区进行分配。从个别来看，外碎片较小；但从整体来看，会形成较多外碎片优点是较大的空闲分区可以被保留。</p>
<blockquote>
<p>最坏适配法(worst- fit)</p>
</blockquote>
<p>按分区在内存的先后次序从头查找，找到最大的空闲分区进行分配。基本不留下小空闲分区，不易形成外碎片。但由于较大的空闲分区不被保留，当对内存需求较大的进程需要运行时，其要求不易被满足。</p>
<p>为了解决分区分配带来的碎片问题，引入了伙伴系统:无论已分配分区或空闲分区，其大小均为2的k次幂。在系统运行过程中，由于不断的划分，可能会形成若干个不连续的空闲分区，将这些空闲分区根据分区的大小进行分类，对于每一类具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表。这样，不同大小的空闲分区形成了k个空闲分区链表。</p>
<p><a href="http://blog.csdn.net/hguisu/article/details/5713164" target="_blank" rel="external">http://blog.csdn.net/hguisu/article/details/5713164</a></p>
<h2 id="基本内存管理"><a href="#基本内存管理" class="headerlink" title="基本内存管理"></a>基本内存管理</h2><p>是不连续分配的分配方式，主要分为分页、分段、段页</p>
<h3 id="基本分页存储管理"><a href="#基本分页存储管理" class="headerlink" title="基本分页存储管理"></a>基本分页存储管理</h3><p>将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)。<br>程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。<br>该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。<br>在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量）<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/pagem.jpg" alt="地址转换的过程" title="">
                </div>
                <div class="image-caption">地址转换的过程</div>
            </figure></p>
<p>页式管理方式的优点是：<br>1）没有外碎片，每个内碎片不超过页大比前面所讨论的几种管理方式的最大进步是，<br>2）一个程序不必连续存放。<br>3）便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。<br>缺点是：要求程序全部装入内存，没有足够的内存，程序就不能执行<br><a href="http://baike.baidu.com/link?url=BYjmowZdQZ1QHn0BXSXYdEBmB1e41Bp1_w9VTTlexXYUCD4g4zhC1t_1xMJbTqdAE0x1VMKPC2usTDHGuq66Fdv09zwQJBdaBwWy5KrpyUSnZfeklsh_uf5qUCZaSwNtbQ3YJeCr6OCiO3JpLpgaeoemLaFa3GV6-rSsEfQRfBe7sC3H6IXRohgjvyQCYAW0gpEBLH-ShOjqEOsZ1tjsOq" target="_blank" rel="external">http://baike.baidu.com/link?url=BYjmowZdQZ1QHn0BXSXYdEBmB1e41Bp1_w9VTTlexXYUCD4g4zhC1t_1xMJbTqdAE0x1VMKPC2usTDHGuq66Fdv09zwQJBdaBwWy5KrpyUSnZfeklsh_uf5qUCZaSwNtbQ3YJeCr6OCiO3JpLpgaeoemLaFa3GV6-rSsEfQRfBe7sC3H6IXRohgjvyQCYAW0gpEBLH-ShOjqEOsZ1tjsOq</a></p>
<h3 id="基本分段存储管理"><a href="#基本分段存储管理" class="headerlink" title="基本分段存储管理"></a>基本分段存储管理</h3><p>在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例如，有主程序段MAIN、子程序段X、数据段D及栈段S等。每个段都有自己的名字。为了实现简单起见，通常可用一个段号来代替段名，每个段都从0开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。整个作业的地址空间由于是分成多个段，因而是二维的，亦即，其逻辑地址由段号(段名)和段内地址所组成。<br>在段式存储管理中，将程序的地址空间划分为若干个段(segment)，这样每个进程有一个二维的地址空间。<br>其逻辑地址由段号和段内偏移组成<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/duanm.jpg" alt="地址转换的过程" title="">
                </div>
                <div class="image-caption">地址转换的过程</div>
            </figure><br>总的来说，段式存储管理的优点是：没有内碎片，外碎片可以通过内存紧缩来消除；便于实现内存共享。缺点与页式存储管理的缺点相同，进程必须全部装入内存。</p>
<p>为了实现段式管理，操作系统需要如下的数据结构来实现进程的地址空间到物理内存空间的映射，并跟踪物理内存的使用情况，以便在装入新的段的时候，合理地分配内存空间。<br><a href="http://baike.baidu.com/link?url=56HfbLNhe7kwyaavpBIffXZ3PHkXDjBaOEYBXDk4bHW8Z5U0ACQerZEIlj7_3vI1fdFUrmfhnoh6ag4_EVZYKRucH4PXpuH7z8Qo7UbF02rzFWhI0oV979I5MPDdl_TBnRjpt8rPhUKV7NIdap7jGU8U8U51uuBBubcOeMTAkfwXcjFS0aMsr7rypj_xtf9JpdgML50Ee8N4L4kayRfZFa" target="_blank" rel="external">http://baike.baidu.com/link?url=56HfbLNhe7kwyaavpBIffXZ3PHkXDjBaOEYBXDk4bHW8Z5U0ACQerZEIlj7_3vI1fdFUrmfhnoh6ag4_EVZYKRucH4PXpuH7z8Qo7UbF02rzFWhI0oV979I5MPDdl_TBnRjpt8rPhUKV7NIdap7jGU8U8U51uuBBubcOeMTAkfwXcjFS0aMsr7rypj_xtf9JpdgML50Ee8N4L4kayRfZFa</a></p>
<h5 id="段页式管理方式"><a href="#段页式管理方式" class="headerlink" title="段页式管理方式"></a>段页式管理方式</h5><h2 id="请求分页、段-虚拟内存管理"><a href="#请求分页、段-虚拟内存管理" class="headerlink" title="请求分页、段(虚拟内存管理)"></a>请求分页、段(虚拟内存管理)</h2><p>基本的内存管理方式有两个特征：<br>一次性：作业必须全部一次性装入，才能运行<br>驻留性：作业被装入内存后，就一直驻留在内存中，其任何以一部分都不会被换出，直至作业运行完毕。</p>
<p>基于程序局部性原理，可以将程序的一部分装入内存中，而其余部分留在外存，就可以让程序执行。程序执行过程中，当访问信息不存在内存的时候，有操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂不使用的内容换出到外存，从而腾出空间存放将要调入内存的信息，这样，操作系统好像为用户提供了一个比实际大很多的存储器，称为虚拟存储器。</p>
<p>虚拟内存的实现有以下三种方式：</p>
<ul>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页存储管理</li>
</ul>
<p>不管使用哪一种方式都需要一定的硬件支持，一般需要以下几方面：</p>
<ol>
<li>一定容量的内存和外存</li>
<li>页表机制或者段表机制，作为主要的数据结构</li>
<li>中断机构，当用户程序要范文的部分尚未调入内存的时候，则产生中断</li>
<li>地址变换机构，逻辑地址到物理地址的转换</li>
</ol>
<p>请求分页系统建立在基本的分页系统之上，为了支持虚拟内存功能而增加了请求调页功能和页面置换功能。</p>
<h3 id="请求分页过程"><a href="#请求分页过程" class="headerlink" title="请求分页过程"></a>请求分页过程</h3><h4 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h4><p>在请求分页系统中所需要的主要数据结构是页表。其基本作用仍然是将用户空间中的逻辑地址变换为内存空间中的物理地址。<br>由于只将应用程序的一部分调入内存，还有一部分仍在盘上，故需在页表中再增加若干项，供程序（数据）在换进、换出时参考。<br>在请求分页系统中的每个页表项如下所示：<br><code>页号 | 物理块号 | 状态位P | 访问字段A | 修改位M | 外存地址</code><br>各字段的说明如下：<br>—- 状态位P：用于指示该页是否已调入内存，供程序访问时参考。<br>—- 访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，供选择换出页面时参考。<br>—- 修改位M：表示该页在调入内存后是否被修改过。供置换页面时参考。<br>由于内存中的每一页都在外存上有一份副本，因此，若未被修改，在置换该页时就不需要将该页写回到外存上，以减少系统的开销和<br>启动磁盘的次数；若已被修改，则必须将该页重写到外存上，以保证外存中所保留的始终是最新副本。<br>—- 外存地址：用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。</p>
<h4 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h4><p><strong>在请求分页系统中，每当所要访问的页面不在内存中时，便产生一次缺页中断，请求OS将所缺之页调入内存</strong>。<br>缺页中断作为中断，同样需要经历诸如保护CPU现场、分析中断原因、转入缺页中断处理程序进行处理、恢复CPU现场等几个步骤。<br>但缺页中断又是一种特殊的中断，它与一般的中断相比，有着明显的区别，主要表现在下面两个方面：<br>a. 在指令执行期间产生和处理中断信号。通常，CPU都是在一条指令执行完成后，才检查是否有中断请求到达。若有，便去响应，否则，继续执行下一条指令。然而，缺页中断是在指令执行期间，发现所要访问的指令或数据不在内存时所产生和处理的。<br>b. 一条指令在执行期间，可能产生多次缺页中断。所以，系统中的硬件机构应能保存多次中断时的状态，并保证最后能返回到中断前产生缺页中断的指令处继续执行。</p>
<h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p><strong>请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟存储器而增加了某些功能而形成的，<br>如产生和处理缺页中断，以及从内存中换出一页的功能等等</strong>。</p>
<p>变换算法<br>虚拟存储器地址变换基本上有3种形虚拟存储器工作过程式：全联想变换、直接变换和组联想变换。<br>任何逻辑空间页面能够变换到物理空间任何页面位置的方式称为全联想变换。<br>每个逻辑空间页面只能变换到物理空间一个特定页面的方式称为直接变换。<br>组联想变换是指各组之间是直接变换，而组内各页间则是全联想变换。</p>
<p>在进行地址变换时，首先去检索快表，试图从中找出所要访问的页。<br>若找到，便修改页表项中的访问位。对于写指令，还需将修改位置成“1”，然后利用页表项中给出的物理块号和页内地址形成物理地址。地址变换过程到此结束。<br>如果在快表中未找到该页的页表项时，应到内存中去查找页表，再根据找到的页表项中的状态位P，了解该页是否已调入内存。<br>若该页已调入内存，这时应将此页的页表项写入快表，当快表已满时，应先调出按某种算法所确定的页的页表项；然后再写入该页的页表项。<br>若该页尚未调入内存，这时应产生缺页中断，请求OS从外存把该页调入内存。</p>
<h3 id="常见的页面置换功能"><a href="#常见的页面置换功能" class="headerlink" title="常见的页面置换功能"></a>常见的页面置换功能</h3><p>常见的置换算法有以下四种。</p>
<h4 id="最佳置换算法-OPT"><a href="#最佳置换算法-OPT" class="headerlink" title="最佳置换算法(OPT)"></a>最佳置换算法(OPT)</h4><p>最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。</p>
<h4 id="先进先出-FIFO-页面置换算法"><a href="#先进先出-FIFO-页面置换算法" class="headerlink" title="先进先出(FIFO)页面置换算法"></a>先进先出(FIFO)页面置换算法</h4><p><strong>优先淘汰最早进入内存的页面</strong>，亦即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。</p>
<p>FIFO算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由 Belady于1969年发现，故称为Belady异常<br><strong>只有FIFO算法可能出现Belady 异常，而LRU和OPT算法永远不会出现Belady异常。</strong></p>
<h4 id="最近最久未使用-LRU-置换算法"><a href="#最近最久未使用-LRU-置换算法" class="headerlink" title="最近最久未使用(LRU)置换算法"></a>最近最久未使用(LRU)置换算法</h4><p>选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。</p>
<p>实际上，LRU算法根据各页以前的情况，是“向前看”的，而最佳置换算法则根据各页以后的使用情况，是“向后看”的。</p>
<p><strong>LRU性能较好，但需要寄存器和栈的硬件支持</strong>。<br>LRU是堆栈类的算法。理论上可以证明，堆栈类算法不可能出现Belady异常。<br>FIFO算法基于队列实现，不是堆栈类算法。</p>
<h4 id="时钟-CLOCK-置换算法"><a href="#时钟-CLOCK-置换算法" class="headerlink" title="时钟(CLOCK)置换算法"></a>时钟(CLOCK)置换算法</h4><p>LRU算法的性能接近于OPT,但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。</p>
<p>简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。</p>
<p><a href="http://c.biancheng.net/cpp/html/2614.html" target="_blank" rel="external">http://c.biancheng.net/cpp/html/2614.html</a></p>
<h3 id="抖动（颠簸）"><a href="#抖动（颠簸）" class="headerlink" title="抖动（颠簸）"></a>抖动（颠簸）</h3><p>在页面置换过程中，最糟糕的情况是刚刚换出的页面又马上换入主存，刚刚换入主存的页面又要换出去，这种频繁的页面调度行为称为抖动或者颠簸。<br>即如果一个进程在换页的时间多于执行事件，这个进程就在抖动<br><strong>频繁地发生缺页中断主要原因是进程频繁访问的页面数高于可用的物理页帧数</strong>, 最直接有效的方法当然是撤销部分进程。<br>虚拟内存技术可以在内存中保留更多的进程以提髙系统效率。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。但如果管理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。</p>
<h3 id="工作集（驻留集）"><a href="#工作集（驻留集）" class="headerlink" title="工作集（驻留集）"></a>工作集（驻留集）</h3><p>工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。</p>
<p>工作集模型的原理是：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。</p>
<p>正确选择工作集的大小，对存储器的利用率和系统吞吐量的提嵩，都将产生重要影响。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程管理&quot;&gt;&lt;a href=&quot;#进程管理&quot; class=&quot;headerlink&quot; title=&quot;进程管理&quot;&gt;&lt;/a&gt;进程管理&lt;/h1&gt;&lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h
    
    </summary>
    
      <category term="note" scheme="http://duyao.github.io/categories/note/"/>
    
    
      <category term="os" scheme="http://duyao.github.io/tags/os/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式和工厂模式</title>
    <link href="http://duyao.github.io/2017/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://duyao.github.io/2017/04/05/设计模式-单例模式和工厂模式/</id>
    <published>2017-04-05T08:37:16.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>构造方法私有，不允许外部直接创建对象</p>
<h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><p>创建私有静态类的实例：因为构造私有，静态的话使用类就能得到，这个就能从通过方法获得实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="comment">//私有且静态</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </div><div class="line">    <span class="comment">//构造方法私有</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="comment">//获取实例的方法，静态</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">      <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为实例被设置为静态，类在加载时就被创建，不管用户是不是要调用</p>
<h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="comment">//声明</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="comment">//获得实例</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </div><div class="line">          instance = <span class="keyword">new</span> Singleton();  </div><div class="line">      &#125;  </div><div class="line">      <span class="keyword">return</span> instance;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。<br>优点：第一次调用才初始化，避免内存浪费。<br>缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。<br>getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。</p>
<p>为了提高性能，需要使用双重锁检查DCL，即 double-checked locking<br>使用volatile关键字是防止DCL失效<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </div><div class="line">      <span class="comment">//对于大部分情况，单例已经设好</span></div><div class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </div><div class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </div><div class="line">          <span class="comment">//线程安全</span></div><div class="line">          <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </div><div class="line">              singleton = <span class="keyword">new</span> Singleton();  </div><div class="line">          &#125;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> singleton;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </div><div class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">      <span class="keyword">return</span> SingletonHolder.INSTANCE;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方式能达到双检锁方式一样的功效，但实现更简单。<br>对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。</p>
<p>这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟饿汉不同的是：<br>饿汉方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），<br>而这种方式是 Singleton 类被装载了，instance 不一定被初始化。<br>因为 SingletonHolder 类没有被主动使用，<strong>只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类</strong>，从而实例化 instance。</p>
<p>想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比饿汉方式就显得很合理。</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </div><div class="line">    INSTANCE;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span> </span>&#123;  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Singleton a = Mo.INSTANCE;</div><div class="line">        Singleton b = Mo.INSTANCE;</div><div class="line">        System.out.println(a==b);<span class="comment">//true</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。<br>这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。<br>不能通过 reflection attack 来调用私有构造方法。</p>
<p><a href="http://www.runoob.com/design-pattern/singleton-pattern.html" target="_blank" rel="external">http://www.runoob.com/design-pattern/singleton-pattern.html</a></p>
<h2 id="破坏单例"><a href="#破坏单例" class="headerlink" title="破坏单例"></a>破坏单例</h2><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//启动JVM的安全检察,在进行反射校验的时候，判断一下是否是“singleton”，如果是，就禁止反射</span></div><div class="line">System.setSecurityManager(<span class="keyword">new</span> SecurityManager()&#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(Permission perm)</span> </span>&#123;</div><div class="line">       <span class="keyword">if</span> (perm <span class="keyword">instanceof</span> ReflectPermission &amp;&amp; <span class="string">"suppressAccessChecks"</span>.equals(perm.getName())) &#123;</div><div class="line">            <span class="keyword">for</span> (StackTraceElement elem : Thread.currentThread().getStackTrace()) &#123;</div><div class="line">                 <span class="keyword">if</span> (elem.getClassName().endsWith(<span class="string">"Singleton"</span>)) &#123;</div><div class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException();</div><div class="line">                 &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">   &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><a href="http://iamzhongyong.iteye.com/blog/2053010" target="_blank" rel="external">http://iamzhongyong.iteye.com/blog/2053010</a></p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>序列化单例后再反序列化回来会破坏单例，可以重写<code>readResolve</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> INSTANCE;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE; <span class="comment">//ensure singleton is returned upon deserialization.</span></div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>两个不同的类加载器，加载单例会产生两个不一样的单例<br><a href="http://javarevisited.blogspot.com/2011/03/10-interview-questions-on-singleton.html" target="_blank" rel="external">http://javarevisited.blogspot.com/2011/03/10-interview-questions-on-singleton.html</a><br><a href="http://stackoverflow.com/questions/11654876/cracking-singleton-with-other-ways" target="_blank" rel="external">http://stackoverflow.com/questions/11654876/cracking-singleton-with-other-ways</a></p>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>使用工厂方法代替<code>new</code>操作</li>
<li>工厂模式包括<code>工厂方法模式</code>和<code>抽象工厂模式</code></li>
<li><code>抽象工厂模式</code>是<code>工厂方法模式</code>的扩展</li>
</ul>
<h2 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h2><ul>
<li>定义一个接口老创建对象，但是让子类来决定哪些类需要被实例化</li>
<li>工厂发放把实例化的工作推迟到子类中去实现</li>
</ul>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>有一组类似的对象需要创建</li>
<li>在编码时不能预见需要创建哪种类的实例(超市里买苹果，不知道买蛇果，阿克苏还是冰糖心)</li>
<li>系统需要考虑扩展性</li>
</ul>
<h2 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h2><ul>
<li><p>jdbc<br>执行sql的java api，可以为多种数据库提供统一访问</p>
</li>
<li><p>spring Bean Factory<br>Bean Factory 是spring中IoC的基本容器，是一个产生bean给客户端的工厂</p>
</li>
</ul>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="工厂模式工厂模式" title="">
                </div>
                <div class="image-caption">工厂模式工厂模式</div>
            </figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="抽象工厂模式" title="">
                </div>
                <div class="image-caption">抽象工厂模式</div>
            </figure>
<ul>
<li>工厂模式是一种极段的抽象工厂模式，而抽象工厂模式是工厂模式的推广</li>
<li>工厂模式用来创建一个产品的等级结构，而抽象工厂模式用来创建多个产品的等级结构</li>
<li>工厂模式只有一个抽象产品类，而抽象工厂模式有多个抽象产品类</li>
</ul>
<p>抽象工程关键在于产品之间的抽象关系，所以至少要两个产品；工厂方法在于生成产品，不关注产品间的关系，所以可以只生成一个产品。<br>抽象工厂中客户端把产品的抽象关系理清楚，在最终使用的时候，一般使用客户端（和其接口），产品之间的关系是被封装固定的；而工厂方法是在最终使用的时候，使用产品本身（和其接口）。<br>抽象工厂的工厂是类；工厂方法的工厂是方法。</p>
<p>工厂方法模式： 一个抽象产品类，可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类只能创建一个具体产品类的实例。<br>抽象工厂模式： 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类可以创建多个具体产品类的实例。<br>区别： 工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。 工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单例模式&quot;&gt;&lt;/a&gt;单例模式&lt;/h1&gt;&lt;p&gt;构造方法私有，不允许外部直接创建对象&lt;/p&gt;
&lt;h2 id=&quot;饿汉模式&quot;&gt;&lt;a href=&quot;#饿汉模式&quot; class=&quot;he
    
    </summary>
    
      <category term="note" scheme="http://duyao.github.io/categories/note/"/>
    
    
      <category term="设计模式" scheme="http://duyao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>内部类</title>
    <link href="http://duyao.github.io/2017/04/01/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://duyao.github.io/2017/04/01/内部类/</id>
    <published>2017-04-01T02:23:51.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类</p>
<p>内部类会再生成一个class文件<br>编译器会为匿名内部类和局部内部类起名为Outter$Inner.class<br>内部类(非静态内部类)访问可以任意直接访问外部类，但是外部类不行<br>内部类(非静态内部类)不可以有静态的方法或者声明</p>
<p>创建静态内部类对象的一般形式为：  外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()<br>创建成员内部类对象的一般形式为：  外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名()</p>
<h1 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h1><p><strong>成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）</strong>。<br>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。<br>在外部类中如果要访问成员内部类的成员，必须<strong>先创建一个成员内部类的对象，再通过指向这个对象的引用来访问</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.radius = radius;</div><div class="line">        getInnerInstance().drawSahpe();   <span class="comment">//必须先创建成员内部类的对象，再进行访问</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner();</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;     <span class="comment">//内部类</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"drawshape"</span>);</div><div class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></div><div class="line">            System.out.println(count);   <span class="comment">//外部类的静态成员</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//第一种方式：</span></div><div class="line">        Outter outter = <span class="keyword">new</span> Outter();</div><div class="line">        Outter.Inner inner = outter.new Inner();  <span class="comment">//必须通过Outter对象来创建</span></div><div class="line"></div><div class="line">        <span class="comment">//第二种方式：</span></div><div class="line">        Outter.Inner inner1 = outter.getInnerInstance();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="为什么成员内部类可以无条件访问外部类的成员？"><a href="#为什么成员内部类可以无条件访问外部类的成员？" class="headerlink" title="为什么成员内部类可以无条件访问外部类的成员？"></a>为什么成员内部类可以无条件访问外部类的成员？</h2><p>反编译Outter$Inner.class<br>虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对Outter this&amp;0引用进行初始化赋值，也就无法创建成员内部类的对象了。</p>
<h1 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h1><p>局部内部类是定义在一个方法或者一个作用域里面的类<br>它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;   <span class="comment">//局部内部类</span></div><div class="line">            <span class="keyword">int</span> age =<span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Woman();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，<strong>局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的</strong>。</p>
<h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><p>匿名内部类应该是平时我们编写代码时用得最多的<br>形式为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> 父类构造器（参数列表）|实现接口（）  </div><div class="line">    &#123;  </div><div class="line">     <span class="comment">//匿名内部类的类体部分  </span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">       <span class="meta">@Override</span></div><div class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">   &#125;);</div></pre></td></tr></table></figure></p>
<p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。<br>匿名内部类在编译的时候由系统自动起名为Outter$1.class。<br>一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
<p>匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。</p>
<p>在使用匿名内部类的过程中，我们需要注意如下几点：<br>1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。<br>2、匿名内部类中是不能定义构造函数的。<br>3、匿名内部类中不能存在任何的静态成员变量和静态方法。<br>4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。<br>5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</p>
<h2 id="为什么局部内部类和匿名内部类只能访问局部final变量？"><a href="#为什么局部内部类和匿名内部类只能访问局部final变量？" class="headerlink" title="为什么局部内部类和匿名内部类只能访问局部final变量？"></a>为什么局部内部类和匿名内部类只能访问局部final变量？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">final</span> String name,String age)</span></span>&#123;</div><div class="line">        <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</div><div class="line">            <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</div><div class="line">                System.out.println(name);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//编译后实际是这个样子</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span>$<span class="title">InnerClass</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">(String name,String age)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.InnerClass$name = name;</div><div class="line">        <span class="keyword">this</span>.InnerClass$age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="keyword">this</span>.InnerClass$name + <span class="string">"----"</span> + <span class="keyword">this</span>.InnerClass$age );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。<br>也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。<br>从上面可以看出，在run方法中访问的变量a根本就不是test方法中的局部变量a。这样一来就解决了前面所说的 生命周期不一致的问题。但是新的问题又来了，既然在run方法中访问的变量a和test方法中的变量a不是同一个变量，当在run方法中改变变量a的值的话，会出现什么情况？</p>
<p>对，会造成数据不一致性，这样就达不到原本的意图和要求。为了解决这个问题，java编译器就限定必须将变量a限制为final变量，不允许对变量a进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。</p>
<p>到这里，想必大家应该清楚为何方法中的局部变量和形参都必须用final进行限定了。<br>在java1.8中，可以允许不加final<br><a href="http://www.cnblogs.com/chenssy/p/3390871.html" target="_blank" rel="external">http://www.cnblogs.com/chenssy/p/3390871.html</a></p>
<h2 id="Java不允许在非静态内部类里定义static成员却允许static-final"><a href="#Java不允许在非静态内部类里定义static成员却允许static-final" class="headerlink" title="Java不允许在非静态内部类里定义static成员却允许static final"></a>Java不允许在非静态内部类里定义static成员却允许static final</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Out</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</div><div class="line">        <span class="comment">//static final Integer ia = 0;//compile error</span></div><div class="line">        <span class="comment">//static final Object o = new Object();//同上，内部类不允许定义static</span></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ib = <span class="number">100</span>;</div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> String ibb = <span class="string">"fs"</span>;</div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"Inner ib="</span> + ib);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Out out = <span class="keyword">new</span> Out();</div><div class="line">        Out.Inner inner = out.new Inner();</div><div class="line">        inner.f();</div><div class="line">        <span class="comment">//相当于 常量</span></div><div class="line">        System.out.println(<span class="string">"Inner.ib="</span> + Inner.ib);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每一个非静态内部类，必须维持一个对其外部类实例的应用，这就表明了非静态内部类的作用域是实例级别；而static关键字显式指定某个属性、方法或内部类的作用域是属于类级别。既然二者在语言层面要求的作用域不同，自然无法编译通过。<br>为什么添加final就可以了呢。final关键字的字面语义就是指明不可变，用在属性上，表示属性一旦赋值后即不可改变。与static关键字合用即表示定义一个常量，一旦作为常量，其作用域自然不再是实例级别了，而是全局级别了，类级别作用域其实就只是加了一个访问权限修饰的全局作用域而已。所以编译自然OK</p>
<p>这个问题有点类似于局部变量必须初始化才能使用，而静态变量无需初始化也能使用。</p>
<p><a href="http://stackoverflow.com/questions/27095847/why-static-final-variables-are-accepted-in-local-classes" target="_blank" rel="external">http://stackoverflow.com/questions/27095847/why-static-final-variables-are-accepted-in-local-classes</a><br><a href="http://stackoverflow.com/questions/2482327/why-can-we-have-static-final-members-but-cant-have-static-method-in-an-inner-cla" target="_blank" rel="external">http://stackoverflow.com/questions/2482327/why-can-we-have-static-final-members-but-cant-have-static-method-in-an-inner-cla</a></p>
<p>相似的问题还有：非静态变量不能被静态方法引用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bar;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getBar</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> bar; <span class="comment">// does not compile;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="http://stackoverflow.com/questions/4584258/communication-between-static-method-and-instance-field-in-java" target="_blank" rel="external">http://stackoverflow.com/questions/4584258/communication-between-static-method-and-instance-field-in-java</a></p>
<h1 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h1><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。<br><strong>静态内部类是不需要依赖于外部类的</strong>，这点和类的静态成员属性有点类似<br><strong>静态内部类不能使用外部类的非static成员变量或者方法</strong>，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</div><div class="line">        Outter.Inner inner = <span class="keyword">new</span> Outter.Inner();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="http://www.cnblogs.com/dolphin0520/p/3811445.html" target="_blank" rel="external">http://www.cnblogs.com/dolphin0520/p/3811445.html</a></p>
<p><a href="http://www.jianshu.com/p/b447bd84a512" target="_blank" rel="external">http://www.jianshu.com/p/b447bd84a512</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类&lt;/p&gt;
&lt;p&gt;内部类会再生成一个class文件&lt;br&gt;编译器会为匿名内部类和局部内部类起名为Outter$Inner.class&lt;br&gt;内部类(非静态内部类)访问可以任意直接访问外部类，但
    
    </summary>
    
      <category term="note" scheme="http://duyao.github.io/categories/note/"/>
    
    
      <category term="java" scheme="http://duyao.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>分布式技术</title>
    <link href="http://duyao.github.io/2017/03/26/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8A%80%E6%9C%AF/"/>
    <id>http://duyao.github.io/2017/03/26/分布式技术/</id>
    <published>2017-03-26T11:50:51.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式系统的难点"><a href="#分布式系统的难点" class="headerlink" title="分布式系统的难点"></a>分布式系统的难点</h1><p>分布式系统比起单机系统存在哪些难点呢？</p>
<h2 id="网络因素"><a href="#网络因素" class="headerlink" title="网络因素"></a>网络因素</h2><p>由于服务和数据分布在不同的机器上，每次交互都需要跨机器运行，这带来如下几个问题：<br>1.网络延迟：性能、超时</p>
<p>同机房的网络IO还是比较块的，但是跨机房，尤其是跨IDC，网络IO就成为不可忽视的性能瓶颈了。<br>并且，延迟不是带宽，带宽可以随便增加，千兆网卡换成万兆，只是成本的问题，但延迟是物理限制，基本不可能降低。<br>这带来的问题就是系统整体性能的降低，会带来一系列的问题，比如资源的锁住，所以系统调用一般都要设置一个超时时间进行自我保护，但是过度的延迟就会带来系统的RPC调用超时，引发一个令人头疼的问题：分布式系统调用的三态结果：成功、失败、超时。不要小看这个第三态，这几乎是所有分布式系统复杂性的根源。<br>针对这个问题有一些相应的解决方案：异步化，失败重试。 而对于跨IDC数据分布带来的巨大网络因素影响，则一般会采用数据同步，代理专线等处理方式。<br>2.网络故障：丢包、乱序、抖动。</p>
<p>这个可以通过将服务建立在可靠的传输协议上来解决，比如TCP协议。不过带来的是更多的网络交互。<br>因此是性能和流量的一个trade off。这个在移动互联网中更需要考虑。</p>
<h2 id="分布式系统特性-CAP理论-鱼和熊掌不可兼得"><a href="#分布式系统特性-CAP理论-鱼和熊掌不可兼得" class="headerlink" title="分布式系统特性-CAP理论(鱼和熊掌不可兼得)"></a>分布式系统特性-CAP理论(鱼和熊掌不可兼得)</h2><p>CAP理论是由Eric Brewer提出的分布式系统中最为重要的理论之一：<br>Consistency：[强]一致性，事务保障，ACID模型。<br>Availiablity：[高]可用性，冗余以避免单点，至少做到柔性可用（服务降级）。<br>Partition tolerance：[高]可扩展性（分区容忍性）：一般要求系统能够自动按需扩展，比如HBase。<br>CAP原理告诉我们，这三个因素最多只能满足两个，不可能三者兼顾。<br>对于分布式系统来说，分区容错是基本要求，所以必然要放弃一致性。<br>对于大型网站来说，分区容错和可用性的要求更高，所以一般都会选择适当放弃一致性。<br>对应CAP理论，NoSQL追求的是AP，而传统数据库追求的是CA，这也可以解释为什么传统数据库的扩展能力有限的原因。</p>
<p>在CAP三者中，“可扩展性”是分布式系统的特有性质。分布式系统的设计初衷就是利用集群多机的能力处理单机无法解决的问题。<br>当需要扩展系统性能时，一种做法是优化系统的性能或者升级硬件(scale up)，一种做法就是“简单”的增加机器来扩展系统的规模(scale out)。<br>好的分布式系统总在追求”线性扩展性”，即性能可以随集群数量增长而线性增长。</p>
<p>可用性和可扩展性一般是相关联的，可扩展行好的系统，其可用性一般会比较高，因为有多个服务(数据)节点，不是整体的单点<br>所以分布式系统的所有问题，基本都是在一致性与可用性和可扩展性这两者之间的一个协调和平衡。<br>对于没有状态的系统，不存在一致性问题，根据CAP原理，它们的可用性和分区容忍性都是很高，简单的添加机器就可以实现线性扩展。而对于有状态的系统，则需要根据业务需求和特性在CAP三者中牺牲其中的一者。一般来说，交易系统类的业务对一致性的要求比较高，一般会采用ACID模型来保证数据的强一致性，所以其可用性和扩展性就比较差。而其他大多数业务系统一般不需要保证强一致性，只要最终一致就可以了，它们一般采用BASE模型，用最终一致性的思想来设计分布式系统，从而使得系统可以达到很高的可用性和扩展性。</p>
<p>CAP定律其实也是衡量分布式系统的重要指标，另一个重要的指标是性能。</p>
<h3 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h3><p>主要有三种：<br>Strong Consistency（强一致性）：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，Azure Table都是强一致性的。<br>Week Consistency（弱一致性）：不同副本上的值有新有旧，需要应用方做更多的工作获取最新值。比如Dynamo。<br>Evantual Consistency（最终一致性）：一旦更新成功，各副本的数据最终将达到一致。<br>从这三种一致型的模型上来说，我们可以看到，Weak和Eventually一般来说是异步冗余的，而Strong一般来说是同步冗余的(多写)，异步的通常意味着更好的性能，但也意味着更复杂的状态控制。同步意味着简单，但也意味着性能下降。<br>以及其他变体：<br>Causal Consistency（因果一致性）：如果Process A通知Process B它已经更新了数据，那么Process B的后续读取操作则读取A写入的最新值，而与A没有因果关系的C则可以最终一致性。<br>Read-your-writes Consistency（读你所写一致性）：如果Process A写入了最新的值，那么 Process A的后续操作都会读取到最新值。但是其它用户可能要过一会才可以看到。<br>Session Consistency（会话一致性）：一次会话内一旦读到某个值，不会读到更旧的值。<br>Monotonic Read Consistency（单调一致性）：一个用户一旦读到某个值，不会读到比这个值更旧的值，其他用户不一定。<br>等等。<br>其中最重要的变体是第二条：Read-your-Writes Consistency。特别适用于数据的更新同步，用户的修改马上对自己可见，但是其他用户可以看到他老的版本。Facebook的数据同步就是采用这种原则。</p>
<h1 id="分布式系统常用技术和应用场景"><a href="#分布式系统常用技术和应用场景" class="headerlink" title="分布式系统常用技术和应用场景"></a>分布式系统常用技术和应用场景</h1><ul>
<li>consistent hashing [with virtual node]：一致性哈希，数据分布</li>
<li>vector clock：时钟向量，多版本数据修改</li>
<li>Quorum W+R&gt;N [with vector clock]：抽屉原理，数据一致性的另一种解决方案。时钟向量，多版本数据修改。</li>
<li>Merkle tree [with anti-entropy]：数据复制</li>
<li>MVCC：copy-on-write与snapshot</li>
<li>2PC/3PC：分布式事务</li>
<li>Paxos：强一致性协议</li>
<li>Raft:简化版的Paxos</li>
<li>Symmetry and Decentralization：对称性和去中心化。<br>对称性(symmetry)简化了系统的配置和维护。去中心化是对对称性的延伸，可以避免master单点，同时方便集群scale out。</li>
<li>Map-Reduce：分而治之；移动数据不如移动计算。<br>将计算尽量调度到与存储节点在同一台物理机器上的计算节点上进行，这称之为本地化计算。本地化计算是计算调度的一种重要优化。</li>
<li>Gossip协议：节点管理</li>
<li>Lease机制</li>
</ul>
<h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p>我们通常使用的hash算法是hash() mod n，但是如果发生某个节点失效时，无法快速切换到其他节点。<br>为了解决单点故障的问题，我们为每个节点都增加一个备用节点，当某个节点失效时，就自动切换到备用节点上，类似于数据库的master和slave。<br>但是依然无法解决增加或删除节点后，需要做hash重分布的问题，也就是无法动态增删节点。</p>
<p>这时就引入了一致性hash的概念 ：<br>将所有的节点分布到一个hash环上，每个请求都落在这个hash环上的某个位置，只需要按照顺时针方向找到的第一个节点，就是自己需要的服务节点。<br>当某个节点发生故障时，只需要在环上找到下一个可用节点即可</p>
<p>virtual node<br>前面说过，有的Consistent Hashing的实现方法采用了虚拟节点的思想。使用一般的hash函数的话，服务器的映射地点的分布非常不均匀。<br>因此，使用虚拟节点的思想，为每个物理节点（服务器）在continuum上分配100～200个点。<br>这样就能抑制分布不均匀，最大限度地减小服务器增减时的缓存重新分布。</p>
<p><a href="http://blog.codinglabs.org/articles/consistent-hashing.html" target="_blank" rel="external">http://blog.codinglabs.org/articles/consistent-hashing.html</a></p>
<h2 id="Quorum-W-R-gt-N：抽屉原理，数据一致性的另一种解决方案"><a href="#Quorum-W-R-gt-N：抽屉原理，数据一致性的另一种解决方案" class="headerlink" title="Quorum W+R&gt;N：抽屉原理，数据一致性的另一种解决方案"></a>Quorum W+R&gt;N：抽屉原理，数据一致性的另一种解决方案</h2><p>N: 复制的节点数，即一份数据被保存的份数。<br>R: 成功读操作的最小节点数，即每次读取成功需要的份数。<br>W: 成功写操作的最小节点数 ，即每次写成功需要的份数。<br>所以 W+R&gt;N的意思是：对于有N份拷贝的分布式系统，写到W(W&lt;=N)份成功算写成功，读R(R&lt;=N)份数据算读成功。</p>
<p>这三个因素决定了可用性，一致性和分区容错性。<br><strong>W+R&gt;N可以保证数据的一致性(C)和分区容错性(P)，W越大数据一致性越高</strong>。<br>这个NWR模型把CAP的选择权交给了用户，让用户自己在功能，性能和成本效益之间进行权衡。<br>对于一个分布式系统来说，N通常都大于3，也就说同一份数据需要保存在三个以上不同的节点上，以防止单点故障。<br>W是成功写操作的最小节点数，这里的写成功可以理解为“同步”写，比如N=3，W=1，那么只要写成功一个节点就可以了，另外的两份数据是通过异步的方式复制的。<br>R是成功读操作的最小节点数，读操作为什么要读多份数据呢？在分布式系统中，数据在不同的节点上可能存在着不一致的情况，我们可以选择读取多个节点上的不同版本，来达到增强一致性的目的。<br>NWR模型的一些设置会造成脏数据和版本冲突问题，所以一般要引入vector clock算法来解决这个问题。<br>需要保证系统中有max(N-W+1,N-R+1)个节点可用。<br><a href="http://coolshell.cn/articles/10910.html" target="_blank" rel="external">http://coolshell.cn/articles/10910.html</a><br><a href="https://my.oschina.net/manmao/blog/618344" target="_blank" rel="external">https://my.oschina.net/manmao/blog/618344</a></p>
<h2 id="vector-clock：时钟向量，多版本数据修改"><a href="#vector-clock：时钟向量，多版本数据修改" class="headerlink" title="vector clock：时钟向量，多版本数据修改"></a>vector clock：时钟向量，多版本数据修改</h2><p><a href="http://coolshell.cn/articles/10910.html" target="_blank" rel="external">http://coolshell.cn/articles/10910.html</a><br>参见 分布式系统的事务处理，写的很通俗易懂。</p>
<h2 id="lease机制"><a href="#lease机制" class="headerlink" title="lease机制"></a>lease机制</h2><p>lease的原理：<br>lease的思想非常简单，既然中心节点需要获取目标节点是否异常的情况，同时又要考虑网络出问题等异常。<br>那就干脆考虑各种异常情况在内，只单方面给对方一个期限，在这个期限内，我认为你是正常的，不正常也认为正常。超出这个期限，我就认为你异常了。由于网络延迟等原因，这个期限不能使用相对时间，而必须使用绝对时间。<br>比如，1点之间，节点A就是主节点。这样就能避免双主问题。节点A为如果收到这个lease，即得到了中心节点的授权，1点前绝对只有自己是主。心跳依旧照发，只是每次中心节点都只根据lease是否有效来判断节点状况，不会出问题。</p>
<p>lease是一种颁发的带期限的承诺，有两方面的意义：颁发者在承诺期限内一定遵守承诺，被颁发者在承诺期限内可放心行使承诺的内容；期限过了以后，被颁发者一定不可再行使承诺。</p>
<p>lease与活锁<br>lease的颁发往往是被动的，比如A节点需要中心节点的某个承诺，比如读并缓存，则会向中心节点请求lease，中心节点回复最新可缓存的数据与一个lease，在此lease期限内，中心节点保证目标节点缓存内容与中心节点一致。<br>按lease方案，如果中心节点需要修改对应数据，必须等全部lease失效。问题是等lease失效的过程中，可能有新的请求元数据的请求到达，这时中心节点又会继续颁发新的lease，使得lease一直不结束，形成“活锁”，即修改请求等待lease失效，而又源源不断颁发新lease而一直无法完成。<br>解决活锁的办法：当有修改请求在等待着lease失效时，如果后续有读请求，则只返回请求数据而不颁发新lease，或者是只颁发目前最长的lease。<br>解决活锁后，修改请求仍然需要等待全部lease结束，写请求可能阻塞太久。可以在写请求到达时，中心节点主动给各节点发取消lease的消息。如果全部正确返回，则写可立即进行。如果有异常，那就正常等待lease结束。</p>
<p>lease的容错：<br>由于仅依赖于绝对时间，因此lease机制天生即可容忍网络、lease接收方的出错。<br>对于中心节点异常，比如宕机，只需要在颁发者恢复后，等待一个最大lease期限就可保证所有lease失效；另一方面，颁发者宕机可能使得全部节点没有lease，系统处于不可用状态，解决的方法就是使用一个小集群而不是单一节点作为颁发者。<br>颁发者与被颁发者之间的时钟可能也存在误差，只需要颁发者考虑时钟误差即可。<br>lease时间长短一般取经验值10秒。太短网络压力大，太长则收回承诺时间过长影响可用性。</p>
<p>应用：</p>
<p>GFS中，Master通过lease机制决定哪个是主副本，lease在给各节点的心跳响应消息中携带。收不到心跳时，则等待lease过期，再颁发给其他节点。<br>Niobe中，主副本持有从副本颁发的lease，当lease过期时，主从分别会在中心节点上标记对方不可用，而中心节点是全局一致的，两者只有一个会成功。如果主成功了，从不可用，需要重新与主同步才能可用；如果从成功了，则自己成为新主。<br>chubby中，paxos选主后，从节点会给主颁发lease，在期限内不选其他节点为主。另一方面，主节点给每个client节点发送lease，用于判断client死活。<br>zookeeper中，选主不用lease，而是直接发现没有主则选主。其余和chubby一致。</p>
<h2 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h2><p>Gossip用于P2P系统中自治节点获悉对集群认识（如集群的节点状态，负载情况等）。 系统中的节点定期互相八卦，很快八卦就在整个系统传开了。 A、B两个节点八卦的方式主要是：A告诉B知道哪些人的什么八卦；B告诉A这些八卦里B知道哪些更新了；B更新A告诉他的八卦…… 说是自治系统，其实节点中还有一些种子节点。种子节点的作用主要是在有新节点加入系统时体现。新节点加入系统中，先与种子节点八卦，新节点获得系统信息，种子节点知道系统中多了新节点。其他节点定期与种子节点八卦的时候就知道有新节点加入了。 各个节点互相八卦的过程中，如果发现某个节点的状态很长时间都没更新，就认为该节点已经宕机了。<br>Dynamo使用了Gossip协议来做会员和故障检测。</p>
<h2 id="2PC、3PC、Paxos协议、Raft-分布式事务的解决方案"><a href="#2PC、3PC、Paxos协议、Raft-分布式事务的解决方案" class="headerlink" title="2PC、3PC、Paxos协议、Raft: 分布式事务的解决方案"></a>2PC、3PC、Paxos协议、Raft: 分布式事务的解决方案</h2><p>分布式事务很难做，所以除非必要，一般来说都是采用最终一致性来规避分布式事务。<br>目前底层NoSQL存储系统实现分布式事务的只有Google的系统，它在Bigtable之上用Java语言开发了一个系统 Megastore，实现了两阶段锁，并通过Chubby来避免两阶段锁协调者宕机带来的问题。Megastore实现目前只有简单介绍，还没有相关论文。</p>
<h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>这个协议的缩写又叫2PC，中文叫两阶段提交。<br>在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。<br>当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。</p>
<p>两阶段提交的算法如下：</p>
<p>第一阶段：</p>
<blockquote>
<p>协调者会问所有的参与者结点，是否可以执行提交操作。<br>各个参与者开始事务执行的准备工作：如：为资源上锁，预留资源，写undo/redo log……<br>参与者响应协调者，如果事务的准备工作成功，则回应“可以提交”，否则回应“拒绝提交”。</p>
</blockquote>
<p>第二阶段：</p>
<blockquote>
<p>如果所有的参与者都回应“可以提交”，那么，协调者向所有的参与者发送“正式提交”的命令。参与者完成正式提交，并释放所有资源，然后回应“完成”，协调者收集各结点的“完成”回应后结束这个Global Transaction。<br>如果有一个参与者回应“拒绝提交”，那么，协调者向所有的参与者发送“回滚操作”，并释放所有资源，然后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个Global Transaction。</p>
</blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/2pc.png" alt="2PC" title="">
                </div>
                <div class="image-caption">2PC</div>
            </figure>
<p>2PC说白了就是第一阶段做Vote，第二阶段做决定的一个算法，也可以看到2PC这个事是强一致性的算法。<br>在前面我们讨论过Master-Slave的强一致性策略，和2PC有点相似，只不过2PC更为保守一些——先尝试再提交。<br>2PC用的是比较多的，在一些系统设计中，会串联一系列的调用，比如：A -&gt; B -&gt; C -&gt; D，每一步都会分配一些资源或改写一些数据。<br>比如我们B2C网上购物的下单操作在后台会有一系列的流程需要做。<br>如果我们一步一步地做，就会出现这样的问题，如果某一步做不下去了，那么前面每一次所分配的资源需要做反向操作把他们都回收掉，所以，操作起来比较复杂。</p>
<p>实现简单，但是效率低，所有参与者需要block，throughput低；无容错，一个节点失败整个事务失败。<br>如果第一阶段完成后，参与者在第二阶没有收到决策，那么数据结点会进入“不知所措”的状态，这个状态会block住整个事务。</p>
<h3 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h3><p>在2pc中，如果第一阶段完成后，参与者在第二阶没有收到决策，那么数据结点会进入“不知所措”的状态，这个状态会block住整个事务。<br>也就是说，协调者Coordinator对于事务的完成非常重要，Coordinator的可用性是个关键。<br>因些，我们引入三段提交，三段提交在Wikipedia上的描述如下，他把二段提交的第一个段break成了两段：询问，然后再锁资源。最后真正提交。三段提交的示意图如下：</p>
<p>三段提交的核心理念是：<strong>在询问的时候并不锁定资源，除非所有人都同意了，才开始锁资源。</strong><br>如果结点处在P状态（PreCommit）的时候发生了F/T的问题，三段提交比两段提交的好处是，<strong>三段提交可以继续直接把状态变成C状态（Commit），而两段提交则不知所措</strong>。<br>理论上来说，如果第一阶段所有的结点返回成功，那么有理由相信成功提交的概率很大。<br>这样一来，可以降低参与者Cohorts的状态未知的概率。<br>也就是说，一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了。这一点很重要。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/3pc.png" alt="3PC" title="">
                </div>
                <div class="image-caption">3PC</div>
            </figure></p>
<p>改进版的2PC，把2PC的第一个段break成了两段: 询问，然后再锁资源，最后真正提交。<br>3PC的核心理念是：在询问的时候并不锁定资源，除非所有人都同意了，才开始锁资源。<br>3PC比2PC的好处是，如果结点处在P状态（PreCommit）的时候发生了Fail/Timeout的问题，3PC可以继续直接把状态变成C状态（Commit），而2PC则不知所措。<br>不过3PC实现比较困难，而且无法处理网络分离问题。如果preCommit消息发送后两个机房断开，这时候coordinator所在的机房会abort，剩余的participant会commit。</p>
<h3 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h3><p>Paxos 算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。<br>一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。<br>为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个「一致性算法」以保证每个节点看到的指令一致。<br>一个通用的一致性算法可以应用在许多场景中，是分布式计算中的重要问题。从20世纪80年代起对于一致性算法的研究就没有停止过。</p>
<p>Notes：Paxos算法是莱斯利·兰伯特（Leslie Lamport，就是 LaTeX 中的”La”，此人现在在微软研究院）于1990年提出的一种基于消息传递的一致性算法。由于算法难以理解起初并没有引起人们的重视，使Lamport在八年后1998年重新发表到ACM Transactions on Computer Systems上（The Part-Time Parliament）。即便如此paxos算法还是没有得到重视，2001年Lamport 觉得同行无法接受他的幽默感，于是用容易接受的方法重新表述了一遍（Paxos Made Simple）。可见Lamport对Paxos算法情有独钟。近几年Paxos算法的普遍使用也证明它在分布式一致性算法中的重要地位。<br>2006年Google的三篇论文初现“云”的端倪，其中的Chubby Lock服务使用Paxos作为Chubby Cell中的一致性算法，Paxos的人气从此一路狂飙。（Lamport 本人在 他的blog 中描写了他用9年时间发表这个算法的前前后后）</p>
<p>简单说来，Paxos的目的是让整个集群的结点对某个值的变更达成一致。<br>Paxos算法基本上来说是个民主选举的算法——大多数的决定会成个整个集群的统一决定。<br>任何一个点都可以提出要修改某个数据的提案，是否通过这个提案取决于这个集群中是否有超过半数的结点同意（所以Paxos算法需要集群中的结点是单数）。</p>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p>主要涉及到的角色有：<code>Proposer</code>提交者、<code>Acceptor</code>仲裁者、<code>learner</code>、<code>client</code><br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/paxos-flow.png" alt="paxos-flow" title="">
                </div>
                <div class="image-caption">paxos-flow</div>
            </figure><br>第一阶段 Prepare</p>
<blockquote>
<p>P1a：Proposer 发送 Prepare请求</p>
</blockquote>
<p>Proposer 生成全局唯一且递增的ProposalID，向 Paxos 集群的所有机器发送 Prepare请求，这里不携带value，只携带 ProposalID 。</p>
<blockquote>
<p>P1b：Acceptor 应答 Prepare</p>
</blockquote>
<p>Acceptor 收到 Prepare请求 后，判断：收到的ProposalID 是否比之前已响应的所有提案的ProposalID 大：<br>如果是，则：<br>(1) 在本地持久化 ProposalID，可记为Max_ProposalID。<br>(2) 回复请求，并带上 <strong>已Accept的提案中 ProposalID 最大的 value</strong>（若此时还没有已Accept的提案，则返回value为空）。<br>(3) 做出承诺：不会Accept 任何小于 Max_ProposalID的提案。<br>如果否：不回复。</p>
<p>第二阶段 Accept</p>
<blockquote>
<p>P2a：Proposer 发送 Accept</p>
</blockquote>
<p>经过一段时间后，Proposer 收集到一些 Accpet 的 Prepare 回复，有下列几种情况：<br>(1) 回复数量 &gt; 一半的Acceptor数量，且<strong>所有的回复的 value 都为空</strong>，则 Porposer发出accept请求，并带上自己指定的value。<br>(2) 回复数量 &gt; 一半的Acceptor数量，且<strong>有的回复 value 不为空</strong>，则 Porposer发出accept请求，并<strong>带上回复中 ProposalID最大的value</strong>(作为自己的提案内容)。<br>(3) 回复数量 &lt;= 一半的Acceptor数量，则尝试更新生成更大的 ProposalID，再转P1a执行。</p>
<blockquote>
<p>P2b：Acceptor 应答 Accept</p>
</blockquote>
<p>Accpetor 收到 Accpet请求 后，判断：<br>(1) 收到的ProposalID &gt;= Max_ProposalID (一般情况下是等于)，则回复提交成功，并持久化ProposalID 和value。<br>(2) 收到的ProposalID &lt; Max_ProposalID，则 不回复 或者 回复提交失败。</p>
<blockquote>
<p>P2c: Proposer 统计投票</p>
</blockquote>
<p>经过一段时间后，Proposer 收集到一些 Accept 回复提交成功，有几种情况：<br>(1) 回复数量 &gt; 一半的Acceptor数量，则表示提交value成功。此时，可以发一个广播给所有Proposer、Learner，通知它们 已commit的value。<br>(2) 回复数量 &lt;= 一半的Acceptor数量，则 尝试更新生成更大的 ProposalID，再转 P1a 执行。<br>(3) 收到一条提交失败的回复，则 尝试更新生成更大的ProposalID，再转 P1a 执行。</p>
<p>最后，经过多轮投票后，达到的结果是：<br>(1) 所有Proposer都提交提案成功了，且提交的value是同一个value。<br>(2) 过半数的 Acceptor都提交成功了，且提交的是 同一个value。</p>
<p>Paxos 协议 的几个约束：<br>P1: 一个Acceptor必须接受(accept)第一次收到的提案;<br>P2a: 一旦一个具有value v的提案被批准(chosen)，那么之后任何Acceptor 再次接受(accept)的提案必须具有value v;<br>P2b: 一旦一个具有value v的提案被批准(chosen)，那么以后任何 Proposer 提出的提案必须具有value v;<br>P2c: 如果一个编号为n的提案具有value v，那么存在一个多数派，要么他们中所有人都没有接受(accept)编号小于n的任何提案，要么他们已经接受(accpet)的所有编号小于n的提案中编号最大的那个提案具有value v;<br><a href="https://angus.nyc/2012/paxos-by-example/" target="_blank" rel="external">https://angus.nyc/2012/paxos-by-example/</a><br><a href="http://www.tudou.com/programs/view/e8zM8dAL6hM/" target="_blank" rel="external">http://www.tudou.com/programs/view/e8zM8dAL6hM/</a></p>
<h4 id="常见的疑问、及异常处理"><a href="#常见的疑问、及异常处理" class="headerlink" title="常见的疑问、及异常处理"></a>常见的疑问、及异常处理</h4><p>1、Paxos算法的核心思想是什么？<br>(1) 引入了 多个Acceptor，避免单个Acceptor成为单点。<br>Proposer用更大ProposalID 来抢占临时的访问权，避免其中一个 Proposer崩溃宕机导致死锁。<br>(2) 保证一个ProposalID，只有一个Proposer能进行到第二阶段运行，Proposer按照ProposalID递增的顺序依次运行。<br>(3) 新ProposalID 的 proposer 采用 后者认同前者的思路运行。<br>在肯定旧ProposalID 还没有生成确定的value (Acceptor 提交成功一个value)时，新ProposalID 会提交自己的value，不会冲突。<br>一旦旧ProposalID 生成了确定的value，新ProposalID 肯定可以获取到此值，并且认同此值。</p>
<p>2、容错要求：<br>(1) 半数以内的Acceptor失效、任意数量的Proposer 失效，都能运行。<br>(2) 一旦value值被确定，即使 半数以内的Acceptor失效，此值也可以被获取，并不再修改。</p>
<p>3、工程实践中 ProposalID 怎么定？<br>在《Paxos made simple》中提到，推荐Proposer从不相交的数据集合中进行选择，例如系统有5个Proposer，则可为每一个Proposer分配一个标识j(0~4)，则每一个proposer每次提出决议的编号可以为5*i + j(i可以用来表示提出议案的次数)。<br>在实践过程中，可以用<code>时间戳 + 提出提案的次数 + 机器 IP/机器ID</code>来保证唯一性和递增性。</p>
<p>4、如何保证 更大的ProposalID的Proposer不会破坏已经达成的确定性取值value？<br>在P2a阶段中，Proposer会以所有回复中ProposalID最大 的value 作为自己的提案内容。<br>其中，prepare阶段的目的有两个: 1) 检查是否有被批准的值，如果有，就改用批准的值。2) 如果之前的提案还没有被批准，则阻塞掉他们以便不让他们和我们发生竞争，当然最终由ProposalID 的大小决定。</p>
<p>5、Paxos协议的活锁问题<br>新轮次的抢占会使旧轮次停止运行，如果每一轮在第二阶段执行成功之前 都 被 新一轮抢占，则导致活锁。怎么解决？<br>这个问题在实际应用会发生地比较少，一般可通过 随机改变 ProposalID的增长幅度 或者 增加Proposer发送新一轮提案的间隔 来解决。</p>
<p>6、Paxos 运行过程中，半数以内的Acceptor失效，都能运行。为什么？<br>(1) 如果 半数以内的Acceptor失效时 还没确定最终的value，此时，所有Proposer会竞争 提案的权限，最终会有一个提案会 成功提交。之后，会有半过数的Acceptor以这个value提交成功。<br>(2) 如果 半数以内的Acceptor失效时 已确定最终的value，此时，所有Proposer提交前 必须以 最终的value 提交，因为，一个Proposer要拿到过半数的accept响应，必须同一个已提交的Acceptor存在交集，故会在P2a阶段中会继续沿用该value。</p>
<p>7、若两个Proposer以不同的ProposalID，在进行到P2a阶段，收到的prepare回复的value值都为空，则两个proposer都以自己的值作为value(提案内容)，向Acceptor提交请求，最后，两个proposer都会认为自己提交成功了吗？<br>不会，因为Acceptor会根据ProposalID，批准执行最大的ProposalID的value，另一个会回复 执行失败。当proposer收到执行失败的回复时，就知道：当前具有更大的ProposalID的提案提交成功了。</p>
<p>8、由于大ProposalID 可以抢占小ProposalID 的提交权限，如果 此时 Acceptor还没有一个确定性取值，有一个具有最大ProposalID的proposer进行到P2a阶段了，但这时 这个proposer挂了，会造成一种死锁状态（小ProposalID的会提交失败，但是 具有最大ProposalID的proposer却不能提交accept请求），如何解决这种死锁状态？<br>不会产生这种死锁状态，acceptor回复提交失败后，proposer再生成更大的ProposalID，下一轮可以用自己value提交成功。</p>
<p><a href="https://baozh.github.io/2016-03/paxos-learning/" target="_blank" rel="external">https://baozh.github.io/2016-03/paxos-learning/</a></p>
<h3 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h3><p>Paxos 相比 Raft 比较复杂和难以理解。角色扮演和流程比 Raft 都要啰嗦。<br>比如 Agreement 这个流程，在 Paxos 里边：Client 发起请求举荐 Proposer 成为 Leader，Proposer 然后向全局 Acceptors 寻求确认，Acceptors 全部同意 Proposer 后，Proposer 的 Leader 地位得已承认，Acceptors 还得再向Learners 进行全局广播来同步。<br>而在 Raft 里边，只有 Follower/Candidate/Leader 三种角色，角色本身代表状态，角色之间进行状态转移是一件非常自由民主的事情。<br>Raft虽然有角色之分但是是全民参与进行选举的模式；但是在Paxos里边，感觉更像议员参政模式。</p>
<h4 id="三个角色"><a href="#三个角色" class="headerlink" title="三个角色"></a>三个角色</h4><p>follower、candidate、leader。<br>最开始大家都是follower，当follower监听不到leader，就可以自己成为candidate，发起投票</p>
<h4 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h4><p>主要通过2个timeout来控制：election timeout和heartbeat timeout<br>lection timeout：<br>follower成为candidate的超时时间，每个follower都在150ms - 300ms之间随机，之后看谁先timeout，谁就先成为candidate，然后它会先投自己一票，再向其他节点发起投票邀请。<br>如果其他节点在这轮选举还没有投过票，那么就给candidate投票，然后重置自己的选举timeout。<br>如果得到大多数的投票就成为leader，之后定期开始向follower发送心跳heartbeat timeout。</p>
<p>期间还有可能发生split vote：<br>如果两个follower同时成为candidate的话，如果最后得到的票数相同，则等待其他follower的选择timeout之后成为candidate，继续开始新一轮的选举。</p>
<h4 id="log复制"><a href="#log复制" class="headerlink" title="log复制"></a>log复制</h4><p>leader把变动的log借助心跳同步给follower，过半回复之后才成功提交，之后再下一次心跳之后，follower也commit变动，在自己的node上生效。</p>
<p>分裂之后，另一个分区的follower接受不到leader的timeout，然后会有一个先timeout，成为candidate，最后成为leader。于是两个分区就有了两个leader。<br>当客户端有变动时，其中的leader由于无法收到过半的提交，则保持未提交状态。有的leader的修改，可以得到过半的提交，则可以修改生效。<br>当分裂恢复之后，leader开始对比选举的term，发现有更高的term存在时，他们会撤销未提交的修改，然后以最新的为准。</p>
<p><a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="external">http://thesecretlivesofdata.com/raft/</a><br><a href="https://raft.github.io/" target="_blank" rel="external">https://raft.github.io/</a></p>
<h2 id="MVCC：多版本并发控制"><a href="#MVCC：多版本并发控制" class="headerlink" title="MVCC：多版本并发控制"></a>MVCC：多版本并发控制</h2><p>在并发读写数据库时，读操作可能会不一致的数据（脏读）。为了避免这种情况，需要实现数据库的并发访问控制，最简单的方式就是加锁访问。<br>由于，加锁会将读写操作串行化，所以不会出现不一致的状态。但是，读操作会被写操作阻塞，大幅降低读性能。<br>在Java concurrent包中，有copyonwrite系列的类，专门用于优化读远大于写的情况。而其优化的手段就是，在进行写操作时，将数据copy一份，不会影响原有数据，然后进行修改，修改完成后原子替换掉旧的数据，而读操作只会读取原有数据。通过这种方式实现写操作不会阻塞读操作，从而优化读效率。而写操作之间是要互斥的，并且每次写操作都会有一次copy，所以只适合读大于写的情况。</p>
<p>MVCC的原理与copyonwrite类似，全称是Multiversion Concurrency Controll，即多版本并发控制。在MVCC协议下，<strong>每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读</strong>。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。<br>由此可以看出MVCC是一种用来解决读-写冲突的无锁并发控制.</p>
<p>MVCC的基本原理是：<br>MVCC的实现，通过<strong>保存数据在某个时间点的快照</strong>来实现的。<br>这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。<br>根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。</p>
<p><a href="http://blog.duyaokeep.cn/2017/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/" target="_blank" rel="external">http://blog.duyaokeep.cn/2017/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/</a></p>
<h3 id="各种一致性的比较"><a href="#各种一致性的比较" class="headerlink" title="各种一致性的比较"></a>各种一致性的比较</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/Transaction-Across-DataCenter.jpg" alt="Transaction-Across-DataCenter" title="">
                </div>
                <div class="image-caption">Transaction-Across-DataCenter</div>
            </figure>
<h2 id="Two-Generals-Problem（两将军问题）"><a href="#Two-Generals-Problem（两将军问题）" class="headerlink" title="Two Generals Problem（两将军问题）"></a>Two Generals Problem（两将军问题）</h2><p>Two Generals Problem 两将军问题是这么一个思维性实验问题： 有两支军队，它们分别有一位将军领导，现在准备攻击一座修筑了防御工事的城市。<br>这两支军队都驻扎在那座城市的附近，分占一座山头。一道山谷把两座山分隔开来，并且两位将军唯一的通信方式就是派各自的信使来往于山谷两边。不幸的是，这个山谷已经被那座城市的保卫者占领，并且存在一种可能，那就是任何被派出的信使通过山谷是会被捕。<br>请注意，虽然两位将军已经就攻击那座城市达成共识，但在他们各自占领山头阵地之前，并没有就进攻时间达成共识。<br>两位将军必须让自己的军队同时进攻城市才能取得成功。因此，他们必须互相沟通，以确定一个时间来攻击，并同意就在那时攻击。<br>如果只有一个将军进行攻击，那么这将是一个灾难性的失败。 这个思维实验就包括考虑他们如何去做这件事情。下面是我们的思考：</p>
<p>1）第一位将军先发送一段消息“让我们在上午9点开始进攻”。然而，一旦信使被派遣，他是否通过了山谷，第一位将军就不得而知了。任何一点的不确定性都会使得第一位将军攻击犹豫，因为如果第二位将军不能在同一时刻发动攻击，那座城市的驻军就会击退他的军队的进攻，导致他的军对被摧毁。<br>2）知道了这一点，第二位将军就需要发送一个确认回条：“我收到您的邮件，并会在9点的攻击。”但是，如果带着确认消息的信使被抓怎么办？所以第二位将军会犹豫自己的确认消息是否能到达。<br>3）于是，似乎我们还要让第一位将军再发送一条确认消息——“我收到了你的确认”。然而，如果这位信使被抓怎么办呢？<br>4）这样一来，是不是我们还要第二位将军发送一个“确认收到你的确认”的信息。</p>
<p>靠，于是你会发现，这事情很快就发展成为不管发送多少个确认消息，都没有办法来保证两位将军有足够的自信自己的信使没有被敌军捕获。</p>
<p>这个问题是无解的。</p>
<p>从工程上来说，一个解决两个将军问题的实际方法是使用一个能够承受通信信道不可靠性的方案，并不试图去消除这个不可靠性，但要将不可靠性削减到一个可以接受的程度。<br>比如，第一位将军排出了100位信使并预计他们都被捕的可能性很小。在这种情况下，不管第二位将军是否会攻击或者受到任何消息，第一位将军都会进行攻击。另外，第一位将军可以发送一个消息流，而第二位将军可以对其中的每一条消息发送一个确认消息，这样如果每条消息都被接收到，两位将军会感觉更好。<br>然而我们可以从证明中看出，他们俩都不能肯定这个攻击是可以协调的。他们没有算法可用（比如，收到4条以上的消息就攻击）能够确保防止仅有一方攻击。<br>再者，第一位将军还可以为每条消息编号，说这是1号，2号……直到n号。这种方法能让第二位将军知道通信信道到底有多可靠，并且返回合适的数量的消息来确保最后一条消息被接收到。如果信道是可靠的话，只要一条消息就行了，其余的就帮不上什么忙了。最后一条和第一条消息丢失的概率是相等的。</p>
<p>两将军问题可以扩展成更变态的拜占庭将军问题 (Byzantine Generals Problem)，其故事背景是这样的：<br>拜占庭位于现在土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信差传消息。<br>在战争的时候，拜占庭军队内所有将军必需达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，军队可能有叛徒和敌军间谍，这些叛徒将军们会扰乱或左右决策的过程。<br>这时候，在已知有成员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，这就是拜占庭将军问题。</p>
<h1 id="Map-Reduce思想"><a href="#Map-Reduce思想" class="headerlink" title="Map-Reduce思想"></a>Map-Reduce思想</h1><p>1.分而治之</p>
<p>2.移动数据不如移动计算</p>
<p>如果计算节点和存储节点位于不同的物理机器则计算的数据需要通过网络传输，此种方式的开销很大。<br>另一种思路是，将计算尽量调度到与存储节点在同一台物理机器上的计算节点上进行，这称之为本地化计算。<br>本地化计算是计算调度的一种重要优化。</p>
<p><a href="http://coolshell.cn/articles/10910.html" target="_blank" rel="external">http://coolshell.cn/articles/10910.html</a><br><a href="http://coolshell.cn/articles/17459.html" target="_blank" rel="external">http://coolshell.cn/articles/17459.html</a><br><a href="http://blog.hebiace.net/other/428.html" target="_blank" rel="external">http://blog.hebiace.net/other/428.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;分布式系统的难点&quot;&gt;&lt;a href=&quot;#分布式系统的难点&quot; class=&quot;headerlink&quot; title=&quot;分布式系统的难点&quot;&gt;&lt;/a&gt;分布式系统的难点&lt;/h1&gt;&lt;p&gt;分布式系统比起单机系统存在哪些难点呢？&lt;/p&gt;
&lt;h2 id=&quot;网络因素&quot;&gt;&lt;a href=
    
    </summary>
    
      <category term="note" scheme="http://duyao.github.io/categories/note/"/>
    
    
      <category term="分布式" scheme="http://duyao.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>反射和类加载</title>
    <link href="http://duyao.github.io/2017/03/25/%E5%8F%8D%E5%B0%84%E5%92%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>http://duyao.github.io/2017/03/25/反射和类加载/</id>
    <published>2017-03-25T12:37:02.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>在java中万事万物都是对象。<br>但是只有静态对象和<br>类是java.lang.Class的对象<br>即任何一个类都是Class的对象</p>
<h3 id="表达实例对象"><a href="#表达实例对象" class="headerlink" title="表达实例对象"></a>表达实例对象</h3><p>表达实例对象有三种方法<br>比如Foo的实例对象如何表示<br><code>Foo foo1 = new Foo();</code>//foo1就表示出来了.<br>Foo这个类 也是一个实例对象，Class类的实例对象,如何表示呢<br>任何一个类都是Class的实例对象，这个实例对象有三种表示方式</p>
<p>//第一种表示方式—&gt;实际在告诉我们任何一个类都有一个隐含的静态成员变量class<br><code>Class c1 = Foo.class;</code></p>
<p>//第二中表达方式  已经知道该类的对象通过getClass方法<br><code>Class c2 = foo1.getClass();</code><br>官网 c1 ,c2 表示了Foo类的类类型(class type)<br>万事万物皆对象，类也是对象，是Class类的实例对象,这个对象我们称为该类的类类型</p>
<p>不管c1  or c2都代表了Foo类的类类型，一个类只可能是Class类的一个实例对象<br><code>System.out.println(c1 == c2);//true</code></p>
<p>第三种表达方式<code>c3 = Class.forName(&quot;com.imooc.reflect.Foo&quot;);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Class c3 = <span class="keyword">null</span>;</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">	c3 = Class.forName(<span class="string">"com.imooc.reflect.Foo"</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">	<span class="comment">// TODO Auto-generated catch block</span></div><div class="line">	e.printStackTrace();</div><div class="line">&#125;</div><div class="line">System.out.println(c2==c3);<span class="comment">//true</span></div></pre></td></tr></table></figure></p>
<h2 id="静态加载和动态加载"><a href="#静态加载和动态加载" class="headerlink" title="静态加载和动态加载"></a>静态加载和动态加载</h2><h3 id="静态加载"><a href="#静态加载" class="headerlink" title="静态加载"></a>静态加载</h3><p>一个程序需要先编译javac然后才能运行java<br>编译的过程可以认为是包括加载、验证、准备、解析和初始化<br>对于new关键字，在初始化阶段完成，也就是说如果一个类在new的时候没有找到，那么就会编译失败。<br>因此说new是静态加载机制。<br>比如<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/load1.png" alt="静态加载" title="">
                </div>
                <div class="image-caption">静态加载</div>
            </figure></p>
<h3 id="动态加载"><a href="#动态加载" class="headerlink" title="动态加载"></a>动态加载</h3><p>因此可以使用类类型实现动态加载<br><code>Interface intterface = (Interface)class.forName()</code><br>这里要写成interface接口，因为根部不知道要加载哪个类<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/load2.png" alt="动态加载" title="">
                </div>
                <div class="image-caption">动态加载</div>
            </figure></p>
<h2 id="获取类的信息"><a href="#获取类的信息" class="headerlink" title="获取类的信息"></a>获取类的信息</h2><h3 id="获取方法信息"><a href="#获取方法信息" class="headerlink" title="获取方法信息"></a>获取方法信息</h3><p>Method类，方法对象<br>一个成员方法就是一个Method对象<br>getMethods()方法获取的是所有的public的函数，包括父类继承而来的<br>getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限<br>Method[] ms = c.getMethods();//c.getDeclaredMethods()<br>//得到方法的返回值类型的类类型<br>Class returnType = ms[i].getReturnType();<br>//得到方法的名称<br>ms[i].getName()<br>//获取参数类型—&gt;得到的是参数列表的类型的类类型<br>Class[] paramTypes = ms[i].getParameterTypes();<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 打印类的信息，包括类的成员函数、成员变量(只获取成员函数)</div><div class="line"> * <span class="doctag">@param</span> obj 该对象所属类的信息</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printClassMethodMessage</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">	<span class="comment">//要获取类的信息  首先要获取类的类类型</span></div><div class="line">	Class c = obj.getClass();<span class="comment">//传递的是哪个子类的对象  c就是该子类的类类型</span></div><div class="line">	<span class="comment">//获取类的名称</span></div><div class="line">	System.out.println(<span class="string">"类的名称是:"</span>+c.getName());</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * Method类，方法对象</div><div class="line">	 * 一个成员方法就是一个Method对象</div><div class="line">	 * getMethods()方法获取的是所有的public的函数，包括父类继承而来的</div><div class="line">	 * getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限</div><div class="line">	 */</div><div class="line">	Method[] ms = c.getMethods();<span class="comment">//c.getDeclaredMethods()</span></div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ms.length;i++)&#123;</div><div class="line">		<span class="comment">//得到方法的返回值类型的类类型</span></div><div class="line">		Class returnType = ms[i].getReturnType();</div><div class="line">		System.out.print(returnType.getName()+<span class="string">" "</span>);</div><div class="line">		<span class="comment">//得到方法的名称</span></div><div class="line">		System.out.print(ms[i].getName()+<span class="string">"("</span>);</div><div class="line">		<span class="comment">//获取参数类型---&gt;得到的是参数列表的类型的类类型</span></div><div class="line">		Class[] paramTypes = ms[i].getParameterTypes();</div><div class="line">		<span class="keyword">for</span> (Class class1 : paramTypes) &#123;</div><div class="line">			System.out.print(class1.getName()+<span class="string">","</span>);</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">")"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>比如class是String，会打印出<br>会打印出int lastIndexOf(int,int,)、int length()、boolean matches(java.lang.String,)等</p>
<h3 id="获取成员变量的信息"><a href="#获取成员变量的信息" class="headerlink" title="获取成员变量的信息"></a>获取成员变量的信息</h3><p>成员变量也是对象，java.lang.reflect.Field<br>Field类封装了关于成员变量的操作<br>getFields()方法获取的是所有的public的成员变量的信息<br>getDeclaredFields获取的是该类自己声明的成员变量的信息<br>Field[] fs = c.getDeclaredFields();<br>for (Field field : fs) {<br>//得到成员变量的类型的类类型<br>Class fieldType = field.getType();<br>//得到成员变量的名称<br>String fieldName = field.getName();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">   * 获取成员变量的信息</div><div class="line">   * <span class="doctag">@param</span> obj</div><div class="line">   */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printFieldMessage</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">	Class c = obj.getClass();</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 成员变量也是对象</div><div class="line">	 * java.lang.reflect.Field</div><div class="line">	 * Field类封装了关于成员变量的操作</div><div class="line">	 * getFields()方法获取的是所有的public的成员变量的信息</div><div class="line">	 * getDeclaredFields获取的是该类自己声明的成员变量的信息</div><div class="line">	 */</div><div class="line">	<span class="comment">//Field[] fs = c.getFields();</span></div><div class="line">	Field[] fs = c.getDeclaredFields();</div><div class="line">	<span class="keyword">for</span> (Field field : fs) &#123;</div><div class="line">		<span class="comment">//得到成员变量的类型的类类型</span></div><div class="line">		Class fieldType = field.getType();</div><div class="line">		String typeName = fieldType.getName();</div><div class="line">		<span class="comment">//得到成员变量的名称</span></div><div class="line">		String fieldName = field.getName();</div><div class="line">		System.out.println(typeName+<span class="string">" "</span>+fieldName);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比如class是String，会打印出int hash、long serialVersionUID等</p>
<h3 id="获取构造法方法信息"><a href="#获取构造法方法信息" class="headerlink" title="获取构造法方法信息"></a>获取构造法方法信息</h3><p>构造函数也是对象，java.lang. Constructor中封装了构造函数的信息<br>getConstructors获取所有的public的构造函数<br>getDeclaredConstructors得到所有的构造函数</p>
<p>Constructor[] cs = c.getDeclaredConstructors();<br>//获取构造函数的参数列表—&gt;得到的是参数列表的类类型<br>Class[] paramTypes = constructor.getParameterTypes();<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 打印对象的构造函数的信息</div><div class="line"> * <span class="doctag">@param</span> obj</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printConMessage</span><span class="params">(Object obj)</span></span>&#123;</div><div class="line">	Class c = obj.getClass();</div><div class="line">	<span class="comment">/*</span></div><div class="line">	 * 构造函数也是对象</div><div class="line">	 * java.lang. Constructor中封装了构造函数的信息</div><div class="line">	 * getConstructors获取所有的public的构造函数</div><div class="line">	 * getDeclaredConstructors得到所有的构造函数</div><div class="line">	 */</div><div class="line">	<span class="comment">//Constructor[] cs = c.getConstructors();</span></div><div class="line">	Constructor[] cs = c.getDeclaredConstructors();</div><div class="line">	<span class="keyword">for</span> (Constructor constructor : cs) &#123;</div><div class="line">		System.out.print(constructor.getName()+<span class="string">"("</span>);</div><div class="line">		<span class="comment">//获取构造函数的参数列表---&gt;得到的是参数列表的类类型</span></div><div class="line">		Class[] paramTypes = constructor.getParameterTypes();</div><div class="line">		<span class="keyword">for</span> (Class class1 : paramTypes) &#123;</div><div class="line">			System.out.print(class1.getName()+<span class="string">","</span>);</div><div class="line">		&#125;</div><div class="line">		System.out.println(<span class="string">")"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>比如class是String，会打印出java.lang.String([B,int,int,)、java.lang.String([B,java.nio.charset.Charset,)等</p>
<h2 id="反射的基本操作"><a href="#反射的基本操作" class="headerlink" title="反射的基本操作"></a>反射的基本操作</h2><p>主要过程：<br>1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型<br>//要获取print(int ,int )方法<br>A a1 = new A();<br>Class c = a1.getClass();</p>
<p>2.获取方法 名称和参数列表来决定<br>getMethod获取的是public的方法<br>getDelcaredMethod自己声明的方法</p>
<p>//Method m =  c.getMethod(“print”, new Class[]{int.class,int.class});<br>Method m = c.getMethod(“print”, int.class,int.class);</p>
<p>3.方法的反射操作<br>方法的反射操作是用m对象来进行方法调用 invoke和a1.print调用的效果完全相同<br>//方法如果没有返回值返回null,有返回值返回具体的返回值<br>//Object o = m.invoke(a1,new Object[]{10,20});<br>Object o = m.invoke(a1, 10,20);</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDemo1</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//要获取print(int ,int )方法  </span></div><div class="line">        <span class="comment">//  1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型</span></div><div class="line">        A a1 = <span class="keyword">new</span> A();</div><div class="line">        Class c = a1.getClass();</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * 2.获取方法 名称和参数列表来决定  </div><div class="line">		 * getMethod获取的是public的方法</div><div class="line">		 * getDelcaredMethod自己声明的方法</div><div class="line">		 */</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//Method m =  c.getMethod("print", new Class[]&#123;int.class,int.class&#125;);</span></div><div class="line">            Method m = c.getMethod(<span class="string">"print"</span>, <span class="keyword">int</span>.class, <span class="keyword">int</span>.class);</div><div class="line"></div><div class="line">            <span class="comment">//方法的反射操作  </span></div><div class="line">            <span class="comment">//a1.print(10, 20);</span></div><div class="line">						<span class="comment">//方法的反射操作是用m对象来进行方法调用 和a1.print调用的效果完全相同</span></div><div class="line">            <span class="comment">//方法如果没有返回值返回null,有返回值返回具体的返回值</span></div><div class="line">            <span class="comment">//Object o = m.invoke(a1,new Object[]&#123;10,20&#125;);</span></div><div class="line">            Object o = m.invoke(a1, <span class="number">10</span>, <span class="number">20</span>);</div><div class="line">            System.out.println(<span class="string">"=================="</span>);</div><div class="line">            <span class="comment">//获取方法print(String,String)</span></div><div class="line">            Method m1 = c.getMethod(<span class="string">"print"</span>, String.class, String.class);</div><div class="line">            <span class="comment">//用方法进行反射操作</span></div><div class="line">            <span class="comment">//a1.print("hello", "WORLD");</span></div><div class="line">            o = m1.invoke(a1, <span class="string">"hello"</span>, <span class="string">"WORLD"</span>);</div><div class="line">            System.out.println(<span class="string">"==================="</span>);</div><div class="line">            <span class="comment">//  Method m2 = c.getMethod("print", new Class[]&#123;&#125;);</span></div><div class="line">            Method m2 = c.getMethod(<span class="string">"print"</span>);</div><div class="line">            <span class="comment">// m2.invoke(a1, new Object[]&#123;&#125;);</span></div><div class="line">            m2.invoke(a1);</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"helloworld"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">        System.out.println(a + b);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String a, String b)</span> </span>&#123;</div><div class="line">        System.out.println(a.toUpperCase() + <span class="string">","</span> + b.toLowerCase());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="集合与泛型"><a href="#集合与泛型" class="headerlink" title="集合与泛型"></a>集合与泛型</h2><p>对于集合来说一般会在创建的时候就制定其类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ArrayList list = new ArrayList();</div><div class="line">ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;();</div></pre></td></tr></table></figure></p>
<p>同时我们还知道java语法糖，即编译之后集合的泛型是去泛型化的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class c1 = list.getClass();</div><div class="line">Class c2 = list1.getClass();</div><div class="line">System.out.println(c1 == c2);//true</div></pre></td></tr></table></figure></p>
<p>如果错误地添加会导致编译失败，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list1.add(&quot;hello&quot;);</div><div class="line">//list1.add(20);错误的</div></pre></td></tr></table></figure></p>
<p>但是通过泛型就可以绕过编译这一过程，完成添加不同类型的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Method m = c2.getMethod(&quot;add&quot;, Object.class);</div><div class="line">m.invoke(list1, 20);//绕过编译操作就绕过了泛型</div><div class="line">System.out.println(list1.size());</div><div class="line">System.out.println(list1);</div></pre></td></tr></table></figure></p>
<p>完整程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		ArrayList list = <span class="keyword">new</span> ArrayList();</div><div class="line"></div><div class="line">		ArrayList&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">		list1.add(<span class="string">"hello"</span>);</div><div class="line">		<span class="comment">//list1.add(20);错误的</span></div><div class="line">		Class c1 = list.getClass();</div><div class="line">		Class c2 = list1.getClass();</div><div class="line">		System.out.println(c1 == c2);</div><div class="line">		<span class="comment">//反射的操作都是编译之后的操作</span></div><div class="line"></div><div class="line">		<span class="comment">/*</span></div><div class="line">		 * c1==c2结果返回true说明编译之后集合的泛型是去泛型化的</div><div class="line">		 * Java中集合的泛型，是防止错误输入的，只在编译阶段有效，</div><div class="line">		 * 绕过编译就无效了</div><div class="line">		 * 验证：我们可以通过方法的反射来操作，绕过编译</div><div class="line">		 */</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Method m = c2.getMethod(<span class="string">"add"</span>, Object.class);</div><div class="line">			m.invoke(list1, <span class="number">20</span>);<span class="comment">//绕过编译操作就绕过了泛型</span></div><div class="line">			System.out.println(list1.size());</div><div class="line">			System.out.println(list1);</div><div class="line">			<span class="comment">/*for (String string : list1) &#123;</span></div><div class="line">				System.out.println(string);</div><div class="line">			&#125;*/<span class="comment">//现在不能这样遍历</span></div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">		  e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h1 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h1><p>类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。<br>一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。<br>类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。<br>通过此实例的 newInstance()方法就可以创建出该类的一个对象。<br>实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。</p>
<p>基本上所有的类加载器都是 java.lang.ClassLoader类的一个实例。</p>
<h2 id="java-lang-ClassLoader类介绍"><a href="#java-lang-ClassLoader类介绍" class="headerlink" title="java.lang.ClassLoader类介绍"></a><code>java.lang.ClassLoader</code>类介绍</h2><p>java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class类的一个实例。<br>除此之外，ClassLoader还负责加载 Java 应用所需的资源，如图像文件和配置文件等。不过本文只讨论其加载类的功能。为了完成加载类的这个职责，ClassLoader提供了一系列的方法.<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/classloaderfun.png" alt="ClassLoader主要方法" title="">
                </div>
                <div class="image-caption">ClassLoader主要方法</div>
            </figure></p>
<h2 id="类加载器的树状组织结构"><a href="#类加载器的树状组织结构" class="headerlink" title="类加载器的树状组织结构"></a>类加载器的树状组织结构</h2><p>Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。<br>系统提供的类加载器主要有下面三个：<br>引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，<strong>并不继承自 java.lang.ClassLoader</strong>。<br>扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。<br>系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。<br>除了系统提供的类加载器以外，<strong>开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求</strong>。<br><strong>除了引导类加载器之外，所有的类加载器都有一个父类加载器</strong>。通过 <code>getParent()</code>方法可以得到。<br>对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；<br>对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。<br>因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。<br>一般来说，开发人员编写的类加载器的父类加载器是系统类加载器。类加载器通过这种方式组织起来，形成树状结构。</p>
<h2 id="类加载器的代理模式"><a href="#类加载器的代理模式" class="headerlink" title="类加载器的代理模式"></a>类加载器的代理模式</h2><p>类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。</p>
<p>Java 虚拟机是如何判定两个 Java 类是相同的?<br>Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。<br>只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。</p>
<p>代理模式是为了保证 Java 核心库的类型安全。<br>所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。<br>如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。<br>通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。<br>不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。<br>不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。</p>
<p>真正完成类的加载工作是通过调用 <code>defineClass</code>来实现的；而启动类的加载过程是通过调用 <code>loadClass</code>来实现的。<br>前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。<br>在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。<br>也就是说，哪个类加载器启动类的加载过程并不重要，<strong>重要的是最终定义这个类的加载器</strong>。<br>两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。<br>如类 com.example.Outer引用了类 com.example.Inner，则由类 com.example.Outer的定义加载器负责启动类 com.example.Inner的加载过程。</p>
<p>方法 loadClass()抛出的是 java.lang.ClassNotFoundException异常；方法 defineClass()抛出的是 java.lang.NoClassDefFoundError异常。<br>类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。<br>下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。<br>也就是说，对于一个类加载器实例来说，相同全名的类只加载一次，<strong>即 loadClass方法不会被重复调用</strong>。</p>
<h2 id="loadClass-方法"><a href="#loadClass-方法" class="headerlink" title="loadClass()方法"></a><code>loadClass()</code>方法</h2><p>java.lang.ClassLoader类的方法 <code>loadClass()</code>封装了前面提到的代理模式的实现。<br> 同时<code>loadClass()</code>体现了模板模式，这个方法定义了类加载的过程，属于方法基类，其中<code>findClass(String name)</code>是由子类实现的，即不同的classloader有不同的实现方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</div><div class="line">    <span class="keyword">throws</span> ClassNotFoundException</div><div class="line">&#123;</div><div class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</div><div class="line">        <span class="comment">// First, check if the class has already been loaded</span></div><div class="line">        Class&lt;?&gt; c = findLoadedClass(name);</div><div class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    c = findBootstrapClassOrNull(name);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></div><div class="line">                <span class="comment">// from the non-null parent class loader</span></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></div><div class="line">                <span class="comment">// to find the class.</span></div><div class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line">                c = findClass(name);</div><div class="line"></div><div class="line">                <span class="comment">// this is the defining class loader; record the stats</span></div><div class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</div><div class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</div><div class="line">                sun.misc.PerfCounter.getFindClasses().increment();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (resolve) &#123;</div><div class="line">            resolveClass(c);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> c;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法会首先调用 findLoadedClass()方法来检查该类是否已经被加载过；<br>如果没有加载过的话，会调用父类加载器的 loadClass()方法来尝试加载该类；<br>如果父类加载器无法加载该类的话，就调用 findClass()方法来查找该类。<br>因此，为了保证类加载器都正确实现代理模式，<strong>在开发自己的类加载器时，最好不要覆写 loadClass()方法，而是覆写 findClass()方法</strong>。</p>
<h2 id="开发自己的类加载器"><a href="#开发自己的类加载器" class="headerlink" title="开发自己的类加载器"></a>开发自己的类加载器</h2><p>首先继承 <code>java.lang.ClassLoader</code><br>然后，自己开发的类加载器只需要覆写 <code>findClass(String name)</code>方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String rootDir;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileSystemClassLoader</span><span class="params">(String rootDir)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.rootDir = rootDir;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">		<span class="comment">//得到类的全名的字节流</span></div><div class="line">		<span class="keyword">byte</span>[] classData = getClassData(name);</div><div class="line">		<span class="keyword">if</span> (classData == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">//定义一个类</span></div><div class="line">			<span class="keyword">return</span> defineClass(name, classData, <span class="number">0</span>, classData.length);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//将类的全名转为字节流输入</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">byte</span>[] getClassData(String className) &#123;</div><div class="line">		String path = classNameToPath(className);</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			InputStream ins = <span class="keyword">new</span> FileInputStream(path);</div><div class="line">			ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</div><div class="line">			<span class="keyword">int</span> bufferSize = <span class="number">4096</span>;</div><div class="line">			<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</div><div class="line">			<span class="keyword">int</span> bytesNumRead = <span class="number">0</span>;</div><div class="line">			<span class="keyword">while</span> ((bytesNumRead = ins.read(buffer)) != -<span class="number">1</span>) &#123;</div><div class="line">				baos.write(buffer, <span class="number">0</span>, bytesNumRead);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span> baos.toByteArray();</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">classNameToPath</span><span class="params">(String className)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> rootDir + File.separatorChar</div><div class="line">				+ className.replace(<span class="string">'.'</span>, File.separatorChar) + <span class="string">".class"</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		String classDataRootPath = <span class="string">"C:\\Documents and Settings\\Administrator\\workspace\\Classloader\\classData"</span>;</div><div class="line">		FileSystemClassLoader fscl1 = <span class="keyword">new</span> FileSystemClassLoader(classDataRootPath);</div><div class="line">		FileSystemClassLoader fscl2 = <span class="keyword">new</span> FileSystemClassLoader(classDataRootPath);</div><div class="line">		String className = <span class="string">"com.example.Sample"</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Class&lt;?&gt; class1 = fscl1.loadClass(className);</div><div class="line">			Object obj1 = class1.newInstance();</div><div class="line">			Class&lt;?&gt; class2 = fscl2.loadClass(className);</div><div class="line">			Object obj2 = class2.newInstance();</div><div class="line">			Method setSampleMethod = class1.getMethod(<span class="string">"setSample"</span>, java.lang.Object.class);</div><div class="line">			setSampleMethod.invoke(obj1, obj2);</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类 FileSystemClassLoader的 findClass()方法首先根据类的全名在硬盘上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass()方法来把这些字节代码转换成 java.lang.Class类的实例。</p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/#minor1.1" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/java/j-lo-classloader/#minor1.1</a></p>
<p>在每个类加载器中的执行顺序：loadClass-&gt;findClass-&gt;defineClass<br>首先classloader主动调用loadClass，在loadClass中，如果父类不能加载就调用findClass，在findClass中找到类的全限定名，然后调用defineClass生成class。</p>
<p>#TODO<br><a href="http://www.infoq.com/cn/articles/cf-java-byte-code" target="_blank" rel="external">http://www.infoq.com/cn/articles/cf-java-byte-code</a><br><a href="http://zyjustin9.iteye.com/blog/2092131" target="_blank" rel="external">http://zyjustin9.iteye.com/blog/2092131</a><br><a href="http://www.cnblogs.com/xrq730/p/4847337.html" target="_blank" rel="external">http://www.cnblogs.com/xrq730/p/4847337.html</a><br>contextClassLoader</p>
<h1 id="Class-forName和classloader的区别"><a href="#Class-forName和classloader的区别" class="headerlink" title="Class.forName和classloader的区别"></a>Class.forName和classloader的区别</h1><p>Java中class.forName()和classLoader都可用来对类进行加载。<br><strong>class.forName()除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。</strong><br>而<strong>classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</strong><br>Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Class.forName(String className)  这是1.8的源码  </span></div><div class="line">   <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;  </div><div class="line">       Class&lt;?&gt; caller = Reflection.getCallerClass();  </div><div class="line">       <span class="keyword">return</span> forName0(className, <span class="keyword">true</span>, ClassLoader.getClassLoader(caller), caller);  </div><div class="line">   &#125;  </div><div class="line"><span class="comment">//注意第二个参数，是指Class被loading后是不是必须被初始化。 不初始化就是不执行static的代码即静态代码</span></div></pre></td></tr></table></figure></p>
<p>LoadClass（）方法加载类及初始化过程：<br>类加载（loadclass（））（加载）——》newInstance（）（链接+初始化）<br>newInstance（）:<br>（开始连接）静态代码块——》普通变量分配准备（a=0;b=0;c=null）——》（开始初始化）普通变量赋值（a=1;b=2;c=”haha”）——》构造方法——》初始化成功。</p>
<p>Class.forName(Stirng className)一个参数方法加载类及初始化过程：<br>类加载(Class.forName())（加载）——》静态代码块——》newInstance（）（链接+初始化）</p>
<p>newInstance（）：<br>（开始连接）普通变量分配准备（a=0;b=0;c=null）——》（开始初始化）普通变量赋值（a=1;b=2;c=”haha”）——》构造方法——》初始化成功。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;反射&quot;&gt;&lt;a href=&quot;#反射&quot; class=&quot;headerlink&quot; title=&quot;反射&quot;&gt;&lt;/a&gt;反射&lt;/h1&gt;&lt;h2 id=&quot;对象&quot;&gt;&lt;a href=&quot;#对象&quot; class=&quot;headerlink&quot; title=&quot;对象&quot;&gt;&lt;/a&gt;对象&lt;/h2&gt;&lt;p&gt;在ja
    
    </summary>
    
      <category term="note" scheme="http://duyao.github.io/categories/note/"/>
    
    
      <category term="java" scheme="http://duyao.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>juc之同步工具和并发容器</title>
    <link href="http://duyao.github.io/2017/03/24/juc%E4%B9%8B%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7%E5%92%8C%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    <id>http://duyao.github.io/2017/03/24/juc之同步工具和并发容器/</id>
    <published>2017-03-24T05:40:21.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="同步工具"><a href="#同步工具" class="headerlink" title="同步工具"></a>同步工具</h1><p><a href="http://watchmen.cn/portal.php?mod=view&amp;aid=513" target="_blank" rel="external">http://watchmen.cn/portal.php?mod=view&amp;aid=513</a></p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h3><p>public void lockInterruptibly() throws InterruptedException<br>调用<code>lockInterruptibly()</code>声明可中断</p>
<h3 id="可限时"><a href="#可限时" class="headerlink" title="可限时"></a>可限时</h3><p>public boolean tryLock()<br>public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException<br>超时不能获得锁，就返回false，不会永久等待构成死锁</p>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>先来先得<br>public ReentrantLock(boolean fair)<br>public static ReentrantLock fairLock = new ReentrantLock(true);</p>
<h3 id="可绑定条件"><a href="#可绑定条件" class="headerlink" title="可绑定条件"></a>可绑定条件</h3><p>ReentrantLock可以和多个condition一起使用</p>
<h3 id="与synchronized区别"><a href="#与synchronized区别" class="headerlink" title="与synchronized区别"></a>与synchronized区别</h3><p>主要区别就是ReentrantLock的四个特性：可中断、可限时、公平锁、可绑定多个条件<br>synchronized比较简单，通常与一个对象相关联，悲观锁，<br>ReentrantLock更高级，但是比较复杂，可以与多个对象相关联，乐观锁<br>他们都是可重入的，synchronized子程序调用父类，不会产生死锁的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(toString() + <span class="string">": calling doSomething"</span>);</div><div class="line">        <span class="keyword">super</span>.doSomething();<span class="comment">//若内置锁是不可重入的，则发生死锁</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="http://topmanopensource.iteye.com/blog/1736739" target="_blank" rel="external">http://topmanopensource.iteye.com/blog/1736739</a><br><a href="http://www.importnew.com/20472.html" target="_blank" rel="external">http://www.importnew.com/20472.html</a></p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>应用层面的锁，基本上使用java实现的，很少有很底层的东西</p>
<ul>
<li>CAS原理</li>
<li>等待队列</li>
<li>LockSupport.park();</li>
</ul>
<p>基于AQS的锁(比如ReentrantLock)原理大体是这样:<br>有一个state变量，初始值为0，假设当前线程为A,每当A获取一次锁，status++. 释放一次，status–.锁会记录当前持有的线程。<br>当A线程拥有锁的时候，status&gt;0. B线程尝试获取锁的时候会对这个status有一个CAS(0,1)的操作，尝试几次失败后就挂起线程，进入一个等待队列。<br>如果A线程恰好释放，–status==0, A线程会去唤醒等待队列中第一个线程，即刚刚进入等待队列的B线程，B线程被唤醒之后回去检查这个status的值，尝试CAS(0,1),而如果这时恰好C线程也尝试去争抢这把锁</p>
<p>非公平锁实现：<br>C直接尝试对这个status CAS(0,1)操作，并成功改变了status的值，B线程获取锁失败，再次挂起，这就是非公平锁，B在C之前尝试获取锁，而最终是C抢到了锁。<br>公平锁：<br>C发现有线程在等待队列，直接将自己进入等待队列并挂起,B获取锁</p>
<p><a href="http://www.cnblogs.com/xrq730/p/4979021.html" target="_blank" rel="external">http://www.cnblogs.com/xrq730/p/4979021.html</a><br><a href="http://www.importnew.com/19472.html" target="_blank" rel="external">http://www.importnew.com/19472.html</a><br><a href="http://blog.csdn.net/ns_code/article/details/17487337" target="_blank" rel="external">http://blog.csdn.net/ns_code/article/details/17487337</a><br><a href="https://www.zhihu.com/question/36964449/answer/69790971?utm_source=com.youdao.note&amp;utm_medium=social" target="_blank" rel="external">https://www.zhihu.com/question/36964449/answer/69790971?utm_source=com.youdao.note&amp;utm_medium=social</a><br><a href="http://www.cnblogs.com/maxmys/p/5181775.html" target="_blank" rel="external">http://www.cnblogs.com/maxmys/p/5181775.html</a></p>
<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>条件对象：进入临界区时发现必须满足一定的条件才能执行，那么就可以使用一个条件对象管理那些已经获得锁但是不能工作的线程<br>类似于 Object.wait()和Object.notify()<br>与ReentrantLock结合使用，一个ReentrantLock可以有多个Condition，习惯上给条件对象命名为可以反应它所表达的条件的名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void transfer(int from, int amount)&#123;</div><div class="line">  ReentrantLock bank = new ReentrantLock();</div><div class="line">  Condition sufficient = bank.newCondition();</div><div class="line"></div><div class="line">  bank.lock();//如果使用锁就不能使用带资源的try语句</div><div class="line">  try &#123;</div><div class="line">    while(!account[from] &lt; account)&#123;</div><div class="line">      sufficient.await();//await调用必须方法while(!ok to proceed)中，阻塞线程</div><div class="line">      //transfer funds</div><div class="line"></div><div class="line">      sufficient.signalAll();//解除等待线程的阻塞</div><div class="line">  &#125;</div><div class="line">  &#125;finally &#123;</div><div class="line">    bank.lock();//解锁一定要放在finally中</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><ul>
<li><p>void await() throws InterruptedException;<br>await()方法会使当前线程等待，同时释放当前锁，当其他线程中使用signal()时或者signalAll()方法时，线程会重新获得锁并继续执行。或者当线程被中断时，也能跳出等待。这和Object.wait()方法很相似。</p>
</li>
<li><p>void awaitUninterruptibly();<br>awaitUninterruptibly()方法与await()方法基本相同，但是它并不会再等待过程中响应中断。</p>
</li>
<li><p>void signal();<br>singal()方法用于唤醒一个在等待中的线程。</p>
</li>
<li><p>void signalAll();<br>相对的singalAll()方法会唤醒所有在等待中的线程。这和Obejct.notify()方法很类似。</p>
</li>
</ul>
<p>await、signal、signalAll必须抛异常</p>
<h2 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h2><p>共享锁，运行多个线程同时临界</p>
<h3 id="主要接口"><a href="#主要接口" class="headerlink" title="主要接口"></a>主要接口</h3><p>public void acquire()<br>public void acquireUninterruptibly()<br>public boolean tryAcquire()<br>public boolean tryAcquire(long timeout, TimeUnit unit)<br>public void release()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">//只有两个信号量</span></div><div class="line">    <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</div><div class="line">    <span class="keyword">static</span> SemaphoreDemo demo = <span class="keyword">new</span> SemaphoreDemo();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//有10个线程去抢夺</span></div><div class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            executor.submit(demo);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//获得</span></div><div class="line">            semaphore.acquire();</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() + <span class="string">" done!"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">//释放</span></div><div class="line">            semaphore.release();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>倒数计时器<br>一种典型的场景就是火箭发射。在火箭发射前，为了保证万无一失，往往还要进行各项设备、仪器的检查。<br>只有等所有检查完毕后，引擎才能点火。这种场景就非常适合使用CountDownLatch。它可以使得点火线程，等待所有检查线程全部完工后，再执行</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>static final CountDownLatch end = new CountDownLatch(10);<br>end.countDown();<br>end.await();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">//5个任务需要检查</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch end = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatchDemo demo = <span class="keyword">new</span> CountDownLatchDemo();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">//执行5个线程完成检查，如果没有完成，所有线程就会阻塞，等待完成</span></div><div class="line">        <span class="comment">// 所以线程的个数必须要与倒计时个数相同</span></div><div class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            executorService.submit(demo);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//等待通知</span></div><div class="line">        end.await();</div><div class="line">        System.out.println(<span class="string">"Fired"</span>);</div><div class="line">        executorService.shutdown();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random r = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(r.nextInt(<span class="number">5</span>) * <span class="number">1000</span>);</div><div class="line">            end.countDown();</div><div class="line">            System.out.println(<span class="string">"chenk over, remaining "</span>+end.getCount() );</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>循环栅栏<br>Cyclic意为循环，也就是说这个计数器可以反复使用。比如，假设我们将计数器设置为10。那么凑齐第一批10个线程后，计数器就会归零，然后接着凑齐下一批10个线程</p>
<h3 id="主要接口-1"><a href="#主要接口-1" class="headerlink" title="主要接口"></a>主要接口</h3><ul>
<li><p>public CyclicBarrier(int parties, Runnable barrierAction)<br>barrierAction就是当计数器一次计数完成后，系统会执行的动作，必须是实现Runnable接口</p>
</li>
<li><p>public int await() throws InterruptedException, BrokenBarrierException<br>抛出InterruptedException中断异常的目的是避免线程中断，而一直阻塞，产生永久性的异常<br>抛出BrokenBarrierException的原因是一批线程中只有凑够了个数才会执行。<br>事实上，有可能出现其中一个线程出问题，那么导致其他线程阻塞无法执行，这时候其他线程就会抛出BrokenBarrierException，表示自己永远不能执行了</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> String soldier;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclic;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Soldier</span><span class="params">(CyclicBarrier cyclic, String soldier)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.soldier = soldier;</div><div class="line">            <span class="keyword">this</span>.cyclic = cyclic;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//复用栅栏</span></div><div class="line">                <span class="comment">//等待所有士兵到齐</span></div><div class="line">                cyclic.await();</div><div class="line">                doWork();</div><div class="line">                <span class="comment">//等待所有士兵完成工作</span></div><div class="line">                cyclic.await();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;<span class="comment">//在等待过程中,线程被中断</span></div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;<span class="comment">//表示当前CyclicBarrier已经损坏.系统无法等到所有线程到齐了.</span></div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(Math.abs(<span class="keyword">new</span> Random().nextInt() % <span class="number">10000</span>));</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(soldier + <span class="string">":任务完成"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarrierRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> flag;</div><div class="line">        <span class="keyword">int</span> N;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BarrierRun</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">int</span> N)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.flag = flag;</div><div class="line">            <span class="keyword">this</span>.N = N;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (flag) &#123;</div><div class="line">                System.out.println(<span class="string">"司令:[士兵"</span> + N + <span class="string">"个,任务完成!]"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                System.out.println(<span class="string">"司令:[士兵"</span> + N + <span class="string">"个,集合完毕!]"</span>);</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10</span>;</div><div class="line">        Thread[] allSoldier = <span class="keyword">new</span> Thread[N];</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//第二个参数就是当计数器一次计数完成后，系统会执行的动作</span></div><div class="line">        CyclicBarrier cyclic = <span class="keyword">new</span> CyclicBarrier(N, <span class="keyword">new</span> BarrierRun(flag, N));</div><div class="line">        <span class="comment">//设置屏障点,主要为了执行这个方法</span></div><div class="line">        System.out.println(<span class="string">"集合队伍! "</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">            System.out.println(<span class="string">"士兵"</span> + i + <span class="string">"报道! "</span>);</div><div class="line">            allSoldier[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Soldier(cyclic, <span class="string">"士兵"</span> + i));</div><div class="line">            allSoldier[i].start();</div><div class="line"></div><div class="line"><span class="comment">//            if(i == 5)&#123;</span></div><div class="line"><span class="comment">//               allSoldier[i].interrupt();</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>CyclicBarrier是支持复用的，协调的是多个线程之间的顺序，即<strong>线程之间要互相等待</strong>，比如abc分别执行任务，然后等三个都完成之后才能继续执行新的任务<br>CountDownLatch是<strong>一个线程等待其他多个线程的完成</strong></p>
<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>提供线程阻塞原语<br>与suspend()比较，不容易引起线程冻结</p>
<p>同时能够响应中断，但不抛出异常。<br>中断响应的结果是，park()函数的返回，可以从Thread.interrupted()得到中断标志</p>
<p>使用的比较底层的操作，类似于被广泛的应用在其他类的是实现中</p>
<h3 id="主要接口-2"><a href="#主要接口-2" class="headerlink" title="主要接口"></a>主要接口</h3><p>LockSupport.park();<br>LockSupport.unpark(Thread thread);</p>
<h2 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h2><p><a href="http://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/" target="_blank" rel="external">http://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/</a></p>
<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><p>对于容器map、set、list等，如果要实现同步，可以使用<code>Collections.synchronizedMap(map)</code>,<code>Collections.synchronizedList(list)</code>d等方法但是这仅仅适合并发量小的情况。<br>因为在其内部，使用<code>synchronized</code>控制<code>final Object mutex</code>变量的获取。<br>每个方法在执行前，都会先获取mutex然后再执行，也就是这个map每次只能被一个线程操作，这样每个方法的执行过程相对就串行化，比如两个get完全不用获得锁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;     <span class="comment">// Backing Map</span></div><div class="line">    <span class="keyword">final</span> Object      mutex;        <span class="comment">// Object on which to synchronize</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">       <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.get(key);&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">       <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">       <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.remove(key);&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>高性能HashMap<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/segment.jpg" alt="ConcurrentHashMap" title="">
                </div>
                <div class="image-caption">ConcurrentHashMap</div>
            </figure><br>ConcurrentHashMap将hash表分为16个桶（默认值），诸如get,put,remove等常用操作只锁当前需要用到的桶。<br>试想，原来只能一个线程进入，现在却能同时16个写线程进入（写线程才需要锁定，而读线程几乎不受限制，之后会提到），并发性的提升是显而易见的。<br>更令人惊讶的是ConcurrentHashMap的读取并发，因为在<strong>读取的大多数时候都没有用到锁定，所以读取操作几乎是完全的并发操作</strong>，而<strong>写操作锁定的粒度又非常细</strong>，比起之前又更加快速（这一点在桶更多时表现得更明显些）。<br><strong>ConcurrentHashMap只有在求size等操作时才需要锁定整个表</strong></p>
<h3 id="java1-7实现方法"><a href="#java1-7实现方法" class="headerlink" title="java1.7实现方法"></a>java1.7实现方法</h3><blockquote>
<p>锁分离 (Lock Stripping)</p>
</blockquote>
<p>ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p>
<blockquote>
<p>不变(Immutable)和易变(Volatile)</p>
</blockquote>
<p>ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。HashEntry代表每个hash链中的一个节点，其结构如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </div><div class="line">    <span class="keyword">final</span> K key;  </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  </div><div class="line">    <span class="keyword">volatile</span> V value;  </div><div class="line">    <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到除了value不是final的，其它值都是final的，这意味着不能从hash链的中间或尾部添加或删除节点，因为这需要修改next引用值，所有的节点的修改只能从头部开始。对于put操作，可以一律添加到Hash链的头部。但是对于remove操作，可能需要从中间删除一个节点，这就需要将要删除节点的前面所有节点整个复制一遍，最后一个节点指向要删除结点的下一个结点。这在讲解删除操作时还会详述。为了确保读操作能够看到最新的值，将value设置成volatile，这避免了加锁。</p>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。<br>Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;  </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;  </div><div class="line">     <span class="comment">/**</span></div><div class="line">      * The number of elements in this segment's region.</div><div class="line">      */  </div><div class="line">     <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;  </div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line">      * Number of updates that alter the size of the table. This is</div><div class="line">      * used during bulk-read methods to make sure they see a</div><div class="line">      * consistent snapshot: If modCounts change during a traversal</div><div class="line">      * of segments computing size or checking containsValue, then</div><div class="line">      * we might have an inconsistent view of state so (usually)</div><div class="line">      * must retry.</div><div class="line">      */  </div><div class="line">     <span class="keyword">transient</span> <span class="keyword">int</span> modCount;  </div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line">      * The table is rehashed when its size exceeds this threshold.</div><div class="line">      * (The value of this field is always &lt;tt&gt;(int)(capacity *</div><div class="line">      * loadFactor)&lt;/tt&gt;.)</div><div class="line">      */  </div><div class="line">     <span class="keyword">transient</span> <span class="keyword">int</span> threshold;  </div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line">      * The per-segment table.</div><div class="line">      */  </div><div class="line">     <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;  </div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line">      * The load factor for the hash table.  Even though this value</div><div class="line">      * is same for all segments, it is replicated to avoid needing</div><div class="line">      * links to outer object.</div><div class="line">      * <span class="doctag">@serial</span></div><div class="line">      */  </div><div class="line">     <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
<h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (count != <span class="number">0</span>) &#123; <span class="comment">// read-volatile  </span></div><div class="line">        HashEntry&lt;K,V&gt; e = getFirst(hash);  </div><div class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;  </div><div class="line">                V v = e.value;  </div><div class="line">                <span class="keyword">if</span> (v != <span class="keyword">null</span>)  </div><div class="line">                    <span class="keyword">return</span> v;  </div><div class="line">                <span class="keyword">return</span> readValueUnderLock(e); <span class="comment">// recheck  </span></div><div class="line">            &#125;  </div><div class="line">            e = e.next;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get操作不需要锁。<br>第一步是访问count变量，这是一个volatile变量，由于所有的修改操作在进行结构修改时都会在最后一步写count变量，通过这种机制保证get操作能够得到几乎最新的结构更新。对于非结构更新，也就是结点值的改变，由于HashEntry的value变量是volatile的，也能保证读取到最新的值。<br>接下来就是对hash链进行遍历找到要获取的结点，如果没有找到，直接访回null。</p>
<p>对hash链进行遍历不需要加锁的原因在于链指针next是final的。<br>但是头指针却不是final的，这是通过getFirst(hash)方法返回，也就是存在table数组中的值。这使得getFirst(hash)可能返回过时的头结点，例如，当执行get方法时，刚执行完getFirst(hash)之后，另一个线程执行了删除操作并更新头结点，这就导致get方法中返回的头结点不是最新的。这是可以允许，通过对count变量的协调机制，get能读取到几乎最新的数据，虽然可能不是最新的。要得到最新的数据，只有采用完全的同步。</p>
<p>最后，如果找到了所求的结点，判断它的值如果非空就直接返回，否则在有锁的状态下再读一次。</p>
<h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;  </div><div class="line">    lock();  </div><div class="line">    <span class="keyword">try</span> &#123;  </div><div class="line">        <span class="keyword">int</span> c = count;  </div><div class="line">        <span class="keyword">if</span> (c++ &gt; threshold) <span class="comment">// ensure capacity  </span></div><div class="line">            rehash();  </div><div class="line">        HashEntry&lt;K,V&gt;[] tab = table;  </div><div class="line">        <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);  </div><div class="line">        HashEntry&lt;K,V&gt; first = tab[index];  </div><div class="line">        HashEntry&lt;K,V&gt; e = first;  </div><div class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key)))  </div><div class="line">            e = e.next;  </div><div class="line"></div><div class="line">        V oldValue;  </div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;  </div><div class="line">            oldValue = e.value;  </div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent)  </div><div class="line">                e.value = value;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span> &#123;  </div><div class="line">            oldValue = <span class="keyword">null</span>;  </div><div class="line">            ++modCount;  </div><div class="line">            tab[index] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(key, hash, first, value);  </div><div class="line">            count = c; <span class="comment">// write-volatile  </span></div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> oldValue;  </div><div class="line">    &#125; <span class="keyword">finally</span> &#123;  </div><div class="line">        unlock();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法也是在持有段锁的情况下执行的，首先判断是否需要rehash，需要就先rehash。<br>接着是找是否存在同样一个key的结点，如果存在就直接替换这个结点的值。否则创建一个新的结点并添加到hash链的头部，这时一定要修改modCount和count的值，同样修改count的值一定要放在最后一步。put方法调用了rehash方法，reash方法实现得也很精巧，主要利用了table的大小为2^n，这里就不介绍了。</p>
<h4 id="remove操作"><a href="#remove操作" class="headerlink" title="remove操作"></a>remove操作</h4><p>整个操作是在持有段锁的情况下执行的，空白行之前的行主要是定位到要删除的节点e。<br>接下来，如果不存在这个节点就直接返回null，否则就要将<strong>e前面的结点复制一遍</strong>，尾结点指向e的下一个结点。<strong>e后面的结点不需要复制</strong>，它们可以重用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123;  </div><div class="line">    lock();  </div><div class="line">    <span class="keyword">try</span> &#123;  </div><div class="line">        <span class="keyword">int</span> c = count - <span class="number">1</span>;  </div><div class="line">        HashEntry&lt;K,V&gt;[] tab = table;  </div><div class="line">        <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);  </div><div class="line">        HashEntry&lt;K,V&gt; first = tab[index];  </div><div class="line">        HashEntry&lt;K,V&gt; e = first;  </div><div class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key)))  </div><div class="line">            e = e.next;  </div><div class="line"></div><div class="line">        V oldValue = <span class="keyword">null</span>;  </div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;  </div><div class="line">            V v = e.value;  </div><div class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span> || value.equals(v)) &#123;  </div><div class="line">                oldValue = v;  </div><div class="line">                <span class="comment">// All entries following removed node can stay  </span></div><div class="line">                <span class="comment">// in list, but all preceding ones need to be  </span></div><div class="line">                <span class="comment">// cloned.  </span></div><div class="line">                ++modCount;  </div><div class="line">                HashEntry&lt;K,V&gt; newFirst = e.next;  </div><div class="line">                <span class="comment">//复制</span></div><div class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = first; p != e; p = p.next)  </div><div class="line">                    newFirst = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(p.key, p.hash,  </div><div class="line">                                                  newFirst, p.value);  </div><div class="line">                tab[index] = newFirst;  </div><div class="line">                count = c; <span class="comment">// write-volatile  </span></div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> oldValue;  </div><div class="line">    &#125; <span class="keyword">finally</span> &#123;  </div><div class="line">        unlock();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/concurrenthashmapremove.png" alt="remove方法" title="">
                </div>
                <div class="image-caption">remove方法</div>
            </figure>
<p>参考：</p>
<p><a href="http://www.iteye.com/topic/344876" target="_blank" rel="external">http://www.iteye.com/topic/344876</a><br><a href="http://www.infoq.com/cn/articles/ConcurrentHashMap" target="_blank" rel="external">http://www.infoq.com/cn/articles/ConcurrentHashMap</a></p>
<h3 id="java1-8实现方法"><a href="#java1-8实现方法" class="headerlink" title="java1.8实现方法"></a>java1.8实现方法</h3><p>改进一：取消segments字段，直接采用transient volatile HashEntry<k,v>[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。</k,v></p>
<p>改进二：将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。对于hash表来说，最核心的能力在于将key hash之后能均匀的分布在数组中。如果hash之后散列的很均匀，那么table数组中的每个队列长度主要为0或者1。但实际情况并非总是如此理想，虽然ConcurrentHashMap类默认的加载因子为0.75，但是在数据量过大或者运气不佳的情况下，还是会存在一些队列长度过长的情况，如果还是采用单向列表方式，那么查询某个节点的时间复杂度为O(n)；因此，对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能。</p>
<p><a href="http://blog.csdn.net/u010412719/article/details/52145145" target="_blank" rel="external">http://blog.csdn.net/u010412719/article/details/52145145</a><br><a href="http://www.cnblogs.com/everSeeker/p/5601861.html" target="_blank" rel="external">http://www.cnblogs.com/everSeeker/p/5601861.html</a></p>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>阻塞队列，不是高性能，接口<br>可以用于生产者消费者模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue queue;</div><div class="line">  Producer(BlockingQueue q) &#123; queue = q; &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; queue.put(produce()); &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ...&#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function">Object <span class="title">produce</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue queue;</div><div class="line">  Consumer(BlockingQueue q) &#123; queue = q; &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; consume(queue.take()); &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ...&#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">(Object x)</span> </span>&#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Setup</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    BlockingQueue q = <span class="keyword">new</span> SomeQueueImplementation();</div><div class="line">    Producer p = <span class="keyword">new</span> Producer(q);</div><div class="line">    Consumer c1 = <span class="keyword">new</span> Consumer(q);</div><div class="line">    Consumer c2 = <span class="keyword">new</span> Consumer(q);</div><div class="line">    <span class="keyword">new</span> Thread(p).start();</div><div class="line">    <span class="keyword">new</span> Thread(c1).start();</div><div class="line">    <span class="keyword">new</span> Thread(c2).start();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>1、入队列就将尾索引往右移动一个，新元素加入尾索引的位置；<br>2、出队列就将头索引往尾索引方向移动一个，同时将旧头索引元素设为null，返回旧头索引的元素。<br>3、一旦数组已满，那么就不允许添加新元素（除非扩充容量）<br>4、如果尾索引移到了数组的最后（最大索引处），那么就从索引0开始，形成一个“闭合”的数组。<br>5、由于头索引和尾索引之间的元素都不能为空（因为为空不知道take出来的元素为空还是队列为空），所以删除一个头索引和尾索引之间的元素的话，需要移动删除索引前面或者后面的所有元素，以便填充删除索引的位置。<br>6、由于是阻塞队列，那么显然需要一个锁，另外由于只是一份数据（一个数组），所以只能有一个锁，也就是同时只能有一个线程操作队列。</p>
<p>主要通过ReentrantLock和Condition实现加锁、阻塞的功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Main lock guarding all access */</span></div><div class="line"><span class="keyword">final</span> ReentrantLock lock;</div><div class="line"><span class="comment">/** Condition for waiting takes */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</div><div class="line"><span class="comment">/** Condition for waiting puts */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</div><div class="line"><span class="comment">/** The queued items */</span></div><div class="line"><span class="keyword">final</span> Object[] items;</div></pre></td></tr></table></figure></p>
<p>put方法，先加锁，这里就证实了它并不是一个高性能容器，因为这里毫无分析的就加锁，性能一定不高<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    checkNotNull(e);</div><div class="line">    <span class="comment">//加锁</span></div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    <span class="comment">//响应阻塞</span></div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (count == items.length)</div><div class="line">            <span class="comment">//队列满就等待</span></div><div class="line">            notFull.await();</div><div class="line">        enqueue(e);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="comment">//释放锁</span></div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* Inserts element at current put position, advances, and signals.</div><div class="line">* Call only when holding lock.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></div><div class="line">    <span class="comment">// assert items[putIndex] == null;</span></div><div class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line">    items[putIndex] = x;</div><div class="line">    <span class="keyword">if</span> (++putIndex == items.length)</div><div class="line">        putIndex = <span class="number">0</span>;</div><div class="line">    count++;</div><div class="line">    <span class="comment">//通知不空</span></div><div class="line">    notEmpty.signal();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在java中可以使用BlockingQueue来实现消息队列，但是效率不是非常高，因为其内部不是无锁方式。</p>
<h4 id="Disruptor"><a href="#Disruptor" class="headerlink" title="Disruptor"></a>Disruptor</h4><p>Disruptor可以实现高性能生产者和消费者模式<br>Disruptor通过以下设计来解决队列速度慢的问题：</p>
<ul>
<li><p>环形数组结构<br>为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。</p>
</li>
<li><p>元素位置定位<br>数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。</p>
</li>
<li><p>无锁设计<br>每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。</p>
</li>
</ul>
<p>Diruptor 页面：<a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="external">https://github.com/LMAX-Exchange/disruptor</a><br>待完成<br><a href="https://zhuanlan.zhihu.com/p/21355046" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/21355046</a><br><a href="https://www.bittiger.io/classpage/QHkP5QobvhNWGZv9f" target="_blank" rel="external">https://www.bittiger.io/classpage/QHkP5QobvhNWGZv9f</a><br><a href="http://tech.meituan.com/disruptor.html" target="_blank" rel="external">http://tech.meituan.com/disruptor.html</a></p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue有两个ReentrantLock和两个Condition以及用于AtomicInteger的count<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Current number of elements */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</div><div class="line"><span class="comment">/** Lock held by take, poll, etc */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="comment">/** Lock held by put, offer, etc */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="comment">/** Wait queue for waiting takes */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</div><div class="line"><span class="comment">/** Wait queue for waiting puts */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</div><div class="line"><span class="comment">/** Linked list node class */</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E item;</div><div class="line">    Node&lt;E&gt; next;</div><div class="line">    Node(E x) &#123; item = x; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是整体上讲，LinkedBlockingQueue和ConcurrentLinkedQueue的结构类似，都是采用头尾节点，每个节点指向下一个节点的结构，这表示它们在操作上应该类似。<br>1、LinkedBlockingQueue引入了AtomicInteger的count，这意味着获取队列大小size()已经是常量时间了，不再需要遍历队列。每次队列长度有变更时只需要修改count即可。<br>2、有了修改Node指向有了锁，所以不需要volatile特性了。<br>3、引入了两个锁，一个入队列锁，一个出队列锁。当然同时有一个队列不满的Condition和一个队列不空的Condition。</p>
<p>参照锁机制的生产者-消费者模型就知道，入队列就代表生产者，出队列就代表消费者。<br>为什么需要两个锁？一个锁行不行？其实一个锁完全可以，但是一个锁意味着入队列和出队列同时只能有一个在进行，另一个必须等待其释放锁。<br>而从ConcurrentLinkedQueue的实现原理来看，事实上head和last (ConcurrentLinkedQueue中是tail)是分离的，互相独立的，这意味着入队列实际上是不会修改出队列的数据的，同时出队列也不会修改入队列，也就是说这两个操作是互不干扰的。<br>更通俗的将，这个锁相当于两个写入锁，入队列是一种写操作，操作head，出队列是一种写操作，操作tail。可见它们是无关的。但是并非完全无关，后面详细分析。</p>
<p>入队列的阻塞过程大概是这样的：<br>获取入队列的锁putLock，检测队列大小，如果队列已满，那么就挂起线程，等待队列不满信号notFull的唤醒。<br>将元素加入到队列尾部，同时修改队列尾部引用last。<br>队列大小加1。<br>释放锁putLock。<br>唤醒notEmpty线程（如果有挂起的出队列线程），告诉消费者，已经有了新的产品。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></div><div class="line">    <span class="comment">// holding count negative to indicate failure unless set.</span></div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</div><div class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">    putLock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Note that count is used in wait guard even though it is</div><div class="line">         * not protected by lock. This works because count can</div><div class="line">         * only decrease at this point (all other puts are shut</div><div class="line">         * out by lock), and we (or some other waiting put) are</div><div class="line">         * signalled if it ever changes from capacity. Similarly</div><div class="line">         * for all other uses of count in other wait guards.</div><div class="line">         */</div><div class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</div><div class="line">            notFull.await();</div><div class="line">        &#125;</div><div class="line">        enqueue(node);</div><div class="line">        c = count.getAndIncrement();</div><div class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</div><div class="line">            notFull.signal();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        putLock.unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">        signalNotEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对比入队列，出队列的阻塞过程大概是这样的：</p>
<p>获取出队列的锁takeLock，检测队列大小，如果队列为空，那么就挂起线程，等待队列不为空notEmpty的唤醒。<br>将元素从头部移除，同时修改队列头部引用head。<br>队列大小减1。<br>释放锁takeLock。<br>唤醒notFull线程（如果有挂起的入队列线程），告诉生产者，现在还有空闲的空间。</p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><blockquote>
<p>一个基于链接节点的无界线程安全队列。此队列按照 FIFO（先进先出）原则对元素进行排序。<br>队列的头部 是队列中时间最长的元素。<br>队列的尾部 是队列中时间最短的元素。<br>新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。<br>当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择。此队列不允许使用 null 元素。</p>
</blockquote>
<p>主要使用cas原理<br>ConcurrentLinkedQueue只有头结点、尾节点两个元素，而对于一个节点Node而言除了保存队列元素item外，还有一个指向下一个节点的引用next。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">      <span class="keyword">volatile</span> E item;</div><div class="line">      <span class="keyword">volatile</span> Node&lt;E&gt; next;</div><div class="line">      ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>1、所有结构（head/tail/item/next）都是volatile类型。 这是因为ConcurrentLinkedQueue是非阻塞的，所以只有volatile才能使变量的写操作对后续读操作是可见的（这个是有happens-before法则保证的）。同样也不会导致指令的重排序。<br>2、由于队列中任何一个节点（Node）只有下一个节点的引用，所以这个队列是单向的，根据FIFO特性，也就是说出队列在头部(head)，入队列在尾部(tail)。头部保存有进入队列最长时间的元素，尾部是最近进入的元素。<br>3、没有对队列长度进行计数，所以队列的长度是无限的，同时获取队列的长度的时间不是固定的，这<strong>需要遍历整个队列，并且这个计数也可能是不精确的</strong>。<br>4、初始情况下队列头和队列尾都指向一个空节点，但是非null，这是为了方便操作，不需要每次去判断head/tail是否为空。但是head却不作为存取元素的节点，tail在不等于head情况下保存一个节点元素。也就是说head.item这个应该一直是空，但是tail.item却不一定是空（如果head!=tail，那么tail.item!=null）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public boolean offer(E e) &#123;</div><div class="line">    checkNotNull(e);</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);</div><div class="line"></div><div class="line">    for (Node&lt;E&gt; t = tail, p = t;;) &#123;</div><div class="line">        Node&lt;E&gt; q = p.next;</div><div class="line">        if (q == null) &#123;</div><div class="line">            // p is last node</div><div class="line">            if (p.casNext(null, newNode)) &#123;</div><div class="line">                // Successful CAS is the linearization point</div><div class="line">                // for e to become an element of this queue,</div><div class="line">                // and for newNode to become &quot;live&quot;.</div><div class="line">                if (p != t) // hop two nodes at a time</div><div class="line">                    casTail(t, newNode);  // Failure is OK.</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            // Lost CAS race to another thread; re-read next</div><div class="line">        &#125;</div><div class="line">        else if (p == q)</div><div class="line">            // We have fallen off list.  If tail is unchanged, it</div><div class="line">            // will also be off-list, in which case we need to</div><div class="line">            // jump to head, from which all live nodes are always</div><div class="line">            // reachable.  Else the new tail is a better bet.</div><div class="line">            p = (t != (t = tail)) ? t : head;</div><div class="line">        else</div><div class="line">            // Check for tail updates after two hops.</div><div class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="http://www.infoq.com/cn/articles/ConcurrentLinkedQueue" target="_blank" rel="external">http://www.infoq.com/cn/articles/ConcurrentLinkedQueue</a><br><a href="http://www.blogjava.net/xylz/archive/2010/07/23/326934.html" target="_blank" rel="external">http://www.blogjava.net/xylz/archive/2010/07/23/326934.html</a></p>
<h2 id="常见的BlockingQueue"><a href="#常见的BlockingQueue" class="headerlink" title="常见的BlockingQueue"></a>常见的BlockingQueue</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/allblockingqueue.png" alt="各种" title="">
                </div>
                <div class="image-caption">各种</div>
            </figure>
<h2 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h2><p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。<br>其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。<br>从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是<code>CopyOnWriteArrayList</code>和<code>CopyOnWriteArraySet</code>。<br>CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>
<p>CopyOnWrite容器即写时复制的容器。<br>通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。<br>这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<h3 id="CopyOnWriteArrayList的实现原理"><a href="#CopyOnWriteArrayList的实现原理" class="headerlink" title="CopyOnWriteArrayList的实现原理"></a>CopyOnWriteArrayList的实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</div><div class="line">  <span class="comment">/** The lock protecting all mutators */</span></div><div class="line">  <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">  <span class="comment">/** The array, accessed only via getArray/setArray. */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Object[] elements = getArray();</div><div class="line">        <span class="keyword">int</span> len = elements.length;</div><div class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</div><div class="line">        newElements[len] = e;</div><div class="line">        setArray(newElements);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> (E) a[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>CopyOnWrite的应用场景</p>
<p>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。</p>
<p>使用CopyOnWriteMap需要注意两件事情：<br>1.减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。<br>2.使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
<p>内存占用问题。<br>因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。<br>如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。</p>
<p>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p>
<p>数据一致性问题。<br>CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>
<p><a href="http://ifeve.com/java-copy-on-write/" target="_blank" rel="external">http://ifeve.com/java-copy-on-write/</a></p>
<h2 id="volatile-final"><a href="#volatile-final" class="headerlink" title="volatile final"></a>volatile final</h2><p>不可变一定是线程安全的</p>
<h2 id="同步更新、互斥同步、非阻塞同步"><a href="#同步更新、互斥同步、非阻塞同步" class="headerlink" title="同步更新、互斥同步、非阻塞同步"></a>同步更新、互斥同步、非阻塞同步</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;同步工具&quot;&gt;&lt;a href=&quot;#同步工具&quot; class=&quot;headerlink&quot; title=&quot;同步工具&quot;&gt;&lt;/a&gt;同步工具&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://watchmen.cn/portal.php?mod=view&amp;amp;aid=513&quot; t
    
    </summary>
    
      <category term="note" scheme="http://duyao.github.io/categories/note/"/>
    
    
      <category term="jvm" scheme="http://duyao.github.io/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>395. Longest Substring with At Least K Repeating Characters</title>
    <link href="http://duyao.github.io/2017/03/22/395-Longest-Substring-with-At-Least-K-Repeating-Characters/"/>
    <id>http://duyao.github.io/2017/03/22/395-Longest-Substring-with-At-Least-K-Repeating-Characters/</id>
    <published>2017-03-22T12:45:03.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/#/description" target="_blank" rel="external">https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/#/description</a></p>
<p>类似于二分的做法<br>找出小于k次出现的字符，然后以该字符二分区间，从而找到最长<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestSubstring</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.length() == <span class="number">0</span> || k &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="keyword">return</span> s.length();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> f(s, <span class="number">0</span>, s.length(), k);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//找出每一段区间中那个少于k次的值，然后二分法求得每一段的长度</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(String s, <span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (b &lt; a) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (b - a + <span class="number">1</span> &lt; k) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">//记录下来每一个字符出现的频率</span></div><div class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &lt; b; i++) &#123;</div><div class="line">        arr[s.charAt(i) - <span class="string">'a'</span>]++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> len = b - a;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a; i &lt; b; i++) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//找到小于k次的字符，然后用它分割整个区间</span></div><div class="line">        <span class="keyword">if</span> (arr[s.charAt(i) - <span class="string">'a'</span>] &lt; k &amp;&amp; arr[s.charAt(i) - <span class="string">'a'</span>] &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//二分法求值</span></div><div class="line">            <span class="keyword">int</span> left = f(s, i + <span class="number">1</span>, b, k);</div><div class="line">            <span class="keyword">int</span> right = f(s, a, i, k);</div><div class="line"></div><div class="line">            <span class="keyword">return</span> Math.max(right, left);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> len;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/#/description&quot; target=&quot;_blank&quot; rel=&quot;externa
    
    </summary>
    
      <category term="algorithm" scheme="http://duyao.github.io/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="http://duyao.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>3. Longest Substring Without Repeating Characters</title>
    <link href="http://duyao.github.io/2017/03/20/3-Longest-Substring-Without-Repeating-Characters/"/>
    <id>http://duyao.github.io/2017/03/20/3-Longest-Substring-Without-Repeating-Characters/</id>
    <published>2017-03-20T14:31:55.000Z</published>
    <updated>2017-06-17T04:17:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/#/solutions" target="_blank" rel="external">https://leetcode.com/problems/longest-substring-without-repeating-characters/#/solutions</a></p>
<p>这道题目就是用map存放已经遍历过字母的位置<br>如果发现存在就重新设置起点的位置，注意设置起点位置是在当前起点和出现字符位置+1中选择大的，防止回退<br>另外每次都要更新maxl，而不是只更换起点时候更新，因为一直没有重复的就不会发生更新<br>最后计算长度的时候还要+1，因为都是闭区间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">   HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">   <span class="keyword">int</span> start = <span class="number">0</span>, cur = <span class="number">0</span>;</div><div class="line">   <span class="keyword">int</span> maxl = <span class="number">0</span>;</div><div class="line">   <span class="keyword">while</span> (cur &lt; s.length()) &#123;</div><div class="line">       <span class="keyword">if</span> (map.containsKey(s.charAt(cur))) &#123;</div><div class="line">           <span class="comment">//注意这里不能单纯找后一个值，而是要比较当前值与回退值哪个大</span></div><div class="line">           <span class="comment">//比如abba</span></div><div class="line">           start = Math.max(start, map.get(s.charAt(cur)) + <span class="number">1</span>);</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">//这里每次都要更新位置</span></div><div class="line">       map.put(s.charAt(cur), cur);</div><div class="line">       <span class="comment">//全部都是闭区间</span></div><div class="line">       maxl = Math.max(maxl, cur - start + <span class="number">1</span>);</div><div class="line">       cur++;</div><div class="line"></div><div class="line">   &#125;</div><div class="line">   <span class="comment">// System.out.println(maxl);</span></div><div class="line">   <span class="keyword">return</span> maxl;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-substring-without-repeating-characters/#/solutions&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https:/
    
    </summary>
    
      <category term="algorithm" scheme="http://duyao.github.io/categories/algorithm/"/>
    
    
      <category term="leetcode" scheme="http://duyao.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
