title: 二叉树及其相关
toc: true
date: 2016-03-20 19:33:39
tags: java
categories:
---
 本文用来整理二叉树的各种知识点

## 二叉树性质

- 性质1 一棵非空二叉树的第i层上最多有2i-1个结点(i≥1)。
- 性质2 若规定空树的深度为0，则深度为k的二叉树最多有2k-1个结点(k≥0)。
- 性质3 具有n个结点的完全二叉树的深度k为log2n+1。
- 性质4 对于一棵非空二叉树，如果度为0的结点数目为n0，度为2的结点数目为n2，则有n0= n2+1。
- 性质5 对于具有n个结点的完全二叉树，如果按照从上到下和从左到右的顺序对所有结点从1开始编号，则对于序号为i的结点，有：
（1）如果i>1，则序号为i的结点的双亲结点的序号为i/2(“/”表示整除)；如果i=1，则该结点是根结点，无双亲结点。
（2）如果2i≤n，则该结点的左孩子结点的序号为2i；若2i>n，则该结点无左孩子。
（3）如果2i+1≤n，则该结点的右孩子结点的序号为2i+1；若2i+1>n，则该结点无右孩子。
- 性质6 给定N个节点，能构成h(N)种不同的二叉树。

h(N)为卡特兰数的第N项。h(n)=C(n,2*n)/(n+1)


## 满二叉树(Full Binary Tree)

如果一棵二叉树**只有度为0的结点和度为2的结点**，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

**深度为k的满二叉树的结点个数为2k-1**

## 完全二叉树(Complete Binary Tree)

深度为k，有n个结点的二叉树当且仅当其每一个结点都与深度为k，有n个结点的满二叉树中编号从1到n的结点一一对应时，称为完全二叉树。

完全二叉树的特点是叶子结点只可能出现在层次最大的两层上，并且某个结点的左分支下子孙的最大层次与右分支下子孙的最大层次相等或大1。

完全二叉树是由满二叉树引出来的，因此满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。

## 二叉查找树(Binary Search Tree)

二叉查找树,也称二叉搜索树、有序二叉树（英语：ordered binary tree），排序二叉树（英语：sorted binary tree）.

是指一棵空树或者具有下列性质的二叉树

- 任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 任意节点的左、右子树也分别为二叉查找树；
- 没有键值相等的节点。

删除时要注意，如果删除的节点有左右子树，那么用左子树的最右节点(推荐)或者右子树的最左节点取代该删除节点

二叉查找树的时间复杂度不是严格的log(N)，在最坏的情况下会出现“链表”的形式，复杂度退化到O(N)
因此有了AVL树(利用平衡因子), RB Tree红黑树(利用颜色), Treap(树和堆的结合)等来优化BST的最坏情况

References:
[Binary_search_tree](https://en.wikipedia.org/wiki/Binary_search_tree)


### AVL树

在AVL树中任何节点的两个子树的高度最大差别为一
查找、插入和删除在平均和最坏情况下都是O(log n)
增加和删除可能需要通过一次或多次树旋转来重新平衡这个树

节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来

References:
[AVL_tree](https://en.wikipedia.org/wiki/AVL_tree)

### 红黑树Red-Black Tree

在O(log n)时间内做查找，插入和删除，这里的n是树中元素的数目。

红黑树是每个节点都带有颜色属性的**二叉查找树**，颜色为红色或黑色。
在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求：

- 节点是红色或黑色。
- 根是黑色。
- 所有叶子都是黑色（叶子是NIL节点）。
- 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）
- 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。

**红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高.**


详细内容请看[红黑树](http://duyao.github.io/2016/03/19/%E7%BA%A2%E9%BB%91%E6%A0%91/)


### Treap

树和堆的合体，在树中维护一个"优先级"，"优先级"采用随机数的方法，但是"优先级"必须满足根堆的性质
插入原理与AVL相似

References:
[树堆](http://www.cnblogs.com/huangxincheng/archive/2012/07/30/2614484.html)
[Treap](https://en.wikipedia.org/wiki/Treap)

### 伸展树(Splay Tree)
能在O(log n)内完成插入、查找和删除操作。

在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。
于是想到设计一个简单方法， 在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生。
伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。

它的优势在于不需要记录用于平衡树的冗余信息。
伸展树最显著的缺点是它有可能会变成一条链。这种情况可能发生在以非降顺序访问n个元素之后。然而均摊的最坏情况是对数级的——O(log n)

References:
[伸展树](http://www.cnblogs.com/huangxincheng/archive/2012/08/04/2623455.html)
[Splay_tree](https://en.wikipedia.org/wiki/Splay_tree)


TODO:

## 字典树
## 堆
堆肯定是一棵平衡二叉树(×)
因堆是二叉树，但不是二叉排序树，平衡二叉树是二叉排序树
## B-Tree，B+树，mysql，磁盘索引
## jvm 堆栈


