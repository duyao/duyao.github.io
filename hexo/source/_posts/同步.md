title: 同步
date: 2016-03-08 08:24:48
tags: java
toc: true
---
## 锁对象
ReentrantLock 是可重入锁，用来控制同时访问
```
private Lock mylock = new ReentrantLock();


mylock.lock();
try{
	//临界区
	
}finally{
	//不论如何最终释放锁
	mylock.unlock();
}
```
每一个对象都有一个锁，只有两个线程同时访问同一个对象，才会出现锁的串行化，否则不会出现线程阻塞
线程可以重复获得已有的锁

## 条件对象
通常进入临界区后，发现必须满足一个条件才能执行，因此要使用条件对象来管理已经获得锁却不能进行工作的线程，和锁对象联合使用。
比如转账之前要确定有足够的钱,例如一个对象刚刚得到锁，要转账，发现没有足够的钱，则需要等待其他账户转钱，但是此时由于锁被夺走，其他账户无法完成转钱的事务，因此需要条件对象。
一个锁对象有多个条件对象。
```
public void transfer(int from, int to, int amount){
	mylock.lock();
	try{
		while(account[from] < amount){
			//wait
		}
		//transfer	
	}finally{
		mylock.unlock();
	}
}
```

使用`await`来阻塞当前线程，使其放弃锁，无条件进入等待状态
使用`signalAll`来重新激活因为这一条件等待的线程，即条件可能满足，可以重新检测条件。
但是无法激活自身，因此还可能导致死锁。
```
public void transfer(int from, int to, int amount){
	mylock.lock();
	try{
		while(account[from] < amount){
			sufficent.await();
		}
		System.out.println(Thread.currentThread());
		account[from] -= amout;
		account[to] += amout;
		sufficent.signalAll();
		
	}finally{
		mylock.unlock();
	}
	
}
```
## synchronized关键字
synchronized使用对象的内部锁来控制线程，与Lock和Condition相似。
```
public synchronized void method(){
	//method body
}
```
两者是等同的，同时`wait()`和`notifyAll()`,`notify()`与Condition中的`await()`和`signalAll()`,`signal()`用法相似
```
public void method(){
	this.intrinsicLock.lock();
	try{
		//method body
	}finally{
		this.intrinsicLock.unlock();
	}
}
```
使用synchronized关键字的方法
```
public synchronized void transfer(){
	while(account[from] < amount){
		wait();
	}
	System.out.println(Thread.currentThread());
	account[from] -= amout;
	account[to] += amout;
	notifyAll();
}
```

[synchronized与Lock区别](https://dzone.com/articles/what-are-reentrant-locks)

## 同步异步阻塞非阻塞
### 同步与异步
同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)
所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。
换句话说，就是由*调用者*主动等待这个*调用*的结果。

而异步则是相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。
而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。

- 例子
你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。
而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

### 阻塞非阻塞
阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.

阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

- 例子
你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。
在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。

## Volatile
- Volatile
Guarantees visibility and NOT atomicity

- Synchronization (Locking)
Guarantees visibility and atomicity (if done properly)

**Volatile is not a substitute for synchronization**

Use volatile only when you are updating the reference and not performing some other operations on it. If two threads are both reading and writing to a shared variable, then using the volatile keyword for that is not enough. You need to use a synchronized in that case to guarantee that the reading and writing of the variable is atomic.

So where volatile only synchronizes the value of **one variable** between thread memory and "main" memory, synchronized synchronizes the value of **all variables** between thread memory and "main" memory, and locks and releases a monitor to boot. 

## ThreadLocal
One possible (and common) use is when you have some object that is not thread-safe, but you want to avoid synchronizing access to that object (SimpleDateFormat). 
Instead, give each thread its own instance of the object.
[ThreadLocal介绍](https://dzone.com/articles/java-thread-local-%E2%80%93-how-use)

```
public static final ThreadLocal<SimpleDateFormat> dateFormat = new ThreadLocal<SimpleDateFormat>() {
	protected SimpleDateFormat initialValue() {
		return new SimpleDateFormat("yyyy-MM-dd HH:mm");
	}

};
//访问方法
//首次调用get会先调用initialValue，返回当前进程的实例
String dateStamp = dateFormat.get().format(new Date());
```

## 锁测试与超时
### boolean tryLock()
尝试获得锁而没有发生阻塞，成功是返回真，这个方法会抢夺锁，即使有公平的策略
```
Lock lock = ...;
if (lock.tryLock()) {
  try {
      // manipulate protected state
  } finally {
      lock.unlock();
  }
} else {
  // perform alternative actions
}

```

### boolean tryLock(int time, TimeUnit unit)
TimeUnit是枚举型，取值有MILLISECONDS, SECONDS等
等待过程中被中断将会抛出异常，可以打破死锁
同样的，有`condition.await(100,TimeUnit.SECONDS)`

## 读写锁
java.util.concurrent.locks中定义了两类锁，一种是`ReentrantLock`，另一种是`ReentrantReadWriteLock`
`eentrantReadWriteLock`适用于很多线程多数据，少数线程写数据的情景。
```
//1.构造读写锁对象
private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
//2.抽取读写锁
private Lock readLock = rwl.readLock();
private Lock writeLock = rwl.writeLock();
//3.对所有的获取方法加锁
public double getTotalBalance(){
	readLock.lock();
	try {
		//read data
	} finally {
		readLock.unlock();
	}
}
//4.对所有的修改方法加锁
public void transfer(){
	writeLock.lock();
	try{
		//write data
	}finally{
		writeLock.unlock();
	}
}
```