title: 1.1
date: 2015-10-25 15:52:49
tags: niuke
categories: algorithm
---

## 实现“之”字形打印矩阵

输入一个矩阵，按照从之字形打印出每一个数字，例如，如果输入如下矩阵：
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
则依次打印出数字1 5 2 3 6 9 13 10 7 4 8 11 14 15 12 16

<!--more-->

---

### 思路
可以将问题化简为按照斜线打印，然后每次打印方向遇上一次相反
先给出斜线的上下顶点，打印斜线，然后移动再打印

---
### 代码

```c++
#include <stdio.h>
int m,n;
int a[1010][1010];
void zigzag(int ux,int uy,int dx,int dy,int flag){
	
	if(flag){
		//flag=1从下到上 
		
		for(int i=dx,j=dy;i>=ux,j<=uy;i--,j++){
			printf("%d ",a[i][j]);
		}
	}else{
		//flag=0从上向下
		for(int i=ux,j=uy;i<=dx,j>=dy;i++,j--){
			printf("%d ",a[i][j]);
		}
	}
	

}
int main()
{
	freopen("in.txt","r",stdin);
	while(scanf("%d %d",&m,&n)!=EOF){
		
		for (int i=0;i<m;i++){
			
			for(int j=0;j<n;j++){
				scanf("%d",&a[i][j]);
			}
		}
		
		if(m==1){
			for(int i=0;i<n;i++){
				printf("%d ",a[0][i]);
			}
			
		}
		else if(n==1){
			for(int i=0;i<m;i++){
				printf("%d ",a[i][0]);
			}
		}else{
			//给出定点坐标和方向
			int flag=0;
			int ux=0,uy=0,dx=0,dy=0;
			//指出上下定点的坐标 
			while(ux<m&&dy<n){
				zigzag(ux,uy,dx,dy,flag);
				//flag是用来告诉方向的 
				flag=!flag;
				//上点右移，uy+，下点下移，dx+
				//对于非正方形，要同时移动ux及dy 
				uy++;dx++;
				if(uy>=n){
					uy=n-1;
					ux++;
				}
				if(dx>=m){
					dx=m-1;
					dy++;
				}
			}
 	
		}
		printf("\n");
	}
	
	return 0;
}
```

---

## 顺时针打印

- 题目描述：
输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵：
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.
- 输入：
输入可能包含多个测试样例，对于每个测试案例，
输入的第一行包括两个整数m和n(1<=m,n<=1000)：表示矩阵的维数为m行n列。
接下来的m行，每行包括n个整数，表示矩阵的元素，其中每个元素a的取值范围为(1<=a<=10000)。
- 输出：
对应每个测试案例，输出一行，
按照从外向里以顺时针的顺序依次打印出每一个数字，每个数字后面都有一个空格。
- 样例输入：
4 4
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
- 样例输出：
1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10 

[顺时针打印矩阵](http://ac.jobdu.com/problem.php?pid=1391 "http://ac.jobdu.com/problem.php?pid=1391")

---

### 思路

可以看做是按圈打印，先打印最外圈的数字，然后打印内圈，打印的顺序都是顺时针。
首先给出左上和右下的坐标，然后按照顺时针打印。
打印完一圈后，左上和右下往里移动。直到两者相遇。

---

### 代码

```c++
#include <stdio.h>
int m,n;
int a[1010][1010];
int main()
{
     
    while(scanf("%d %d",&m,&n)!=EOF){
         
        for (int i=0;i<m;i++){
             
            for(int j=0;j<n;j++){
                scanf("%d",&a[i][j]);
            }
        }
         
        //只有一行
        if (m == 1){
            for(int i=0;i<n;i++){
                printf("%d ",a[0][i]);
            }
            printf("\n");
            continue;
        }
        //只有一列
        if( n==1){
            for(int i=0;i<m;i++){
                printf("%d ",a[i][0]);
            }
            printf("\n");
            continue;
        }

        int ux=0,uy=0,dx=m-1,dy=n-1;
        while(ux<=dx && uy<=dy ){
             
            for(int j=uy;j<dy;j++){
                printf("%d ",a[ux][j]);
            }
            for(int i = ux;i<dx; i++){
                printf("%d ",a[i][dy] ) ;
            }
            for (int j=dy;j>uy;j--){
                 
                printf("%d ",a[dx][j]);
            }
             
            for(int i=dx;i>ux;i--){
                printf("%d ",a[i][uy]);
            }
             
                 ux++,uy++,dx--,dy--;
        }
        printf("\n");
    }
    return 0;
}
```
