title: 数据库-范式
toc: true
date: 2017-04-25 10:23:30
tags: 数据库
categories: note
---
范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。
实际上你可以把它粗略地理解为一张数据表的表结构所符合的某种设计标准的级别。

# 第一范式1NF
定义为：**符合1NF的关系中的每个属性都不可再分**。
1NF是所有关系型数据库的最基本要求

| 编号 | 商品| 进货 | 销售|备注|
| :---: | :---: |:---: | :---: |:---: |
|      |    |数量+单价 |数量+单价 |||

但是仅仅符合1NF的设计，仍然会存在**数据冗余过大，插入异常，删除异常，修改异常**的问题，例如对于图1中的设计：
![图1](http://7xilc8.com1.z0.glb.clouddn.com/2nf.jpg)

# 第二范式（2NF）
对1NF进行了一些改进。其改进是，**2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖**。
接下来对这句话中涉及到的四个概念——“函数依赖”、“码”、“非主属性”、与“部分函数依赖”进行一下解释。


## 函数依赖
我们可以这么理解（但并不是特别严格的定义）：**若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y。**
也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。
这也就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。
例如，对于图1中的数据，找不到任何一条记录，它们的学号相同而对应的姓名不同。所以我们可以说姓名函数依赖于学号，写作 `学号 → 姓名`。
但是反过来，因为可能出现同名的学生，所以有可能不同的两条学生记录，它们在姓名上的值相同，但对应的学号不同，所以我们不能说学号函数依赖于姓名。
表中其他的函数依赖关系还有如：
- `系名 → 系主任`
- `学号 → 系主任`
- `（学号，课名） → 分数`

但以下函数依赖关系则不成立：
- `学号 → 课名`
- `学号 → 分数`
- `课名 → 系主任`
- `（学号，课名） → 姓名`

从“函数依赖”这个概念展开，还会有三个概念：
>完全函数依赖

在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ' → Y 不成立，那么我们称 Y 对于 X 完全函数依赖，记作 X F→ Y。（那个F应该写在箭头的正上方）
例如： 学号 F→ 姓名 （学号，课名） F→ 分数  （注：因为同一个的学号对应的分数不确定，同一个课名对应的分数也不确定）
>部分函数依赖

假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 X  P→ Y（P在箭头上方）
例如：（学号，课名） P→ 姓名
>传递函数依赖

假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （严格来说还有一个X 不包含于Y，且 Y 不函数依赖于Z的前提条件），那么我们就称 Z 传递函数依赖于 X ，记作 X T→ Z(T在箭头上方)

## 码
设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都**完全**函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为候选码，简称为码。
在实际中我们通常可以理解为：**假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。**
一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为主码）
例如：对于图1，（学号、课名）这个属性组就是码。该表中有且仅有这一个码。（假设所有课没有重名的情况）

## 非主属性
包含在任何一个码中的属性成为主属性。例如：对于图1，主属性就有两个，学号 与 课名。


终于可以回过来看2NF了。首先，我们需要判断，图1是否符合2NF的要求？根据2NF的定义，**判断的依据实际上就是看数据表中是否存在非主属性对于码的部分函数依赖**。
若存在，则数据表最高只符合1NF的要求，若不存在，则符合2NF的要求。
判断的方法是：
第一步：找出数据表中所有的码。
第二步：根据第一步所得到的码，找出所有的主属性。
第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。
第四步：查看是否存在非主属性对码的部分函数依赖。
对于图1，根据前面所说的四步，我们可以图中所有的函数依赖关系：
![函数依赖](http://7xilc8.com1.z0.glb.clouddn.com/dependency.jpg)
这一步完成以后，可以得到，图1的码只有一个，就是（学号、课名）。
第二步：主属性有两个：学号 与 课名
第三步：非主属性有四个：姓名、系名、系主任、分数
第四步：
对于`（学号，课名） → 姓名`，有 `学号 → 姓名`，存在非主属性 `姓名` 对码`（学号，课名）`的部分函数依赖。
对于`（学号，课名） → 系名`，有 `学号 → 系名`，存在非主属性 `系名` 对码`（学号，课名）`的部分函数依赖。
对于`（学号，课名） → 系主任`，有`学号 → 系主任`，存在非主属性 `系主任`  对码`（学号，课名）`的部分函数依赖。
所以图1存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要求。

为了让图1符合2NF的要求，我们必须消除这些部分函数依赖，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”模式分解“。
模式分解的方法不是唯一的，以下是其中一种方法：
选课（学号，课名，分数）
学生（学号，姓名，系名，系主任）
新的函数依赖如下图所示：
![新的函数依赖](http://7xilc8.com1.z0.glb.clouddn.com/dependency1.jpg)
对于选课表，其码是（学号，课名），主属性是学号和课名，非主属性是分数，学号确定，并不能唯一确定分数，课名确定，也不能唯一确定分数，所以不存在非主属性分数对于码 （学号，课名）的部分函数依赖，所以此表符合2NF的要求。
对于学生表，其码是学号，主属性是学号，非主属性是姓名、系名和系主任，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求


# 第三范式（3NF）
3NF在2NF的基础之上，**消除了非主属性对于码的传递函数依赖**。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。

对于上面新的函数依赖，可以分析：
对于选课表，主码为（学号，课名），主属性为学号和课名，非主属性只有一个，为分数，不可能存在传递函数依赖，所以选课表的设计，符合3NF的要求。
对于学生表，主码为学号，主属性为学号，非主属性为姓名、系名和系主任。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性系主任对于码学号的传递函数依赖，所以学生表的设计，不符合3NF的要求。。

为了让数据表设计达到3NF，我们必须进一步进行模式分解为以下形式：
选课（学号，课名，分数）
学生（学号，姓名，系名）
系（系名，系主任）
对于选课表，符合3NF的要求，之前已经分析过了。
对于学生表，码为学号，主属性为学号，非主属性为系名，不可能存在非主属性对于码的传递函数依赖，所以符合3NF的要求。
对于系表，码为系名，主属性为系名，非主属性为系主任，不可能存在非主属性对于码的传递函数依赖（至少要有三个属性才可能存在传递函数依赖关系），所以符合3NF的要求。

结论
由此可见，符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF，但是作为数据库设计人员，至少应该知道，3NF的要求是怎样的。


## BCNF范式
要了解 BCNF 范式，那么先看这样一个问题：若：某公司有若干个仓库；每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。
那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？
答：
已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量
码：（管理员，物品名），（仓库名，物品名）
主属性：仓库名、管理员、物品名
非主属性：数量
∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。

因此BCNF就是解决存在着主属性对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。
解决办法就是要在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。

仓库（仓库名，管理员）
库存（仓库名，物品名，数量）

https://www.zhihu.com/question/24696366/answer/29189700
