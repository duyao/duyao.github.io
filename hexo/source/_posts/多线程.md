title: 多线程
date: 2016-02-29 14:51:33
tags: java
---
[TOC]
## 什么是线程

1. 实现Runnable接口的run方法
2. 创建类对象D1
3. 由Runnalbe创建Thread对象
4. 启动线程start()
**直接调用run方法只会执行同一线程的任务，而不会启动新任务**
```
public class D1 implements Runnable{

	@Override
	public void run() {
		// TODO Auto-generated method stub
		System.out.println("test...");
	}
	public static void main(String[] args) {
		D1 demo = new D1();
		Thread t = new Thread(demo);
		t.start();
		Thread.currentThread().isInterrupted()
	}

}
```

- isInterrupted()
测试线程是否中断，不改变线程的状态
- interrupted()
静态方法，测试是否中断，且将中断状态置为false
- interrupt()
向线程发送中断请求，线程的状态设置为true。如果当前线程被sleep置为阻塞，则抛出InterruptedException.

## 线程的状态
- new
- runnable
- blocked
- waiting
- time waiting
- terminated

### new
新创建线程，new Thread(r)新建线程，该线程还未开始运行
### runnable
可运行线程，一旦调用start方法，进入可运行状态，但是不一定是运行状态，需要抢占时间片
### blocked
试图获得对象的内部锁，而该锁被其他线程持有，进入阻塞状态
### time waiting
超时参数导致机进入计时等待，
### waiting
等待另一个线程通知调度器一个条件时，调用wait(),join()会出现等待状态
### terminated
- 正常执行run方法死亡
- 因为一个没有捕获的异常终止run方法而意外死亡

## 线程属性
- 线程优先级
每一个线程都有优先级，默认情况下集成父亲的优先级，可以用`setPriority`改变
- 守护线程
使用`t.setDaemon(true)`将普通线程转化为守护线程且在线程启动之前调用，作用是为其他线程服务。
当只剩下守护线程，虚拟机就会退出。
- 处理未捕获异常的处理器和线程组
这个处理器必须实现`Thread.UncaughtExceptionHandler`接口的`uncaughtException(Thread arg0, Throwable arg1)`方法
可以用`setDefaultUncaughtExceptionHandler`为任何一个线程安装处理器
```
public class MyCrashHandler implements UncaughtExceptionHandler {  
  
    @Override  
    public void uncaughtException(Thread arg0, Throwable arg1) {  
        //当程序发生未捕获的异常时，会执行该方法  
        System.out.println("抱歉，程序出异常了...");  
    }  
      
} 
public class Test {  
  
    public static void main(String[] args) {  
        //为当前线程设置默认的未捕获异常处理器  
        Thread.setDefaultUncaughtExceptionHandler(new MyCrashHandler());  
        //执行子线程，产生异常  
        new TestThread().start();  
    }  
  
    static class TestThread extends Thread {  
  
        @Override  
        public void run() {  
            super.run();  
            //在子线程中模拟一个异常  
            System.out.println("1/0 = " + 1 / 0);  
        }  
  
    }  
  
}  
```

