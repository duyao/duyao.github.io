{"meta":{"title":"Du Yao's blog","subtitle":"Make progress step by step","description":"","author":"Du Yao","url":"http://duyao.github.io"},"pages":[{"title":"","date":"2017-06-11T09:11:45.000Z","updated":"2017-03-02T12:02:18.000Z","comments":false,"path":"categories/index.html","permalink":"http://duyao.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-06-11T09:11:45.000Z","updated":"2017-03-02T12:02:52.000Z","comments":false,"path":"tags/index.html","permalink":"http://duyao.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"zookeeper基础","slug":"zookeeper基础","date":"2017-05-28T08:40:02.000Z","updated":"2017-05-30T08:52:56.000Z","comments":true,"path":"2017/05/28/zookeeper基础/","link":"","permalink":"http://duyao.github.io/2017/05/28/zookeeper基础/","excerpt":"","text":"zk介绍 Zookeeper是Apache Hadoop的一个子项目，本质是一个分布式小文件系统，主要解决分布式系统应用中遇到的数据管理问题（一致性问题）：统一命名服务，状态同步服务，集群管理，分布式应用配置项的管理。 基本命令 命令 作用 stat path [watch] f set path data [version] stat ls path [watch] stat delquota [-n/-b] path stat ls2 path [watch] stat setAcl path acl stat setquota -n/-b val path stat history stat redo cmdno stat printwatches on/off stat delete path [version] stat sync path stat listquota path stat rmr path stat get path [watch] stat create [-s] [-e] path data acl stat addauth scheme auth stat quit stat getAcl path stat close stat connect host:port stat 数据模型 zk中的数据结构 每个子目录项（比如图中的NameService）都被称为znode。znode可以有子节点目录，并且每个znode都可以保存数据，但注意EPHEMERAL类型的目录节点不能有子节点目录。 znode是有版本的，每个znode中存储的数据可以有多个版本，也就是同一访问路径可以存储多份数据。 对于临时的znode，一旦创建这个znode的客户端与服务器失去联系，这个znode也将自动删除，Zookeeper的客户端和服务器通信采用长链接方式，每个客户端和服务器通过心跳来保持连接。 znode可以被监控，包括这个节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知监听的客户端，这个是Zookeeper的重要特性。 节点类型Zookeeper节点在创建后其类型不能被修改，有四种类型的节点: PERSISTENT所谓持久节点，是指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点——不会因为创建该节点的客户端会话失效而消失。 PERSISTENT_SEQUENTIAL这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在ZK中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的上限是整型的最大值。 EPHEMERAL和持久节点不同的是，临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。 EPHEMERAL_SEQUENTIALZK会自动为给定节点名的临时节点加上一个数字后缀，作为新的节点名。同持久顺序节点。 节点信息zookeeper目录中的每一个节点对应着一个znode，每个znode维护着一个属性结构，它包含数据的版本号、时间戳、等信息，同时每个Znode由3部分组成:① stat：此为状态信息, 描述该Znode的版本, 权限等信息② data：与该Znode关联的数据③ children：该Znode下的子节点 Zookeeper就是通过这些属性来实现它特定的功能。每当znode的数据改变时，相应的版本号会增加，每当客户端查询、更新和删除数据时，也必须提供要被操作的znode版本号，如果所提供的数据版本号与实际的不匹配，那么将会操作失败。节点属性：12345678910111213[zk: localhost:2181(CONNECTED) 2] get /test123cZxid = 0x6ctime = Sun May 28 15:24:48 CST 2017mZxid = 0x6mtime = Sun May 28 15:24:48 CST 2017pZxid = 0x6cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 3numChildren = 0 属性 描述 cZxid 节点被创建的zxid值 ctime 节点创建的时间 mZxid 节点被修改时zxid值 mtime 节点最后一次的修改时间 pZxid 最后一次更改该节点孩子的事务id cvesion 节点所拥有的子节点被修改的版本号 dataVersion 数据版本 aclVersion 访问控制版本 ephemeralOwner 如果节点为临时节点，那么它的值为这个节点拥有者的session ID；负责它的值为0 dataLength 节点数据的长度 numChildren 节点拥有子节点的个数 watcherwatcher监听器ZooKeeper中所有的读操作getData(),getChildren()和 exists()可以选择设置一个watcher。还有在创建客户端对象实例时也可以设置watcher，ZooKeeper(String connectString, int sessionTimeout, Watcher watcher)ZooKeeper有两个监听器列表：数据监听和子节点监听:getData()和exists()设置数据监听器; getChildren()设置子节点监听器。只能二选一，根据返回数据的类型来设置监听器。getData()和exists()返回节点的数据信息，然而getChildren()返回一个子节点列表。 设置监视器的操作及对应的触发器 因此，setData()会触发数据监听器。一个成功的 create()会触发一个数据监听器。一个delete()会触发数据监听器和子节点监听器。 wathcer的触发及改变 注意点1.Watches通知是一次性的，必须重复注册.2.同一个ZK客户端，反复对同一个ZK节点（znode）注册相同的watcher，是无效的，最终只会有一个生效。3.发生CONNECTIONLOSS之后，只要在session_timeout之内再次连接上（即不发生SESSIONEXPIRED），那么这个连接注册的watches依然在。4.客户端会话失效之后，所有这个会话中创建的Watcher都会被移除。5.节点数据的版本变化会触发NodeDataChanged，注意，这里特意说明了是版本变化。存在这样的情况，只要成功执行了setData()方法，无论内容是否和之前一致，都会触发NodeDataChanged事件。6.对某个节点注册了watcher，但是节点被删除了，那么注册在这个节点上的watcher都会被移除。 注册过程总体来说.可以概括为以下几个过程:（1）客户端注册Watcher（2）服务端处理Watcher（3）客户端回调Watcher首先需要了解一下zookeeper中的watchedevent结构，其包括三个基本属性：通知状态（keepstate）、事件类型（eventType）和节点路径（path）。zookeeper使用watchedevent对象来封装服务端事件并传递给watcher，而实际传递的是watcherevent，其结构和watchedevent一样，WatcherEvent 实体实现了序列化接口，因此可以用于网络传输。数据结构如下。12345Class WatcherEvent&#123; type:int state:int path:String&#125; 从这里可以看出，watcher事件只是一个简单的事件说明，并不包含事件的数据变更内容，这样能保证网络传输的高效性。这里也体现出观察者模式中推拉结合，发生的变化被推送到观察者，此时观察者只知道发生了变化，只有靠拉才能知道到底发生了什么变化。 http://blog.csdn.net/lionaiying/article/details/53915878 process() 是 Watch 接口中的回调方法。当 ZooKeeper 向客户端发送一个 Watcher 时间通知时，客户端就会对相应的 process 方法进行回调，从而实现对事件的处理。 like this：syncNodes（）方法。abstract public void process ( WatchedEvent event ) http://www.cnblogs.com/rocky24/p/4859206.htmlhttps://www.ibm.com/developerworks/cn/opensource/os-cn-apache-zookeeper-watcher/ ServerCnxn类及cnxn对象 Zk客户端与服务器之间的tcp连接 实现了watcher接口总结：既包含了连接信息又包了watcher信息watchManager Zk服务器端Watcher的管理者 从两个维度维护watcher• watchTable:从数据节点的粒度来维护• watch2Paths从watcher的粒度来维护 负责watcher事件的触发ACLScheme:id:permission比如world:anyone:crdwa Scheme:验证过程中使用的检验策略 Id:权限被赋予的对象，比如ip或者某个用户 Permission:权限，Ї面的crdwa，表示五个权限组合通过setAcl命令置节点的权限,getAcl可以查看节点的Acl信息123456789101112131415[zk: localhost:2181(CONNECTED) 8] setAcl /test world:anyone:cacZxid = 0x6ctime = Sun May 28 15:24:48 CST 2017mZxid = 0x6mtime = Sun May 28 15:24:48 CST 2017pZxid = 0xacversion = 1dataVersion = 0aclVersion = 1ephemeralOwner = 0x0dataLength = 3numChildren = 1[zk: localhost:2181(CONNECTED) 9] getAcl /test&apos;world,&apos;anyone: ca 节点的acl不具有继承关系 Scheme类型worldId的固定值为anyone，表示任何用户world:anyone:crdwa表示任何用户都Ӏ有crdwa权限 authauth:username:password:crdwa表示给认证通过的所有用户设置acl权限，同时可以添加多个用户通过addauth命令进行认证用户的添加addauth digest &lt;username&gt;:&lt;password&gt;Auth策略的本质就是digest如果通过addauth创建多组用户和密码，当使用setAcl修改权限时，所有的用户和密码的权限都会跟着修改通过addauth新创建的用户和密码组需要重新调用setAcl才会加入到权限组中去 digestScheme:id:permission，比如 digest:username:password:crdwa指定某个用户及它的密码可以访问这里的username:password必须经过SHA-1和BASE64编码，即BASE64(SHA1(username:password))通过addauth命令进行认证用户的添加addauth digest &lt;username&gt;:&lt;password&gt; IPScheme:id:permission ，比如 ip:127.0.0.1:crdwa指定某个ip地址可以访问 super供运维人员维护节点使用有权限操作任何节点启动时，在命令参数中配置 -Dzookeeper.DigestAuthenticationProvider.superDigest=admin:015uTByzA4zSglcmseJsxTo7n3c= 打开zkCli.cmd，在java命令后添加以上配置用户名和密码也需要通过sha1和base64编码https://holynull.gitbooks.io/zookeeper/content/cao_zuo_operations.htmlzk用途zk原理Zookeeper集群的特点 是一种对等集群，所有节点的数据都一样 集群节点之间靠心跳感知彼此的存在 所有写操作都在主节点，其他节点只能读，虽然可以接收写请求，但是内部会把写操作转给主节点 通过选举机制选出主节点，从而保障了主节点的高可用 至少少3个节点，必须是奇数个节点(与选举算法相关) 当一半以上的节点数据写入ۨ成功，则返回写入ۨ成功，是最终一致性的策略 ZAB协议ZooKeeper Atomic Broadcast即ZooKeeper原子消息广播协议，简称ZAB 选举过程需要依赖ZAB协议 数据写入过程也需要ZAB协议 ZAB的核心是定义了那些会改变zk服务器数据状态的请求的处理方式 所有事物请求必须由一个全局唯一的服务器来协调处理，该服务器被称Leader服务器，而剩余的其它服务器则称为Follower服务器。Leader服务器负责将一个客户端事物请求转换成那个一个事物Proposa，并将该Proposal分发给集群中所有的Follower服务器。之后Leader服务器需要等待所有Follower服务器的反馈，一旦超过半数的Follower服务器进行了正确的反馈后，那么Leader就会再次向所有的Follower服务器分发Commit消息，要求其将前一个Proposal进行提交。 服务器角色Leader 事物请求的唯一调度和处理者，保证集群事物处理的顺序性 集群内部各服务器的调度者Follower 处理客户端非事物请求，转发事物请求给Leader服务器 参与事物请求Proposal的投票 参与Leader选举投票Observer 处理客户端非事物请求，转发事物请求给Leader服务器 不参与任何形式的投票，包括选举和事物投票超过半数确认 此角色在通常是为了提高读性能 服务器状态LOOKING 寻找Leader状态 当服务器处于此状态时，表示当前没有Leader，需要进入选举流程FOLLOWING 跟随者状态，表明当前服务器角色是FollowerOBSERVING 观察者状态，表明当前服务器角色ОObserverLEADING 领导者状态，表明当前服务器角色ОLeaderZAB协议三阶段 发现Discovery，即选举Leader过程 同步Synchronization，选举出新的Leader后，Follwer或者Observer从Leader同步最新的数据 广播，同步完成后，就可以接收客户端新的事物请求，并进行消息广播，实现数据在集群节点的副本存储通信基于TCP协议 О了避免୍复创建两个节点之间的tcp连接，zk按照myid数值方向来建立连接，即小数的节点发起大的节点连接，比如idО1的向idО2的发起tcp连接 多端口 配置中第一个端口是通信和数据同࠵端口，默认是2888 第и个端口是投票端口，默认是3888 只支持FastLeaderElection的tcp协议版本的选举算法 会话管理客户端Curator介绍","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"http://duyao.github.io/tags/zookeeper/"}]},{"title":"多线程面试题目","slug":"多线程面试题目","date":"2017-05-24T14:25:04.000Z","updated":"2017-05-24T15:17:56.000Z","comments":true,"path":"2017/05/24/多线程面试题目/","link":"","permalink":"http://duyao.github.io/2017/05/24/多线程面试题目/","excerpt":"","text":"wait和notify Q1 如何让两个线程按照指定方式有序交叉运行假设有两个线程，一个是线程 A，另一个是线程 B，两个线程分别依次打印 1-3 三个数字即可 Q2 编写程序实现,子线程循环10次,接着主线程循环20次,接着再子线程循环10次,主线程循环20次,如此反复,循环50次. synchronized Q3 设计四个线程,其中两个线程每次对变量i加1,另外两个线程每次对i减1. 生产者-消费者#现有的程序代码模拟产生了16个日志对象，并且需要运行16秒才能打印完这些日志，请在程序中增加4个线程去调用parseLog()方法来分头打印这16个日志对象，程序只需要运行4秒即可打印完这些日志对象。 编写死锁joinCountDownLatchCyclicBarrierhttp://www.importnew.com/12773.htmlhttp://ifeve.com/15-java-faq/http://www.cnblogs.com/fingerboy/p/5352880.htmlhttp://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"java","slug":"java","permalink":"http://duyao.github.io/tags/java/"}]},{"title":"背包问题","slug":"背包问题","date":"2017-05-15T02:50:12.000Z","updated":"2017-05-17T08:41:38.000Z","comments":true,"path":"2017/05/15/背包问题/","link":"","permalink":"http://duyao.github.io/2017/05/15/背包问题/","excerpt":"","text":"01背包问题题目有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。 基本思路这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]} “将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为f[i-1][v]；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-c[i]的背包中”，此时能获得的最大价值就是f[i-1][v-c[i]]再加上通过放入第i件物品获得的价值w[i]。123456//O(NV)f[0][0 ~ V] = 0;for(int i = 1; i &lt;= n; ++i) for(int j = 0; j &lt;= V; ++j) if(j &lt; w[i]) f[i][j] = f[i - 1][j]; else f[i][j] = max(f[i - 1][j], f[i - 1][j - w[i]] + v[i]); 优化空间复杂度以上方法的时间和空间复杂度均为O(VN)，其中时间复杂度应该已经不能再优化了，但空间复杂度却可以优化到O。 先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。那么，如果只用一个数组f[0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？f[i][v]是由f[i-1][v]和f[i-1][v-c[i]]两个子问题递推而来，能否保证在推f[i][v]时（也即在第i次主循环中推f[v]时）能够得到f[i-1][v]和f[i-1][v-c[i]]的值呢？事实上，这要求在每次主循环中我们以v=V..0的顺序推f[v]，这样才能保证推f[v]时f[v-c[i]]保存的是状态f[i-1][v-c[i]]的值。伪代码如下：123for i=1..N for v=V..0 f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;; 其中的f[v]=max{f[v],f[v-c[i]]}一句恰就相当于我们的转移方程f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]}，因为现在的f[v-c[i]]就相当于原来的f[i-1][v-c[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-c[i]]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。12345//O(NV) 滚动数组f[0 ~ V] = 0;for(int i = 1; i &lt;= n; ++i) for(int j = V; j &gt;= w[i]; --j) f[j] = max(f[j], f[j - w[i]] + v[i]); 一个常数优化前面的伪代码中有 for v=V..1，可以将这个循环的下限进行改进。 由于只需要最后f[v]的值，倒推前一个物品，其实只要知道f[v-w[n]]即可。以此类推，对以第j个背包，其实只需要知道到f[v-sum{w[j..n]}]即可，即代码中的12for i=1..N for v=V..0 可以改成123for i=1..n bound=max&#123;V-sum&#123;w[i..n]&#125;,c[i]&#125; for v=V..bound 这对于V比较大时是有用的。 例题及代码http://www.lintcode.com/zh-cn/problem/backpack-ii/二维数组法12345678910111213141516171819public static int ZeroOnePack(int m, int[] A, int V[]) &#123; //m背包体积,A体积，V价值 // write your code here int[][] dp = new int[A.length + 1][m + 1]; for (int i = 1; i &lt;= A.length; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (j &gt;= A[i - 1]) &#123; dp[i][j] = Math.max(V[i - 1] + dp[i - 1][j - A[i - 1]], dp[i - 1][j]); &#125; else &#123; dp[i][j] = dp[i - 1][j]; &#125; &#125; &#125; // System.out.println(Arrays.deepToString(dp)); return dp[A.length][m];&#125; 一维数组法123456789101112131415161718192021public static int ZeroOnePack(int m, int[] A, int V[]) &#123; //m背包体积,A体积，V价值 // write your code here int[] dp = new int[m + 1]; for (int i = 1; i &lt;= A.length; i++) &#123; //逆序 for (int j = m; j &gt;= 0; j--) &#123; if (j &gt;= A[i - 1]) &#123; dp[j] = Math.max(V[i - 1] + dp[j - A[i - 1]], dp[j]); &#125; else &#123; //这里后面的dp[j]代表的是dp[i-1][j]，即没有上一行的数值 dp[j] = dp[j]; &#125; &#125; &#125; // System.out.println(Arrays.deepToString(dp)); return dp[m];&#125; 完全背包问题题目有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本思路这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样： f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;=v} 这跟01背包问题一样有O(VN)个状态需要求解，但求解每个状态的时间已经不是常数了，求解状态f[i][v]的时间是O(v/c[i])，总的复杂度可以认为是O(V*Σ(V/c[i]))，是比较大的。 转化为01背包问题求解既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选V/c[i]件，于是可以把第i种物品转化为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。 更高效的转化方法是：把第i种物品拆成费用为c[i]*2^k、价值为w[i]*2^k的若干件物品，其中k满足c[i]*2^k&lt;=V。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。这样把每种物品拆成O(log V/c[i])件物品，是一个很大的改进。123456//O(NVK)f[0][0 ~ V] = 0;for(int i = 1; i &lt;= n; ++i) for(int j = 0; j &lt;= V; ++j) for(int k = 0; k * w[i] &lt;= j; ++k) f[i][j] = max(f[i][j], f[i - 1][j - k * w[i]] + k * v[i]); O(VN)的算法这个算法使用一维数组，先看伪代码：123for i=1..N for v=0..V f[v]=max&#123;f[v],f[v-cost]+weight&#125; 你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态f[i][v]是由状态f[i-1][v-c[i]]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v=0..V的顺序循环。这就是这个简单的程序为何成立的道理。 值得一提的是，上面的伪代码中两层for循环的次序可以颠倒。这个结论有可能会带来算法时间常数上的优化。 这个算法也可以以另外的思路得出。例如，将基本思路中求解f[i][v-c[i]]的状态转移方程显式地写出来，代入原方程中，会发现该方程可以等价地变形成这种形式：f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}将这个方程用一维数组实现，便得到了上面的伪代码。 最后抽象出处理一件完全背包类物品的过程伪代码：123456789101112//O(NV)f[0][0 ~ V] = 0;for(int i = 1; i &lt;= n; ++i) for(int j = 0; j &lt;= V; ++j) if(j &lt; w[i]) f[i][j] = f[i - 1][j]; else f[i][j] = max(f[i - 1][j], f[i][j - w[i]] + v[i]);//O(NV) 滚动数组f[0 ~ V] = 0;for(int i = 1; i &lt;= n; ++i) for(int j = w[i]; j &lt;= V; ++j) f[j] = max(f[j], f[j - w[i]] + v[i]); 多重背包问题题目有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 基本算法这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有n[i]+1种策略：取0件，取1件……取n[i]件。令f[i][v]表示前i种物品恰放入一个容量为v的背包的最大权值，则有状态转移方程： f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k&lt;=n[i]} 复杂度是O(V*Σn[i])。 转化为01背包问题另一种好想好写的基本方法是转化为01背包求解：把第i种物品换成n[i]件01背包中的物品，则得到了物品数为Σn[i]的01背包问题，直接求解，复杂度仍然是O(V*Σn[i])。 但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n[i]件——均能等价于取若干件代换以后的物品。另外，取超过n[i]件的策略必不能出现。 12345678910111213//O(NVK)f[0][0 ~ V] = 0;for(int i = 1; i &lt;= n; ++i) for(int j = 0; j &lt;= V; ++j) for(int k = 0; k &lt;= c[i] &amp;&amp; k * w[i] &lt;= j; ++k) f[i][j] = max(f[i][j], f[i - 1][j - k * w[i]] + k * v[i]);//O(NVK)f[0 ~ V] = 0;for(int i = 1; i &lt;= n; ++i) for(int j = V; j &gt;= 0; --j) for(int k = 1; k &lt;= c[i] &amp;&amp; k * w[i] &lt;= j; ++k) f[j] = max(f[j], f[j - k * w[i]] + k * v[i]); 多重背包的优化二进制优化 ci=1+2+4+⋯+2^k+a, 0≤a","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"Java注解","slug":"Java注解","date":"2017-05-12T10:59:43.000Z","updated":"2017-05-17T08:40:02.000Z","comments":true,"path":"2017/05/12/Java注解/","link":"","permalink":"http://duyao.github.io/2017/05/12/Java注解/","excerpt":"","text":"分类源码注解只存在于源码中，编译时就没有了，即class文件无注解 编译时注解注解在源码和class文件都在,比如Override 运行时注解运行阶段起作用，甚至影响运行时的逻辑，比如Autowired 自定义注解语法要求必须使用@interface关键字成员函数无参数无异常，同时可以指定默认值，形式类似于接口声明方法成员类型是受限制的，只能是原始数据类型或者String、Class、Annotation、Enumerattion如果只有一个成员，那么成员必须是String value();1234567891011121314151617181920//作用域@Target(&#123;ElementType.METHOD,ElementType.FIELD&#125;)//声明周期@Retention(RetentionPolicy.RUNTIME)//可以继承，但是只用类，不用于接口@Inherited//生成javadoc中存在该注解@Documentedpublic @interface Description &#123; String desc = null; String author(); int age() default 18;&#125;//使用@Description(desc=\"desc\",author=\"amy\")public void fun &#123; String desc = null; String author(); int age() default 18;&#125;","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"java","slug":"java","permalink":"http://duyao.github.io/tags/java/"}]},{"title":"设计模式-策略模式和模板方法模式","slug":"设计模式-策略模式和模板方法模式","date":"2017-05-08T09:10:19.000Z","updated":"2017-05-08T11:51:24.000Z","comments":true,"path":"2017/05/08/设计模式-策略模式和模板方法模式/","link":"","permalink":"http://duyao.github.io/2017/05/08/设计模式-策略模式和模板方法模式/","excerpt":"","text":"策略模式策略模式就是要应对规则变化和新规则加入对程序带来的影响。比如实现一个fly方法有很多种方式，可以做火箭飞、可以带翅膀飞等，那么当添加新的方式的时候可有选择以下方案：1、继承：即将设计一个抽象类，里面有这个fly的抽象方法 父类提供该实现方法，简单易用，不具有灵活性，支持性差，因为子类需要重写该父类方法，有可能忘记重写 父类中实现一个抽象方法，每个类都要实现，不能复用代码 2、组合：将fly设计成为接口，使得父类持有该接口， 并由接口代理飞行 多用组合少用继承 has-a的概念 足够灵活，复用代码 可以得到结论：优先使用组合方式，将不变部分抽象为接口，面向接口而不是面向继承，从而达到多用组合少用继承的目的 实现1、分离变化得到接口2、策略的实现类：实现一些不同的策略3、客户端持有该策略的对象4、在客户端正确的组合和这些策略 策略模式 点评优点： 使用组合，架构灵活 富有弹性，较好的应对变化 代码复用性好（相对继承） 消除大量的条件语句 缺点： 客户端需要了解每个策略细节，因为每个客户端要选择自己适合的策略 增加策略就要增加对象，这样就增加了对象的数目 应用场景什么情况适合策略模式： 许多相关的类仅仅是行为差异 运行时选取不同的算法变体 通过条件语句在多个分支中选取一个 在java中以下方法使用了策略模式： sort方法 Java.util.Collections#sort(List list, Comparator &lt; ? super T &gt; c) java.util.Arrays#sort(T[], Comparator &lt; ? super T &gt; c) sort方法 Context：是实际调用排序的代码，即Collections的类。可以看到，默认使用了TimSort进行排序，排序的算法与对象的compare具体实现无关。Strategy：即具体的对象比较接口，Comparator。ConcreteStrategy：具体的比较算法，通过Comparator实现。例如实现大小写敏感、大小写不敏感或任意规则的比对。 线程池的排队和拒绝策略 ThreadPoolExecutor中的ThreadFactory和RejectedExecutionHandler 线程池的排队和拒绝策略 Context：ThreadPoolExecutor实际执行的方法execute()。按照用户设定的排队策略和拒绝任务的处理策略执行。Strategy：这里排队策略和拒绝任务的处理策略提供了各自的接口，分别是BlockingQueue和RejectedExecutionHandler。ConcreteStrategy：具体的排队策略和拒绝任务的处理策略，JDK中都提供了默认的实现方法。可以实现接口自定义策略进行扩展。 http://www.importnew.com/12690.htmlhttp://www.importnew.com/12853.htmlhttp://www.cnblogs.com/zuoxiaolong/p/pattern8.html 模板方法所谓模板方法模式就是在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。模板方法模式就是基于继承的代码复用技术的。在模板方法模式中，我们可以将相同部分的代码放在父类中，而将不同的代码放入不同的子类中。 实现 模板方法模式 抽象基类：定义了一个算法的步骤，这个方法一定是final的，因为所有的子类都是这么实现的，不允许子类改变，还有：定义了基本方法(每个子类都是这么实现的)和抽象方法(每个子类实现方式不同，abstract修饰无方法体)以及钩子函数(这个方法有个默认实现，同时也可以由子类实现，用于判断是否执行某些方法，protect修饰有方法体)实现子类：重写抽象基类的protect方法，即抽象方法和钩子函数http://www.importnew.com/23467.html 点评缺点：继承单继承 应用场景类加载器classloader在ClassLoader中定义的算法顺序是：1，首先看是否有已经加载好的类。2，如果父类加载器不为空，则首先从父类类加载器加载。3，如果父类加载器为空，则尝试从启动加载器加载。4，如果两者都失败，才尝试从findClass方法加载。findClass这个方法，并不是必须实现的，所以JDK选择留给程序员们自己选择是否要覆盖 http://www.cnblogs.com/zuoxiaolong/p/pattern10.html","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://duyao.github.io/tags/设计模式/"}]},{"title":"设计模式-观察者模式和责任链模式","slug":"设计模式-观察者模式和责任链模式","date":"2017-05-05T12:45:43.000Z","updated":"2017-05-08T13:56:44.000Z","comments":true,"path":"2017/05/05/设计模式-观察者模式和责任链模式/","link":"","permalink":"http://duyao.github.io/2017/05/05/设计模式-观察者模式和责任链模式/","excerpt":"","text":"观察模式观察者模式（有时又被称为发布-订阅模式、模型-视图模式、源-收听者模式或从属者模式）是软件设计模式的一种。在此种模式中，一个目标物件管理所有相依于它的观察者物件，并且在它本身的状态改变时主动发出通知。这通常透过呼叫各观察者所提供的方法来实现。此种模式通常被用来实作事件处理系统。简单点概括成通俗的话来说，就是一个类管理着所有依赖于它的观察者类，并且它状态变化时会主动给这些依赖它的类发出通知。 观察者模式 我们的被观察者类Observable只关联了一个Observer的列表，然后在自己状态变化时，使用notifyObservers方法通知这些Observer，具体这些Observer都是什么，被观察者是不关心也不需要知道的。 一对多的方法，当一个对象的状态发生改变，那么依赖这个状态的相应对象都会发生改变。目标与观察者的关系，可以多目标一个观察者，也可以多个观察者一个目标单向依赖：只有目标什么更新观察者命名：目标subject，观察者observer，更新方法update触发通知的时机：先设置值再更新观察者实现的顺序：通知顺序：顺序不确定 推模型和拉模型 推模型： 目标对象主动向观察者推送目标的详细信息，推送的信息通常是目标对象的全部或者部分数据，广播方式，在update方法中传递的是定制的内容 拉模型： 目标对象在通知观察着的时候，只传递少量信息如果观察者需要更具体的信息，有观察者主动到目标对象中去获取，相当于观察者从目标对象中拉数据一般这种模型的实现中，会把目标对象自身通过update方法传递给观察者 比较： 推模型假定目标是知道自己想要什么的，因此update中传递的是定制的值，同时这样做会使得代码难以复用拉模型是目标对象不知道自己想要什么值，因此要把对象本身给观察者，由观察者来取值 java中对观察者模式的实现由于JDK中为了方便开发人员，已经写好了现成的观察者接口和被观察者类观察者接口。12345//观察者接口，每一个观察者都必须实现这个接口public interface Observer &#123; //这个方法是观察者在观察对象产生变化时所做的响应动作，从中传入了观察的对象和一个预留参数 void update(Observable o, Object arg);&#125; 被观察者类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.Vector;//被观察者类public class Observable &#123; //这是一个改变标识，来标记该被观察者有没有改变 private boolean changed = false; //持有一个观察者列表 private Vector obs; public Observable() &#123; obs = new Vector(); &#125; //添加观察者，添加时会去重 public synchronized void addObserver(Observer o) &#123; if (o == null) throw new NullPointerException(); if (!obs.contains(o)) &#123; obs.addElement(o); &#125; &#125; //删除观察者 public synchronized void deleteObserver(Observer o) &#123; obs.removeElement(o); &#125; //notifyObservers(Object arg)的重载方法 public void notifyObservers() &#123; notifyObservers(null); &#125; //通知所有观察者，被观察者改变了，你可以执行你的update方法了。 public void notifyObservers(Object arg) &#123; //一个临时的数组，用于并发访问被观察者时，留住观察者列表的当前状态，这种处理方式其实也算是一种设计模式，即备忘录模式。 Object[] arrLocal; //注意这个同步块，它表示在获取观察者列表时，该对象是被锁定的 //也就是说，在我获取到观察者列表之前，不允许其他线程改变观察者列表 synchronized (this) &#123; //如果没变化直接返回 if (!changed) return; //这里将当前的观察者列表放入临时数组 arrLocal = obs.toArray(); //将改变标识重新置回未改变 clearChanged(); &#125; //注意这个for循环没有在同步块，此时已经释放了被观察者的锁，其他线程可以改变观察者列表 //但是这并不影响我们当前进行的操作，因为我们已经将观察者列表复制到临时数组 //在通知时我们只通知数组中的观察者，当前删除和添加观察者，都不会影响我们通知的对象 for (int i = arrLocal.length-1; i&gt;=0; i--) ((Observer)arrLocal[i]).update(this, arg); &#125; //删除所有观察者 public synchronized void deleteObservers() &#123; obs.removeAllElements(); &#125; //标识被观察者被改变过了 protected synchronized void setChanged() &#123; changed = true; &#125; //标识被观察者没改变 protected synchronized void clearChanged() &#123; changed = false; &#125; //返回被观察者是否改变 public synchronized boolean hasChanged() &#123; return changed; &#125; //返回观察者数量 public synchronized int countObservers() &#123; return obs.size(); &#125;&#125; 点评观察者和目标之间是松耦合；观察者实现了动态联动；观察者支持广播通信可能会引起无谓的操作何时使用观察者模式http://www.runoob.com/design-pattern/observer-pattern.htmlhttp://www.cnblogs.com/zuoxiaolong/p/pattern7.htmlhttp://www.cnblogs.com/fingerboy/p/6393644.htmlhttp://abc08010051.iteye.com/blog/1972960 回调函数http://www.cnblogs.com/heshuchao/p/5376298.htmlhttps://www.zhihu.com/question/19801131http://blog.csdn.net/xiaanming/article/details/8703708 事件监听https://my.oschina.net/u/923324/blog/792857 责任链模式责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。 实现 责任链模式 责任链模式涉及到的角色如下所示：抽象处理者(Handler)角色：定义一个处理请求的抽象类。如果需要，可以定义一个方法以设定和返回对下家的引用。具体处理者(ConcreteHandler)角色：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。 纯的与不纯的责任链模式一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：一是承担责任，而是把责任推给下家。不允许出现某一个具体处理者对象在承担了一部分责任后又把责任向下传的情况。在一个纯的责任链模式里面，一个请求必须被某一个处理者对象所接收；在一个不纯的责任链模式里面，一个请求可以最终不被任何接收端对象所接收。纯的责任链模式的实际例子很难找到，一般看到的例子均是不纯的责任链模式的实现。 点评不用职责链的结构，我们需要和公司中的每一个层级都发生耦合关系。如果反映在代码上即使我们需要在一个类中去写上很多丑陋的if….else语句。如果用了职责链，相当于我们面对的是一个黑箱，我们只需要认识其中的一个部门，然后让黑箱内部去负责传递就好了 缺点：构造大量的对象，但是最终只有一个对象响应请求，因此内存中的性能会有所损耗，可以使用观察者模式代替还有就是责任链必须遍历整条链才能找到响应，比较耗时 应用：异常处理，filter(多个filter可以响应，不止是一个)http://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html http://blog.csdn.net/zuoxiaolong8810/article/category/1434962/2","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://duyao.github.io/tags/设计模式/"}]},{"title":"设计模式原则和UML图","slug":"设计模式原则和UML图","date":"2017-04-30T08:46:35.000Z","updated":"2017-05-19T11:32:32.000Z","comments":true,"path":"2017/04/30/设计模式原则和UML图/","link":"","permalink":"http://duyao.github.io/2017/04/30/设计模式原则和UML图/","excerpt":"","text":"SOLID设计原则SRP：单一指责，每个类，每个方法专注一件事，小方法构成大功能。但是拆分到何种程度？取决于业务，当某个业务变更时发现会同时修改几个方法，那么可以考虑合并。OCP： 对修改关闭，对扩展开放，尽量不修改原有功能，原有功能已经上线，修改有风险，所以设计时考虑可扩展性，能通过扩展实现新的需求。实现OCP的思路有：多态，不要硬编码LSP：里氏替换，对于有继承关系的类，使用子类替换父类。ISP：接口隔离，一个大接口不如多个小接口，粒度小，灵活性好，使用小功能组装成大功能，使用一个小功能没有必要引入过多的其他功能。那么接口小到何种程度？也值得思考。DIP：依赖抽象，接口，而不是依赖具体实现。Spring中体现的很明显。 uml图类的关系有泛化(Generalization)、实现（Realization）、依赖(Dependency)和关联(Association)。其中关联又分为一般关联关系和聚合关系(Aggregation)，组合关系(Composition)。12345678类的关系====泛华(继承)====实现(接口)====依赖(方法参数、返回值)====关联========关联关系(成员变量)========聚合关系(弱依赖)========组合关系(强依赖) UML类图 车的类图结构为&lt;&gt;，表示车是一个抽象类； 它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示； 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示； 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示； 学生与班级之间是聚合关系，使用带空心箭头的实线表示； 学生与身份证之间为关联关系，使用一根实线表示； 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示； 泛化(generalization)表示is-a的关系，是对象之间耦合度最大的一种关系，子类继承父类的所有细节。直接使用语言中的继承表达。在类图中使用带三角箭头的实线表示，箭头从子类指向父类。 实现（Realization）在类图中就是接口和实现的关系。这个没什么好讲的。在类图中使用带三角箭头的虚线表示，箭头从实现类指向接口。 依赖(Dependency)对象之间最弱的一种关联方式，是临时性的关联。代码中一般指由局部变量、函数参数、返回值建立的对于其他对象的调用关系。一个类调用被依赖类中的某些方法而得以完成这个类的一些职责。在类图使用带箭头的虚线表示，箭头从使用类指向被依赖的类。在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系；依赖关系除了临时知道对方外，还是“使用”对方的方法和属性； 关联关联关系(association)关联关系是用一条直线表示的；它描述不同类的对象之间的结构关系；它是一种静态关系，通常与运行状态无关，一般由常识等因素决定的；它一般用来定义对象之间静态的、天然的结构； 所以，关联关系是一种“强关联”的关系；比如，乘车人和车票之间就是一种关联关系；学生和学校就是一种关联关系；关联关系默认不强调方向，表示对象间相互知道；在最终代码中，关联对象通常是以成员变量的形式实现的 聚合关系(Aggregation)表示has-a的关系，是一种不稳定的包含关系。较强于一般关联,有整体与局部的关系,并且没有了整体,局部也可单独存在。如公司和员工的关系，公司包含员工，但如果公司倒闭，员工依然可以换公司。在类图使用空心的菱形表示，菱形从局部指向整体。 组合关系(Composition)表示contains-a的关系，是一种强烈的包含关系。组合类负责被组合类的生命周期。是一种更强的聚合关系。部分不能脱离整体存在。如公司和部门的关系，没有了公司，部门也不能存在了；调查问卷中问题和选项的关系；订单和订单选项的关系。在类图使用实心的菱形表示，菱形从局部指向整体。http://www.uml.org.cn/oobject/201104212.asphttp://design-patterns.readthedocs.io/zh_CN/latest/read_uml.html 设计模式6个原则","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://duyao.github.io/tags/设计模式/"}]},{"title":"数据库-范式","slug":"数据库-范式","date":"2017-04-25T02:23:30.000Z","updated":"2017-05-08T08:29:04.000Z","comments":true,"path":"2017/04/25/数据库-范式/","link":"","permalink":"http://duyao.github.io/2017/04/25/数据库-范式/","excerpt":"","text":"范式是“符合某一种级别的关系模式的集合，表示一个关系内部各属性之间的联系的合理化程度”。实际上你可以把它粗略地理解为一张数据表的表结构所符合的某种设计标准的级别。 第一范式1NF定义为：符合1NF的关系中的每个属性都不可再分。1NF是所有关系型数据库的最基本要求 编号 商品 进货 销售 备注 数量+单价 数量+单价 但是仅仅符合1NF的设计，仍然会存在数据冗余过大，插入异常，删除异常，修改异常的问题，例如对于图1中的设计： 图1 第二范式（2NF）对1NF进行了一些改进。其改进是，2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。接下来对这句话中涉及到的四个概念——“函数依赖”、“码”、“非主属性”、与“部分函数依赖”进行一下解释。 函数依赖我们可以这么理解（但并不是特别严格的定义）：若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y。也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。例如，对于图1中的数据，找不到任何一条记录，它们的学号相同而对应的姓名不同。所以我们可以说姓名函数依赖于学号，写作 学号 → 姓名。但是反过来，因为可能出现同名的学生，所以有可能不同的两条学生记录，它们在姓名上的值相同，但对应的学号不同，所以我们不能说学号函数依赖于姓名。表中其他的函数依赖关系还有如： 系名 → 系主任 学号 → 系主任 （学号，课名） → 分数 但以下函数依赖关系则不成立： 学号 → 课名 学号 → 分数 课名 → 系主任 （学号，课名） → 姓名 从“函数依赖”这个概念展开，还会有三个概念： 完全函数依赖 在一张表中，若 X → Y，且对于 X 的任何一个真子集（假如属性组 X 包含超过一个属性的话），X ‘ → Y 不成立，那么我们称 Y 对于 X 完全函数依赖，记作 X F→ Y。（那个F应该写在箭头的正上方）例如： 学号 F→ 姓名 （学号，课名） F→ 分数 （注：因为同一个的学号对应的分数不确定，同一个课名对应的分数也不确定） 部分函数依赖 假如 Y 函数依赖于 X，但同时 Y 并不完全函数依赖于 X，那么我们就称 Y 部分函数依赖于 X，记作 X P→ Y（P在箭头上方）例如：（学号，课名） P→ 姓名 传递函数依赖 假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （严格来说还有一个X 不包含于Y，且 Y 不函数依赖于Z的前提条件），那么我们就称 Z 传递函数依赖于 X ，记作 X T→ Z(T在箭头上方) 码设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为候选码，简称为码。在实际中我们通常可以理解为：假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为主码）例如：对于图1，（学号、课名）这个属性组就是码。该表中有且仅有这一个码。（假设所有课没有重名的情况） 非主属性包含在任何一个码中的属性成为主属性。例如：对于图1，主属性就有两个，学号 与 课名。 终于可以回过来看2NF了。首先，我们需要判断，图1是否符合2NF的要求？根据2NF的定义，判断的依据实际上就是看数据表中是否存在非主属性对于码的部分函数依赖。若存在，则数据表最高只符合1NF的要求，若不存在，则符合2NF的要求。判断的方法是：第一步：找出数据表中所有的码。第二步：根据第一步所得到的码，找出所有的主属性。第三步：数据表中，除去所有的主属性，剩下的就都是非主属性了。第四步：查看是否存在非主属性对码的部分函数依赖。对于图1，根据前面所说的四步，我们可以图中所有的函数依赖关系： 函数依赖 这一步完成以后，可以得到，图1的码只有一个，就是（学号、课名）。第二步：主属性有两个：学号 与 课名第三步：非主属性有四个：姓名、系名、系主任、分数第四步：对于（学号，课名） → 姓名，有 学号 → 姓名，存在非主属性 姓名 对码（学号，课名）的部分函数依赖。对于（学号，课名） → 系名，有 学号 → 系名，存在非主属性 系名 对码（学号，课名）的部分函数依赖。对于（学号，课名） → 系主任，有学号 → 系主任，存在非主属性 系主任 对码（学号，课名）的部分函数依赖。所以图1存在非主属性对于码的部分函数依赖，最高只符合1NF的要求，不符合2NF的要求。 为了让图1符合2NF的要求，我们必须消除这些部分函数依赖，只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表，在拆分的过程中，要达到更高一级范式的要求，这个过程叫做”模式分解“。模式分解的方法不是唯一的，以下是其中一种方法：选课（学号，课名，分数）学生（学号，姓名，系名，系主任）新的函数依赖如下图所示： 新的函数依赖 对于选课表，其码是（学号，课名），主属性是学号和课名，非主属性是分数，学号确定，并不能唯一确定分数，课名确定，也不能唯一确定分数，所以不存在非主属性分数对于码 （学号，课名）的部分函数依赖，所以此表符合2NF的要求。对于学生表，其码是学号，主属性是学号，非主属性是姓名、系名和系主任，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求 第三范式（3NF）3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。 对于上面新的函数依赖，可以分析：对于选课表，主码为（学号，课名），主属性为学号和课名，非主属性只有一个，为分数，不可能存在传递函数依赖，所以选课表的设计，符合3NF的要求。对于学生表，主码为学号，主属性为学号，非主属性为姓名、系名和系主任。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性系主任对于码学号的传递函数依赖，所以学生表的设计，不符合3NF的要求。。 为了让数据表设计达到3NF，我们必须进一步进行模式分解为以下形式：选课（学号，课名，分数）学生（学号，姓名，系名）系（系名，系主任）对于选课表，符合3NF的要求，之前已经分析过了。对于学生表，码为学号，主属性为学号，非主属性为系名，不可能存在非主属性对于码的传递函数依赖，所以符合3NF的要求。对于系表，码为系名，主属性为系名，非主属性为系主任，不可能存在非主属性对于码的传递函数依赖（至少要有三个属性才可能存在传递函数依赖关系），所以符合3NF的要求。 结论由此可见，符合3NF要求的数据库设计，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF，但是作为数据库设计人员，至少应该知道，3NF的要求是怎样的。 BCNF范式要了解 BCNF 范式，那么先看这样一个问题：若：某公司有若干个仓库；每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？答：已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量码：（管理员，物品名），（仓库名，物品名）主属性：仓库名、管理员、物品名非主属性：数量∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。 因此BCNF就是解决存在着主属性对于码的部分函数依赖与传递函数依赖。（在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。解决办法就是要在 3NF 的基础上消除主属性对于码的部分与传递函数依赖。 仓库（仓库名，管理员）库存（仓库名，物品名，数量） https://www.zhihu.com/question/24696366/answer/29189700","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://duyao.github.io/tags/数据库/"}]},{"title":"数据库","slug":"数据库","date":"2017-04-21T01:55:53.000Z","updated":"2017-05-16T08:50:48.000Z","comments":true,"path":"2017/04/21/数据库/","link":"","permalink":"http://duyao.github.io/2017/04/21/数据库/","excerpt":"","text":"mysql架构 MySQL最重要的、最与众不同的特性是它的存储引擎架构，这种构架的设计将查询处理及其它系统任务和数据的存储/提取相分离。 锁为什么需要锁？因为数据库要解决并发控制问题。在同一时刻，可能会有多个客户端对表中同一行记录进行操作，比如有的在读取该行数据，其他的尝试去删除它。为了保证数据的一致性，数据库就要对这种并发操作进行控制，因此就有了锁的概念。 乐观锁和悲观锁以及时间戳并发控制一般采用三种方法，分别是乐观锁和悲观锁以及时间戳 乐观锁认为一个用户读数据的时候，别人不会去写自己所读的数据； 悲观锁就刚好相反，觉得自己读数据库的时候，别人可能刚好在写自己刚读的数据，其实就是持一种比较保守的态度；悲观锁就是在读取数据的时候，为了不让别人修改自己读取的数据，就会先对自己读取的数据加锁，只有自己把数据读完了，才允许别人修改那部分数据，或者反过来说，就是自己修改某条数据的时候，不允许别人读取该数据，只有等自己的整个事务提交了，才释放自己加上的锁，才允许其他用户访问那部分数据。 并发量较大时候选择悲观锁，并发量较小的时候选择乐观锁 时间戳就是不加锁，通过时间戳来控制并发出现的问题。时间戳就是在数据库表中单独加一列时间戳，比如“TimeStamp”，每次读出来的时候，把该字段也读出来，当写回去的时候，把该字段加1，提交之前 ，跟数据库的该字段比较一次，如果比数据库的值大的话，就允许保存，否则不允许保存，这种处理方法虽然不使用数据库系统提供的锁机制，但是这种方法可以大大提高数据库处理的并发量，因为这种方法可以避免了长事务中的数据库加锁开销（操作员A 和操作员B操作过程中，都没有对数据库数据加锁），大大提升了大并发量下的系 统整体性能表现。 悲观锁以上悲观锁所说的加“锁”，其实分为3种锁 共享（S)锁：多个事务可封锁一个共享页；任何事务都不能修改该页； 通常是该页被读取完毕，S锁立即被释放。 排它（X)锁：仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到事务结束才能被释放。 更新（U)锁：更新锁在修改操作的初始化阶段用来锁定可能要被修改的资源，这样可以避免使用共享锁造成的死锁现象。 因为使用共享锁时，修改数据的操作分为两步，首先获得一个共享锁，读取数据，然后将共享锁升级为排它锁，然后再执行修改操作。这样如果同时有两个或多个事务同时对一个事务申请了共享锁，在修改数据的时候，这些事务都要将共享锁升级为排它锁。这时，这些事务都不会释放共享锁而是一直等待对方释放，这样就造成了死锁。在update语句中很容易出现死锁现象，比如t1和t2都要更新id=100的记录，那么可能存在t1先获取读锁，然后t2再获取读锁，然后t1要得写锁，同时t2也要获得写锁，这时候就会产生死锁。因为t1获得写锁的前提是t2释放读锁，而t2获得写锁的前提是t1释放读锁。所以为了防止这种情的发生，一个数据在修改前直接申请更新锁，在数据修改的时候再升级为排它锁，就可以避免死锁。 更新锁有如下特征： 加锁的条件：当一个事务执行update语句时，数据库系统会先为事务分配一把更新锁。 解锁的条件：当读取数据完毕，执行更新操作时，会把更新锁升级为独占锁。 与其他锁的兼容性：更新锁与共享锁是兼容的，也就是说，一个资源可以同时放置更新锁和共享锁，但是最多放置一把更新锁。这样，当多个事务更新相同的数据时，只有一个事务能获得更新锁，然后再把更新锁升级为独占锁，其他事务必须等到前一个事务结束后，才能获取得更新锁，这就避免了死锁。 默认来说，当sql脚本修改更新某条记录的时候，会给该条记录加X锁，读的话加的是S锁对于 UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁；事务可以通过显式给记录集加共享锁或排他锁。 锁粒度（Lock granularity）为了尽可能提高数据库的并发度，每次锁定的数据范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁是很耗资源的事情（涉及获取，检查，释放锁等动作），因此数据库系统需要在高并发响应和系统性能两方面进行平衡，这样就产生了“锁粒度（Lock granularity）”的概念。 一种提高共享资源并发发性的方式是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。但是，加锁也需要消耗资源。锁的各种操作，包括获得锁、检查锁和是否已经解除、释放锁等，都会增加系统的开销。所谓锁策略，就是在锁的开销和数据的安全性之间寻求平衡。 表锁与行锁表锁：管理锁的开销最小，同时允许的并发量也最小的锁机制。MyIsam存储引擎使用表锁。当要写入数据时，把整个表都锁上，此时其他读、写动作一律等待。在MySql中，除了MyIsam存储引擎使用这种锁策略外，MySql本身也使用表锁来执行某些特定动作，比如alter table. 另外，写锁比读锁有更高的优先级，因此一个写锁可能会被插入到读锁队列的前面。 行锁：可以支持最大并发的锁策略（同时也带来了最大的锁开销）。InnoDB和Falcon两张存储引擎都采用行锁。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。服务器层完全不了解存储引擎中的锁实现。 MySql是一种开放的架构，你可以实现自己的存储引擎，并实现自己的锁粒度策略，不像Oracle，你没有机会改变锁策略，Oracle采用的是行锁。 多版本并发控制 MVCC在并发读写数据库时，读操作可能会不一致的数据（脏读）。为了避免这种情况，需要实现数据库的并发访问控制，最简单的方式就是加锁访问。由于，加锁会将读写操作串行化，所以不会出现不一致的状态。但是，读操作会被写操作阻塞，大幅降低读性能。在Java concurrent包中，有copyonwrite系列的类，专门用于优化读远大于写的情况。而其优化的手段就是，在进行写操作时，将数据copy一份，不会影响原有数据，然后进行修改，修改完成后原子替换掉旧的数据，而读操作只会读取原有数据。通过这种方式实现写操作不会阻塞读操作，从而优化读效率。而写操作之间是要互斥的，并且每次写操作都会有一次copy，所以只适合读大于写的情况。 MVCC的原理与copyonwrite类似，全称是Multiversion Concurrency Controll，即多版本并发控制。在MVCC协议下，每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。由此可以看出MVCC是一种用来解决读-写冲突的无锁并发控制. MVCC策略：MVCC并不是MySql独有的，Oracle，PostgreSQL等都在使用。MVCC并没有简单地使用行锁，而是使用“行级别锁”（row-level locking）。 MVCC的基本原理是：MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。 MVCC的基本特征：每行数据都存在一个版本，每次数据更新时都更新该版本。修改时Copy出当前版本随意修改，各个事务之间无干扰。保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback） InnoDB存储引擎MVCC的实现策略：在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空）。这里的版本号并不是实际的时间值，而是系统版本号。每开始个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目的。 MVCC MVCC具体的操作如下： SELECT:InnoDB会根据以下两个条件检查每行记录，只有满足两个条件才会返回： 1）InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，只么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。 2）行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。 INSERT:InnoDB为新插入的每一行保存当前系统版本号作为行版本号。 DELETE:InnoDB为删除的每一行保存当前系统版本号作为行删除标识。 UPDATE:InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当系统的版本号为原来的行作为删除标识。 保存这两个额外系统版本号，使大多数操作都可以不用加锁。这样设计使得计数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。 MVCC只在REPEATABLE READ和READ COMMITED两个隔离级别下工作，其它两个隔离级别和MVCC不兼容。 Innodb的实现算不上MVCC，因为并没有实现核心的多版本共存，undo log中的内容只是串行化的结果，记录了多个事务的过程，不属于多版本共存。但理想的MVCC是难以实现的，当事务仅修改一行记录使用理想的MVCC模式是没有问题的，可以通过比较版本号进行回滚；但当事务影响到多行数据时，理想的MVCC据无能为力了。 比如，如果Transaciton1执行理想的MVCC，修改Row1成功，而修改Row2失败，此时需要回滚Row1，但因为Row1没有被锁定，其数据可能又被Transaction2所修改，如果此时回滚Row1的内容，则会破坏Transaction2的修改结果，导致Transaction2违反ACID。 理想MVCC难以实现的根本原因在于企图通过乐观锁代替二段提交。修改两行数据，但为了保证其一致性，与修改两个分布式系统中的数据并无区别，而二段提交是目前这种场景保证一致性的唯一手段。二段提交的本质是锁定，乐观锁的本质是消除锁定，二者矛盾，故理想的MVCC难以真正在实际中被应用，Innodb只是借了MVCC这个名字，提供了读的非阻塞而已。http://blog.csdn.net/chen77716/article/details/6742128http://blog.csdn.net/xifeijian/article/details/45230053 两阶段封锁InnoDB采用两阶段锁协议(2PL：Two-phase Locking Protocol)实现串行化。在事务内任意时刻加锁，最后提交或回滚时一起释放所有锁。 一次性锁协议：事务开始时，一次性申请所有的锁，之后不会再申请任何锁。如果其中某个锁不可用，则整个申请就不成功，事务就不会执行，在事务尾端，一次性释放所有的锁。一次性锁协议不会产生死锁的问题，但事务的并发度不高。 两阶段锁协议(跟分布式事务XA的两阶段提交)具体如下：两阶段锁协议：整个事务分为两个阶段，前一个阶段为加锁，后一个阶段为解锁。在加锁阶段，事务只能加锁，也可以操作数据，但不能解锁。直到事务释放第一个锁，就进入解锁阶段，此过程中事务只能解锁，也可以操作数据，不能再加锁。两阶段锁协议使得事务具有较高的并发度，因为解锁不必发生在事务结尾。它的不足是没有解决死锁的问题，因为它在加锁阶段没有顺序要求。如两个事务分别申请了A, B锁，接着又申请对方的锁，此时进入死锁状态。 加锁的情况在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例： 快照读：简单的select操作，属于快照读，不加锁。(当然，也有例外，下面会分析)select * from table where ?;当前读：特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。select * from table where ? lock in share mode;select * from table where ? for update;insert into table values (…);update table set ? where ?;delete from table where ?;所有以上的语句，都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。 分析加锁SQL1：select * from t1 where id = 10;SQL2：delete from t1 where id = 10; 在RC，RR隔离级别下，SQL1：select操作均不加锁，采用的是快照读，因此在下面的讨论中就忽略了，主要讨论SQL2：delete操作的加锁。 组合一：id主键+RC结论：id是主键时，此SQL只需要在id=10这条记录上加X锁即可。 组合二：id唯一索引+RC若id列是unique列，其上有unique索引。那么SQL需要加两个X锁，一个对应于id unique索引上的id = 10的记录，另一把锁对应于聚簇索引上的[name=’d’,id=10]的记录。 组合三：id非唯一索引+RC结论：若id列上有非唯一索引，那么对应的所有满足SQL查询条件的记录，都会被加锁。同时，这些记录在主键索引上的记录，也会被加锁。 组合四：id无索引+RC结论：若id列上没有索引，SQL会走聚簇索引的全扫描进行过滤，由于过滤是由MySQL Server层面进行的。因此每条记录，无论是否满足条件，都会被加上X锁。但是，为了效率考量，MySQL做了优化，对于不满足条件的记录，会在判断后放锁，最终持有的，是满足条件的记录上的锁，但是不满足条件的记录上的加锁/放锁动作不会省略。同时，优化也违背了2PL的约束。 组合五：id主键+RR组合五，id列是主键列，Repeatable Read隔离级别，针对delete from t1 where id = 10; 这条SQL，加锁与组合一：[id主键，Read Committed]一致。 组合六：id唯一索引+RR与组合五类似，组合六的加锁，与组合二：[id唯一索引，Read Committed]一致。两个X锁，id唯一索引满足条件的记录上一个，对应的聚簇索引上的记录一个。 组合七：id非唯一索引+RR结论：Repeatable Read隔离级别下，id列上有一个非唯一索引，对应SQL：delete from t1 where id = 10; 首先，通过id索引定位到第一条满足查询条件的记录，加记录上的X锁，加GAP上的GAP锁，然后加主键聚簇索引上的记录X锁，然后返回；然后读取下一条，重复进行。直至进行到第一条不满足条件的记录[11,f]，此时，不需要加记录X锁，但是仍旧需要加GAP锁，最后返回结束。 组合八：id无索引+RR结论：在Repeatable Read隔离级别下，如果进行全表扫描的当前读，那么会锁上表中的所有记录，同时会锁上聚簇索引内的所有GAP，杜绝所有的并发 更新/删除/插入 操作。当然，也可以通过触发semi-consistent read，来缓解加锁开销与并发影响，但是semi-consistent read本身也会带来其他问题，不建议使用。 组合九：Serializable针对前面提到的简单的SQL，最后一个情况：Serializable隔离级别。对于SQL2：delete from t1 where id = 10; 来说，Serializable隔离级别与Repeatable Read隔离级别完全一致，因此不做介绍。Serializable隔离级别，影响的是SQL1：select * from t1 where id = 10; 这条SQL，在RC，RR隔离级别下，都是快照读，不加锁。但是在Serializable隔离级别，SQL1会加读锁，也就是说快照读不复存在，MVCC并发控制降级为Lock-Based CC。结论：在MySQL/InnoDB中，所谓的读不加锁，并不适用于所有的情况，而是隔离级别相关的。Serializable隔离级别，读不加锁就不再成立，所有的读操作，都是当前读。 认真读：什么情况加锁 死锁（Dead Lock）死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的假象。多个事务同时锁定同一个资源时，也会产生死锁。数据库系统实现了各种死锁检测和死锁超时的机制，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。 并发控制会造成活锁和死锁，就像操作系统那样，会因为互相等待而导致。活锁指的是T1封锁了数据R，T2同时也请求封锁数据R，T3也请求封锁数据R，当T1释放了锁之后，T3会锁住R，T4也请求封锁R，则T2就会一直等待下去，这种处理方法就是采用“先来先服务”策略；死锁就是我等你，你又等我，双方就会一直等待下去，比如：T1封锁了数据R1，正请求对R2封锁，而T2封住了R2,正请求封锁R1，这样就会导致死锁，死锁这种没有完全解决的方法，只能尽量预防. 预防死锁的方法有：①一次封锁发，指的是一次性把所需要的数据全部封锁住，但是这样会扩大了封锁的范围，降低系统的并发度；②顺序封锁发，指的是事先对数据对象指定一个封锁顺序，要对数据进行封锁，只能按照规定的顺序来封锁，但是这个一般不大可能的。另外，系统如何判断出现死锁，毕竟出现死锁不能一直干等下去，要及时发现死锁同时尽快解决出现的死锁， 诊断和判断死锁有两种方法:1）超时法：超时法就是如果某个事物的等待时间超过指定时限，则判定为出现死锁；2）等待图法：等待图法指的是如果事务等待图中出现了回路，则判断出现了死锁。 对于解决死锁的方法，只能是撤销一个处理死锁代价最小的事务，释放此事务持有的所有锁，同时对撤销的事务所执行的数据修改操作必须加以恢复。 数据库系统实现了各种死锁检测和死锁超时的机制，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。 事务（Transaction）事务ACID原则从业务角度出发，对数据库的一组操作要求保持4个特征： Atomicity（原子性）：一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。 Consistency（一致性）：一致性保证能看到系统内的所有改变。一致性是指事务使得系统从一个一致的状态转换到另一个一致状态。事务的一致性决定了一个系统设计和实现的复杂度。事务可以不同程度的一致性：强一致性：读操作可以立即读到提交的更新操作。弱一致性：提交的更新操作，不一定立即会被读操作读到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。最终一致性：是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样的值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等。其他一致性变体还有：单调一致性：如果一个进程已经读到一个值，那么后续不会读到更早的值。会话一致性：保证客户端和服务器交互的会话过程中，读操作可以读到更新操作后的最新值。 Isolation（隔离性）：通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。注意这里的“通常来说”，后面的事务隔离级级别会说到。可以将隔离性理解为以性能为理由，对一致性进行破坏。 Durability（持久性）：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。（持久性的安全性与刷新日志级别也存在一定关系，不同的级别对应不同的数据安全级别。）数据为了保证持久性使用raid技术来冗余数据，raid主要解决了两个问题：①如何保证数据同时写到两个磁盘上去②由于每次请求都要刷磁盘会导致性能下降，因此要将请求打包同意发送到存储 。down机恢复，要进入recovery模式，不能读写 隔离级别（Isolation Level）SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。 Read Uncommitted（未提交读）在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。 Read Committed（提交读）这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。 Repeatable Read（可重复读）这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。一种更易理解的说法是：在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据。那么，在第一个事务的两次读数据之间。由于第二个事务的修改，那么第一个事务读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复。 不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。 Serializable（可串行化）这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。 事务的隔离级别 这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如： 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。 不可重复读重点在于update和delete，而幻读的重点在于insert。例子：http://www.hollischuang.com/archives/900 在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示： 脏读 不可重复读 幻读 未提交读 Y Y Y 提交读 N Y Y 可重复读 N N Y 可串行化 N N N 索引索引是在存储引擎中实现的，而不是在服务器层中实现的。所以，每种存储引擎的索引都不一定完全相同，并不是所有的存储引擎都支持所有的索引类型 b树索引B－Tree：每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历。B－Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同，很适合查找范围数据。 不同的b树索引实现MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。 MyISAM索引 在InnoDB中完全不同：第一个重大区别是InnoDB的数据文件本身就是索引文件。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。 InnoDB索引 这张图中的主键索引就是聚集索引 注意：辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。 索引的查询 b树索引 其索引包含表中每一行的last_name、first_name和dob列。 索引存储的值按索引列中的顺序排列。可以利用B-Tree索引进行全关键字、关键字范围和关键字前缀查询如果想使用索引，你必须保证按索引的最左边前缀(leftmost prefix of the index) 来进行查询。(1)匹配全值(Match the full value)：对索引中的所有列都指定具体的值。例如，上图中索引可以帮助你查找出生于1960-01-01的Cuba Allen。(2)匹配最左前缀(Match a leftmost prefix)：你可以利用索引查找last name为Allen的人，仅仅使用索引中的第1列。(3)匹配列前缀(Match a column prefix)：例如，你可以利用索引查找last name以J开始的人，这仅仅使用索引中的第1列。(4)匹配值的范围查询(Match a range of values)：可以利用索引查找last name在Allen和Barrymore之间的人，仅仅使用索引中第1列。(5)匹配部分精确而其它部分进行范围匹配(Match one part exactly and match a range on another part)：可以利用索引查找last name为Allen，而first name以字母K开始的人。(6)仅对索引进行查询(Index-only queries)：如果查询的列都位于索引中，则不需要读取元组的值。(覆盖索引) 由于B-树中的节点都是顺序存储的，所以可以利用索引进行查找(找某些值)，也可以对查询结果进行ORDER BY。当然，使用B-tree索引有以下一些限制：(1) 查询必须从索引的最左边的列开始，否则无法使用索引。关于这点已经提了很多遍了。例如你不能利用索引查找在某一天出生的人。(2) 不能跳过某一索引列。例如，你不能利用索引查找last name为Smith且出生于某一天的人。(3) 存储引擎不能使用索引中范围条件右边的列。例如，如果你的查询语句为WHERE last_name=”Smith” AND first_name LIKE ‘J%’ AND dob=’1976-12-23’，则该查询只会使用索引中的前两列，因为LIKE是范围查询。 聚簇索引聚簇索引(Clustered Indexes)聚簇索引保证关键字的值相近的元组存储的物理位置也相同（所以字符串类型不宜建立聚簇索引，特别是随机字符串，会使得系统进行大量的移动操作），且一个表只能有一个聚簇索引。因为由存储引擎实现索引，所以，并不是所有的引擎都支持聚簇索引。目前，只有solidDB和InnoDB支持。聚簇索引的结构大致如下：叶子页包含了行的全部数据，但是节点页只包含了索引列。二级索引叶子节点保存的不是指行的物理位置的指针，而是行的主键值。这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获取对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。这里做了重复的工作：两次B－TREE查找而不是一次。 b树索引 InnoDB对主键建立聚簇索引。如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。 http://blog.csdn.net/xifeijian/article/details/20312557 查询优化 mysql查询过程 MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization） sql语句方面的优化 join做索引 尽量不用null，全部设置为not null，避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描如select id from t where num/2=100应改为:select id from t where num=100*2 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：select id from t where substring(name,1,3)=’abc’或select id from t where datediff(day,createdate,’2005-11-30′)=0–’2005-11-30′应改为:select id from t where name like ‘abc%’和select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′ 索引失效情况： like语句中%前置可能会导致索引失效 如果条件中有or，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因) 对于多列索引，不是使用的第一部分，则不会使用索引 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引 http://www.uml.org.cn/sjjm/201610184.asp 使用查询缓存大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。使用函数时要注意，因为像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。http://blog.csdn.net/xifeijian/article/details/45320605 经常查询的做索引索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：Index Selectivity = Cardinality / #T显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。SELECT count(DISTINCT(title))/count(*) AS Selectivity FROM employees.titles;http://blog.codinglabs.org/articles/theory-of-mysql-index.html 使用explain做优化explain的含义，type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.通常来说, 不同的 type 类型的性能关系如下:ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; systemALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了. https://segmentfault.com/a/1190000008131735 使用正确的索引引擎MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*)这类的计算是超快无比的。 InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。 http://blog.csdn.net/xifeijian/article/details/45287139http://blog.codinglabs.org/articles/theory-of-mysql-index.html 一些定义DQL,DML,DDL,DCLDQL数据查询语言：其语句，也称为“数据检索语句”，用以从表中获得数据，确定数据怎样在应用程序给出。保留字SELECT是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有WHERE，ORDER BY，GROUP BY和HAVING。这些DQL保留字常与其他类型的SQL语句一起使用。 DML（data manipulation language）是数据操纵语言：UPDATE、INSERT、DELETE，当执行DML命令如果没有提交，将不会被其他会话看到。除非在DML命令之后执行了DDL命令或DCL命令，或用户退出会话，或终止实例，此时系统会自动发出commit命令，使未提交的DML命令提交。 DDL（data definition language）是数据定义语言：DDL比DML要多，主要的命令有CREATE、ALTER、DROP等，DDL主要是用在定义或改变表（TABLE）的结构，数据类型，表之间的链接和约束等初始化工作上，他们大多在建立表时使用。当执行DDL语句时，在每一条语句前后，oracle都将提交当前的事务。如果用户使用insert命令将记录插入到数据库后，执行了一条DDL语句(如create table)，此时来自insert命令的数据将被提交到数据库。当DDL语句执行完成时，DDL语句会被自动提交，不能回滚。 DCL（Data Control Language）是数据库控制语言：是用来设置或更改数据库用户或角色权限的语句，包括（grant,deny,revoke等）语句。 因为DDL没有事务性，所以DDL不能回滚。要实现自动回滚。(begin,commit,rollback)，则SQL语句中只能包括DML。 MySQL默认操作模式就是autocommit自动提交模式。这就表示除非显式地开始一个事务，否则每个查询都被当做一个单独的事务自动执行。 mysqldump导出数据库 SQL truncate 、delete与drop区别相同点：1.truncate和不带where子句的delete、以及drop都会删除表内的数据。2.drop、truncate都是DDL语句(数据定义语言),执行后会自动提交。 不同点：1.truncate 和 delete 只删除数据不删除表的结构(定义)drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。2.delete 语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。3.速度，一般来说: drop&gt; truncate &gt; deleteDELETE语句执行删除操作的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。4.安全性：小心使用 drop 和 truncate，尤其没有备份的时候.否则哭都来不及使用上,想删除部分数据行用 delete，注意带上where子句. 回滚段要足够大.想删除表,当然用 drop想保留表而将所有数据删除，如果和事务无关，用truncate即可。如果和事务有关,或者想触发trigger,还是用delete。 primary key,key,index,uniqueprimary key是主键，一个表中只能有一个主键，mysql会为其建造聚集索引unique表示不会重复，有唯一约束，一个表中可以有多个uniquemysql中key和index是同义的，是索引的意思，没有唯一约束key,index,unique建造的都是B+树索引 视图视图可以定义在多张表上，因此定义功能比表强。视图中数据更新受到诸多限制，例如不能有聚集函数，不能是定义在多张表上等，因此操作功能弱于表。视图的数据控制功能和表的数据控制功能相当，都有GRANT、REVOKE。 连接 join左外连接的结果集包括 LEFT OUTER 子句中指定的左表的所有行，而不仅仅是连接列所匹配的行右外连接是左向外连接的反向连接。将返回右表的所有行。全外连接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。 (类似于求并集)内连接使用比较运算符根据每个表共有的列的值匹配两个表中的行。(类似于求交集) mysql中的join join的原则：小表驱动大表，即小表放在外层http://www.kuqin.com/database/20081206/29717.htmlhttp://www.cnblogs.com/zhengyun_ustc/p/slowquery1.html having、group by、● 聚合语句avg，min等必须要和group联合使用 ● 需要注意having和where的用法区别：1.having只能用在group by之后，对分组后的结果进行筛选(即使用having的前提条件是分组)。2.where肯定在group by 之前3.where后的条件表达式里不允许使用聚合函数，而having可以。 SELECT COUNT(CustomerID), CountryFROM Customerswhere City like ‘_o%’GROUP BY CountryHAVING COUNT(CustomerID) &gt; 5 limit 10; ● 当一个查询语句同时出现了where,group by,having,order by的时候，执行顺序和编写顺序是：wghso我哥好帅哦1.执行where xx对全表数据做筛选，返回第1个结果集。2.针对第1个结果集使用group by分组，返回第2个结果集。3.针对第2个结果集中的每1组数据执行select xx，有几组就执行几次，返回第3个结果集。4.针对第3个结集执行having xx进行筛选，返回第4个结果集。5.针对第4个结果集排序。 FROM &amp; JOINs determine &amp; filter rowsWHERE more filters on the rowsGROUP BY combines those rows into groupsHAVING filters groupsORDER BY arranges the remaining rows/groupsLIMIT filters on the remaining rows/groups http://stackoverflow.com/questions/1130062/what-is-the-execution-sequence-of-group-by-having-and-where-clause-in-sql-server 范式1NF:原子性 字段不可再分,否则就不是关系数据库;2NF:唯一性 一个表只说明一个事物;3NF:每列都与主键有直接关系，不存在传递依赖;https://www.zhihu.com/question/24696366 分页功能利用limit关键字123456mysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 //为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1： mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. //如果只给定一个参数，它表示返回最大的记录行数目： mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行 //换句话说，LIMIT n 等价于 LIMIT 0,n。 事务调优原则1、尽可能较小锁的覆盖范围2、尽可能让多线程并发访问数据3、并发度不高使用乐观锁，并发度较高使用悲观锁","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://duyao.github.io/tags/数据库/"}]},{"title":"nio","slug":"nio","date":"2017-04-18T08:16:57.000Z","updated":"2017-04-23T12:51:44.000Z","comments":true,"path":"2017/04/18/nio/","link":"","permalink":"http://duyao.github.io/2017/04/18/nio/","excerpt":"","text":"io模型一些概念用户空间与内核空间现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全。操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对Linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。 用户空间和内核空间 进程切换为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。 从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化： 保存处理机上下文，包括程序计数器和其他寄存器。 更新PCB信息。 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。 选择另一个进程执行，并更新其PCB。 更新内存管理的数据结构。 恢复处理机上下文。 进程的阻塞正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。 文件描述符fd文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。 缓存 I/O缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。 缓存 I/O 的缺点：数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。 io模型刚才说了，对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段： 等待数据准备 (Waiting for the data to be ready) 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process) 正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。 阻塞I/O（blocking IO） 非阻塞I/O（nonblocking IO） I/O多路复用（ IO multiplexing） 异步I/O（asynchronous IO） 阻塞I/O在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样： 阻塞I/O 当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。 blocking IO的特点就是在IO执行的两个阶段都被block了。 非阻塞I/Olinux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子： 非阻塞I/O 当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。 nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。 I/O 多路复用IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。 I/O 当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。 select，poll，epoll区别1、支持一个进程所能打开的最大连接数select有上限，poll没有上限、epoll基本没有上限2、FD剧增后带来的IO效率问题select和poll每次调用都要线性遍历，而epoll使用callback回调函数3、消息传递方式select和poll消息要从内核空间传递到用户空间，需要内核拷贝，epoll通过内核和用户空间共享一块内存空间来实现消息传递 select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善java nio包是select模型 https://my.oschina.net/xianggao/blog/663655http://blog.sae.sina.com.cn/archives/5042 异步 I/OLinux下的asynchronous IO其实用得很少。先看一下它的流程： 异步 用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。 http://blog.csdn.net/ywcpig/article/details/52540853?locationNum=1&amp;fps=1 几种 I/O 模型的比较前三种模型的区别是阶段1不相同，阶段2基本相同，都是将数据从内核拷贝到调用者的缓冲区。而异步 I/O 的两个阶段都不同于三四个模型。同步 I/O 操作引起请求进程阻塞，直到 I/O 操作完成。异步 I/O 操作不引起请求进程阻塞。 I/O 阻塞与非阻塞指的的是当不能进行读写（网卡满时的写/网卡空的时候的读）的时候，I/O 操作立即返回还是阻塞；同步异步指的是，当数据已经ready的时候，读写操作是同步读还是异步读，阶段不同而已。 java中的io模型阻塞I/O：服务器启动后，等待客户端连接。在客户端连接服务器后，服务器就阻塞读写取数据流。就是普通的serversocket，这种情况一个客户端连接之后，只能accept一个客户端，其他的是连接不到的 阻塞I/O+多线程：每次接收到新的连接都要新建一个线程，处理完成后销毁线程，但是这样做代价大，当有大量地短连接出现时，性能比较低。 阻塞I/O+线程池：针对上面多线程的模型中，出现的线程重复创建、销毁带来的开销，可以采用线程池来优化。每次接收到新连接后从池中取一个空闲线程进行处理，处理完成后再放回池中，重用线程避免了频率地创建和销毁线程带来的开销。存在着问题：在大量短连接的场景中性能会有提升，因为不用每次都创建和销毁线程，而是重用连接池中的线程。但在大量长连接的场景中，因为线程被连接长期占用，不需要频繁地创建和销毁线程，因而没有什么优势。虽然这种方法可以适用于小到中度规模的客户端的并发数，如果连接数超过 100,000或更多，那么性能将很不理想。 “阻塞I/O+线程池”网络模型虽然比”阻塞I/O+多线程”网络模型在性能方面有提升，但这两种模型都存在一个共同的问题：读和写操作都是同步阻塞的,面对大并发（持续大量连接同时请求）的场景，需要消耗大量的线程来维持连接。CPU 在大量的线程之间频繁切换，性能损耗很大。一旦单机的连接超过1万，甚至达到几万的时候，服务器的性能会急剧下降。 而 NIO 的 Selector 却很好地解决了这个问题，用主线程（一个线程或者是 CPU 个数的线程）保持住所有的连接，管理和读取客户端连接的数据，将读取的数据交给后面的线程池处理，线程池处理完业务逻辑后，将结果交给主线程发送响应给客户端，少量的线程就可以处理大量连接的请求。Java NIO 由以下几个核心部分组成： Channel Buffer Selector 要使用 Selector，得向 Selector 注册 Channel，然后调用它的 select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。 异步I/O”模式Java SE 7 版本之后，引入了异步 I/O （NIO.2） 的支持，为构建高性能的网络应用提供了一个利器。 https://waylau.com/java-io-model-evolution/#https://github.com/waylau/essential-java/blob/master/docs/io-model.md 两种IO多路复用方案:Reactor and Proactor一般情况下，I/O 复用机制需要事件分享器(event demultiplexor )。 事件分享器的作用，即将那些读写事件源分发给各读写事件的处理者，就像送快递的在楼下喊: 谁的什么东西送了， 快来拿吧。开发人员在开始的时候需要在分享器那里注册感兴趣的事件，并提供相应的处理者(event handlers)，或者是回调函数; 事件分享器在适当的时候会将请求的事件分发给这些handler或者回调函数。涉及到事件分享器的两种模式称为：Reactor and Proactor 。Reactor模式是基于同步I/O的，而Proactor模式是和异步I/O相关的。 Reactor 在Reactor模式中，事件分离者等待某个事件或者可应用或个操作的状态发生（比如文件描述符可读写，或者是socket可读写），事件分离者就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。 而在Proactor模式中，事件处理者(或者代由事件分离者发起)直接发起一个异步读写操作(相当于请求)，而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区，读的数据大小，或者用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分离者得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。举例来说，在Windows上事件处理者投递了一个异步IO操作(称有overlapped的技术)，事件分离者等IOCompletion事件完成。 这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可称之为“系统级别”的或者“真正意义上”的异步，因为具体的读写是由操作系统代劳的。http://blog.jobbole.com/59676/ nioJava NIO（ New IO） 是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同， NIO支持面向缓冲区的、基于通道的IO操作。 NIO将以更加高效的方式进行文件的读写操作。 IO NIO 面向流(Stream Oriented) 面向缓冲区(Buffer Oriented) 阻塞IO(Blocking IO) 非阻塞IO(Non Blocking IO) (无) 选择器(Selectors) Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。 Java Java NIO系统的核心在于：通道(Channel)和缓冲区(Buffer)。通道表示打开到 IO 设备(例如：文件、套接字)的连接。若需要使用 NIO 系统，需要获取用于连接 IO 设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。 buffer缓冲区（ Buffer） ：一个用于特定基本数据类型的容器。由 java.nio 包定义的，所有缓冲区都是 Buffer 抽象类的子类。Java NIO 中的 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的。Buffer 就像一个数组，可以保存多个相同类型的数据。根据数据类型不同(boolean 除外) ，有以下 Buffer 常用子类： ByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 上述 Buffer 类 他们都采用相似的方法进行管理数据，只是各自管理的数据类型不同而已。都是通过如下方法获取一个 Buffer对象：static XxxBuffer allocate(int capacity) : 创建一个容量为 capacity 的 XxxBuffer 对象 基本属性容量 (capacity) ： 表示 Buffer 最大数据容量，缓冲区容量不能为负，并且创建后不能更改。限制 (limit)： 第一个不应该读取或写入的数据的索引，即位于 limit 后的数据不可读写。缓冲区的限制不能为负，并且不能大于其容量。位置 (position)： 下一个要读取或写入的数据的索引。缓冲区的位置不能为负，并且不能大于其限制标记 (mark)与重置 (reset)： 标记是一个索引，通过 Buffer 中的 mark() 方法指定 Buffer 中一个特定的 position，之后可以通过调用 reset() 方法恢复到这个 position.标记、 位置、 限制、 容量遵守不变式：0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity I/O Buffer 所有子类提供了两个用于数据操作的方法： get()与 put() 方法获取 Buffer 中的数据 get() ：读取单个字节 get(byte[] dst)：批量读取多个字节到 dst 中 get(int index)：读取指定索引位置的字节(不会移动 position)放入数据到 Buffer 中 put(byte b)：将给定单个字节写入缓冲区的当前位置 put(byte[] src)：将 src 中的字节写入缓冲区的当前位置 put(int index, byte b)：将指定字节写入缓冲区的索引位置(不会移动 position) equals()与compareTo()方法可以使用equals()和compareTo()方法两个Buffer。 equals()当满足下列条件时，表示两个Buffer相等： 有相同的类型（byte、char、int等）。 Buffer中剩余的byte、char等的个数相等。 Buffer中所有剩余的byte、char等都相同。如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。 compareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer： 第一个不相等的元素小于另一个Buffer中对应的元素 。 所有元素都相等，但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。剩余元素是从 position到limit之间的元素 compact()和clear()如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。如果调用的是clear()方法，position将被设回0，limit被设置成 capacity的值。换句话说，Buffer相当于 被清空了（实际上Buffer中的内容并未真正被清空，此时如果调用rewind()或者设置position=0仍然可读取旧的数据）。该方法实际上只是重设了position和limit的值，进而告诉我们可以从哪里开始往Buffer里写数据。如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。 Buffer常用方法 Buffer常用方法 直接缓冲区和非直接缓冲区字节缓冲区要么是直接的，要么是非直接的。 直接缓冲区和非直接缓冲区 非直接缓冲区：通过 allocate() 方法分配缓冲区，将缓冲区建立在 JVM 的内存中直接缓冲区：通过 allocateDirect() 方法分配直接缓冲区，将缓冲区建立在物理内存中。可以提高效率 如果为直接字节缓冲区，则 Java 虚拟机会尽最大努力直接在此缓冲区上执行本机 I/O 操作。也就是说，在每次调用基础操作系统的一个本机 I/O 操作之前（或之后），虚拟机都会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容）。直接字节缓冲区可以通过调用此类的 allocateDirect() 工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。直接缓冲区的内容可以驻留在常规的垃圾回收堆之外，因此，它们对应用程序的内存需求量造成的影响可能并不明显。所以，建议将直接缓冲区主要分配给那些易受基础系统的本机 I/O 操作影响的大型、持久的缓冲区。一般情况下，最好仅在直接缓冲区能在程序性能方面带来明显好处时分配它们。 public abstract MappedByteBuffer map(MapMode mode,long position, long size)直接字节缓冲区还可以通过 FileChannel 的 map() 方法 将文件区域直接映射到物理内存中来创建。该方法返回MappedByteBuffer 。 Java 平台的实现有助于通过 JNI 从本机代码创建直接字节缓冲区。如果以上这些缓冲区中的某个缓冲区实例指的是不可访问的内存区域，则试图访问该区域不会更改该缓冲区的内容，并且将会在访问期间或稍后的某个时间导致抛出不确定的异常。 字节缓冲区是直接缓冲区还是非直接缓冲区可通过调用其 isDirect() 方法来确定。提供此方法是为了能够在性能关键型代码中执行显式缓冲区管理。 HeapByteBuffer和DirectByteBuffer以及MappedByteBuffer区别 三者的关系 在ByteBuffer.allocate(int capacity)和ByteBuffer.wrap(byte[] array)中，通过实例化HeapByteBuffer来创建的ByteBuffer对象就是heap buffer.在ByteBuffer.allocateDirect(int capacity)方法中调用DirectByteBuffer(capacity)这个类创建的是direct buffer Direct Buffer则是通过JNI(native方法)在Java的虚拟机外的内存中分配了一块缓冲区(所以即使在运行时通过-Xmx指定了Java虚拟机的最大堆内存，还是可以实例化超出该大小的Direct ByteBuffer),该块并不直接由Java虚拟机负责垃圾回收收集，但是在direct buffer包装类DirectByteBuffer被回收时，会通过Java Reference机制来释放该内存块。(但Direct Buffer的JAVA对象DirectByteBuffer是归GC管理的，只要GC回收了它的JAVA对象，操作系统才会释放Direct Buffer所申请的空间)。DirectByteBuffer 自身是一个Java对象，在Java堆中；而这个对象中有个long类型字段address，记录着一块调用 malloc() 申请到的native memory。12345 Java | native |DirectByteBuffer | malloc&apos;d[ address ] -+-&gt; [ data ] | DirectByteBuffer 自身是（Java）堆内的，它背后真正承载数据的buffer是在（Java）堆外——native memory中的。这是 malloc() 分配出来的内存，是用户态的。https://www.zhihu.com/question/57374068/answer/152691891 heap buffer这种缓冲区是分配在堆上面的，直接由Java虚拟机负责垃圾回收，可以直接想象成一个字节数组的包装类。FileChannel 的read(ByteBuffer dst)函数,write(ByteBuffer src)函数中，如果传入的参数是HeapBuffer类型,则会临时申请一块DirectBuffer,进行数据拷贝，而不是直接进行数据传输. 劣势：创建和释放Direct Buffer的代价比Heap Buffer得要高；优势：当我们把一个Direct Buffer写入Channel的时候，就好比是“内核缓冲区”的内容直接写入了Channel，这样显然快了，减少了数据拷贝（因为我们平时的read/write都是需要在I/O设备与应用程序空间之间的“内核缓冲区”中转一下的）。而当我们把一个Heap Buffer写入Channel的时候，实际上底层实现会先构建一个临时的Direct Buffer，然后把Heap Buffer的内容复制到这个临时的Direct Buffer上，再把这个Direct Buffer写出去。当然，如果我们多次调用write方法，把一个Heap Buffer写入Channel，底层实现可以重复使用临时的Direct Buffer，这样不至于因为频繁地创建和销毁Direct Buffer影响性能。 结论：Direct Buffer创建和销毁的代价很高，所以要用在尽可能重用的地方。 比如周期长传输文件大采用direct buffer，不然一般情况下就直接用heap buffer 就好。http://eyesmore.iteye.com/blog/1133335 The difference between the buffer types is that MappedByteBuffers are allocated in virtual-memory space in the operating system. R/W done with MappedByteBuffers is managed at the OS level by the VM paging logic. Direct ByteBuffers are just a solid slab of free memory (e.g. malloc) in RAM that you can utilize from within Java and treated by the OS as a standard memory allocation.A MappedByteBuffer represents a section of memory allocated using mmap call, which is used to perform memory mapped I/O. Therefore MappedByteBuffers won’t register their use of memory in the same way a Direct ByteBuffer will. http://www.developersite.org/903-129308-filehttp://stackoverflow.com/questions/1229037/difference-between-bytebuffer-allocatedirect-and-mappedbytebuffer-loadDirectByteBuffers是操作系统中真实的区域，通过malloc在用户空间申请的内存区域，并不是在jvm中MappedByteBuffers申请了操作系统中的虚拟内存，当这块buffer进行读写操作的时候，需要操作系统进行页的置换，并没有真正的申请内存，只是调用了mmap()方法 内存映射文件和标准IO操作最大的不同之处就在于它虽然最终也是要从磁盘读取数据，但是它并不需要将数据读取到OS内核缓冲区，而是直接将进程的用户私有地址空间中的一部分区域与文件对象建立起映射关系，就好像直接从内存中读、写文件一样，速度当然快了Linux只能怪有块区域叫做“Memory mapped region for shared libraries” ，这段区域就是在内存映射文件的时候将某一段的虚拟地址和文件对象的某一部分建立起映射关系，此时并没有拷贝数据到内存中去，而是当进程代码第一次引用这段代码内的虚拟地址时，触发了缺页异常，这时候OS根据映射关系直接将文件的相关部分数据拷贝到进程的用户私有空间中去，当有操作第N页数据的时候重复这样的OS页面调度程序操作。注意啦，原来内存映射文件的效率比标准IO高的重要原因就是因为少了把数据拷贝到OS内核缓冲区这一步 http://blog.csdn.net/fcbayernmunchen/article/details/8635427 channel 数据的传输过程 通道（ Channel）：由 java.nio.channels 包定义的。 Channel 表示 IO 源与目标打开的连接。Channel 类似于传统的“流”。只不过 Channel本身不能直接访问数据， Channel 只能与Buffer 进行交互。 Java 为 Channel 接口提供的最主要实现类如下： FileChannel：用于读取、写入、映射和操作文件的通道。 DatagramChannel：通过 UDP 读写网络中的数据通道。 SocketChannel：通过 TCP 读写网络中的数据。 ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。 获取通道的一种方式是对支持通道的对象调用getChannel() 方法。支持通道的类如下： FileInputStream FileOutputStream RandomAccessFile DatagramSocket Socket ServerSocket 获取通道的其他方式是使用 Files 类的静态方法 newByteChannel() 获取字节通道。FileChannel channel = new RandomAccessFile(&quot;1.txt&quot;, &quot;rw&quot;).getChannel()或者通过通道的静态方法 open() 打开并返回指定通道。public static FileChannel open(Path path, OpenOption... options) throws IOException FileChannel常见用法 通道的数据传输通道将数据传输给ByteBuffer对象或者从ByteBuffer对象获取数据进行传输通道可以是单向(unidirectional)或者双向的(bidirectional)。一个channel类可能实现定义read()方法的ReadableByteChannel接口，而另一个channel类也许实现WritableByteChannel接口以提供write()方法。实现这两种接口其中之一的类都是单向的，只能在一个方向上传输数据。如果一个类同时实现这两个接口，那么它是双向的，可以双向传输数据。 标准io12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public void test1()&#123; FileInputStream fis = null; FileOutputStream fos = null; //①获取通道 FileChannel inChannel = null; FileChannel outChannel = null; try &#123; fis = new FileInputStream(\"d:/1.mkv\"); fos = new FileOutputStream(\"d:/2.mkv\"); inChannel = fis.getChannel(); outChannel = fos.getChannel(); //②分配指定大小的缓冲区 ByteBuffer buf = ByteBuffer.allocate(1024); //③将通道中的数据存入缓冲区中 while(inChannel.read(buf) != -1)&#123; buf.flip(); //切换读取数据的模式 //④将缓冲区中的数据写入通道中 outChannel.write(buf); buf.clear(); //清空缓冲区 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if(outChannel != null)&#123; try &#123; outChannel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(inChannel != null)&#123; try &#123; inChannel.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fos != null)&#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(fis != null)&#123; try &#123; fis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 直接io1234567891011121314151617public void test2() throws IOException&#123; FileChannel inChannel = FileChannel.open(Paths.get(\"d:/1.mkv\"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get(\"d:/2.mkv\"), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE); //内存映射文件 MappedByteBuffer inMappedBuf = inChannel.map(MapMode.READ_ONLY, 0, inChannel.size()); MappedByteBuffer outMappedBuf = outChannel.map(MapMode.READ_WRITE, 0, inChannel.size()); //直接对缓冲区进行数据的读写操作 byte[] dst = new byte[inMappedBuf.limit()]; inMappedBuf.get(dst); outMappedBuf.put(dst); inChannel.close(); outChannel.close();&#125; 分散(Scatter)和聚集(Gather)分散读取（ Scattering Reads）是指从 Channel 中读取的数据“分散” 到多个 Buffer 中。注意：按照缓冲区的顺序，从 Channel 中读取的数据依次将 Buffer 填满。public final long read(ByteBuffer[] dsts) throws IOException聚集写入（ Gathering Writes）是指将多个 Buffer 中的数据“聚集”到 Channel。注意：按照缓冲区的顺序，写入 position 和 limit 之间的数据到 Channel 。public final long write(ByteBuffer[] srcs) throws IOException 通道之间的传输public abstract long transferFrom(ReadableByteChannel src, long position, long count)public abstract long transferTo(long position, long count, WritableByteChannel target)12345678910public void test3() throws IOException&#123; FileChannel inChannel = FileChannel.open(Paths.get(\"d:/1.mkv\"), StandardOpenOption.READ); FileChannel outChannel = FileChannel.open(Paths.get(\"d:/2.mkv\"), StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.CREATE);// inChannel.transferTo(0, inChannel.size(), outChannel); outChannel.transferFrom(inChannel, 0, inChannel.size()); inChannel.close(); outChannel.close();&#125; 网络channelServerSocketChannel： Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道，就像标准IO中的ServerSocket一样。 SocketChannel：Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。操作步骤：① 打开 SocketChannel ② 读写数据 ③ 关闭 SocketChanne DatagramChannel：Java NIO中的DatagramChannel是一个能收发UDP包的通道。操作步骤： ① 打开 DatagramChannel ② 接收/发送数据 Selector选择器（ Selector） 是 SelectableChannle 对象的多路复用器， Selector 可以同时监控多个 SelectableChannel 的 IO 状况，也就是说，利用 Selector可使一个单独的线程管理多个 Channel。 Selector 是非阻塞 IO 的核心。 SelectableChannle 由此可见selector只能监控网络channel Selector 的常用方法 Selector SelectionKeySelectionKey： 表示 SelectableChannel 和 Selector 之间的注册关系。每次向选择器注册通道时就会选择一个事件(选择键)。 选择键包含两个表示为整数值的操作集。操作集的每一位都表示该键的通道所支持的一类可选择操作。可以监听的事件类型（ 可使用 SelectionKey 的四个常量表示）：读 : SelectionKey.OP_READ （ 1）写 : SelectionKey.OP_WRITE （ 4）连接 : SelectionKey.OP_CONNECT （ 8）接收 : SelectionKey.OP_ACCEPT （ 16） SelectionKey 选择器（ Selector）的应用1.创建 Selector ：通过调用 Selector selector = Selector.open() 方法创建一个 Selector。2.向选择器注册通道： SelectableChannel.register(Selector sel, int ops)当调用 register(Selector sel, int ops) 将通道注册选择器时，选择器对通道的监听事件，需要通过第二个参数 ops 指定。 若注册时不止监听一个事件，则可以使用“位或”操作符连接。SelectableChannel.register(selector, SelectionKey.OP_ACCEPT|SelectionKey.OP_READ) NIO中的server1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public void server() throws IOException&#123; //1. 获取通道 ServerSocketChannel ssChannel = ServerSocketChannel.open(); //2. 切换非阻塞模式 ssChannel.configureBlocking(false); //3. 绑定连接 ssChannel.bind(new InetSocketAddress(9898)); //4. 获取选择器 Selector selector = Selector.open(); //5. 将通道注册到选择器上, 并且指定“监听接收事件” ssChannel.register(selector, SelectionKey.OP_ACCEPT); //6. 轮询式的获取选择器上已经“准备就绪”的事件 while(selector.select() &gt; 0)&#123; //7. 获取当前选择器中所有注册的“选择键(已就绪的监听事件)” Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator(); while(it.hasNext())&#123; //8. 获取准备“就绪”的是事件 SelectionKey sk = it.next(); //9. 判断具体是什么事件准备就绪 if(sk.isAcceptable())&#123; //10. 若“接收就绪”，获取客户端连接 SocketChannel sChannel = ssChannel.accept(); //11. 切换非阻塞模式 sChannel.configureBlocking(false); //12. 将该通道注册到选择器上 sChannel.register(selector, SelectionKey.OP_READ); &#125;else if(sk.isReadable())&#123; //13. 获取当前选择器上“读就绪”状态的通道 SocketChannel sChannel = (SocketChannel) sk.channel(); //14. 读取数据 ByteBuffer buf = ByteBuffer.allocate(1024); int len = 0; while((len = sChannel.read(buf)) &gt; 0 )&#123; buf.flip(); System.out.println(new String(buf.array(), 0, len)); buf.clear(); &#125; &#125; //15. 取消选择键 SelectionKey it.remove(); &#125; &#125;&#125; 管道 (Pipe)Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道，从source通道读取。 SelectionKey 123456789101112131415161718192021public void test1() throws IOException&#123; //1. 获取管道 Pipe pipe = Pipe.open(); //2. 将缓冲区中的数据写入管道 ByteBuffer buf = ByteBuffer.allocate(1024); Pipe.SinkChannel sinkChannel = pipe.sink(); buf.put(\"通过单向管道发送数据\".getBytes()); buf.flip(); sinkChannel.write(buf); //3. 读取缓冲区中的数据 Pipe.SourceChannel sourceChannel = pipe.source(); buf.flip(); int len = sourceChannel.read(buf); System.out.println(new String(buf.array(), 0, len)); sourceChannel.close(); sinkChannel.close();&#125; Path、 Paths、 Files、CharSethttp://www.365mini.com/page/tag/java-niohttp://ifeve.com/?x=0&amp;y=0&amp;s=nio","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"java nio","slug":"java-nio","permalink":"http://duyao.github.io/tags/java-nio/"}]},{"title":"排序","slug":"排序","date":"2017-04-17T06:57:47.000Z","updated":"2017-04-23T06:21:14.000Z","comments":true,"path":"2017/04/17/排序/","link":"","permalink":"http://duyao.github.io/2017/04/17/排序/","excerpt":"","text":"各种排序算法 排序算法比较 快速排序快排123456789101112131415161718192021222324252627282930public void quicksort(int[] arr, int low, int high) &#123; if (low &lt; high) &#123;//这里要判断 //先找出pivot int pivot = partition(arr, low, high); //分别排序 quicksort(arr, low, pivot); quicksort(arr, pivot + 1, high); &#125; &#125; private int partition(int arr[], int low, int high) &#123; //每次都要和flag进行比较 int flag = arr[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; arr[high] &gt;= flag) &#123; high--; &#125; //交换low和high的位置 swap(arr, low, high); while (low &lt; high &amp;&amp; arr[low] &lt;= flag) &#123; low++; &#125; swap(arr, low, high); &#125; //返回的是下标 return low; &#125; 双轴快排1234567891011121314151617Partitioning: left part center part right part+--------------------------------------------------------------+| &lt; pivot1 | pivot1 &lt;= &amp;&amp; &lt;= pivot2 | ? | &gt; pivot2 |+--------------------------------------------------------------+ ^ ^ ^ | | | less k greatInvariants: all in (left, less) &lt; pivot1 pivot1 &lt;= all in [less, k) &lt;= pivot2 all in (great, right) &gt; pivot2Pointer k is the first index of ?-part. 一般的快速排序采用一个枢轴来把一个数组划分成两半，然后递归之。大量经验数据表面，采用两个枢轴来划分成3份的算法更高效，这就是DualPivotQuicksort。动画：https://learnforeverlearn.com/yaro_web/http://www.tuicool.com/articles/BfY7Nz bfprtMedian of medians时间复杂度O(N)其精髓是选择pivot，不是任意的选,而是选择中位数中的中位数-Median of medians步骤：5个数分一组，分为n/5一组组内插入排序，选择所有的上中位数，单独组成一个数组arrm[]求所有中位数的中位数，即arrm[]的中位数，使用递归调用，求出次中位数pivot然后快排使用pivot来划分区域，看k是否是中间区域http://blog.duyaokeep.cn/2015/11/05/5.2/ 堆排序123456789101112131415161718192021222324252627282930public void heapsort(int[] arr) &#123; //初次建堆 //这里是以0开头的数组，因此最后一个非子节点是arr.length / 2 - 1，如果序号是1就是arr.length / 2 for (int i = arr.length / 2 - 1; i &gt;= 0; i--) &#123; heapy(arr, i, arr.length); &#125; //每次堆排都把最大的放在0的位置，然后把排好的放在最后 for (int i = arr.length - 1; i &gt; 0; i--) &#123; swap(arr, 0, i); heapy(arr, 0, i); &#125;&#125;private void heapy(int[] arr, int parent, int len) &#123; //每次都和这个值比较，即使parent变化 int tmp = arr[parent]; int child = parent * 2 + 1; while (child &lt; len) &#123; if (child + 1 &lt; len &amp;&amp; arr[child] &lt; arr[child + 1]) &#123; child++; &#125; if (tmp &gt; arr[child]) &#123; break; &#125; arr[parent] = arr[child]; parent = child; child = parent * 2 + 1; &#125; //因为上面已经将父节点下移，所以tmp相当于与给子节点赋值了 arr[parent] = tmp; &#125; 初次建立堆的过程是O(n)，heapy的过程是O(logn)堆排总的时间复杂度是O(nlogn)因为一共n个数字每个数字都要堆化heapyO(logn) 归并排序12345678910111213141516171819202122232425262728293031323334public void mergesort(int[] arr, int low, int high) &#123; //仍然要加条件 if (low &lt; high) &#123; int mid = low + (high - low) / 2; mergesort(arr, low, mid); mergesort(arr, mid + 1, high); mergeArray(arr, low, mid, high); &#125;&#125;private void mergeArray(int[] arr, int low, int mid, int high) &#123; int[] tmp = new int[high - low + 1]; int cnt = 0; int i = low, j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (arr[i] &lt; arr[j]) &#123; tmp[cnt++] = arr[i]; i++; &#125; else &#123; tmp[cnt++] = arr[j]; j++; &#125; &#125; while (i &lt;= mid) &#123; tmp[cnt++] = arr[i++]; &#125; while (j &lt;= high) &#123; tmp[cnt++] = arr[j++]; &#125; for (cnt = 0; cnt + low &lt;= high; cnt++) &#123; arr[cnt + low] = tmp[cnt]; &#125;&#125; 基数排序又称为桶排序，将数字按照位数拆分为若干个关键字，每次对一位进行排序123456789101112131415161718192021222324252627282930313233343536373839public void radixSort(int[] array) &#123; int max = array[0]; for (int i = 0; i &lt; array.length; i++) &#123; //找到数组中的最大值 if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; int keysNum = 0; //关键字的个数，我们使用个位、十位、百位...当做关键字，所以关键字的个数就是最大值的位数 while (max &gt; 0) &#123; max /= 10; keysNum++; &#125; List&lt;ArrayList&lt;Integer&gt;&gt; buckets = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; //每位可能的数字为0~9，所以设置10个桶 buckets.add(new ArrayList&lt;Integer&gt;()); //桶由ArrayList&lt;Integer&gt;构成 &#125; for (int i = 0; i &lt; keysNum; i++) &#123; //由最次关键字开始，依次按照关键字进行分配 for (int j = 0; j &lt; array.length; j++) &#123; //扫描所有数组元素，将元素分配到对应的桶中 //取出该元素对应第i+1位上的数字，比如258，现在要取出十位上的数字，258%100=58,58/10=5 int key = array[j] % (int) Math.pow(10, i + 1) / (int) Math.pow(10, i); buckets.get(key).add(array[j]); //将该元素放入关键字为key的桶中 &#125; //分配完之后，将桶中的元素依次复制回数组 int counter = 0; //元素计数器 for (int j = 0; j &lt; 10; j++) &#123; ArrayList&lt;Integer&gt; bucket = buckets.get(j); //关键字为j的桶 while (bucket.size() &gt; 0) &#123; array[counter++] = bucket.remove(0); //将桶中的第一个元素复制到数组，并移除 &#125; &#125; &#125; &#125; 其它排序冒泡排序http://blog.csdn.net/u012152619/article/details/47305859选择排序http://blog.csdn.net/u012152619/article/details/47306053插入排序http://blog.csdn.net/u012152619/article/details/47306209","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"java","slug":"java","permalink":"http://duyao.github.io/tags/java/"}]},{"title":"剑指offer","slug":"剑指offer","date":"2017-04-12T13:26:22.000Z","updated":"2017-05-23T13:56:50.000Z","comments":true,"path":"2017/04/12/剑指offer/","link":"","permalink":"http://duyao.github.io/2017/04/12/剑指offer/","excerpt":"","text":"二进制中1的个数http://www.lintcode.com/zh-cn/problem/count-1-in-binary/原理是n&amp;(n-1)就能把最右边的1变成0比如：n=5的二进制是101,n-1=4二进制是100，n&amp;(n-1)=101&amp;100=100，这样5中最右边的1就变成了012345678public int countOnes(int n) &#123; int cnt = 0; while (n != 0) &#123; cnt++; n = n &amp; (n - 1); &#125; return cnt;&#125; 还可以判断一个是是不是2的指数(2的指数中只有1位是1)还可以判断一个二进制数变为另一个二进制数需要转换几位(先异或，再求) 在O(1)时间复杂度删除链表节点http://www.lintcode.com/zh-cn/problem/delete-node-in-the-middle-of-singly-linked-list/ 删除链表节点 a图是一个链表b图是已知先序删除链表的过程c图是只知道要删除节点，那么需要将该删除节点和后继换位置，然后删除后继就可以完成删除节点的过程12345678910111213public void deleteNode(ListNode node) &#123; ListNode next = node.next; if(next != null)&#123; int a = next.val; next.val = node.val; node.val = a; &#125;else&#123; node = null; return; &#125; node.next = next.next;&#125; 快速幂搜索二维矩阵http://www.lintcode.com/zh-cn/problem/search-a-2d-matrix-ii/在每行每列的矩阵中寻找元素个数这道题目应该在矩阵右上角开始查找，然后划线删除法下图是查找数字7的过程 搜索二维矩阵 12345678910111213141516171819202122public int searchMatrix(int[][] matrix, int target) &#123; if(matrix == null || matrix.length == 0 || matrix[0].length==0)&#123; return 0; &#125; // write your code here int i = 0; int j = matrix[0].length-1; int cnt = 0; while(i &lt; matrix.length &amp;&amp; j&gt;=0)&#123; if(matrix[i][j] &gt; target)&#123; j--; &#125;else if(matrix[i][j] &lt; target)&#123; i++; &#125;else&#123; cnt++; j--; i++; &#125; &#125; return cnt;&#125; 是否是子树http://www.lintcode.com/zh-cn/problem/subtree/首先从t1中的每一个值对比t2的根节点，如果值不相同，就要继续比较t1中的值和t2如果值相同，就可以比较是不是完全相同的子树了==如果完全相同的子树返回==如果不完全相同就继续比较的！！！，即t1.left和t1.right于t2比较1234567891011121314151617181920212223242526272829303132public static boolean isSubtree(TreeNode T1, TreeNode T2) &#123; if (T2 == null || T1 == null &amp;&amp; T2 == null) &#123; return true; &#125; else if (T1 == null) &#123; return false; &#125; else &#123; if (T1.val != T2.val) &#123; return isSubtree(T1.left, T2) || isSubtree(T1.right, T2); &#125; else &#123; //这里不能直接返回isSame(T1, T2)，不相同要继续比较 if (isSame(T1, T2)) &#123; return true; &#125; else &#123; return isSubtree(T1.left, T2) || isSubtree(T1.right, T2); &#125; &#125; &#125; &#125; private static boolean isSame(TreeNode T1, TreeNode T2) &#123; if (T1 == null &amp;&amp; T2 != null || T2 == null &amp;&amp; T1 != null) &#123; return false; &#125; else if (T1 == null &amp;&amp; T2 == null) &#123; return true; &#125; else if (T1.val != T2.val) &#123; return false; &#125; else &#123; return isSame(T1.left, T2.left) &amp;&amp; isSame(T1.right, T2.right); &#125; &#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[]},{"title":"操作系统","slug":"操作系统","date":"2017-04-10T06:42:30.000Z","updated":"2017-05-25T03:47:12.000Z","comments":true,"path":"2017/04/10/操作系统/","link":"","permalink":"http://duyao.github.io/2017/04/10/操作系统/","excerpt":"","text":"进程管理进程程序是指令的集合，进程是程序的真正运行。同一个程序对应多个进程，允许多个用户云运行同一程序。 进程状态图 线程线程被称为轻量级进程，是程序执行流的最小单元。线程是进程中的一个实体，是系统独立调度和执行的最小单位。线程自己不拥有资源，只拥有一点必不可少的资源。可以与同一进程的其他线程共享资源。进程与线程的区别：https://duyao.github.io/2017/02/25/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/ 进程通信（1）管道（Pipe）：管道可用于具有亲缘关系进程间的通信，允许一个进程和另一个与它有共同祖先的进程之间进行通信。（2）命名管道（named pipe）：命名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。（3）信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送 信号给进程本身；Linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。（4）消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺（5）共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。（6）内存映射（mapped memory）：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。（7）信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。（8）套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。 调度算法调度的基本准则不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法所具有的特性。为了比较处理机调度算法的性能，人们提出很多评价准则，下面介绍主要的几种：1) CPU利用率。CPU是计算机系统中最重要和昂贵的资源之一，所以应尽可能使CPU 保持“忙”状态，使这一资源利用率最髙。2) 系统吞吐量。表示单位时间内CPU完成作业的数量。长作业需要消耗较长的处理机时间，因此会降低系统的吞吐量。而对于短作业，它们所需要消耗的处理机时间较短，因此能提高系统的吞吐量。调度算法和方式的不同，也会对系统的吞吐量产生较大的影响。3) 周转时间。是指从作业提交到作业完成所经历的时间，包括作业等待、在就绪队列中排队、在处理机上运行以及进行输入/输出操作所花费时间的总和。 作业的周转时间可用公式表示如下： 周转时间 = 作业完成时间 - 作业提交时间 = 等待时间 + 实际运行时间 平均周转时间是指多个作业周转时间的平均值： 平均周转时间 = (作业1的周转时间 + … + 作业 n 的周转时间) / n 带权周转时间是指作业周转时间与作业实际运行时间的比值，平均带权周转时间是指多个作业带权周转时间的平均值： 平均带权周转时间 = (作业1的带权周转时间 + … + 作业 n 的带权周转时间) / n 4) 等待时间。=开始时间—提交时间。是指进程处于等处理机状态时间之和，等待时间越长，用户满意度越低。处理机调度算法实际上并不影响作业执行或输入/输出操作的时间，只影响作业在就绪队列中等待所花的时间。因此，衡量一个调度算法优劣常常只需简单地考察等待时间。 5) 响应时间。是指从用户提交请求到系统首次产生响应所用的时间。在交互式系统中，周转时间不可能是最好的评价准则，一般釆用响应时间作为衡量调度算法的重要准则之一。从用户角度看，调度策略应尽量降低响应时间，使响应时间处在用户能接受的范围之内。 要想得到一个满足所有用户和系统要求的算法几乎是不可能的。设计调度程序，一方面要满足特定系统用户的要求（如某些实时和交互进程快速响应要求)，另一方面要考虑系统整体效率（如减少整个系统进程平均周转时间），同时还要考虑调度算法的开销。 调度算法先来先服务(FCFS)调度算法FCFS调度算法是一种最简单的调度算法，该调度算法既可以用于作业调度也可以用于进程调度。 FCFS调度算法属于不可剥夺算法。从表面上看，它对所有作业都是公平的，但若一个长作业先到达系统，就会使后面许多短作业等待很长时间，因此它不能作为分时系统和实时系统的主要调度策略。但它常被结合在其他调度策略中使用。例如，在使用优先级作为调度策略的系统中，往往对多个具有相同优先级的进程按FCFS原则处理。 FCFS调度算法的特点是算法简单，但效率低；对长作业比较有利，但对短作业不利（相对SJF和高响应比）；有利于CPU繁忙型作业，而不利于I/O繁忙型作业。 短作业优先(SJF)调度算法短作业（进程）优先调度算法（Shortest Job First ）是指对短作业（进程）优先调度的算法。该调度算法既可以用于作业调度也可以用于进程调度。 SJF调度算法也存在不容忽视的缺点：该算法对长作业不利，容易对长作业产生饥饿现象。该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业会被及时处理。注意，SJF调度算法的平均等待时间、平均周转时间最少。 优先级调度算法优先级调度算法又称优先权调度算法，该算法既可以用于作业调度，也可以用于进程调度，该算法中的优先级用于描述作业运行的紧迫程度。 根据新的更高优先级进程能否抢占正在执行的进程，可将该调度算法分为： 1)非剥夺式优先级调度算法:当某一个进程正在处理机上运行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在运行的进程继续运行，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件），才把处理机分配给更为重要或紧迫的进程。2)剥夺式优先级调度算法:当一个进程正在处理机上运行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给更重要或紧迫的进程。 而根据进程创建后其优先级是否可以改变，可以将进程优先级分为以下两种：1)静态优先级。优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。2)动态优先级。在进程运行过程中，根据进程情况的变化动态调整优先级。动态调整优先级的主要依据为进程占有CPU时间的长短、就绪进程等待CPU时间的长短。 高响应比优先调度算法高响应比优先调度算法主要用于作业调度，该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。 响应比的变化规律可描述为： 响应比=(等待时间+要求服务时间)/要求服务时间 根据公式可知：当作业的等待时间相同时，则要求服务时间越短，其响应比越高，有利于短作业。当要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而它实现的是先来先服务。对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，其响应比便可升到很高，从而也可获得处理机。克服了饥饿状态，兼顾了长作业。 时间片轮转调度算法时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。 在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。如果时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法。如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少。因此时间片的大小应选择适当。 时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力。 多级反馈队列调度算法（集合了前几种算法的优点）多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展。通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。例如，为提高系统吞吐量和缩短平均周转时间而照顾短进程；为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程；同时，也不必事先估计进程的执行时间。 多级反馈队列 多级反馈队列调度算法的实现思想如下：应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍， ……第i+1级队列的时间片要比第i级队列的时间片长一倍。当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS 原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列……如此下去，当一个长进程从第1级队列依次降到第 n 级队列后，在第 n 级队列中便釆用时间片轮转的方式运行。仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1 ~ (i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第 1 ~ (i-1)中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。 多级反馈队列的优势有：终端型作业用户：短作业优先。短批处理作业用户：周转时间较短。长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理。 http://blog.csdn.net/bigpudding24/article/details/48608483 死锁产生原因资源的竞争和进程推进顺序的不合理 死锁产生的必要条件互不请环（1） 互斥条件：一个资源每次只能被一个进程使用。（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 死锁的处理策略预防破坏必要条件 避免（1）有序资源分配法这种算法资源按某种规则系统中的所有资源统一编号（例如打印机为1、磁带机为2、磁盘为3、等等），申请时必须以上升的次序。系统要求申请进程： 1、对它所必须使用的而且属于同一类的所有资源，必须一次申请完； 2、在申请不同类资源时，必须按各类设备的编号依次申请。例如：进程PA，使用资源的顺序是R1，R2； 进程PB，使用资源的顺序是R2，R1；若采用动态分配有可能形成环路条件，造成死锁。 采用有序资源分配法：R1的编号为1，R2的编号为2；PA：申请次序应是：R1，R2PB：申请次序应是：R1，R2这样就破坏了环路条件，避免了死锁的发生（2）银行算法避免死锁算法中最有代表性的算法是Dijkstra E.W 于1968年提出的银行家算法：系统处于安全状态时，一定不会发生死锁；系统处于不安全状态时，不一定会发生死锁；该算法需要检查申请者对资源的最大需求量，如果系统现存的各类资源可以满足申请者的请求，就满足申请者的请求。这样申请者就可很快完成其计算，然后释放它占用的资源，从而保证了系统中的所有进程都能完成，所以可避免死锁的发生。http://blog.csdn.net/only06/article/details/53381153 检测和解除可以通过资源分配图检测检测死锁的存在http://c.biancheng.net/cpp/html/2607.html 死锁的解除方法主要有：资源剥夺、撤销进程、进程回退 其他问题某系统中有11台打印机，N个进程共享打印机资源，每个进程要求3台，当N的取值不超过（）时系统不会发生死锁。设有m个资源，n个进程，每个进程要调用k个资源，一次只能调用一个，则：m&gt;n(k-1) 对应找满足条件的值即可。 内存管理内存管理主要包括虚地址、地址变换、内存分配和回收、内存扩充、内存共享和保护等功能。 逻辑地址和物理地址程序编译后，每个目标模块都是从0号单元开始编址，成为该目标模块的相对地址(逻辑地址)。当连接程序将每个模块连接成一个完整的可执行目标程序是，连接程序顺序依次按各个模块的相对地址构成同一的从0号单元开始编制的逻辑地址空间。物理地址空间是内存中物理单元的集合，是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址来存取主存。当转入程序将可执行代码装入到内存中的时候，必须通过地址转换将逻辑地址转换为物理地址。这个过程叫做重定位。 http://blog.csdn.net/yusiguyuan/article/details/9664887 内存分配内存分配分为连续分配和不连续分配。连续分配是指为用户分配一个连续的内存空间，主要包括单一连续分配、分区管理（固定分区分配和动态分区分配）不连续分配允许一个程序分散的转入到不相邻的内存空间中：根据分区大小是否分页和分段存储管理两种方式；在分页管理中，又根据运行作业时是否要把作业的所有页面装入到内存才能运行分为基本分页和请求分业。 内存分配分类 存储方法的比较 碎片在内存管理中，内部碎片是已经被分配出去的的内存空间大于请求所需的内存空间。外部碎片是指还没有分配出去，但是由于大小太小而无法分配给申请空间的新进程的内存空间空闲块。 连续分配连续分配是指为一个用户程序分配连续的内存空间。连续分配有单一连续存储管理和分区式储管理两种方式。 单一连续存储管理在这种管理方式中，内存被分为两个区域：系统区和用户区。应用程序装入到用户区，可使用用户区全部空间。其特点是，最简单，适用于单用户、单任务的操作系统。CP／M和 DOS 2．0以下就是采用此种方式。这种方式的最大优点就是易于管理。但也存在着一些问题和不足之处，例如对要求内存空间少的程序，造成内存浪费；程序全部装入，使得很少使用的程序部分也占用—定数量的内存。 分区式存储管理为了支持多道程序系统和分时系统，支持多个程序并发执行，引入了分区式存储管理。分区式存储管理是把内存分为一些大小相等或不等的分区，操作系统占用其中一个分区，其余的分区由应用程序使用，每个应用程序占用一个或几个分区。分区式存储管理虽然可以支持并发，但难以进行内存分区的共享。分区式存储管理引人了两个新的问题：内碎片和外碎片。内碎片是占用分区内未被利用的空间，外碎片是占用分区之间难以利用的空闲分区(通常是小空闲分区)。为实现分区式存储管理，操作系统应维护的数据结构为分区表或分区链表。表中各表项一般包括每个分区的起始地址、大小及状态(是否已分配)。分区式存储管理常采用的一项技术就是内存紧缩(compaction)。 固定分区(nxedpartitioning)。固定式分区的特点是把内存划分为若干个固定大小的连续分区。分区大小可以相等：这种作法只适合于多个相同程序的并发执行(处理多个类型相同的对象)。分区大小也可以不等：有多个小分区、适量的中等分区以及少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。优点：易于实现，开销小。缺点主要有两个：内碎片造成浪费；分区总数固定，限制了并发执行的程序数目。 动态分区(dynamic partitioning)。动态分区的特点是动态创建分区：在装入程序时按其初始要求分配，或在其执行过程中通过系统调用进行分配或改变分区大小。与固定分区相比较其优点是：没有内碎片，有外碎片。动态分区的分区分配就是寻找某个空闲分区，其大小需大于或等于程序的要求。若是大于要求，则将该分区分割成两个分区，其中一个分区为要求的大小并标记为“占用”，而另一个分区为余下部分并标记为“空闲”。分区分配的先后次序通常是从内存低端到高端。动态分区的分区释放过程中有一个要注意的问题是，将相邻的空闲分区合并成一个大的空闲分区。 下面列出了几种常用的分区分配算法： 首次适应算法 最自然的过程，只是按照空闲分区表(空闲区链)中的空闲分区的地址从低到高找到第一个可以满足需要的空闲分区即可。该算法的分配和释放的时间性能较好，较大的空闲分区可以被保留在内存高端。但随着低端分区不断划分会产生较多小分区，每次分配时查找时间开销便会增大。 循环首次适应算法(next fit) 按分区在内存的先后次序，从上次分配的分区起查找(到最后{区时再从头开始}，找到符合要求的第一个分区进行分配)。该算法的分配和释放的时间性能较好，使空闲分区分布得更均匀，但较大空闲分区不易保留。 最佳适配法(best-fit) 按分区在内存的先后次序从头查找，找到其大小与要求相差最小的空闲分区进行分配。从个别来看，外碎片较小；但从整体来看，会形成较多外碎片优点是较大的空闲分区可以被保留。 最坏适配法(worst- fit) 按分区在内存的先后次序从头查找，找到最大的空闲分区进行分配。基本不留下小空闲分区，不易形成外碎片。但由于较大的空闲分区不被保留，当对内存需求较大的进程需要运行时，其要求不易被满足。 为了解决分区分配带来的碎片问题，引入了伙伴系统:无论已分配分区或空闲分区，其大小均为2的k次幂。在系统运行过程中，由于不断的划分，可能会形成若干个不连续的空闲分区，将这些空闲分区根据分区的大小进行分类，对于每一类具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表。这样，不同大小的空闲分区形成了k个空闲分区链表。 http://blog.csdn.net/hguisu/article/details/5713164 基本内存管理是不连续分配的分配方式，主要分为分页、分段、段页 基本分页存储管理将程序的逻辑地址空间划分为固定大小的页(page)，而物理内存划分为同样大小的页框(page frame)。程序加载时，可将任意一页放人内存中任意一个页框，这些页框不必连续，从而实现了离散分配。该方法需要CPU的硬件支持，来实现逻辑地址和物理地址之间的映射。在页式存储管理方式中地址结构由两部构成，前一部分是页号，后一部分为页内地址w（位移量） 地址转换的过程 页式管理方式的优点是：1）没有外碎片，每个内碎片不超过页大比前面所讨论的几种管理方式的最大进步是，2）一个程序不必连续存放。3）便于改变程序占用空间的大小(主要指随着程序运行，动态生成的数据增多，所要求的地址空间相应增长)。缺点是：要求程序全部装入内存，没有足够的内存，程序就不能执行http://baike.baidu.com/link?url=BYjmowZdQZ1QHn0BXSXYdEBmB1e41Bp1_w9VTTlexXYUCD4g4zhC1t_1xMJbTqdAE0x1VMKPC2usTDHGuq66Fdv09zwQJBdaBwWy5KrpyUSnZfeklsh_uf5qUCZaSwNtbQ3YJeCr6OCiO3JpLpgaeoemLaFa3GV6-rSsEfQRfBe7sC3H6IXRohgjvyQCYAW0gpEBLH-ShOjqEOsZ1tjsOq 基本分段存储管理在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。例如，有主程序段MAIN、子程序段X、数据段D及栈段S等。每个段都有自己的名字。为了实现简单起见，通常可用一个段号来代替段名，每个段都从0开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。整个作业的地址空间由于是分成多个段，因而是二维的，亦即，其逻辑地址由段号(段名)和段内地址所组成。在段式存储管理中，将程序的地址空间划分为若干个段(segment)，这样每个进程有一个二维的地址空间。其逻辑地址由段号和段内偏移组成 地址转换的过程 总的来说，段式存储管理的优点是：没有内碎片，外碎片可以通过内存紧缩来消除；便于实现内存共享。缺点与页式存储管理的缺点相同，进程必须全部装入内存。 为了实现段式管理，操作系统需要如下的数据结构来实现进程的地址空间到物理内存空间的映射，并跟踪物理内存的使用情况，以便在装入新的段的时候，合理地分配内存空间。http://baike.baidu.com/link?url=56HfbLNhe7kwyaavpBIffXZ3PHkXDjBaOEYBXDk4bHW8Z5U0ACQerZEIlj7_3vI1fdFUrmfhnoh6ag4_EVZYKRucH4PXpuH7z8Qo7UbF02rzFWhI0oV979I5MPDdl_TBnRjpt8rPhUKV7NIdap7jGU8U8U51uuBBubcOeMTAkfwXcjFS0aMsr7rypj_xtf9JpdgML50Ee8N4L4kayRfZFa 段页式管理方式请求分页、段(虚拟内存管理)基本的内存管理方式有两个特征：一次性：作业必须全部一次性装入，才能运行驻留性：作业被装入内存后，就一直驻留在内存中，其任何以一部分都不会被换出，直至作业运行完毕。 基于程序局部性原理，可以将程序的一部分装入内存中，而其余部分留在外存，就可以让程序执行。程序执行过程中，当访问信息不存在内存的时候，有操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂不使用的内容换出到外存，从而腾出空间存放将要调入内存的信息，这样，操作系统好像为用户提供了一个比实际大很多的存储器，称为虚拟存储器。 虚拟内存的实现有以下三种方式： 请求分页存储管理 请求分段存储管理 请求段页存储管理 不管使用哪一种方式都需要一定的硬件支持，一般需要以下几方面： 一定容量的内存和外存 页表机制或者段表机制，作为主要的数据结构 中断机构，当用户程序要范文的部分尚未调入内存的时候，则产生中断 地址变换机构，逻辑地址到物理地址的转换 请求分页系统建立在基本的分页系统之上，为了支持虚拟内存功能而增加了请求调页功能和页面置换功能。 请求分页过程页表机制在请求分页系统中所需要的主要数据结构是页表。其基本作用仍然是将用户空间中的逻辑地址变换为内存空间中的物理地址。由于只将应用程序的一部分调入内存，还有一部分仍在盘上，故需在页表中再增加若干项，供程序（数据）在换进、换出时参考。在请求分页系统中的每个页表项如下所示：页号 | 物理块号 | 状态位P | 访问字段A | 修改位M | 外存地址各字段的说明如下：—- 状态位P：用于指示该页是否已调入内存，供程序访问时参考。—- 访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，供选择换出页面时参考。—- 修改位M：表示该页在调入内存后是否被修改过。供置换页面时参考。由于内存中的每一页都在外存上有一份副本，因此，若未被修改，在置换该页时就不需要将该页写回到外存上，以减少系统的开销和启动磁盘的次数；若已被修改，则必须将该页重写到外存上，以保证外存中所保留的始终是最新副本。—- 外存地址：用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。 缺页中断机构在请求分页系统中，每当所要访问的页面不在内存中时，便产生一次缺页中断，请求OS将所缺之页调入内存。缺页中断作为中断，同样需要经历诸如保护CPU现场、分析中断原因、转入缺页中断处理程序进行处理、恢复CPU现场等几个步骤。但缺页中断又是一种特殊的中断，它与一般的中断相比，有着明显的区别，主要表现在下面两个方面：a. 在指令执行期间产生和处理中断信号。通常，CPU都是在一条指令执行完成后，才检查是否有中断请求到达。若有，便去响应，否则，继续执行下一条指令。然而，缺页中断是在指令执行期间，发现所要访问的指令或数据不在内存时所产生和处理的。b. 一条指令在执行期间，可能产生多次缺页中断。所以，系统中的硬件机构应能保存多次中断时的状态，并保证最后能返回到中断前产生缺页中断的指令处继续执行。 地址变换机构请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟存储器而增加了某些功能而形成的，如产生和处理缺页中断，以及从内存中换出一页的功能等等。 变换算法虚拟存储器地址变换基本上有3种形虚拟存储器工作过程式：全联想变换、直接变换和组联想变换。任何逻辑空间页面能够变换到物理空间任何页面位置的方式称为全联想变换。每个逻辑空间页面只能变换到物理空间一个特定页面的方式称为直接变换。组联想变换是指各组之间是直接变换，而组内各页间则是全联想变换。 在进行地址变换时，首先去检索快表，试图从中找出所要访问的页。若找到，便修改页表项中的访问位。对于写指令，还需将修改位置成“1”，然后利用页表项中给出的物理块号和页内地址形成物理地址。地址变换过程到此结束。如果在快表中未找到该页的页表项时，应到内存中去查找页表，再根据找到的页表项中的状态位P，了解该页是否已调入内存。若该页已调入内存，这时应将此页的页表项写入快表，当快表已满时，应先调出按某种算法所确定的页的页表项；然后再写入该页的页表项。若该页尚未调入内存，这时应产生缺页中断，请求OS从外存把该页调入内存。 常见的页面置换功能常见的置换算法有以下四种。 最佳置换算法(OPT)最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。 先进先出(FIFO)页面置换算法优先淘汰最早进入内存的页面，亦即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。 FIFO算法还会产生当所分配的物理块数增大而页故障数不减反增的异常现象，这是由 Belady于1969年发现，故称为Belady异常只有FIFO算法可能出现Belady 异常，而LRU和OPT算法永远不会出现Belady异常。 最近最久未使用(LRU)置换算法选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。 实际上，LRU算法根据各页以前的情况，是“向前看”的，而最佳置换算法则根据各页以后的使用情况，是“向后看”的。 LRU性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类的算法。理论上可以证明，堆栈类算法不可能出现Belady异常。FIFO算法基于队列实现，不是堆栈类算法。 时钟(CLOCK)置换算法LRU算法的性能接近于OPT,但是实现起来比较困难，且开销大；FIFO算法实现简单，但性能差。所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近LRU的性能，这类算法都是CLOCK算法的变体。 简单的CLOCK算法是给每一帧关联一个附加位，称为使用位。当某一页首次装入主存时，该帧的使用位设置为1;当该页随后再被访问到时，它的使用位也被置为1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一帧。每当遇到一个使用位为1的帧时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有帧的使用位均为0，则选择遇到的第一个帧替换；如果所有帧的使用位均为1,则指针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为CLOCK算法，又称为最近未用(Not Recently Used, NRU)算法。 http://c.biancheng.net/cpp/html/2614.html 抖动（颠簸）在页面置换过程中，最糟糕的情况是刚刚换出的页面又马上换入主存，刚刚换入主存的页面又要换出去，这种频繁的页面调度行为称为抖动或者颠簸。即如果一个进程在换页的时间多于执行事件，这个进程就在抖动频繁地发生缺页中断主要原因是进程频繁访问的页面数高于可用的物理页帧数, 最直接有效的方法当然是撤销部分进程。虚拟内存技术可以在内存中保留更多的进程以提髙系统效率。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。但如果管理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。 工作集（驻留集）工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。 工作集模型的原理是：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。 正确选择工作集的大小，对存储器的利用率和系统吞吐量的提嵩，都将产生重要影响。","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"os","slug":"os","permalink":"http://duyao.github.io/tags/os/"}]},{"title":"设计模式-单例模式和工厂模式","slug":"设计模式-单例模式和工厂模式","date":"2017-04-05T08:37:16.000Z","updated":"2017-05-08T08:53:26.000Z","comments":true,"path":"2017/04/05/设计模式-单例模式和工厂模式/","link":"","permalink":"http://duyao.github.io/2017/04/05/设计模式-单例模式和工厂模式/","excerpt":"","text":"单例模式构造方法私有，不允许外部直接创建对象 饿汉模式创建私有静态类的实例：因为构造私有，静态的话使用类就能得到，这个就能从通过方法获得实例12345678910public class Singleton &#123; //私有且静态 private static Singleton instance = new Singleton(); //构造方法私有 private Singleton ()&#123;&#125; //获取实例的方法，静态 public static Singleton getInstance() &#123; return instance; &#125; &#125; 因为实例被设置为静态，类在加载时就被创建，不管用户是不是要调用 懒汉模式123456789101112public class Singleton &#123; //声明 private static Singleton instance; private Singleton ()&#123;&#125; //获得实例 public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。优点：第一次调用才初始化，避免内存浪费。缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 为了提高性能，需要使用双重锁检查DCL，即 double-checked locking使用volatile关键字是防止DCL失效12345678910111213141516public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; //对于大部分情况，单例已经设好 if (singleton == null) &#123; synchronized (Singleton.class) &#123; //线程安全 if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125; 内部类123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟饿汉不同的是：饿汉方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 instance。 想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比饿汉方式就显得很合理。 枚举1234567891011public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125; public static void main(String[] args) &#123; Singleton a = Mo.INSTANCE; Singleton b = Mo.INSTANCE; System.out.println(a==b);//true &#125;&#125; 这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。不能通过 reflection attack 来调用私有构造方法。 http://www.runoob.com/design-pattern/singleton-pattern.html 破坏单例反射12345678910111213//启动JVM的安全检察,在进行反射校验的时候，判断一下是否是“singleton”，如果是，就禁止反射System.setSecurityManager(new SecurityManager()&#123; @Override public void checkPermission(Permission perm) &#123; if (perm instanceof ReflectPermission &amp;&amp; \"suppressAccessChecks\".equals(perm.getName())) &#123; for (StackTraceElement elem : Thread.currentThread().getStackTrace()) &#123; if (elem.getClassName().endsWith(\"Singleton\")) &#123; throw new SecurityException(); &#125; &#125; &#125; &#125;&#125;); http://iamzhongyong.iteye.com/blog/2053010 序列化序列化单例后再反序列化回来会破坏单例，可以重写readResolve方法1234567891011public class Singleton implements Serializable &#123; private static final Singleton INSTANCE = new Singleton(); public static Singleton getInstance()&#123; return INSTANCE; &#125; public Object readResolve() throws ObjectStreamException &#123; return INSTANCE; //ensure singleton is returned upon deserialization. &#125;&#125; 类加载两个不同的类加载器，加载单例会产生两个不一样的单例http://javarevisited.blogspot.com/2011/03/10-interview-questions-on-singleton.htmlhttp://stackoverflow.com/questions/11654876/cracking-singleton-with-other-ways 工厂模式概念 使用工厂方法代替new操作 工厂模式包括工厂方法模式和抽象工厂模式 抽象工厂模式是工厂方法模式的扩展 意图 定义一个接口老创建对象，但是让子类来决定哪些类需要被实例化 工厂发放把实例化的工作推迟到子类中去实现 使用场景 有一组类似的对象需要创建 在编码时不能预见需要创建哪种类的实例(超市里买苹果，不知道买蛇果，阿克苏还是冰糖心) 系统需要考虑扩展性 常见应用 jdbc执行sql的java api，可以为多种数据库提供统一访问 spring Bean FactoryBean Factory 是spring中IoC的基本容器，是一个产生bean给客户端的工厂 对比 工厂模式工厂模式 抽象工厂模式 工厂模式是一种极段的抽象工厂模式，而抽象工厂模式是工厂模式的推广 工厂模式用来创建一个产品的等级结构，而抽象工厂模式用来创建多个产品的等级结构 工厂模式只有一个抽象产品类，而抽象工厂模式有多个抽象产品类 抽象工程关键在于产品之间的抽象关系，所以至少要两个产品；工厂方法在于生成产品，不关注产品间的关系，所以可以只生成一个产品。抽象工厂中客户端把产品的抽象关系理清楚，在最终使用的时候，一般使用客户端（和其接口），产品之间的关系是被封装固定的；而工厂方法是在最终使用的时候，使用产品本身（和其接口）。抽象工厂的工厂是类；工厂方法的工厂是方法。 工厂方法模式： 一个抽象产品类，可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类只能创建一个具体产品类的实例。抽象工厂模式： 多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。 一个抽象工厂类，可以派生出多个具体工厂类。 每个具体工厂类可以创建多个具体产品类的实例。区别： 工厂方法模式只有一个抽象产品类，而抽象工厂模式有多个。 工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂模式可以创建多个","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://duyao.github.io/tags/设计模式/"}]},{"title":"内部类","slug":"内部类","date":"2017-04-01T02:23:51.000Z","updated":"2017-04-10T05:15:40.000Z","comments":true,"path":"2017/04/01/内部类/","link":"","permalink":"http://duyao.github.io/2017/04/01/内部类/","excerpt":"","text":"广泛意义上的内部类一般来说包括这四种：成员内部类、局部内部类、匿名内部类和静态内部类 内部类会再生成一个class文件编译器会为匿名内部类和局部内部类起名为Outter$Inner.class内部类(非静态内部类)访问可以任意直接访问外部类，但是外部类不行内部类(非静态内部类)不可以有静态的方法或者声明 创建静态内部类对象的一般形式为： 外部类类名.内部类类名 xxx = new 外部类类名.内部类类名()创建成员内部类对象的一般形式为： 外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名() 成员内部类成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问 123456789101112131415161718192021222324252627282930313233class Outter &#123; private double radius = 0; public static int count = 1; public Outter()&#123;&#125; public Outter(double radius) &#123; this.radius = radius; getInnerInstance().drawSahpe(); //必须先创建成员内部类的对象，再进行访问 &#125; private Inner getInnerInstance() &#123; return new Inner(); &#125; class Inner &#123; //内部类 public void drawSahpe() &#123; System.out.println(\"drawshape\"); System.out.println(radius); //外部类的private成员 System.out.println(count); //外部类的静态成员 &#125; &#125; public static void main(String[] args) &#123; //第一种方式： Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); //必须通过Outter对象来创建 //第二种方式： Outter.Inner inner1 = outter.getInnerInstance(); &#125;&#125; 为什么成员内部类可以无条件访问外部类的成员？反编译Outter$Inner.class虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对Outter this&amp;0引用进行初始化赋值，也就无法创建成员内部类的对象了。 局部内部类局部内部类是定义在一个方法或者一个作用域里面的类它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。1234567891011121314151617class People&#123; public People() &#123; &#125;&#125;class Man&#123; public Man()&#123; &#125; public People getWoman()&#123; class Woman extends People&#123; //局部内部类 int age =0; &#125; return new Woman(); &#125;&#125; 注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。 匿名内部类匿名内部类应该是平时我们编写代码时用得最多的形式为1234567891011new 父类构造器（参数列表）|实现接口（） &#123; //匿名内部类的类体部分 &#125;Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; &#125; &#125;); 匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。 匿名内部类的使用它是存在一个缺陷的，就是它仅能被使用一次，创建匿名内部类时它会立即创建一个该类的实例，该类的定义会立即消失，所以匿名内部类是不能够被重复使用。 在使用匿名内部类的过程中，我们需要注意如下几点：1、使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能继承一个类或者实现一个接口。2、匿名内部类中是不能定义构造函数的。3、匿名内部类中不能存在任何的静态成员变量和静态方法。4、匿名内部类为局部内部类，所以局部内部类的所有限制同样对匿名内部类生效。5、匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。 为什么局部内部类和匿名内部类只能访问局部final变量？123456789101112131415161718192021public class OuterClass &#123; public void display(final String name,String age)&#123; class InnerClass&#123; void display()&#123; System.out.println(name); &#125; &#125; &#125;&#125;//编译后实际是这个样子public class OuterClass$InnerClass &#123; public InnerClass(String name,String age)&#123; this.InnerClass$name = name; this.InnerClass$age = age; &#125; public void display()&#123; System.out.println(this.InnerClass$name + \"----\" + this.InnerClass$age ); &#125;&#125; 内部类并不是直接调用方法传递的参数，而是利用自身的构造器对传入的参数进行备份，自己内部方法调用的实际上时自己的属性而不是外部方法传递进来的参数。也就说如果局部变量的值在编译期间就可以确定，则直接在匿名内部里面创建一个拷贝。如果局部变量的值无法在编译期间确定，则通过构造器传参的方式来对拷贝进行初始化赋值。从上面可以看出，在run方法中访问的变量a根本就不是test方法中的局部变量a。这样一来就解决了前面所说的 生命周期不一致的问题。但是新的问题又来了，既然在run方法中访问的变量a和test方法中的变量a不是同一个变量，当在run方法中改变变量a的值的话，会出现什么情况？ 对，会造成数据不一致性，这样就达不到原本的意图和要求。为了解决这个问题，java编译器就限定必须将变量a限制为final变量，不允许对变量a进行更改（对于引用类型的变量，是不允许指向新的对象），这样数据不一致性的问题就得以解决了。 到这里，想必大家应该清楚为何方法中的局部变量和形参都必须用final进行限定了。在java1.8中，可以允许不加finalhttp://www.cnblogs.com/chenssy/p/3390871.html Java不允许在非静态内部类里定义static成员却允许static final123456789101112131415161718public class Out &#123; class Inner &#123; //static final Integer ia = 0;//compile error //static final Object o = new Object();//同上，内部类不允许定义static static final int ib = 100; static final String ibb = \"fs\"; void f() &#123; System.out.println(\"Inner ib=\" + ib); &#125; &#125; public static void main(String[] args) &#123; Out out = new Out(); Out.Inner inner = out.new Inner(); inner.f(); //相当于 常量 System.out.println(\"Inner.ib=\" + Inner.ib); &#125;&#125; 每一个非静态内部类，必须维持一个对其外部类实例的应用，这就表明了非静态内部类的作用域是实例级别；而static关键字显式指定某个属性、方法或内部类的作用域是属于类级别。既然二者在语言层面要求的作用域不同，自然无法编译通过。为什么添加final就可以了呢。final关键字的字面语义就是指明不可变，用在属性上，表示属性一旦赋值后即不可改变。与static关键字合用即表示定义一个常量，一旦作为常量，其作用域自然不再是实例级别了，而是全局级别了，类级别作用域其实就只是加了一个访问权限修饰的全局作用域而已。所以编译自然OK 这个问题有点类似于局部变量必须初始化才能使用，而静态变量无需初始化也能使用。 http://stackoverflow.com/questions/27095847/why-static-final-variables-are-accepted-in-local-classeshttp://stackoverflow.com/questions/2482327/why-can-we-have-static-final-members-but-cant-have-static-method-in-an-inner-cla 相似的问题还有：非静态变量不能被静态方法引用1234567class Foo &#123; private int bar; public static int getBar() &#123; return bar; // does not compile; &#125;&#125; http://stackoverflow.com/questions/4584258/communication-between-static-method-and-instance-field-in-java 静态内部类静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似静态内部类不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; Outter.Inner inner = new Outter.Inner(); &#125;&#125;class Outter &#123; public Outter() &#123; &#125; static class Inner &#123; public Inner() &#123; &#125; &#125;&#125; http://www.cnblogs.com/dolphin0520/p/3811445.html http://www.jianshu.com/p/b447bd84a512","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"java","slug":"java","permalink":"http://duyao.github.io/tags/java/"}]},{"title":"分布式技术","slug":"分布式技术","date":"2017-03-26T11:50:51.000Z","updated":"2017-04-24T09:26:58.000Z","comments":true,"path":"2017/03/26/分布式技术/","link":"","permalink":"http://duyao.github.io/2017/03/26/分布式技术/","excerpt":"","text":"分布式系统的难点分布式系统比起单机系统存在哪些难点呢？ 网络因素由于服务和数据分布在不同的机器上，每次交互都需要跨机器运行，这带来如下几个问题：1.网络延迟：性能、超时 同机房的网络IO还是比较块的，但是跨机房，尤其是跨IDC，网络IO就成为不可忽视的性能瓶颈了。并且，延迟不是带宽，带宽可以随便增加，千兆网卡换成万兆，只是成本的问题，但延迟是物理限制，基本不可能降低。这带来的问题就是系统整体性能的降低，会带来一系列的问题，比如资源的锁住，所以系统调用一般都要设置一个超时时间进行自我保护，但是过度的延迟就会带来系统的RPC调用超时，引发一个令人头疼的问题：分布式系统调用的三态结果：成功、失败、超时。不要小看这个第三态，这几乎是所有分布式系统复杂性的根源。针对这个问题有一些相应的解决方案：异步化，失败重试。 而对于跨IDC数据分布带来的巨大网络因素影响，则一般会采用数据同步，代理专线等处理方式。2.网络故障：丢包、乱序、抖动。 这个可以通过将服务建立在可靠的传输协议上来解决，比如TCP协议。不过带来的是更多的网络交互。因此是性能和流量的一个trade off。这个在移动互联网中更需要考虑。 分布式系统特性-CAP理论(鱼和熊掌不可兼得)CAP理论是由Eric Brewer提出的分布式系统中最为重要的理论之一：Consistency：[强]一致性，事务保障，ACID模型。Availiablity：[高]可用性，冗余以避免单点，至少做到柔性可用（服务降级）。Partition tolerance：[高]可扩展性（分区容忍性）：一般要求系统能够自动按需扩展，比如HBase。CAP原理告诉我们，这三个因素最多只能满足两个，不可能三者兼顾。对于分布式系统来说，分区容错是基本要求，所以必然要放弃一致性。对于大型网站来说，分区容错和可用性的要求更高，所以一般都会选择适当放弃一致性。对应CAP理论，NoSQL追求的是AP，而传统数据库追求的是CA，这也可以解释为什么传统数据库的扩展能力有限的原因。 在CAP三者中，“可扩展性”是分布式系统的特有性质。分布式系统的设计初衷就是利用集群多机的能力处理单机无法解决的问题。当需要扩展系统性能时，一种做法是优化系统的性能或者升级硬件(scale up)，一种做法就是“简单”的增加机器来扩展系统的规模(scale out)。好的分布式系统总在追求”线性扩展性”，即性能可以随集群数量增长而线性增长。 可用性和可扩展性一般是相关联的，可扩展行好的系统，其可用性一般会比较高，因为有多个服务(数据)节点，不是整体的单点所以分布式系统的所有问题，基本都是在一致性与可用性和可扩展性这两者之间的一个协调和平衡。对于没有状态的系统，不存在一致性问题，根据CAP原理，它们的可用性和分区容忍性都是很高，简单的添加机器就可以实现线性扩展。而对于有状态的系统，则需要根据业务需求和特性在CAP三者中牺牲其中的一者。一般来说，交易系统类的业务对一致性的要求比较高，一般会采用ACID模型来保证数据的强一致性，所以其可用性和扩展性就比较差。而其他大多数业务系统一般不需要保证强一致性，只要最终一致就可以了，它们一般采用BASE模型，用最终一致性的思想来设计分布式系统，从而使得系统可以达到很高的可用性和扩展性。 CAP定律其实也是衡量分布式系统的重要指标，另一个重要的指标是性能。 一致性模型主要有三种：Strong Consistency（强一致性）：新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，Azure Table都是强一致性的。Week Consistency（弱一致性）：不同副本上的值有新有旧，需要应用方做更多的工作获取最新值。比如Dynamo。Evantual Consistency（最终一致性）：一旦更新成功，各副本的数据最终将达到一致。从这三种一致型的模型上来说，我们可以看到，Weak和Eventually一般来说是异步冗余的，而Strong一般来说是同步冗余的(多写)，异步的通常意味着更好的性能，但也意味着更复杂的状态控制。同步意味着简单，但也意味着性能下降。以及其他变体：Causal Consistency（因果一致性）：如果Process A通知Process B它已经更新了数据，那么Process B的后续读取操作则读取A写入的最新值，而与A没有因果关系的C则可以最终一致性。Read-your-writes Consistency（读你所写一致性）：如果Process A写入了最新的值，那么 Process A的后续操作都会读取到最新值。但是其它用户可能要过一会才可以看到。Session Consistency（会话一致性）：一次会话内一旦读到某个值，不会读到更旧的值。Monotonic Read Consistency（单调一致性）：一个用户一旦读到某个值，不会读到比这个值更旧的值，其他用户不一定。等等。其中最重要的变体是第二条：Read-your-Writes Consistency。特别适用于数据的更新同步，用户的修改马上对自己可见，但是其他用户可以看到他老的版本。Facebook的数据同步就是采用这种原则。 分布式系统常用技术和应用场景 consistent hashing [with virtual node]：一致性哈希，数据分布 vector clock：时钟向量，多版本数据修改 Quorum W+R&gt;N [with vector clock]：抽屉原理，数据一致性的另一种解决方案。时钟向量，多版本数据修改。 Merkle tree [with anti-entropy]：数据复制 MVCC：copy-on-write与snapshot 2PC/3PC：分布式事务 Paxos：强一致性协议 Raft:简化版的Paxos Symmetry and Decentralization：对称性和去中心化。对称性(symmetry)简化了系统的配置和维护。去中心化是对对称性的延伸，可以避免master单点，同时方便集群scale out。 Map-Reduce：分而治之；移动数据不如移动计算。将计算尽量调度到与存储节点在同一台物理机器上的计算节点上进行，这称之为本地化计算。本地化计算是计算调度的一种重要优化。 Gossip协议：节点管理 Lease机制 一致性哈希我们通常使用的hash算法是hash() mod n，但是如果发生某个节点失效时，无法快速切换到其他节点。为了解决单点故障的问题，我们为每个节点都增加一个备用节点，当某个节点失效时，就自动切换到备用节点上，类似于数据库的master和slave。但是依然无法解决增加或删除节点后，需要做hash重分布的问题，也就是无法动态增删节点。 这时就引入了一致性hash的概念 ：将所有的节点分布到一个hash环上，每个请求都落在这个hash环上的某个位置，只需要按照顺时针方向找到的第一个节点，就是自己需要的服务节点。当某个节点发生故障时，只需要在环上找到下一个可用节点即可 virtual node前面说过，有的Consistent Hashing的实现方法采用了虚拟节点的思想。使用一般的hash函数的话，服务器的映射地点的分布非常不均匀。因此，使用虚拟节点的思想，为每个物理节点（服务器）在continuum上分配100～200个点。这样就能抑制分布不均匀，最大限度地减小服务器增减时的缓存重新分布。 http://blog.codinglabs.org/articles/consistent-hashing.html Quorum W+R&gt;N：抽屉原理，数据一致性的另一种解决方案N: 复制的节点数，即一份数据被保存的份数。R: 成功读操作的最小节点数，即每次读取成功需要的份数。W: 成功写操作的最小节点数 ，即每次写成功需要的份数。所以 W+R&gt;N的意思是：对于有N份拷贝的分布式系统，写到W(W&lt;=N)份成功算写成功，读R(R&lt;=N)份数据算读成功。 这三个因素决定了可用性，一致性和分区容错性。W+R&gt;N可以保证数据的一致性(C)和分区容错性(P)，W越大数据一致性越高。这个NWR模型把CAP的选择权交给了用户，让用户自己在功能，性能和成本效益之间进行权衡。对于一个分布式系统来说，N通常都大于3，也就说同一份数据需要保存在三个以上不同的节点上，以防止单点故障。W是成功写操作的最小节点数，这里的写成功可以理解为“同步”写，比如N=3，W=1，那么只要写成功一个节点就可以了，另外的两份数据是通过异步的方式复制的。R是成功读操作的最小节点数，读操作为什么要读多份数据呢？在分布式系统中，数据在不同的节点上可能存在着不一致的情况，我们可以选择读取多个节点上的不同版本，来达到增强一致性的目的。NWR模型的一些设置会造成脏数据和版本冲突问题，所以一般要引入vector clock算法来解决这个问题。需要保证系统中有max(N-W+1,N-R+1)个节点可用。http://coolshell.cn/articles/10910.htmlhttps://my.oschina.net/manmao/blog/618344 vector clock：时钟向量，多版本数据修改http://coolshell.cn/articles/10910.html参见 分布式系统的事务处理，写的很通俗易懂。 lease机制lease的原理：lease的思想非常简单，既然中心节点需要获取目标节点是否异常的情况，同时又要考虑网络出问题等异常。那就干脆考虑各种异常情况在内，只单方面给对方一个期限，在这个期限内，我认为你是正常的，不正常也认为正常。超出这个期限，我就认为你异常了。由于网络延迟等原因，这个期限不能使用相对时间，而必须使用绝对时间。比如，1点之间，节点A就是主节点。这样就能避免双主问题。节点A为如果收到这个lease，即得到了中心节点的授权，1点前绝对只有自己是主。心跳依旧照发，只是每次中心节点都只根据lease是否有效来判断节点状况，不会出问题。 lease是一种颁发的带期限的承诺，有两方面的意义：颁发者在承诺期限内一定遵守承诺，被颁发者在承诺期限内可放心行使承诺的内容；期限过了以后，被颁发者一定不可再行使承诺。 lease与活锁lease的颁发往往是被动的，比如A节点需要中心节点的某个承诺，比如读并缓存，则会向中心节点请求lease，中心节点回复最新可缓存的数据与一个lease，在此lease期限内，中心节点保证目标节点缓存内容与中心节点一致。按lease方案，如果中心节点需要修改对应数据，必须等全部lease失效。问题是等lease失效的过程中，可能有新的请求元数据的请求到达，这时中心节点又会继续颁发新的lease，使得lease一直不结束，形成“活锁”，即修改请求等待lease失效，而又源源不断颁发新lease而一直无法完成。解决活锁的办法：当有修改请求在等待着lease失效时，如果后续有读请求，则只返回请求数据而不颁发新lease，或者是只颁发目前最长的lease。解决活锁后，修改请求仍然需要等待全部lease结束，写请求可能阻塞太久。可以在写请求到达时，中心节点主动给各节点发取消lease的消息。如果全部正确返回，则写可立即进行。如果有异常，那就正常等待lease结束。 lease的容错：由于仅依赖于绝对时间，因此lease机制天生即可容忍网络、lease接收方的出错。对于中心节点异常，比如宕机，只需要在颁发者恢复后，等待一个最大lease期限就可保证所有lease失效；另一方面，颁发者宕机可能使得全部节点没有lease，系统处于不可用状态，解决的方法就是使用一个小集群而不是单一节点作为颁发者。颁发者与被颁发者之间的时钟可能也存在误差，只需要颁发者考虑时钟误差即可。lease时间长短一般取经验值10秒。太短网络压力大，太长则收回承诺时间过长影响可用性。 应用： GFS中，Master通过lease机制决定哪个是主副本，lease在给各节点的心跳响应消息中携带。收不到心跳时，则等待lease过期，再颁发给其他节点。Niobe中，主副本持有从副本颁发的lease，当lease过期时，主从分别会在中心节点上标记对方不可用，而中心节点是全局一致的，两者只有一个会成功。如果主成功了，从不可用，需要重新与主同步才能可用；如果从成功了，则自己成为新主。chubby中，paxos选主后，从节点会给主颁发lease，在期限内不选其他节点为主。另一方面，主节点给每个client节点发送lease，用于判断client死活。zookeeper中，选主不用lease，而是直接发现没有主则选主。其余和chubby一致。 Gossip协议Gossip用于P2P系统中自治节点获悉对集群认识（如集群的节点状态，负载情况等）。 系统中的节点定期互相八卦，很快八卦就在整个系统传开了。 A、B两个节点八卦的方式主要是：A告诉B知道哪些人的什么八卦；B告诉A这些八卦里B知道哪些更新了；B更新A告诉他的八卦…… 说是自治系统，其实节点中还有一些种子节点。种子节点的作用主要是在有新节点加入系统时体现。新节点加入系统中，先与种子节点八卦，新节点获得系统信息，种子节点知道系统中多了新节点。其他节点定期与种子节点八卦的时候就知道有新节点加入了。 各个节点互相八卦的过程中，如果发现某个节点的状态很长时间都没更新，就认为该节点已经宕机了。Dynamo使用了Gossip协议来做会员和故障检测。 2PC、3PC、Paxos协议、Raft: 分布式事务的解决方案分布式事务很难做，所以除非必要，一般来说都是采用最终一致性来规避分布式事务。目前底层NoSQL存储系统实现分布式事务的只有Google的系统，它在Bigtable之上用Java语言开发了一个系统 Megastore，实现了两阶段锁，并通过Chubby来避免两阶段锁协调者宕机带来的问题。Megastore实现目前只有简单介绍，还没有相关论文。 2PC这个协议的缩写又叫2PC，中文叫两阶段提交。在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。 两阶段提交的算法如下： 第一阶段： 协调者会问所有的参与者结点，是否可以执行提交操作。各个参与者开始事务执行的准备工作：如：为资源上锁，预留资源，写undo/redo log……参与者响应协调者，如果事务的准备工作成功，则回应“可以提交”，否则回应“拒绝提交”。 第二阶段： 如果所有的参与者都回应“可以提交”，那么，协调者向所有的参与者发送“正式提交”的命令。参与者完成正式提交，并释放所有资源，然后回应“完成”，协调者收集各结点的“完成”回应后结束这个Global Transaction。如果有一个参与者回应“拒绝提交”，那么，协调者向所有的参与者发送“回滚操作”，并释放所有资源，然后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个Global Transaction。 2PC 2PC说白了就是第一阶段做Vote，第二阶段做决定的一个算法，也可以看到2PC这个事是强一致性的算法。在前面我们讨论过Master-Slave的强一致性策略，和2PC有点相似，只不过2PC更为保守一些——先尝试再提交。2PC用的是比较多的，在一些系统设计中，会串联一系列的调用，比如：A -&gt; B -&gt; C -&gt; D，每一步都会分配一些资源或改写一些数据。比如我们B2C网上购物的下单操作在后台会有一系列的流程需要做。如果我们一步一步地做，就会出现这样的问题，如果某一步做不下去了，那么前面每一次所分配的资源需要做反向操作把他们都回收掉，所以，操作起来比较复杂。 实现简单，但是效率低，所有参与者需要block，throughput低；无容错，一个节点失败整个事务失败。如果第一阶段完成后，参与者在第二阶没有收到决策，那么数据结点会进入“不知所措”的状态，这个状态会block住整个事务。 3PC在2pc中，如果第一阶段完成后，参与者在第二阶没有收到决策，那么数据结点会进入“不知所措”的状态，这个状态会block住整个事务。也就是说，协调者Coordinator对于事务的完成非常重要，Coordinator的可用性是个关键。因些，我们引入三段提交，三段提交在Wikipedia上的描述如下，他把二段提交的第一个段break成了两段：询问，然后再锁资源。最后真正提交。三段提交的示意图如下： 三段提交的核心理念是：在询问的时候并不锁定资源，除非所有人都同意了，才开始锁资源。如果结点处在P状态（PreCommit）的时候发生了F/T的问题，三段提交比两段提交的好处是，三段提交可以继续直接把状态变成C状态（Commit），而两段提交则不知所措。理论上来说，如果第一阶段所有的结点返回成功，那么有理由相信成功提交的概率很大。这样一来，可以降低参与者Cohorts的状态未知的概率。也就是说，一旦参与者收到了PreCommit，意味他知道大家其实都同意修改了。这一点很重要。 3PC 改进版的2PC，把2PC的第一个段break成了两段: 询问，然后再锁资源，最后真正提交。3PC的核心理念是：在询问的时候并不锁定资源，除非所有人都同意了，才开始锁资源。3PC比2PC的好处是，如果结点处在P状态（PreCommit）的时候发生了Fail/Timeout的问题，3PC可以继续直接把状态变成C状态（Commit），而2PC则不知所措。不过3PC实现比较困难，而且无法处理网络分离问题。如果preCommit消息发送后两个机房断开，这时候coordinator所在的机房会abort，剩余的participant会commit。 PaxosPaxos 算法解决的问题是在一个可能发生上述异常的分布式系统中如何就某个值达成一致，保证不论发生以上任何异常，都不会破坏决议的一致性。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个「一致性算法」以保证每个节点看到的指令一致。一个通用的一致性算法可以应用在许多场景中，是分布式计算中的重要问题。从20世纪80年代起对于一致性算法的研究就没有停止过。 Notes：Paxos算法是莱斯利·兰伯特（Leslie Lamport，就是 LaTeX 中的”La”，此人现在在微软研究院）于1990年提出的一种基于消息传递的一致性算法。由于算法难以理解起初并没有引起人们的重视，使Lamport在八年后1998年重新发表到ACM Transactions on Computer Systems上（The Part-Time Parliament）。即便如此paxos算法还是没有得到重视，2001年Lamport 觉得同行无法接受他的幽默感，于是用容易接受的方法重新表述了一遍（Paxos Made Simple）。可见Lamport对Paxos算法情有独钟。近几年Paxos算法的普遍使用也证明它在分布式一致性算法中的重要地位。2006年Google的三篇论文初现“云”的端倪，其中的Chubby Lock服务使用Paxos作为Chubby Cell中的一致性算法，Paxos的人气从此一路狂飙。（Lamport 本人在 他的blog 中描写了他用9年时间发表这个算法的前前后后） 简单说来，Paxos的目的是让整个集群的结点对某个值的变更达成一致。Paxos算法基本上来说是个民主选举的算法——大多数的决定会成个整个集群的统一决定。任何一个点都可以提出要修改某个数据的提案，是否通过这个提案取决于这个集群中是否有超过半数的结点同意（所以Paxos算法需要集群中的结点是单数）。 过程主要涉及到的角色有：Proposer提交者、Acceptor仲裁者、learner、client paxos-flow 第一阶段 Prepare P1a：Proposer 发送 Prepare请求 Proposer 生成全局唯一且递增的ProposalID，向 Paxos 集群的所有机器发送 Prepare请求，这里不携带value，只携带 ProposalID 。 P1b：Acceptor 应答 Prepare Acceptor 收到 Prepare请求 后，判断：收到的ProposalID 是否比之前已响应的所有提案的ProposalID 大：如果是，则：(1) 在本地持久化 ProposalID，可记为Max_ProposalID。(2) 回复请求，并带上 已Accept的提案中 ProposalID 最大的 value（若此时还没有已Accept的提案，则返回value为空）。(3) 做出承诺：不会Accept 任何小于 Max_ProposalID的提案。如果否：不回复。 第二阶段 Accept P2a：Proposer 发送 Accept 经过一段时间后，Proposer 收集到一些 Accpet 的 Prepare 回复，有下列几种情况：(1) 回复数量 &gt; 一半的Acceptor数量，且所有的回复的 value 都为空，则 Porposer发出accept请求，并带上自己指定的value。(2) 回复数量 &gt; 一半的Acceptor数量，且有的回复 value 不为空，则 Porposer发出accept请求，并带上回复中 ProposalID最大的value(作为自己的提案内容)。(3) 回复数量 &lt;= 一半的Acceptor数量，则尝试更新生成更大的 ProposalID，再转P1a执行。 P2b：Acceptor 应答 Accept Accpetor 收到 Accpet请求 后，判断：(1) 收到的ProposalID &gt;= Max_ProposalID (一般情况下是等于)，则回复提交成功，并持久化ProposalID 和value。(2) 收到的ProposalID &lt; Max_ProposalID，则 不回复 或者 回复提交失败。 P2c: Proposer 统计投票 经过一段时间后，Proposer 收集到一些 Accept 回复提交成功，有几种情况：(1) 回复数量 &gt; 一半的Acceptor数量，则表示提交value成功。此时，可以发一个广播给所有Proposer、Learner，通知它们 已commit的value。(2) 回复数量 &lt;= 一半的Acceptor数量，则 尝试更新生成更大的 ProposalID，再转 P1a 执行。(3) 收到一条提交失败的回复，则 尝试更新生成更大的ProposalID，再转 P1a 执行。 最后，经过多轮投票后，达到的结果是：(1) 所有Proposer都提交提案成功了，且提交的value是同一个value。(2) 过半数的 Acceptor都提交成功了，且提交的是 同一个value。 Paxos 协议 的几个约束：P1: 一个Acceptor必须接受(accept)第一次收到的提案;P2a: 一旦一个具有value v的提案被批准(chosen)，那么之后任何Acceptor 再次接受(accept)的提案必须具有value v;P2b: 一旦一个具有value v的提案被批准(chosen)，那么以后任何 Proposer 提出的提案必须具有value v;P2c: 如果一个编号为n的提案具有value v，那么存在一个多数派，要么他们中所有人都没有接受(accept)编号小于n的任何提案，要么他们已经接受(accpet)的所有编号小于n的提案中编号最大的那个提案具有value v;https://angus.nyc/2012/paxos-by-example/http://www.tudou.com/programs/view/e8zM8dAL6hM/ 常见的疑问、及异常处理1、Paxos算法的核心思想是什么？(1) 引入了 多个Acceptor，避免单个Acceptor成为单点。Proposer用更大ProposalID 来抢占临时的访问权，避免其中一个 Proposer崩溃宕机导致死锁。(2) 保证一个ProposalID，只有一个Proposer能进行到第二阶段运行，Proposer按照ProposalID递增的顺序依次运行。(3) 新ProposalID 的 proposer 采用 后者认同前者的思路运行。在肯定旧ProposalID 还没有生成确定的value (Acceptor 提交成功一个value)时，新ProposalID 会提交自己的value，不会冲突。一旦旧ProposalID 生成了确定的value，新ProposalID 肯定可以获取到此值，并且认同此值。 2、容错要求：(1) 半数以内的Acceptor失效、任意数量的Proposer 失效，都能运行。(2) 一旦value值被确定，即使 半数以内的Acceptor失效，此值也可以被获取，并不再修改。 3、工程实践中 ProposalID 怎么定？在《Paxos made simple》中提到，推荐Proposer从不相交的数据集合中进行选择，例如系统有5个Proposer，则可为每一个Proposer分配一个标识j(0~4)，则每一个proposer每次提出决议的编号可以为5*i + j(i可以用来表示提出议案的次数)。在实践过程中，可以用时间戳 + 提出提案的次数 + 机器 IP/机器ID来保证唯一性和递增性。 4、如何保证 更大的ProposalID的Proposer不会破坏已经达成的确定性取值value？在P2a阶段中，Proposer会以所有回复中ProposalID最大 的value 作为自己的提案内容。其中，prepare阶段的目的有两个: 1) 检查是否有被批准的值，如果有，就改用批准的值。2) 如果之前的提案还没有被批准，则阻塞掉他们以便不让他们和我们发生竞争，当然最终由ProposalID 的大小决定。 5、Paxos协议的活锁问题新轮次的抢占会使旧轮次停止运行，如果每一轮在第二阶段执行成功之前 都 被 新一轮抢占，则导致活锁。怎么解决？这个问题在实际应用会发生地比较少，一般可通过 随机改变 ProposalID的增长幅度 或者 增加Proposer发送新一轮提案的间隔 来解决。 6、Paxos 运行过程中，半数以内的Acceptor失效，都能运行。为什么？(1) 如果 半数以内的Acceptor失效时 还没确定最终的value，此时，所有Proposer会竞争 提案的权限，最终会有一个提案会 成功提交。之后，会有半过数的Acceptor以这个value提交成功。(2) 如果 半数以内的Acceptor失效时 已确定最终的value，此时，所有Proposer提交前 必须以 最终的value 提交，因为，一个Proposer要拿到过半数的accept响应，必须同一个已提交的Acceptor存在交集，故会在P2a阶段中会继续沿用该value。 7、若两个Proposer以不同的ProposalID，在进行到P2a阶段，收到的prepare回复的value值都为空，则两个proposer都以自己的值作为value(提案内容)，向Acceptor提交请求，最后，两个proposer都会认为自己提交成功了吗？不会，因为Acceptor会根据ProposalID，批准执行最大的ProposalID的value，另一个会回复 执行失败。当proposer收到执行失败的回复时，就知道：当前具有更大的ProposalID的提案提交成功了。 8、由于大ProposalID 可以抢占小ProposalID 的提交权限，如果 此时 Acceptor还没有一个确定性取值，有一个具有最大ProposalID的proposer进行到P2a阶段了，但这时 这个proposer挂了，会造成一种死锁状态（小ProposalID的会提交失败，但是 具有最大ProposalID的proposer却不能提交accept请求），如何解决这种死锁状态？不会产生这种死锁状态，acceptor回复提交失败后，proposer再生成更大的ProposalID，下一轮可以用自己value提交成功。 https://baozh.github.io/2016-03/paxos-learning/ RaftPaxos 相比 Raft 比较复杂和难以理解。角色扮演和流程比 Raft 都要啰嗦。比如 Agreement 这个流程，在 Paxos 里边：Client 发起请求举荐 Proposer 成为 Leader，Proposer 然后向全局 Acceptors 寻求确认，Acceptors 全部同意 Proposer 后，Proposer 的 Leader 地位得已承认，Acceptors 还得再向Learners 进行全局广播来同步。而在 Raft 里边，只有 Follower/Candidate/Leader 三种角色，角色本身代表状态，角色之间进行状态转移是一件非常自由民主的事情。Raft虽然有角色之分但是是全民参与进行选举的模式；但是在Paxos里边，感觉更像议员参政模式。 三个角色follower、candidate、leader。最开始大家都是follower，当follower监听不到leader，就可以自己成为candidate，发起投票 leader选举主要通过2个timeout来控制：election timeout和heartbeat timeoutlection timeout：follower成为candidate的超时时间，每个follower都在150ms - 300ms之间随机，之后看谁先timeout，谁就先成为candidate，然后它会先投自己一票，再向其他节点发起投票邀请。如果其他节点在这轮选举还没有投过票，那么就给candidate投票，然后重置自己的选举timeout。如果得到大多数的投票就成为leader，之后定期开始向follower发送心跳heartbeat timeout。 期间还有可能发生split vote：如果两个follower同时成为candidate的话，如果最后得到的票数相同，则等待其他follower的选择timeout之后成为candidate，继续开始新一轮的选举。 log复制leader把变动的log借助心跳同步给follower，过半回复之后才成功提交，之后再下一次心跳之后，follower也commit变动，在自己的node上生效。 分裂之后，另一个分区的follower接受不到leader的timeout，然后会有一个先timeout，成为candidate，最后成为leader。于是两个分区就有了两个leader。当客户端有变动时，其中的leader由于无法收到过半的提交，则保持未提交状态。有的leader的修改，可以得到过半的提交，则可以修改生效。当分裂恢复之后，leader开始对比选举的term，发现有更高的term存在时，他们会撤销未提交的修改，然后以最新的为准。 http://thesecretlivesofdata.com/raft/https://raft.github.io/ MVCC：多版本并发控制在并发读写数据库时，读操作可能会不一致的数据（脏读）。为了避免这种情况，需要实现数据库的并发访问控制，最简单的方式就是加锁访问。由于，加锁会将读写操作串行化，所以不会出现不一致的状态。但是，读操作会被写操作阻塞，大幅降低读性能。在Java concurrent包中，有copyonwrite系列的类，专门用于优化读远大于写的情况。而其优化的手段就是，在进行写操作时，将数据copy一份，不会影响原有数据，然后进行修改，修改完成后原子替换掉旧的数据，而读操作只会读取原有数据。通过这种方式实现写操作不会阻塞读操作，从而优化读效率。而写操作之间是要互斥的，并且每次写操作都会有一次copy，所以只适合读大于写的情况。 MVCC的原理与copyonwrite类似，全称是Multiversion Concurrency Controll，即多版本并发控制。在MVCC协议下，每个读操作会看到一个一致性的snapshot，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。由此可以看出MVCC是一种用来解决读-写冲突的无锁并发控制. MVCC的基本原理是：MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。 http://blog.duyaokeep.cn/2017/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/ 各种一致性的比较 Transaction-Across-DataCenter Two Generals Problem（两将军问题）Two Generals Problem 两将军问题是这么一个思维性实验问题： 有两支军队，它们分别有一位将军领导，现在准备攻击一座修筑了防御工事的城市。这两支军队都驻扎在那座城市的附近，分占一座山头。一道山谷把两座山分隔开来，并且两位将军唯一的通信方式就是派各自的信使来往于山谷两边。不幸的是，这个山谷已经被那座城市的保卫者占领，并且存在一种可能，那就是任何被派出的信使通过山谷是会被捕。请注意，虽然两位将军已经就攻击那座城市达成共识，但在他们各自占领山头阵地之前，并没有就进攻时间达成共识。两位将军必须让自己的军队同时进攻城市才能取得成功。因此，他们必须互相沟通，以确定一个时间来攻击，并同意就在那时攻击。如果只有一个将军进行攻击，那么这将是一个灾难性的失败。 这个思维实验就包括考虑他们如何去做这件事情。下面是我们的思考： 1）第一位将军先发送一段消息“让我们在上午9点开始进攻”。然而，一旦信使被派遣，他是否通过了山谷，第一位将军就不得而知了。任何一点的不确定性都会使得第一位将军攻击犹豫，因为如果第二位将军不能在同一时刻发动攻击，那座城市的驻军就会击退他的军队的进攻，导致他的军对被摧毁。2）知道了这一点，第二位将军就需要发送一个确认回条：“我收到您的邮件，并会在9点的攻击。”但是，如果带着确认消息的信使被抓怎么办？所以第二位将军会犹豫自己的确认消息是否能到达。3）于是，似乎我们还要让第一位将军再发送一条确认消息——“我收到了你的确认”。然而，如果这位信使被抓怎么办呢？4）这样一来，是不是我们还要第二位将军发送一个“确认收到你的确认”的信息。 靠，于是你会发现，这事情很快就发展成为不管发送多少个确认消息，都没有办法来保证两位将军有足够的自信自己的信使没有被敌军捕获。 这个问题是无解的。 从工程上来说，一个解决两个将军问题的实际方法是使用一个能够承受通信信道不可靠性的方案，并不试图去消除这个不可靠性，但要将不可靠性削减到一个可以接受的程度。比如，第一位将军排出了100位信使并预计他们都被捕的可能性很小。在这种情况下，不管第二位将军是否会攻击或者受到任何消息，第一位将军都会进行攻击。另外，第一位将军可以发送一个消息流，而第二位将军可以对其中的每一条消息发送一个确认消息，这样如果每条消息都被接收到，两位将军会感觉更好。然而我们可以从证明中看出，他们俩都不能肯定这个攻击是可以协调的。他们没有算法可用（比如，收到4条以上的消息就攻击）能够确保防止仅有一方攻击。再者，第一位将军还可以为每条消息编号，说这是1号，2号……直到n号。这种方法能让第二位将军知道通信信道到底有多可靠，并且返回合适的数量的消息来确保最后一条消息被接收到。如果信道是可靠的话，只要一条消息就行了，其余的就帮不上什么忙了。最后一条和第一条消息丢失的概率是相等的。 两将军问题可以扩展成更变态的拜占庭将军问题 (Byzantine Generals Problem)，其故事背景是这样的：拜占庭位于现在土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信差传消息。在战争的时候，拜占庭军队内所有将军必需达成一致的共识，决定是否有赢的机会才去攻打敌人的阵营。但是，军队可能有叛徒和敌军间谍，这些叛徒将军们会扰乱或左右决策的过程。这时候，在已知有成员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，这就是拜占庭将军问题。 Map-Reduce思想1.分而治之 2.移动数据不如移动计算 如果计算节点和存储节点位于不同的物理机器则计算的数据需要通过网络传输，此种方式的开销很大。另一种思路是，将计算尽量调度到与存储节点在同一台物理机器上的计算节点上进行，这称之为本地化计算。本地化计算是计算调度的一种重要优化。 http://coolshell.cn/articles/10910.htmlhttp://coolshell.cn/articles/17459.htmlhttp://blog.hebiace.net/other/428.html","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"分布式","slug":"分布式","permalink":"http://duyao.github.io/tags/分布式/"}]},{"title":"反射和类加载","slug":"反射和类加载","date":"2017-03-25T12:37:02.000Z","updated":"2017-05-04T03:35:50.000Z","comments":true,"path":"2017/03/25/反射和类加载/","link":"","permalink":"http://duyao.github.io/2017/03/25/反射和类加载/","excerpt":"","text":"反射对象在java中万事万物都是对象。但是只有静态对象和类是java.lang.Class的对象即任何一个类都是Class的对象 表达实例对象表达实例对象有三种方法比如Foo的实例对象如何表示Foo foo1 = new Foo();//foo1就表示出来了.Foo这个类 也是一个实例对象，Class类的实例对象,如何表示呢任何一个类都是Class的实例对象，这个实例对象有三种表示方式 //第一种表示方式—&gt;实际在告诉我们任何一个类都有一个隐含的静态成员变量classClass c1 = Foo.class; //第二中表达方式 已经知道该类的对象通过getClass方法Class c2 = foo1.getClass();官网 c1 ,c2 表示了Foo类的类类型(class type)万事万物皆对象，类也是对象，是Class类的实例对象,这个对象我们称为该类的类类型 不管c1 or c2都代表了Foo类的类类型，一个类只可能是Class类的一个实例对象System.out.println(c1 == c2);//true 第三种表达方式c3 = Class.forName(&quot;com.imooc.reflect.Foo&quot;);12345678Class c3 = null;try &#123; c3 = Class.forName(\"com.imooc.reflect.Foo\");&#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace();&#125;System.out.println(c2==c3);//true 静态加载和动态加载静态加载一个程序需要先编译javac然后才能运行java编译的过程可以认为是包括加载、验证、准备、解析和初始化对于new关键字，在初始化阶段完成，也就是说如果一个类在new的时候没有找到，那么就会编译失败。因此说new是静态加载机制。比如 静态加载 动态加载因此可以使用类类型实现动态加载Interface intterface = (Interface)class.forName()这里要写成interface接口，因为根部不知道要加载哪个类 动态加载 获取类的信息获取方法信息Method类，方法对象一个成员方法就是一个Method对象getMethods()方法获取的是所有的public的函数，包括父类继承而来的getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限Method[] ms = c.getMethods();//c.getDeclaredMethods()//得到方法的返回值类型的类类型Class returnType = ms[i].getReturnType();//得到方法的名称ms[i].getName()//获取参数类型—&gt;得到的是参数列表的类型的类类型Class[] paramTypes = ms[i].getParameterTypes();123456789101112131415161718192021222324252627282930/** * 打印类的信息，包括类的成员函数、成员变量(只获取成员函数) * @param obj 该对象所属类的信息 */public static void printClassMethodMessage(Object obj)&#123; //要获取类的信息 首先要获取类的类类型 Class c = obj.getClass();//传递的是哪个子类的对象 c就是该子类的类类型 //获取类的名称 System.out.println(\"类的名称是:\"+c.getName()); /* * Method类，方法对象 * 一个成员方法就是一个Method对象 * getMethods()方法获取的是所有的public的函数，包括父类继承而来的 * getDeclaredMethods()获取的是所有该类自己声明的方法，不问访问权限 */ Method[] ms = c.getMethods();//c.getDeclaredMethods() for(int i = 0; i &lt; ms.length;i++)&#123; //得到方法的返回值类型的类类型 Class returnType = ms[i].getReturnType(); System.out.print(returnType.getName()+\" \"); //得到方法的名称 System.out.print(ms[i].getName()+\"(\"); //获取参数类型---&gt;得到的是参数列表的类型的类类型 Class[] paramTypes = ms[i].getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName()+\",\"); &#125; System.out.println(\")\"); &#125;&#125; 比如class是String，会打印出会打印出int lastIndexOf(int,int,)、int length()、boolean matches(java.lang.String,)等 获取成员变量的信息成员变量也是对象，java.lang.reflect.FieldField类封装了关于成员变量的操作getFields()方法获取的是所有的public的成员变量的信息getDeclaredFields获取的是该类自己声明的成员变量的信息Field[] fs = c.getDeclaredFields();for (Field field : fs) {//得到成员变量的类型的类类型Class fieldType = field.getType();//得到成员变量的名称String fieldName = field.getName(); 123456789101112131415161718192021222324/** * 获取成员变量的信息 * @param obj */public static void printFieldMessage(Object obj) &#123; Class c = obj.getClass(); /* * 成员变量也是对象 * java.lang.reflect.Field * Field类封装了关于成员变量的操作 * getFields()方法获取的是所有的public的成员变量的信息 * getDeclaredFields获取的是该类自己声明的成员变量的信息 */ //Field[] fs = c.getFields(); Field[] fs = c.getDeclaredFields(); for (Field field : fs) &#123; //得到成员变量的类型的类类型 Class fieldType = field.getType(); String typeName = fieldType.getName(); //得到成员变量的名称 String fieldName = field.getName(); System.out.println(typeName+\" \"+fieldName); &#125;&#125; 比如class是String，会打印出int hash、long serialVersionUID等 获取构造法方法信息构造函数也是对象，java.lang. Constructor中封装了构造函数的信息getConstructors获取所有的public的构造函数getDeclaredConstructors得到所有的构造函数 Constructor[] cs = c.getDeclaredConstructors();//获取构造函数的参数列表—&gt;得到的是参数列表的类类型Class[] paramTypes = constructor.getParameterTypes();123456789101112131415161718192021222324/** * 打印对象的构造函数的信息 * @param obj */public static void printConMessage(Object obj)&#123; Class c = obj.getClass(); /* * 构造函数也是对象 * java.lang. Constructor中封装了构造函数的信息 * getConstructors获取所有的public的构造函数 * getDeclaredConstructors得到所有的构造函数 */ //Constructor[] cs = c.getConstructors(); Constructor[] cs = c.getDeclaredConstructors(); for (Constructor constructor : cs) &#123; System.out.print(constructor.getName()+\"(\"); //获取构造函数的参数列表---&gt;得到的是参数列表的类类型 Class[] paramTypes = constructor.getParameterTypes(); for (Class class1 : paramTypes) &#123; System.out.print(class1.getName()+\",\"); &#125; System.out.println(\")\"); &#125;&#125; 比如class是String，会打印出java.lang.String([B,int,int,)、java.lang.String([B,java.nio.charset.Charset,)等 反射的基本操作主要过程：1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型//要获取print(int ,int )方法A a1 = new A();Class c = a1.getClass(); 2.获取方法 名称和参数列表来决定getMethod获取的是public的方法getDelcaredMethod自己声明的方法 //Method m = c.getMethod(“print”, new Class[]{int.class,int.class});Method m = c.getMethod(“print”, int.class,int.class); 3.方法的反射操作方法的反射操作是用m对象来进行方法调用 invoke和a1.print调用的效果完全相同//方法如果没有返回值返回null,有返回值返回具体的返回值//Object o = m.invoke(a1,new Object[]{10,20});Object o = m.invoke(a1, 10,20); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class MethodDemo1 &#123; public static void main(String[] args) &#123; //要获取print(int ,int )方法 // 1.要获取一个方法就是获取类的信息，获取类的信息首先要获取类的类类型 A a1 = new A(); Class c = a1.getClass(); /* * 2.获取方法 名称和参数列表来决定 * getMethod获取的是public的方法 * getDelcaredMethod自己声明的方法 */ try &#123; //Method m = c.getMethod(\"print\", new Class[]&#123;int.class,int.class&#125;); Method m = c.getMethod(\"print\", int.class, int.class); //方法的反射操作 //a1.print(10, 20); //方法的反射操作是用m对象来进行方法调用 和a1.print调用的效果完全相同 //方法如果没有返回值返回null,有返回值返回具体的返回值 //Object o = m.invoke(a1,new Object[]&#123;10,20&#125;); Object o = m.invoke(a1, 10, 20); System.out.println(\"==================\"); //获取方法print(String,String) Method m1 = c.getMethod(\"print\", String.class, String.class); //用方法进行反射操作 //a1.print(\"hello\", \"WORLD\"); o = m1.invoke(a1, \"hello\", \"WORLD\"); System.out.println(\"===================\"); // Method m2 = c.getMethod(\"print\", new Class[]&#123;&#125;); Method m2 = c.getMethod(\"print\"); // m2.invoke(a1, new Object[]&#123;&#125;); m2.invoke(a1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class A &#123; public void print() &#123; System.out.println(\"helloworld\"); &#125; public void print(int a, int b) &#123; System.out.println(a + b); &#125; public void print(String a, String b) &#123; System.out.println(a.toUpperCase() + \",\" + b.toLowerCase()); &#125;&#125; 集合与泛型对于集合来说一般会在创建的时候就制定其类型。12ArrayList list = new ArrayList();ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); 同时我们还知道java语法糖，即编译之后集合的泛型是去泛型化的123Class c1 = list.getClass();Class c2 = list1.getClass();System.out.println(c1 == c2);//true 如果错误地添加会导致编译失败，12list1.add(&quot;hello&quot;);//list1.add(20);错误的 但是通过泛型就可以绕过编译这一过程，完成添加不同类型的过程。1234Method m = c2.getMethod(&quot;add&quot;, Object.class);m.invoke(list1, 20);//绕过编译操作就绕过了泛型System.out.println(list1.size());System.out.println(list1); 完整程序1234567891011121314151617181920212223242526272829public static void main(String[] args) &#123; ArrayList list = new ArrayList(); ArrayList&lt;String&gt; list1 = new ArrayList&lt;String&gt;(); list1.add(\"hello\"); //list1.add(20);错误的 Class c1 = list.getClass(); Class c2 = list1.getClass(); System.out.println(c1 == c2); //反射的操作都是编译之后的操作 /* * c1==c2结果返回true说明编译之后集合的泛型是去泛型化的 * Java中集合的泛型，是防止错误输入的，只在编译阶段有效， * 绕过编译就无效了 * 验证：我们可以通过方法的反射来操作，绕过编译 */ try &#123; Method m = c2.getMethod(\"add\", Object.class); m.invoke(list1, 20);//绕过编译操作就绕过了泛型 System.out.println(list1.size()); System.out.println(list1); /*for (String string : list1) &#123; System.out.println(string); &#125;*///现在不能这样遍历 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 类加载类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。 基本上所有的类加载器都是 java.lang.ClassLoader类的一个实例。 java.lang.ClassLoader类介绍java.lang.ClassLoader类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class类的一个实例。除此之外，ClassLoader还负责加载 Java 应用所需的资源，如图像文件和配置文件等。不过本文只讨论其加载类的功能。为了完成加载类的这个职责，ClassLoader提供了一系列的方法. ClassLoader主要方法 类加载器的树状组织结构Java 中的类加载器大致可以分成两类，一类是系统提供的，另外一类则是由 Java 应用开发人员编写的。系统提供的类加载器主要有下面三个：引导类加载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。扩展类加载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。除了系统提供的类加载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类加载器，以满足一些特殊的需求。除了引导类加载器之外，所有的类加载器都有一个父类加载器。通过 getParent()方法可以得到。对于系统提供的类加载器来说，系统类加载器的父类加载器是扩展类加载器，而扩展类加载器的父类加载器是引导类加载器；对于开发人员编写的类加载器来说，其父类加载器是加载此类加载器 Java 类的类加载器。因为类加载器 Java 类如同其它的 Java 类一样，也是要由类加载器来加载的。一般来说，开发人员编写的类加载器的父类加载器是系统类加载器。类加载器通过这种方式组织起来，形成树状结构。 类加载器的代理模式类加载器在尝试自己去查找某个类的字节代码并定义它时，会先代理给其父类加载器，由父类加载器先去尝试加载这个类，依次类推。 Java 虚拟机是如何判定两个 Java 类是相同的?Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。 代理模式是为了保证 Java 核心库的类型安全。所有 Java 应用都至少需要引用 java.lang.Object类，也就是说在运行的时候，java.lang.Object这个类需要被加载到 Java 虚拟机中。如果这个加载过程由 Java 应用自己的类加载器来完成的话，很可能就存在多个版本的 java.lang.Object类，而且这些类之间是不兼容的。通过代理模式，对于 Java 核心库的类的加载工作由引导类加载器来统一完成，保证了 Java 应用所使用的都是同一个版本的 Java 核心库的类，是互相兼容的。不同的类加载器为相同名称的类创建了额外的名称空间。相同名称的类可以并存在 Java 虚拟机中，只需要用不同的类加载器来加载它们即可。不同类加载器加载的类之间是不兼容的，这就相当于在 Java 虚拟机内部创建了一个个相互隔离的 Java 类空间。 真正完成类的加载工作是通过调用 defineClass来实现的；而启动类的加载过程是通过调用 loadClass来实现的。前者称为一个类的定义加载器（defining loader），后者称为初始加载器（initiating loader）。在 Java 虚拟机判断两个类是否相同的时候，使用的是类的定义加载器。也就是说，哪个类加载器启动类的加载过程并不重要，重要的是最终定义这个类的加载器。两种类加载器的关联之处在于：一个类的定义加载器是它引用的其它类的初始加载器。如类 com.example.Outer引用了类 com.example.Inner，则由类 com.example.Outer的定义加载器负责启动类 com.example.Inner的加载过程。 方法 loadClass()抛出的是 java.lang.ClassNotFoundException异常；方法 defineClass()抛出的是 java.lang.NoClassDefFoundError异常。类加载器在成功加载某个类之后，会把得到的 java.lang.Class类的实例缓存起来。下次再请求加载该类的时候，类加载器会直接使用缓存的类的实例，而不会尝试再次加载。也就是说，对于一个类加载器实例来说，相同全名的类只加载一次，即 loadClass方法不会被重复调用。 loadClass()方法java.lang.ClassLoader类的方法 loadClass()封装了前面提到的代理模式的实现。 同时loadClass()体现了模板模式，这个方法定义了类加载的过程，属于方法基类，其中findClass(String name)是由子类实现的，即不同的classloader有不同的实现方法。12345678910111213141516171819202122232425262728293031323334353637protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; // First, check if the class has already been loaded Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; // ClassNotFoundException thrown if class not found // from the non-null parent class loader &#125; if (c == null) &#123; // If still not found, then invoke findClass in order // to find the class. long t1 = System.nanoTime(); c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 该方法会首先调用 findLoadedClass()方法来检查该类是否已经被加载过；如果没有加载过的话，会调用父类加载器的 loadClass()方法来尝试加载该类；如果父类加载器无法加载该类的话，就调用 findClass()方法来查找该类。因此，为了保证类加载器都正确实现代理模式，在开发自己的类加载器时，最好不要覆写 loadClass()方法，而是覆写 findClass()方法。 开发自己的类加载器首先继承 java.lang.ClassLoader然后，自己开发的类加载器只需要覆写 findClass(String name)方法即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class FileSystemClassLoader extends ClassLoader &#123; private String rootDir; public FileSystemClassLoader(String rootDir) &#123; this.rootDir = rootDir; &#125; protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; //得到类的全名的字节流 byte[] classData = getClassData(name); if (classData == null) &#123; throw new ClassNotFoundException(); &#125; else &#123; //定义一个类 return defineClass(name, classData, 0, classData.length); &#125; &#125; //将类的全名转为字节流输入 private byte[] getClassData(String className) &#123; String path = classNameToPath(className); try &#123; InputStream ins = new FileInputStream(path); ByteArrayOutputStream baos = new ByteArrayOutputStream(); int bufferSize = 4096; byte[] buffer = new byte[bufferSize]; int bytesNumRead = 0; while ((bytesNumRead = ins.read(buffer)) != -1) &#123; baos.write(buffer, 0, bytesNumRead); &#125; return baos.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125; private String classNameToPath(String className) &#123; return rootDir + File.separatorChar + className.replace('.', File.separatorChar) + \".class\"; &#125; public static void main(String[] args) &#123; String classDataRootPath = \"C:\\\\Documents and Settings\\\\Administrator\\\\workspace\\\\Classloader\\\\classData\"; FileSystemClassLoader fscl1 = new FileSystemClassLoader(classDataRootPath); FileSystemClassLoader fscl2 = new FileSystemClassLoader(classDataRootPath); String className = \"com.example.Sample\"; try &#123; Class&lt;?&gt; class1 = fscl1.loadClass(className); Object obj1 = class1.newInstance(); Class&lt;?&gt; class2 = fscl2.loadClass(className); Object obj2 = class2.newInstance(); Method setSampleMethod = class1.getMethod(\"setSample\", java.lang.Object.class); setSampleMethod.invoke(obj1, obj2); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 类 FileSystemClassLoader的 findClass()方法首先根据类的全名在硬盘上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass()方法来把这些字节代码转换成 java.lang.Class类的实例。 https://www.ibm.com/developerworks/cn/java/j-lo-classloader/#minor1.1 在每个类加载器中的执行顺序：loadClass-&gt;findClass-&gt;defineClass首先classloader主动调用loadClass，在loadClass中，如果父类不能加载就调用findClass，在findClass中找到类的全限定名，然后调用defineClass生成class。 #TODOhttp://www.infoq.com/cn/articles/cf-java-byte-codehttp://zyjustin9.iteye.com/blog/2092131http://www.cnblogs.com/xrq730/p/4847337.htmlcontextClassLoader Class.forName和classloader的区别Java中class.forName()和classLoader都可用来对类进行加载。class.forName()除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。而classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象123456//Class.forName(String className) 这是1.8的源码 public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); return forName0(className, true, ClassLoader.getClassLoader(caller), caller); &#125; //注意第二个参数，是指Class被loading后是不是必须被初始化。 不初始化就是不执行static的代码即静态代码 LoadClass（）方法加载类及初始化过程：类加载（loadclass（））（加载）——》newInstance（）（链接+初始化）newInstance（）:（开始连接）静态代码块——》普通变量分配准备（a=0;b=0;c=null）——》（开始初始化）普通变量赋值（a=1;b=2;c=”haha”）——》构造方法——》初始化成功。 Class.forName(Stirng className)一个参数方法加载类及初始化过程：类加载(Class.forName())（加载）——》静态代码块——》newInstance（）（链接+初始化） newInstance（）：（开始连接）普通变量分配准备（a=0;b=0;c=null）——》（开始初始化）普通变量赋值（a=1;b=2;c=”haha”）——》构造方法——》初始化成功。","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"java","slug":"java","permalink":"http://duyao.github.io/tags/java/"}]},{"title":"juc之同步工具和并发容器","slug":"juc之同步工具和并发容器","date":"2017-03-24T05:40:21.000Z","updated":"2017-04-27T05:03:20.000Z","comments":true,"path":"2017/03/24/juc之同步工具和并发容器/","link":"","permalink":"http://duyao.github.io/2017/03/24/juc之同步工具和并发容器/","excerpt":"","text":"同步工具http://watchmen.cn/portal.php?mod=view&amp;aid=513 ReentrantLock可中断public void lockInterruptibly() throws InterruptedException调用lockInterruptibly()声明可中断 可限时public boolean tryLock()public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException超时不能获得锁，就返回false，不会永久等待构成死锁 公平锁先来先得public ReentrantLock(boolean fair)public static ReentrantLock fairLock = new ReentrantLock(true); 可绑定条件ReentrantLock可以和多个condition一起使用 与synchronized区别主要区别就是ReentrantLock的四个特性：可中断、可限时、公平锁、可绑定多个条件synchronized比较简单，通常与一个对象相关联，悲观锁，ReentrantLock更高级，但是比较复杂，可以与多个对象相关联，乐观锁他们都是可重入的，synchronized子程序调用父类，不会产生死锁的。123456789101112public class Widget &#123; public synchronized void doSomething() &#123; ... &#125;&#125;public class LoggingWidget extends Widget &#123; public synchronized void doSomething() &#123; System.out.println(toString() + \": calling doSomething\"); super.doSomething();//若内置锁是不可重入的，则发生死锁 &#125;&#125; http://topmanopensource.iteye.com/blog/1736739http://www.importnew.com/20472.html 实现原理应用层面的锁，基本上使用java实现的，很少有很底层的东西 CAS原理 等待队列 LockSupport.park(); 基于AQS的锁(比如ReentrantLock)原理大体是这样:有一个state变量，初始值为0，假设当前线程为A,每当A获取一次锁，status++. 释放一次，status–.锁会记录当前持有的线程。当A线程拥有锁的时候，status&gt;0. B线程尝试获取锁的时候会对这个status有一个CAS(0,1)的操作，尝试几次失败后就挂起线程，进入一个等待队列。如果A线程恰好释放，–status==0, A线程会去唤醒等待队列中第一个线程，即刚刚进入等待队列的B线程，B线程被唤醒之后回去检查这个status的值，尝试CAS(0,1),而如果这时恰好C线程也尝试去争抢这把锁 非公平锁实现：C直接尝试对这个status CAS(0,1)操作，并成功改变了status的值，B线程获取锁失败，再次挂起，这就是非公平锁，B在C之前尝试获取锁，而最终是C抢到了锁。公平锁：C发现有线程在等待队列，直接将自己进入等待队列并挂起,B获取锁 http://www.cnblogs.com/xrq730/p/4979021.htmlhttp://www.importnew.com/19472.htmlhttp://blog.csdn.net/ns_code/article/details/17487337https://www.zhihu.com/question/36964449/answer/69790971?utm_source=com.youdao.note&amp;utm_medium=socialhttp://www.cnblogs.com/maxmys/p/5181775.html ReadWriteLockStampedLockCondition条件对象：进入临界区时发现必须满足一定的条件才能执行，那么就可以使用一个条件对象管理那些已经获得锁但是不能工作的线程类似于 Object.wait()和Object.notify()与ReentrantLock结合使用，一个ReentrantLock可以有多个Condition，习惯上给条件对象命名为可以反应它所表达的条件的名字 12345678910111213141516public void transfer(int from, int amount)&#123; ReentrantLock bank = new ReentrantLock(); Condition sufficient = bank.newCondition(); bank.lock();//如果使用锁就不能使用带资源的try语句 try &#123; while(!account[from] &lt; account)&#123; sufficient.await();//await调用必须方法while(!ok to proceed)中，阻塞线程 //transfer funds sufficient.signalAll();//解除等待线程的阻塞 &#125; &#125;finally &#123; bank.lock();//解锁一定要放在finally中 &#125;&#125; 主要方法 void await() throws InterruptedException;await()方法会使当前线程等待，同时释放当前锁，当其他线程中使用signal()时或者signalAll()方法时，线程会重新获得锁并继续执行。或者当线程被中断时，也能跳出等待。这和Object.wait()方法很相似。 void awaitUninterruptibly();awaitUninterruptibly()方法与await()方法基本相同，但是它并不会再等待过程中响应中断。 void signal();singal()方法用于唤醒一个在等待中的线程。 void signalAll();相对的singalAll()方法会唤醒所有在等待中的线程。这和Obejct.notify()方法很类似。 await、signal、signalAll必须抛异常 Semaphore信号量共享锁，运行多个线程同时临界 主要接口public void acquire()public void acquireUninterruptibly()public boolean tryAcquire()public boolean tryAcquire(long timeout, TimeUnit unit)public void release() 123456789101112131415161718192021222324252627282930public class SemaphoreDemo implements Runnable &#123; //只有两个信号量 final Semaphore semaphore = new Semaphore(2); static SemaphoreDemo demo = new SemaphoreDemo(); public static void main(String[] args) &#123; //有10个线程去抢夺 ExecutorService executor = Executors.newFixedThreadPool(10); for (int i = 0; i &lt; 10; i++) &#123; executor.submit(demo); &#125; &#125; @Override public void run() &#123; try &#123; //获得 semaphore.acquire(); Thread.sleep(1000); System.out.println(\"Thread \" + Thread.currentThread().getId() + \" done!\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; //释放 semaphore.release(); &#125; &#125;&#125; CountDownLatch倒数计时器一种典型的场景就是火箭发射。在火箭发射前，为了保证万无一失，往往还要进行各项设备、仪器的检查。只有等所有检查完毕后，引擎才能点火。这种场景就非常适合使用CountDownLatch。它可以使得点火线程，等待所有检查线程全部完工后，再执行 使用static final CountDownLatch end = new CountDownLatch(10);end.countDown();end.await(); 12345678910111213141516171819202122232425262728293031323334public class CountDownLatchDemo implements Runnable &#123; //5个任务需要检查 static final CountDownLatch end = new CountDownLatch(5); static final CountDownLatchDemo demo = new CountDownLatchDemo(); public static void main(String[] args) throws InterruptedException &#123; //执行5个线程完成检查，如果没有完成，所有线程就会阻塞，等待完成 // 所以线程的个数必须要与倒计时个数相同 ExecutorService executorService = Executors.newFixedThreadPool(5); for (int i = 0; i &lt; 5; i++) &#123; executorService.submit(demo); &#125; //等待通知 end.await(); System.out.println(\"Fired\"); executorService.shutdown(); &#125; @Override public void run() &#123; Random r = new Random(); try &#123; Thread.sleep(r.nextInt(5) * 1000); end.countDown(); System.out.println(\"chenk over, remaining \"+end.getCount() ); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; CyclicBarrier循环栅栏Cyclic意为循环，也就是说这个计数器可以反复使用。比如，假设我们将计数器设置为10。那么凑齐第一批10个线程后，计数器就会归零，然后接着凑齐下一批10个线程 主要接口 public CyclicBarrier(int parties, Runnable barrierAction)barrierAction就是当计数器一次计数完成后，系统会执行的动作，必须是实现Runnable接口 public int await() throws InterruptedException, BrokenBarrierException抛出InterruptedException中断异常的目的是避免线程中断，而一直阻塞，产生永久性的异常抛出BrokenBarrierException的原因是一批线程中只有凑够了个数才会执行。事实上，有可能出现其中一个线程出问题，那么导致其他线程阻塞无法执行，这时候其他线程就会抛出BrokenBarrierException，表示自己永远不能执行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class CyclicBarrierDemo &#123; public static class Soldier implements Runnable &#123; private String soldier; private final CyclicBarrier cyclic; public Soldier(CyclicBarrier cyclic, String soldier) &#123; this.soldier = soldier; this.cyclic = cyclic; &#125; @Override public void run() &#123; try &#123; //复用栅栏 //等待所有士兵到齐 cyclic.await(); doWork(); //等待所有士兵完成工作 cyclic.await(); &#125; catch (InterruptedException e) &#123;//在等待过程中,线程被中断 e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123;//表示当前CyclicBarrier已经损坏.系统无法等到所有线程到齐了. e.printStackTrace(); &#125; &#125; void doWork() &#123; try &#123; Thread.sleep(Math.abs(new Random().nextInt() % 10000)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(soldier + \":任务完成\"); &#125; &#125; public static class BarrierRun implements Runnable &#123; boolean flag; int N; public BarrierRun(boolean flag, int N) &#123; this.flag = flag; this.N = N; &#125; @Override public void run() &#123; if (flag) &#123; System.out.println(\"司令:[士兵\" + N + \"个,任务完成!]\"); &#125; else &#123; System.out.println(\"司令:[士兵\" + N + \"个,集合完毕!]\"); flag = true; &#125; &#125; &#125; public static void main(String[] args) &#123; final int N = 10; Thread[] allSoldier = new Thread[N]; boolean flag = false; //第二个参数就是当计数器一次计数完成后，系统会执行的动作 CyclicBarrier cyclic = new CyclicBarrier(N, new BarrierRun(flag, N)); //设置屏障点,主要为了执行这个方法 System.out.println(\"集合队伍! \"); for (int i = 0; i &lt; N; i++) &#123; System.out.println(\"士兵\" + i + \"报道! \"); allSoldier[i] = new Thread(new Soldier(cyclic, \"士兵\" + i)); allSoldier[i].start();// if(i == 5)&#123;// allSoldier[i].interrupt();// &#125; &#125; &#125;&#125; 区别CyclicBarrier是支持复用的，协调的是多个线程之间的顺序，即线程之间要互相等待，比如abc分别执行任务，然后等三个都完成之后才能继续执行新的任务CountDownLatch是一个线程等待其他多个线程的完成 LockSupport提供线程阻塞原语与suspend()比较，不容易引起线程冻结 同时能够响应中断，但不抛出异常。中断响应的结果是，park()函数的返回，可以从Thread.interrupted()得到中断标志 使用的比较底层的操作，类似于被广泛的应用在其他类的是实现中 主要接口LockSupport.park();LockSupport.unpark(Thread thread); 线程之间的通信http://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/ 并发容器对于容器map、set、list等，如果要实现同步，可以使用Collections.synchronizedMap(map),Collections.synchronizedList(list)d等方法但是这仅仅适合并发量小的情况。因为在其内部，使用synchronized控制final Object mutex变量的获取。每个方法在执行前，都会先获取mutex然后再执行，也就是这个map每次只能被一个线程操作，这样每个方法的执行过程相对就串行化，比如两个get完全不用获得锁123456789101112131415private static class SynchronizedMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Serializable&#123; private final Map&lt;K,V&gt; m; // Backing Map final Object mutex; // Object on which to synchronize public V get(Object key) &#123; synchronized (mutex) &#123;return m.get(key);&#125; &#125; public V put(K key, V value) &#123; synchronized (mutex) &#123;return m.put(key, value);&#125; &#125; public V remove(Object key) &#123; synchronized (mutex) &#123;return m.remove(key);&#125; &#125;&#125; ConcurrentHashMap高性能HashMap ConcurrentHashMap ConcurrentHashMap将hash表分为16个桶（默认值），诸如get,put,remove等常用操作只锁当前需要用到的桶。试想，原来只能一个线程进入，现在却能同时16个写线程进入（写线程才需要锁定，而读线程几乎不受限制，之后会提到），并发性的提升是显而易见的。更令人惊讶的是ConcurrentHashMap的读取并发，因为在读取的大多数时候都没有用到锁定，所以读取操作几乎是完全的并发操作，而写操作锁定的粒度又非常细，比起之前又更加快速（这一点在桶更多时表现得更明显些）。ConcurrentHashMap只有在求size等操作时才需要锁定整个表 java1.7实现方法 锁分离 (Lock Stripping) ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。 不变(Immutable)和易变(Volatile) ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。HashEntry代表每个hash链中的一个节点，其结构如下所示：123456static final class HashEntry&lt;K,V&gt; &#123; final K key; final int hash; volatile V value; final HashEntry&lt;K,V&gt; next; &#125; 可以看到除了value不是final的，其它值都是final的，这意味着不能从hash链的中间或尾部添加或删除节点，因为这需要修改next引用值，所有的节点的修改只能从头部开始。对于put操作，可以一律添加到Hash链的头部。但是对于remove操作，可能需要从中间删除一个节点，这就需要将要删除节点的前面所有节点整个复制一遍，最后一个节点指向要删除结点的下一个结点。这在讲解删除操作时还会详述。为了确保读操作能够看到最新的值，将value设置成volatile，这避免了加锁。 ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。12345678910111213141516171819202122232425262728293031323334353637static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123; private static final long serialVersionUID = 2249069246763182397L; /** * The number of elements in this segment's region. */ transient volatile int count; /** * Number of updates that alter the size of the table. This is * used during bulk-read methods to make sure they see a * consistent snapshot: If modCounts change during a traversal * of segments computing size or checking containsValue, then * we might have an inconsistent view of state so (usually) * must retry. */ transient int modCount; /** * The table is rehashed when its size exceeds this threshold. * (The value of this field is always &lt;tt&gt;(int)(capacity * * loadFactor)&lt;/tt&gt;.) */ transient int threshold; /** * The per-segment table. */ transient volatile HashEntry&lt;K,V&gt;[] table; /** * The load factor for the hash table. Even though this value * is same for all segments, it is replicated to avoid needing * links to outer object. * @serial */ final float loadFactor; &#125; 一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 get操作123456789101112131415V get(Object key, int hash) &#123; if (count != 0) &#123; // read-volatile HashEntry&lt;K,V&gt; e = getFirst(hash); while (e != null) &#123; if (e.hash == hash &amp;&amp; key.equals(e.key)) &#123; V v = e.value; if (v != null) return v; return readValueUnderLock(e); // recheck &#125; e = e.next; &#125; &#125; return null; &#125; get操作不需要锁。第一步是访问count变量，这是一个volatile变量，由于所有的修改操作在进行结构修改时都会在最后一步写count变量，通过这种机制保证get操作能够得到几乎最新的结构更新。对于非结构更新，也就是结点值的改变，由于HashEntry的value变量是volatile的，也能保证读取到最新的值。接下来就是对hash链进行遍历找到要获取的结点，如果没有找到，直接访回null。 对hash链进行遍历不需要加锁的原因在于链指针next是final的。但是头指针却不是final的，这是通过getFirst(hash)方法返回，也就是存在table数组中的值。这使得getFirst(hash)可能返回过时的头结点，例如，当执行get方法时，刚执行完getFirst(hash)之后，另一个线程执行了删除操作并更新头结点，这就导致get方法中返回的头结点不是最新的。这是可以允许，通过对count变量的协调机制，get能读取到几乎最新的数据，虽然可能不是最新的。要得到最新的数据，只有采用完全的同步。 最后，如果找到了所求的结点，判断它的值如果非空就直接返回，否则在有锁的状态下再读一次。 put操作123456789101112131415161718192021222324252627282930V put(K key, int hash, V value, boolean onlyIfAbsent) &#123; lock(); try &#123; int c = count; if (c++ &gt; threshold) // ensure capacity rehash(); HashEntry&lt;K,V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); HashEntry&lt;K,V&gt; first = tab[index]; HashEntry&lt;K,V&gt; e = first; while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key))) e = e.next; V oldValue; if (e != null) &#123; oldValue = e.value; if (!onlyIfAbsent) e.value = value; &#125; else &#123; oldValue = null; ++modCount; tab[index] = new HashEntry&lt;K,V&gt;(key, hash, first, value); count = c; // write-volatile &#125; return oldValue; &#125; finally &#123; unlock(); &#125; &#125; 该方法也是在持有段锁的情况下执行的，首先判断是否需要rehash，需要就先rehash。接着是找是否存在同样一个key的结点，如果存在就直接替换这个结点的值。否则创建一个新的结点并添加到hash链的头部，这时一定要修改modCount和count的值，同样修改count的值一定要放在最后一步。put方法调用了rehash方法，reash方法实现得也很精巧，主要利用了table的大小为2^n，这里就不介绍了。 remove操作整个操作是在持有段锁的情况下执行的，空白行之前的行主要是定位到要删除的节点e。接下来，如果不存在这个节点就直接返回null，否则就要将e前面的结点复制一遍，尾结点指向e的下一个结点。e后面的结点不需要复制，它们可以重用。 12345678910111213141516171819202122232425262728293031323334V remove(Object key, int hash, Object value) &#123; lock(); try &#123; int c = count - 1; HashEntry&lt;K,V&gt;[] tab = table; int index = hash &amp; (tab.length - 1); HashEntry&lt;K,V&gt; first = tab[index]; HashEntry&lt;K,V&gt; e = first; while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key))) e = e.next; V oldValue = null; if (e != null) &#123; V v = e.value; if (value == null || value.equals(v)) &#123; oldValue = v; // All entries following removed node can stay // in list, but all preceding ones need to be // cloned. ++modCount; HashEntry&lt;K,V&gt; newFirst = e.next; //复制 for (HashEntry&lt;K,V&gt; p = first; p != e; p = p.next) newFirst = new HashEntry&lt;K,V&gt;(p.key, p.hash, newFirst, p.value); tab[index] = newFirst; count = c; // write-volatile &#125; &#125; return oldValue; &#125; finally &#123; unlock(); &#125; &#125; remove方法 参考： http://www.iteye.com/topic/344876http://www.infoq.com/cn/articles/ConcurrentHashMap java1.8实现方法改进一：取消segments字段，直接采用transient volatile HashEntry[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。 改进二：将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。对于hash表来说，最核心的能力在于将key hash之后能均匀的分布在数组中。如果hash之后散列的很均匀，那么table数组中的每个队列长度主要为0或者1。但实际情况并非总是如此理想，虽然ConcurrentHashMap类默认的加载因子为0.75，但是在数据量过大或者运气不佳的情况下，还是会存在一些队列长度过长的情况，如果还是采用单向列表方式，那么查询某个节点的时间复杂度为O(n)；因此，对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能。 http://blog.csdn.net/u010412719/article/details/52145145http://www.cnblogs.com/everSeeker/p/5601861.html BlockingQueue阻塞队列，不是高性能，接口可以用于生产者消费者模式 123456789101112131415161718192021222324252627282930313233class Producer implements Runnable &#123; private final BlockingQueue queue; Producer(BlockingQueue q) &#123; queue = q; &#125; public void run() &#123; try &#123; while (true) &#123; queue.put(produce()); &#125; &#125; catch (InterruptedException ex) &#123; ... handle ...&#125; &#125; Object produce() &#123; ... &#125;&#125;class Consumer implements Runnable &#123; private final BlockingQueue queue; Consumer(BlockingQueue q) &#123; queue = q; &#125; public void run() &#123; try &#123; while (true) &#123; consume(queue.take()); &#125; &#125; catch (InterruptedException ex) &#123; ... handle ...&#125; &#125; void consume(Object x) &#123; ... &#125;&#125;class Setup &#123; void main() &#123; BlockingQueue q = new SomeQueueImplementation(); Producer p = new Producer(q); Consumer c1 = new Consumer(q); Consumer c2 = new Consumer(q); new Thread(p).start(); new Thread(c1).start(); new Thread(c2).start(); &#125;&#125; ArrayBlockingQueue1、入队列就将尾索引往右移动一个，新元素加入尾索引的位置；2、出队列就将头索引往尾索引方向移动一个，同时将旧头索引元素设为null，返回旧头索引的元素。3、一旦数组已满，那么就不允许添加新元素（除非扩充容量）4、如果尾索引移到了数组的最后（最大索引处），那么就从索引0开始，形成一个“闭合”的数组。5、由于头索引和尾索引之间的元素都不能为空（因为为空不知道take出来的元素为空还是队列为空），所以删除一个头索引和尾索引之间的元素的话，需要移动删除索引前面或者后面的所有元素，以便填充删除索引的位置。6、由于是阻塞队列，那么显然需要一个锁，另外由于只是一份数据（一个数组），所以只能有一个锁，也就是同时只能有一个线程操作队列。 主要通过ReentrantLock和Condition实现加锁、阻塞的功能12345678/** Main lock guarding all access */final ReentrantLock lock;/** Condition for waiting takes */private final Condition notEmpty;/** Condition for waiting puts */private final Condition notFull;/** The queued items */final Object[] items; put方法，先加锁，这里就证实了它并不是一个高性能容器，因为这里毫无分析的就加锁，性能一定不高12345678910111213141516171819202122232425262728293031public void put(E e) throws InterruptedException &#123; checkNotNull(e); //加锁 final ReentrantLock lock = this.lock; //响应阻塞 lock.lockInterruptibly(); try &#123; while (count == items.length) //队列满就等待 notFull.await(); enqueue(e); &#125; finally &#123; //释放锁 lock.unlock(); &#125;&#125;/*** Inserts element at current put position, advances, and signals.* Call only when holding lock.*/private void enqueue(E x) &#123; // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; count++; //通知不空 notEmpty.signal();&#125; 在java中可以使用BlockingQueue来实现消息队列，但是效率不是非常高，因为其内部不是无锁方式。 DisruptorDisruptor可以实现高性能生产者和消费者模式Disruptor通过以下设计来解决队列速度慢的问题： 环形数组结构为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。 元素位置定位数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。 无锁设计每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。 Diruptor 页面：https://github.com/LMAX-Exchange/disruptor待完成https://zhuanlan.zhihu.com/p/21355046https://www.bittiger.io/classpage/QHkP5QobvhNWGZv9fhttp://tech.meituan.com/disruptor.html LinkedBlockingQueueLinkedBlockingQueue有两个ReentrantLock和两个Condition以及用于AtomicInteger的count12345678910111213141516/** Current number of elements */private final AtomicInteger count = new AtomicInteger();/** Lock held by take, poll, etc */private final ReentrantLock takeLock = new ReentrantLock();/** Lock held by put, offer, etc */private final ReentrantLock putLock = new ReentrantLock();/** Wait queue for waiting takes */private final Condition notEmpty = takeLock.newCondition();/** Wait queue for waiting puts */private final Condition notFull = putLock.newCondition();/** Linked list node class */static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node(E x) &#123; item = x; &#125;&#125; 但是整体上讲，LinkedBlockingQueue和ConcurrentLinkedQueue的结构类似，都是采用头尾节点，每个节点指向下一个节点的结构，这表示它们在操作上应该类似。1、LinkedBlockingQueue引入了AtomicInteger的count，这意味着获取队列大小size()已经是常量时间了，不再需要遍历队列。每次队列长度有变更时只需要修改count即可。2、有了修改Node指向有了锁，所以不需要volatile特性了。3、引入了两个锁，一个入队列锁，一个出队列锁。当然同时有一个队列不满的Condition和一个队列不空的Condition。 参照锁机制的生产者-消费者模型就知道，入队列就代表生产者，出队列就代表消费者。为什么需要两个锁？一个锁行不行？其实一个锁完全可以，但是一个锁意味着入队列和出队列同时只能有一个在进行，另一个必须等待其释放锁。而从ConcurrentLinkedQueue的实现原理来看，事实上head和last (ConcurrentLinkedQueue中是tail)是分离的，互相独立的，这意味着入队列实际上是不会修改出队列的数据的，同时出队列也不会修改入队列，也就是说这两个操作是互不干扰的。更通俗的将，这个锁相当于两个写入锁，入队列是一种写操作，操作head，出队列是一种写操作，操作tail。可见它们是无关的。但是并非完全无关，后面详细分析。 入队列的阻塞过程大概是这样的：获取入队列的锁putLock，检测队列大小，如果队列已满，那么就挂起线程，等待队列不满信号notFull的唤醒。将元素加入到队列尾部，同时修改队列尾部引用last。队列大小加1。释放锁putLock。唤醒notEmpty线程（如果有挂起的出队列线程），告诉消费者，已经有了新的产品。12345678910111213141516171819202122232425262728293031public void put(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); // Note: convention in all put/take/etc is to preset local var // holding count negative to indicate failure unless set. int c = -1; Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try &#123; /* * Note that count is used in wait guard even though it is * not protected by lock. This works because count can * only decrease at this point (all other puts are shut * out by lock), and we (or some other waiting put) are * signalled if it ever changes from capacity. Similarly * for all other uses of count in other wait guards. */ while (count.get() == capacity) &#123; notFull.await(); &#125; enqueue(node); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty();&#125; 对比入队列，出队列的阻塞过程大概是这样的： 获取出队列的锁takeLock，检测队列大小，如果队列为空，那么就挂起线程，等待队列不为空notEmpty的唤醒。将元素从头部移除，同时修改队列头部引用head。队列大小减1。释放锁takeLock。唤醒notFull线程（如果有挂起的入队列线程），告诉生产者，现在还有空闲的空间。 ConcurrentLinkedQueue 一个基于链接节点的无界线程安全队列。此队列按照 FIFO（先进先出）原则对元素进行排序。队列的头部 是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择。此队列不允许使用 null 元素。 主要使用cas原理ConcurrentLinkedQueue只有头结点、尾节点两个元素，而对于一个节点Node而言除了保存队列元素item外，还有一个指向下一个节点的引用next。1234567private transient volatile Node&lt;E&gt; head;private transient volatile Node&lt;E&gt; tail;private static class Node&lt;E&gt; &#123; volatile E item; volatile Node&lt;E&gt; next; ...&#125; 1、所有结构（head/tail/item/next）都是volatile类型。 这是因为ConcurrentLinkedQueue是非阻塞的，所以只有volatile才能使变量的写操作对后续读操作是可见的（这个是有happens-before法则保证的）。同样也不会导致指令的重排序。2、由于队列中任何一个节点（Node）只有下一个节点的引用，所以这个队列是单向的，根据FIFO特性，也就是说出队列在头部(head)，入队列在尾部(tail)。头部保存有进入队列最长时间的元素，尾部是最近进入的元素。3、没有对队列长度进行计数，所以队列的长度是无限的，同时获取队列的长度的时间不是固定的，这需要遍历整个队列，并且这个计数也可能是不精确的。4、初始情况下队列头和队列尾都指向一个空节点，但是非null，这是为了方便操作，不需要每次去判断head/tail是否为空。但是head却不作为存取元素的节点，tail在不等于head情况下保存一个节点元素。也就是说head.item这个应该一直是空，但是tail.item却不一定是空（如果head!=tail，那么tail.item!=null）。1234567891011121314151617181920212223242526272829public boolean offer(E e) &#123; checkNotNull(e); final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); for (Node&lt;E&gt; t = tail, p = t;;) &#123; Node&lt;E&gt; q = p.next; if (q == null) &#123; // p is last node if (p.casNext(null, newNode)) &#123; // Successful CAS is the linearization point // for e to become an element of this queue, // and for newNode to become &quot;live&quot;. if (p != t) // hop two nodes at a time casTail(t, newNode); // Failure is OK. return true; &#125; // Lost CAS race to another thread; re-read next &#125; else if (p == q) // We have fallen off list. If tail is unchanged, it // will also be off-list, in which case we need to // jump to head, from which all live nodes are always // reachable. Else the new tail is a better bet. p = (t != (t = tail)) ? t : head; else // Check for tail updates after two hops. p = (p != t &amp;&amp; t != (t = tail)) ? t : q; &#125;&#125; http://www.infoq.com/cn/articles/ConcurrentLinkedQueuehttp://www.blogjava.net/xylz/archive/2010/07/23/326934.html 常见的BlockingQueue 各种 CopyOnWrite容器Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。 CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。 CopyOnWriteArrayList的实现原理123456789public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; /** The lock protecting all mutators */ final transient ReentrantLock lock = new ReentrantLock(); /** The array, accessed only via getArray/setArray. */ private transient volatile Object[] array; ...&#125; ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。1234567891011121314public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。123public E get(int index) &#123; return (E) a[index];&#125; 使用场景CopyOnWrite的应用场景 CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。 使用CopyOnWriteMap需要注意两件事情：1.减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。2.使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。 缺点CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。 内存占用问题。因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。 针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。 数据一致性问题。CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。 http://ifeve.com/java-copy-on-write/ volatile final不可变一定是线程安全的 同步更新、互斥同步、非阻塞同步","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://duyao.github.io/tags/jvm/"}]},{"title":"395. Longest Substring with At Least K Repeating Characters","slug":"395-Longest-Substring-with-At-Least-K-Repeating-Characters","date":"2017-03-22T12:45:03.000Z","updated":"2017-03-22T12:48:44.000Z","comments":true,"path":"2017/03/22/395-Longest-Substring-with-At-Least-K-Repeating-Characters/","link":"","permalink":"http://duyao.github.io/2017/03/22/395-Longest-Substring-with-At-Least-K-Repeating-Characters/","excerpt":"","text":"https://leetcode.com/problems/longest-substring-with-at-least-k-repeating-characters/#/description 类似于二分的做法找出小于k次出现的字符，然后以该字符二分区间，从而找到最长123456789101112131415161718192021222324252627282930313233343536public int longestSubstring(String s, int k) &#123; if (s == null || s.length() == 0 || k &lt; 1) &#123; return s.length(); &#125; return f(s, 0, s.length(), k);&#125;//找出每一段区间中那个少于k次的值，然后二分法求得每一段的长度public int f(String s, int a, int b, int k) &#123; if (b &lt; a) return 0; if (b - a + 1 &lt; k) return 0; //记录下来每一个字符出现的频率 int[] arr = new int[26]; for (int i = a; i &lt; b; i++) &#123; arr[s.charAt(i) - 'a']++; &#125; int len = b - a; for (int i = a; i &lt; b; i++) &#123; //找到小于k次的字符，然后用它分割整个区间 if (arr[s.charAt(i) - 'a'] &lt; k &amp;&amp; arr[s.charAt(i) - 'a'] &gt; 0) &#123; //二分法求值 int left = f(s, i + 1, b, k); int right = f(s, a, i, k); return Math.max(right, left); &#125; &#125; return len;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"}]},{"title":"3. Longest Substring Without Repeating Characters","slug":"3-Longest-Substring-Without-Repeating-Characters","date":"2017-03-20T14:31:55.000Z","updated":"2017-03-20T14:38:26.000Z","comments":true,"path":"2017/03/20/3-Longest-Substring-Without-Repeating-Characters/","link":"","permalink":"http://duyao.github.io/2017/03/20/3-Longest-Substring-Without-Repeating-Characters/","excerpt":"","text":"https://leetcode.com/problems/longest-substring-without-repeating-characters/#/solutions 这道题目就是用map存放已经遍历过字母的位置如果发现存在就重新设置起点的位置，注意设置起点位置是在当前起点和出现字符位置+1中选择大的，防止回退另外每次都要更新maxl，而不是只更换起点时候更新，因为一直没有重复的就不会发生更新最后计算长度的时候还要+1，因为都是闭区间 1234567891011121314151617181920212223public int lengthOfLongestSubstring(String s) &#123; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int start = 0, cur = 0; int maxl = 0; while (cur &lt; s.length()) &#123; if (map.containsKey(s.charAt(cur))) &#123; //注意这里不能单纯找后一个值，而是要比较当前值与回退值哪个大 //比如abba start = Math.max(start, map.get(s.charAt(cur)) + 1); &#125; //这里每次都要更新位置 map.put(s.charAt(cur), cur); //全部都是闭区间 maxl = Math.max(maxl, cur - start + 1); cur++; &#125; // System.out.println(maxl); return maxl;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"}]},{"title":"451. Sort Characters By Frequency","slug":"451-Sort-Characters-By-Frequency","date":"2017-03-20T13:15:19.000Z","updated":"2017-03-21T13:42:00.000Z","comments":true,"path":"2017/03/20/451-Sort-Characters-By-Frequency/","link":"","permalink":"http://duyao.github.io/2017/03/20/451-Sort-Characters-By-Frequency/","excerpt":"","text":"https://leetcode.com/problems/sort-characters-by-frequency/#/description 其实这是一个位图的思想首先，数组下标表示字符，而值表示出现的次数然后新建一个数组，和前一步相反，下标表示的次数，而值表示字符本身最后遍历第二个数组，因为下标就是次序，这个遍历的过程就已经排序了 还有个小问题就是char和int的转换，java中直接就可以转换了12int a = 97char c = (Char)97; 12345678910111213141516171819202122232425262728293031323334353637383940414243public String frequencySort(String s) &#123; if (s == null || s.length() == 0) &#123; return s; &#125; int maxf = 0; //首先算出每个值出现的频率 int fren[] = new int[128]; for (int i = 0; i &lt; s.length(); i++) &#123; int cur = s.charAt(i); fren[cur]++; maxf = Math.max(maxf, fren[cur]); &#125; //然后新建一个数组把频率作为下标，值就是字母的list，因为可能多个值出现同样的次数 //这个数组是一个list数组 ArrayList&lt;Character&gt;[] list = new ArrayList[maxf + 1]; for (int i = 0; i &lt; 128; i++) &#123; if (fren[i] != 0) &#123; if (list[fren[i]] == null) &#123; list[fren[i]] = new ArrayList&lt;&gt;(); &#125; list[fren[i]].add((char) i); &#125; &#125; //遍历新建的数组 StringBuffer sb = new StringBuffer(); for (int i = maxf; i &gt;= 0; i--) &#123; if (list[i] != null) &#123; for (int k = 0; k &lt; list[i].size(); k++) &#123; for (int j = 0; j &lt; i; j++) &#123; sb.append(list[i].get(k)); &#125; &#125; &#125; &#125; return sb.toString();&#125; 同样的题目还有347https://leetcode.com/problems/top-k-frequent-elements/#/description","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"}]},{"title":"105. Construct Binary Tree from Preorder and Inorder Traversal","slug":"105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal","date":"2017-03-20T09:41:38.000Z","updated":"2017-04-12T14:03:22.000Z","comments":true,"path":"2017/03/20/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","link":"","permalink":"http://duyao.github.io/2017/03/20/105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal/","excerpt":"","text":"根据先序中序得到树，这类问题都是用递归来解决的 https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/#/description1234567891011121314151617181920212223242526272829public TreeNode buildTree(int[] preorder, int[] inorder) &#123; if(preorder == null || preorder.length == 0 || inorder == null || inorder.length == 0)&#123; return null; &#125; return f(preorder, inorder, 0, 0, inorder.length);&#125;public TreeNode f(int[] preorder, int[] inorder, int pre, int inl, int inr) &#123; //这里所有的区间都是左闭右开 if (pre &gt;= preorder.length || inl &gt;= inr) &#123; return null; &#125; int r = -1; //寻找根在中序的位置 for (int i = inl; i &lt; inr; i++) &#123; if (inorder[i] == preorder[pre]) &#123; r = i; break; &#125; &#125; TreeNode root = new TreeNode(preorder[pre]); //左子树的根节点就是pre的后面一个 root.left = f(preorder, inorder, pre + 1, inl, r); //右子树的根节点就是pre+左子树的长度的后面一个 root.right = f(preorder, inorder, pre + (r - inl) + 1, r + 1, inr); return root;&#125; https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/#/description123456789101112131415161718192021222324252627282930public TreeNode buildTree(int[] inorder, int[] postorder) &#123; if (postorder == null || postorder.length == 0 || inorder == null || inorder.length == 0) &#123; return null; &#125; //初始，根的位置在最后 return f(postorder, inorder, postorder.length-1, 0, inorder.length);&#125;public TreeNode f(int[] postorder, int[] inorder, int post, int inl, int inr) &#123; //这里所有的区间都是左闭右开 if (post &gt;= postorder.length || inl &gt;= inr) &#123; return null; &#125; int r = -1; //寻找根在中序的位置 for (int i = inl; i &lt; inr; i++) &#123; if (inorder[i] == postorder[post]) &#123; r = i; break; &#125; &#125; TreeNode root = new TreeNode(postorder[post]); //左子树的根节点就是post减去右子树长度的前一个 root.left = f(postorder, inorder, post - (inr - r - 1) - 1, inl, r); //右子树的根节点就是pre的前一个 root.right = f(postorder, inorder, post - 1, r + 1, inr); return root;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"}]},{"title":"web开发","slug":"web开发","date":"2017-03-20T00:48:08.000Z","updated":"2017-05-13T13:41:00.000Z","comments":true,"path":"2017/03/20/web开发/","link":"","permalink":"http://duyao.github.io/2017/03/20/web开发/","excerpt":"","text":"springmvcspringmvc主要是DipatcherServlet完成的。DipatcherServlet其本身是一个Servlet,他继承了HttpServlet，因此在servlet启动时调用init方法就可以把DipatcherServlet启动起来。DipatcherServlet在启动时做了很多事情，主要的是初始化了HandlerMappings映射关系和ViewResolvers解析页面、HandlerAdapters实现业务逻辑的handler实例对象 在HandlerAdapters中可以得到ModelAndView。ModelAndView是view和handler实例对象的纽带ViewResolvers可以完成设置页面渲染比如是freemaker或者velocity http://jinnianshilongnian.iteye.com/blog/1617451 工作过程 springmvc工作过程 springmvc工作过程 工作原理:(在HandlerMapping以前做的事情：1、文件上传解析，如果请求类型是multipart将通过MultipartResolver进行文件上传解析；)1、客户端发出一个http请求给web服务器，web服务器对http请求进行解析，如果匹配DispatcherServlet的请求映射路径（在web.xml中指定），web容器将请求转交给DispatcherServlet. 2、DipatcherServlet接收到这个请求之后将根据请求的信息（包括URL、Http方法、请求报文头和请求参数Cookie等）以及HandlerMapping的配置找到处理请求的处理器（Handler）。 3-4、DispatcherServlet根据HandlerMapping找到对应的Handler,将处理权交给Handler（Handler将具体的处理进行封装），再由具体的HandlerAdapter对Handler进行具体的调用。 5、Handler对数据处理完成以后将返回一个ModelAndView()对象给DispatcherServlet。 6、Handler返回的ModelAndView()只是一个逻辑视图并不是一个正式的视图，DispatcherSevlet通过ViewResolver将逻辑视图转化为真正的视图View。 7、Dispatcher通过model解析出ModelAndView()中的参数进行解析最终展现出完整的view并返回给客户端。 DispatcherServlet中使用的特殊的BeanDispatcherServlet默认使用WebApplicationContext作为上下文，因此我们来看一下该上下文中有哪些特殊的Bean：1、Controller：处理器/页面控制器，做的是MVC中的C的事情，但控制逻辑转移到前端控制器了，用于对请求进行处理；2、HandlerMapping：请求到处理器的映射，如果映射成功返回一个HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象；如BeanNameUrlHandlerMapping将URL与Bean名字映射，映射成功的Bean就是此处的处理器；3、HandlerAdapter：HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；如SimpleControllerHandlerAdapter将对实现了Controller接口的Bean进行适配，并且掉处理器的handleRequest方法进行功能处理；4、ViewResolver：ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；如InternalResourceViewResolver将逻辑视图名映射为jsp视图；5、LocalResover：本地化解析，因为Spring支持国际化，因此LocalResover解析客户端的Locale信息从而方便进行国际化；6、ThemeResovler：主题解析，通过它来实现一个页面多套风格，即常见的类似于软件皮肤效果；7、MultipartResolver：文件上传解析，用于支持文件上传；8、HandlerExceptionResolver：处理器异常解析，可以将异常映射到相应的统一错误界面，从而显示用户友好的界面（而不是给用户看到具体的错误信息）；9、RequestToViewNameTranslator：当处理器没有返回逻辑视图名等相关信息时，自动将请求URL映射为逻辑视图名；10、FlashMapManager：用于管理FlashMap的策略接口，FlashMap用于存储一个请求的输出，当进入另一个请求时作为该请求的输入，通常用于重定向场景，后边会细述。 http://jinnianshilongnian.iteye.com/blog/1602617更多资料http://jinnianshilongnian.iteye.com/blog/1752171 配置文件在web.xml中配置springmvc和spring的applicationcontext123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app version=&quot;2.4&quot; xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt; &lt;display-name&gt;Spring MVC Study&lt;/display-name&gt; &lt;!-- Spring应用上下文， 理解层次化的ApplicationContext --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/configs/spring/applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- DispatcherServlet, Spring MVC的核心 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt; org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- DispatcherServlet对应的上下文配置， 默认为/WEB-INF/$servlet-name$-servlet.xml --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/configs/spring/mvc-dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;!-- mvc-dispatcher拦截所有的请求--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 继续对springmvc进行详细配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 本配置文件是工名为mvc-dispatcher的DispatcherServlet使用， 提供其相关的Spring MVC配置 --&gt; &lt;!-- 启用Spring基于annotation的DI, 使用户可以在Spring MVC中使用Spring的强大功能。 激活 @Required @Autowired,JSR 250&apos;s @PostConstruct, @PreDestroy and @Resource 等标注 --&gt; &lt;context:annotation-config /&gt; &lt;!-- DispatcherServlet上下文， 只管理@Controller类型的bean， 忽略其他型的bean, 如@Service --&gt; &lt;context:component-scan base-package=&quot;com.imooc.mvcdemo&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot; /&gt; &lt;/context:component-scan&gt; &lt;!-- HandlerMapping, 无需配置， Spring MVC可以默认启动。 DefaultAnnotationHandlerMapping annotation-driven HandlerMapping --&gt; &lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制器参数 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 静态资源处理， css， js， imgs --&gt; &lt;mvc:resources mapping=&quot;/resources/**&quot; location=&quot;/resources/&quot; /&gt; &lt;!-- 配置ViewResolver。 可以用多个ViewResolver。 使用order属性排序。 InternalResourceViewResolver放在最后。 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.ContentNegotiatingViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot; /&gt; &lt;property name=&quot;mediaTypes&quot;&gt; &lt;map&gt; &lt;entry key=&quot;json&quot; value=&quot;application/json&quot; /&gt; &lt;entry key=&quot;xml&quot; value=&quot;application/xml&quot; /&gt; &lt;entry key=&quot;htm&quot; value=&quot;text/html&quot; /&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;defaultViews&quot;&gt; &lt;list&gt; &lt;!-- JSON View --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.json.MappingJackson2JsonView&quot;&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;ignoreAcceptHeader&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsps/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;/bean&gt; &lt;!--200*1024*1024即200M resolveLazily属性启用是为了推迟文件解析，以便捕获文件大小异常 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;209715200&quot; /&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;property name=&quot;resolveLazily&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt;&lt;/beans&gt; 常用注解@RequestMapping value：指定请求的实际url method：指定请求的method类型， GET、POST、PUT、DELETE等@RequestMapping(value=&quot;/get/{bookid}&quot;,method={RequestMethod.GET,RequestMethod.POST}) params：指定request中必须包含某些参数值是，才让该方法处理。@RequestMapping(params=&quot;action=del&quot;)，请求参数包含“action=del”,如：http://localhost:8080/book?action=del 123456789@Controller@RequestMapping(&quot;/owners/&#123;ownerId&#125;&quot;)public class RelativePathUriTemplateController &#123; @RequestMapping(value = &quot;/pets/&#123;petId&#125;&quot;, method = RequestMethod.GET, params=&quot;myParam=myValue&quot;) public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) &#123; // implementation omitted &#125;&#125; 仅处理请求中包含了名为“myParam”，值为“myValue”的请求。 headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。@RequestMapping(value=&quot;/header/id&quot;, headers = &quot;Accept=application/json&quot;)：表示请求的URL必须为“/header/id 且请求头中必须有“Accept =application/json”参数即可匹配。 consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html。 12345@Controller@RequestMapping(value = &quot;/pets&quot;, method = RequestMethod.POST, consumes=&quot;application/json&quot;)public void addPet(@RequestBody Pet pet, Model model) &#123; // implementation omitted&#125; 方法仅处理request Content-Type为“application/json”类型的请求。 produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回。 @RequestParam@RequestParam用于将请求参数区数据映射到功能处理方法的参数上。比如public String requestparam1(@RequestParam String username) 请求中包含username参数（如/requestparam1?username=zhang），则自动传入。 @RequestParam有以下三个参数： value：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入； required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将抛出异常； defaultValue：默认值，表示如果请求中没有同名参数时的默认值，设置该参数时，自动将required设为false。 public String requestparam4(@RequestParam(value=&quot;username&quot;,required=false) String username)表示请求中可以没有名字为username的参数，如果没有默认为null，此处需要注意如下几点：原子类型：必须有值，否则抛出异常，如果允许空值请使用包装类代替。Boolean包装类型：默认Boolean.FALSE，其他引用类型默认为null。 如果请求参数类似于url?role=admin&amp;rule=user，则实际roleList参数入参的数据为“admin,user”，即多个数据之间使用“，”分割；我们应该使用如下方式来接收多个请求参数：a）public String requestparam7(@RequestParam(value=&quot;role&quot;) String[] roleList)b)public String requestparam8(@RequestParam(value=&quot;list&quot;) List&lt;String&gt; list) @PathVariable@PathVariable用于将请求URL中的模板变量映射到功能处理方法的参数上。1234@RequestMapping(value=&quot;/users/&#123;userId&#125;/topics/&#123;topicId&#125;&quot;)public String test( @PathVariable(value=&quot;userId&quot;) int userId, @PathVariable(value=&quot;topicId&quot;) int topicId) 如请求的URL为“控制器URL/users/123/topics/456”，则自动将URL中模板变量{userId}和{topicId}绑定到通过@PathVariable注解的同名参数上，即入参后userId=123、topicId=456。 @RequestBody@ResponseBody作用：该注解用于将Controller的方法返回的对象，通过适当的HttpMessageConverter转换为指定格式后，写入到Response对象的body数据区。使用时机：返回的数据不是html标签的页面，而是其他某种格式的数据时（如json、xml等）使用； @ModelAttribute注释方法被@ModelAttribute注释的方法表示这个方法的目的是增加一个或多个模型(model)属性。这个方法和被@RequestMapping注释的方法一样也支持@RequestParam参数，但是它不能直接被请求映射。实际上，控制器中的@ModelAttribute方法是在同一控制器中的@RequestMapping方法被调用之前调用的。 注释参数–数据绑定@ModelAttribute注释方法的一个参数表示应从模型model中取得。若在model中未找到，那么这个参数将先被实例化后加入到model中。若在model中找到，则请求参数名称和model属性字段若相匹配就会自动填充。这个机制对于表单提交数据绑定到对象属性上很有效。 当@ModelAttribute注解用于方法参数时，它有了双重功能，即“存/取”。首先，它从模型中取出数据并赋予对应的参数，如果模型中尚不存在，则实例化一个，并存放于模型中；其次，一旦模型中已存在此数据对象，接下来一个很重要的步骤便是将请求参数绑定到此对象上（请求参数名映射对象属性名）这是Spring MVC提供的一个非常便利的机制–数据绑定。 当@ModelAttribute注解用于方法时，与其处于同一个处理类的所有请求方法执行前都会执行一次此方法，这可能并不是我们想要的因此，我们使用更多的是将其应用在请求方法的参数上，而它的一部分功能与@RequestParam注解是一致的，只不过@RequestParam用于绑定单个参数值，而@ModelAttribute注解可以绑定所有名称匹配的，此外它自动将绑定后的数据添加到模型中，无形中也给我们提供了便利，这也可能是它命名为ModelAttribute的原因。 http://www.cnblogs.com/xiaoxi/p/5718894.html redirect和forward forward 转发，如return “forward:/hello”; 浏览器的地址栏不会变，但是有视图返回来 forward方式相当于request.getRequestDispatcher().forward(request,response)，这种方式的外部特征是浏览器地址显示的路径是转发前的路径.工作方式是这样,forward 发生在服务器内部,在前一个控制器处理完毕后,直接进入下一个控制器处理, 并将最后的response发给浏览器. 这种方式的结果是: A.转发前后是同一个request,后一个控制器可共享前一个控制器的参数与属性;B.因为是同一个request,拦截器只会拦截前一个url,如果前一个url在映射时未配置到拦截器拦截，则拦截后一个url，即只拦截一次;C.最后返回到浏览器后,因为地址栏显示的是转发前的url,所以刷新页面时会依次执行前后两个控制器. redirect 重定向，如return “redirect:/hello”; 浏览器的地址栏会变。 spring控制器最后返回一个ModelAndView(urlName),其中urNamel可以是一个视图名称,由视图解析器负责解析后将响应流写回客户端;也可以通过redirect/forward:url方式转到另一个控制器进行处理. redirect方式相当于”response.sendRedirect()”.这种方式外部特征就是浏览器地址栏最后显示的路径是转发后的新的路径.工作方式是这样的, 服务器端会首先发一个response给浏览器, 然后浏览器收到这个response后再发一个requeset给服务器, 然后服务器发新的response给浏览器. 这时页面收到的request是一个新从浏览器发来的.这种方式的结果是: A.在转发前后有两个不同的request对象,转发前后的两个控制器在request上的参数(request.getParameter())和request属性(request.getAttribute())不能共享;B.如果转发前后的两个控制器都配置在spring 拦截器范围内,这样拦截器会拦截前后两个request,即会拦截两次;C.最后返回到浏览器后,因为地址栏显示的是转发后的url,所以刷新页面时只会执行后面的url映射的控制器. springmvc与struts2的区别1、Struts2是类级别的拦截， 一个类对应一个request上下文，SpringMVC是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应,所以说从架构本身上SpringMVC就容易实现restful url,而struts2的架构实现起来要费劲，因为Struts2中Action的一个方法可以对应一个url，而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。2、由上边原因，SpringMVC的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架，方法之间不共享变量，而Struts2搞的就比较乱，虽然方法之间也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码 读程序时带来麻烦，每次来了请求就创建一个Action，一个Action对象对应一个request上下文。3、由于Struts2需要针对每个request进行封装，把request，session等servlet生命周期的变量封装成一个一个Map，供给每个Action使用，并保证线程安全，所以在原则上，是比较耗费内存的。4、 拦截器实现机制上，Struts2有以自己的interceptor机制，SpringMVC用的是独立的AOP方式，这样导致Struts2的配置文件量还是比SpringMVC大。5、SpringMVC的入口是servlet，而Struts2是filter（这里要指出，filter和servlet是不同的。以前认为filter是servlet的一种特殊），这就导致了二者的机制不同，这里就牵涉到servlet和filter的区别了。6、SpringMVC集成了Ajax，使用非常方便，只需一个注解@ResponseBody就可以实现，然后直接返回响应文本即可，而Struts2拦截器集成了Ajax，在Action中处理时一般必须安装插件或者自己写代码集成进去，使用起来也相对不方便。http://blog.csdn.net/chenleixing/article/details/44570681http://blog.csdn.net/gstormspire/article/details/8239182 线程安全问题对于使用过SpringMVC和Struts2的人来说，大家都知道SpringMVC是基于方法的拦截，而Struts2是基于类的拦截。 对于Struts2来说，因为每次处理一个请求，struts就会实例化一个对象；这样就不会有线程安全的问题了;而Spring的controller默认是Singleton的，这意味着每一个request过来，系统都会用原有的instance去处理，这样导致两个结果：一是我们不用每次创建Controller，二是减少了对象创建和垃圾收集的时间;由于只有一个Controller的instance，当多个线程调用它的时候，它里面的instance变量就不是线程安全的了，会发生窜数据的问题。 当然大多数情况下，我们根本不需要考虑线程安全的问题，比如dao,service等，除非在bean中声明了实例变量。因此，我们在使用spring mvc 的contrller时，应避免在controller中定义实例变量。如：123456public class Controller extends AbstractCommandController &#123; protected Company company; protected ModelAndView handle(HttpServletRequest request,HttpServletResponse response,Object command,BindException errors) throws Exception &#123; company = ................; &#125; &#125; 解决方案：有几种解决方法：1、在Controller中使用ThreadLocal变量2、在spring配置文件Controller中声明 scope=”prototype”，每次都创建新的controller所在在使用spring开发web 时要注意，默认Controller、Dao、Service都是单例的。 http://blog.csdn.net/hejingyuan6/article/details/50363647 如果在spring中使用多线程http://blog.csdn.net/hejingyuan6/article/details/51498401 ibatis主要完成两件事情:根据jdbc完成数据库的连接通过反射打通java对象与数据库交互 ibatis的主要方法 SqlMapClient接口主要定义了客户端的操作行为比如insert、update、select和deleteSqlMapSession主要定义了客户端的当前执行环境，可以共享也可以自己创建但一个用户持有了SqlMapClientImpl就可以使用ibatis工作了 iBATIS 框架的一个重要组成部分就是其 SqlMap 配置文件，SqlMap 配置文件的核心是 Statement 语句包括 CIUD。 iBATIS 通过解析 SqlMap 配置文件得到所有的 Statement 执行语句，同时会形成 ParameterMap、ResultMap 两个对象用于处理参数和经过解析后交给数据库处理的 Sql 对象。这样除去数据库的连接，一条 SQL 的执行条件已经具备了。 数据的映射大体的过程是这样的：根据 Statement 中定义的 SQL 语句，解析出其中的参数，按照其出现的顺序保存在 Map 集合中，并按照 Statement 中定义的 ParameterMap 对象类型解析出参数的 Java 数据类型。并根据其数据类型构建 TypeHandler 对象，参数值的复制是通过 DataExchange 对象完成的。 http://blog.csdn.net/column/details/mybatis-principle.html https://www.ibm.com/developerworks/cn/java/j-lo-ibatis-principle/index.html mybatis初始化过程12345String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession sqlSession = sqlSessionFactory.openSession(); List list = sqlSession.selectList(&quot;com.foo.bean.BlogMapper.queryAllBlogInfo&quot;); 上述语句的作用是执行com.foo.bean.BlogMapper.queryAllBlogInfo 定义的SQL语句，返回一个List结果集。总的来说，上述代码经历了mybatis初始化 –&gt;创建SqlSession –&gt;执行SQL语句 返回结果三个过程new SqlSessionFactoryBuilder().build(inputStream)这句话是SqlSessionFactoryBuilder根据传入的数据流生成Configuration对象，然后根据Configuration对象创建默认的SqlSessionFactory实例。 http://blog.csdn.net/luanlouis/article/details/37744073 Mybatis数据源与连接池MyBatis把数据源DataSource分为三种： UNPOOLED 不使用连接池的数据源 POOLED 使用连接池的数据源 JNDI 使用JNDI实现的数据源 创建DataSourceMyBatis数据源DataSource对象的创建发生在MyBatis初始化的过程中。在mybatis的XML配置文件中，使用元素来配置数据源 创建connection当我们需要创建SqlSession对象并需要执行SQL语句时，这时候MyBatis才会去调用dataSource对象来创建java.sql.Connection对象。也就是说，java.sql.Connection对象的创建一直延迟到执行SQL语句的时候。 不使用连接池使用UnpooledDataSource的getConnection(),每调用一次就会产生一个新的Connection实例对象。 使用连接池使用PooledDataSource的getConnection()方法来返回Connection对象。PooledDataSource将java.sql.Connection对象包裹成PooledConnection对象放到了PoolState类型的容器中维护。MyBatis将连接池中的PooledConnection分为两种状态： 空闲状态（idle）和活动状态(active)，这两种状态的PooledConnection对象分别被存储到PoolState容器内的idleConnections和activeConnections两个List集合中： idleConnections:空闲(idle)状态PooledConnection对象被放置到此集合中，表示当前闲置的没有被使用的PooledConnection集合，调用PooledDataSource的getConnection()方法时，会优先从此集合中取PooledConnection对象。当用完一个java.sql.Connection对象时，MyBatis会将其包裹成PooledConnection对象放到此集合中。 activeConnections:活动(active)状态的PooledConnection对象被放置到名为activeConnections的ArrayList中，表示当前正在被使用的PooledConnection集合，调用PooledDataSource的getConnection()方法时，会优先从idleConnections集合中取PooledConnection对象,如果没有，则看此集合是否已满，如果未满，PooledDataSource会创建出一个PooledConnection，添加到此集合中，并返回。 用完connection使用代理模式，为真正的Connection对象创建一个代理对象，代理对象所有的方法都是调用相应的真正Connection对象的方法实现。当代理对象执行close()方法时，要特殊处理，不调用真正Connection对象的close()方法，而是将Connection对象添加到连接池中。 http://blog.csdn.net/luanlouis/article/details/37671851 缓存一级缓存每当我们使用MyBatis开启一次和数据库的会话，MyBatis会创建出一个SqlSession对象表示一次数据库会话。在对数据库的一次会话中，我们有可能会反复地执行完全相同的查询语句，如果不采取一些措施的话，每一次查询都会查询一次数据库,而我们在极短的时间内做了完全相同的查询，那么它们的结果极有可能完全相同，由于查询一次数据库的代价很大，这有可能造成很大的资源浪费。为了解决这一问题，减少资源的浪费，MyBatis会在表示会话的SqlSession对象中建立一个简单的缓存，将每次查询到的结果结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会直接从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了。 MyBatis会在一次会话的表示—-一个SqlSession对象中创建一个本地缓存(local cache)，对于每一次查询，都会尝试根据查询的条件去本地缓存中查找是否在缓存中，如果在缓存中，就直接从缓存中取出，然后返回给用户；否则，从数据库读取数据，将查询结果存入缓存并返回给用户。 mybatis一级缓存 实际上, SqlSession只是一个MyBatis对外的接口，SqlSession将它的工作交给了Executor执行器这个角色来完成，负责完成对数据库的各种操作。当创建了一个SqlSession对象时，MyBatis会为这个SqlSession对象创建一个新的Executor执行器，而缓存信息就被维护在这个Executor执行器中，MyBatis将缓存和对缓存相关的操作封装成了Cache接口中。 一级缓存的生命周期a. MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象，Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。b. 如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用；c. 如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用；d.SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用； Cache原理Cache最核心的实现其实就是一个Map，将本次查询使用的特征值作为key，将查询结果作为value存储到Map中。怎样来确定一次查询的特征值？换句话说就是：怎样判断某两次查询是完全相同的查询？也可以这样说：如何确定Cache中的key值？MyBatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询： 传入的 statementId 查询时要求的结果集中的结果范围 （结果的范围通过rowBounds.offset和rowBounds.limit表示）； 这次查询所产生的最终要传递给JDBC Java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ） 传递给java.sql.Statement要设置的参数值综上所述,CacheKey由以下条件决定：statementId + rowBounds + 传递给JDBC的SQL + 传递给JDBC的参数值 总结1.MyBatis对会话（Session）级别的一级缓存设计的比较简单，就简单地使用了HashMap来维护，并没有对HashMap的容量和大小进行限制。读者有可能就觉得不妥了：如果我一直使用某一个SqlSession对象查询数据，这样会不会导致HashMap太大，而导致 java.lang.OutOfMemoryError错误啊？ 读者这么考虑也不无道理，不过MyBatis的确是这样设计的。MyBatis这样设计也有它自己的理由：a. 一般而言SqlSession的生存时间很短。一般情况下使用一个SqlSession对象执行的操作不会太多，执行完就会消亡；b. 对于某一个SqlSession对象而言，只要执行update操作（update、insert、delete），都会将这个SqlSession对象中对应的一级缓存清空掉，所以一般情况下不会出现缓存过大，影响JVM内存空间的问题；c. 可以手动地释放掉SqlSession对象中的缓存。 一级缓存是一个粗粒度的缓存，没有更新缓存和缓存过期的概念MyBatis的一级缓存就是使用了简单的HashMap，MyBatis只负责将查询数据库的结果存储到缓存中去， 不会去判断缓存存放的时间是否过长、是否过期，因此也就没有对缓存的结果进行更新这一说了。 根据一级缓存的特性，在使用的过程中，我认为应该注意：1、对于数据变化频率很大，并且需要高时效准确性的数据要求，我们使用SqlSession查询的时候，要控制好SqlSession的生存时间，SqlSession的生存时间越长，它其中缓存的数据有可能就越旧，从而造成和真实数据库的误差；同时对于这种情况，用户也可以手动地适时清空SqlSession中的缓存；2、对于只执行、并且频繁执行大范围的select操作的SqlSession对象，SqlSession对象的生存时间不应过长。 二级缓存MyBatis并不是简单地对整个Application就只有一个Cache缓存对象，它将缓存划分的更细，即是Mapper级别的，即每一个Mapper都可以拥有一个Cache对象，具体如下：a.为每一个Mapper分配一个Cache缓存对象（使用节点配置）；b.多个Mapper共用一个Cache缓存对象（使用节点配置）； mybatis二级缓存 具备的条件MyBatis对二级缓存的支持粒度很细，它会指定某一条查询语句是否使用二级缓存。虽然在Mapper中配置了&lt;cache&gt;,并且为此Mapper分配了Cache对象，这并不表示我们使用Mapper中定义的查询语句查到的结果都会放置到Cache对象之中，我们必须指定Mapper中的某条选择语句是否支持缓存，即如下所示，在&lt;select&gt; 节点中配置useCache=”true”，Mapper才会对此Select的查询支持缓存特性，否则，不会对此Select查询，不会经过Cache缓存。如下所示，Select语句配置了useCache=”true”，则表明这条Select语句的查询会使用二级缓存。&lt;select id=&quot;selectByMinSalary&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.util.Map&quot; useCache=&quot;true&quot;&gt; 总之，要想使某条Select查询支持二级缓存，你需要保证： MyBatis支持二级缓存的总开关：全局配置变量参数 cacheEnabled=true 该select语句所在的Mapper，配置了 或节点，并且有效 该select语句的参数 useCache=true MyBatis查询数据的顺序是： 二级缓存 ———&gt; 一级缓存——&gt; 数据库http://blog.csdn.net/luanlouis/article/details/41408341 #与$区别一般如果可以使用#就不要使用$符号。1）使用#入参，myBatis会生成PrepareStatement并且可以安全地设置参数（=?）的值。因为sql语句已经预编译好了，传入参数的时候，不会重新生产sql语句。安全性高。2）用$可以会有sql注入的问题：例如，select * from emp where ename = &#39;用户名&#39;，如果使用$入参，用户名被传入例如smith or 1 = 1，那无论ename是否匹配都能查到结果。3）在特定场景下，例如如果在使用诸如order by &#39;{param}&#39;，这时候就可以使用$. http://www.mybatis.org/mybatis-3/sqlmap-xml.html#String_Substitution velocityVelocity 是一个基于 Java 的模板引擎框架，提供的模板语言可以使用在 Java 中定义的对象和变量上。Velocity 是 Apache 基金会的项目，开发的目标是分离 MVC 模式中的持久化层和业务层。但是在实际应用过程中，Velocity 不仅仅被用在了 MVC 的架构中，还可以被用在以下一些场景中。1.Web 应用：开发者在不使用 JSP 的情况下，可以用 Velocity 让 HTML 具有动态内容的特性。2.源代码生成：Velocity 可以被用来生成 Java 代码、SQL 或者 PostScript。有很多开源和商业开发的软件是使用 Velocity 来开发的。3.自动 Email：很多软件的用户注册、密码提醒或者报表都是使用 Velocity 来自动生成的。使用 Velocity 可以在文本文件里面生成邮件内容，而不是在 Java 代码中拼接字符串。4.转换 xml：Velocity 提供一个叫 Anakia 的 ant 任务，可以读取 XML 文件并让它能够被 Velocity 模板读取。一个比较普遍的应用是将 xdoc 文档转换成带样式的 HTML 文件。 过程 velocity过程 Velocity模板引擎处理机制分为五个基本步骤：a.引擎初始化，通过设置的引擎属性初始化引擎，包括国际化支持，ResourceLoader设置，字符编码等。b.获取并解析模板文件，首先通过资源加载器（ResourceLoader）将模板文件加载到内存（转化为InputStream），然后通过AST（Abstract Syntax Tree）解析器将InputStream解析为一个AST。c.创建一个Contextd.将模板渲染所需的参数放入contexte.执行模板渲染，产生输出流。渲染过程中通过遍历该模板对应的AST，调用相应节点的处理器执行渲染。 12345678910111213141516171819202122232425public class VelocityMergeTest &#123; public static void main(String[] args) &#123; VelocityEngine ve = new VelocityEngine(); ve.setProperty(Velocity.RESOURCE_LOADER, \"class\"); //设置引擎的资源加载使用ClasspathResourceLoader。 ve.setProperty(\"class.resource.loader.class\", \"org.apache.velocity.runtime.resource.loader.ClasspathResourceLoader\"); try &#123; //引擎初始化 ve.init(); //加载解析模板 Template tp = ve.getTemplate(\"template.vm\"); //创建context Context context = new VelocityContext(); //设置Context中参数值 //创建一个context，并在其中放入一个foo=VV的参数。 context.put(\"foo\", \"VV\"); StringWriter writer = new StringWriter(); //执行渲染 tp.merge(context, writer); System.out.println(writer.toString()); &#125; catch (Exception e) &#123; &#125; &#125;&#125; 加载解析模板当执行ve.getTemplate(“template.vm”)时，首先通过ResourceLoader将tempalte加载为InputStream，然后通过Parser生成如下Token集合：{[ Hello], [$foo], [world! ]}，可以发现velocity根本不关系模板最终要渲染出来的是html还是什么的其他的东西，也就以为这所有的html标签对velocity来讲都是纯文本。最终构建的AST如下 velocity过程 根节点下有三个子节点： [ Hello]对应的ASTText节点；[$foo]对应的ASTReference节点；[world! ]对应的ASTText节点Velocity引擎在这里有个优化策略，可以针对生成的语法树进行cache。 执行渲染 当执行tp.merge(context, writer);时，模板遍历其对应的AST树，执行每个节点的渲染过程。如ASTText节点只是简单的将文本写入writer。ASTReference节点需要从context中获取引用的参数foo的值VV，将$foo替换，并写入到writer中。Velocity的AST中有多种节点，如ASTIdentitor等，有些需要反射机制处理。当整个AST遍历结束，也就意味着模板渲染结束，渲染的结果位于writer流中。 关于AST解析Velocity作为模板语言，其核心在与模板文件的解析，构建AST。Velocity的解析器是通过JavaCC构建的，JavaCC（Java Complier Complier）是一个用于生成解析器的工具，可以根据语法定义（.jj文件）生成用于校验一份文本是否符合该语法定义的java代码。JJTree是JavaCC中提供的一种根据语法定义（.jjt文件）生成构建符合该语法定义的文本的语法树的java代码的工具。 常用优化技巧Velocity渲染模板是先把模板解析成一棵语法树，然后去遍历这棵树分别渲染每个节点，知道了它的工作原理，我们就可以根据它的工作机制来优化渲染的速度。既然是遍历这棵树来渲染节点的，而且是顺序遍历的，那么很容易想到有两种办法来优化渲染： 减少树的总节点数量。123#set($one=-1)#set($pageid=&quot;$!page.id&quot;)#set($page=$one+$pageid) 这段代码实际上只是要计算一个值，但是由于不熟悉Velocity的一些语法，写得很麻烦，其实只要一个表达式就好了，如下：#set($page=-1+$!page.id)这样可以减少很多语法节点。 减少渲染耗时的节点数量。Velocity的方法调用是通过反射执行的，显然反射执行方法是耗时的，那么又如何减少反射执行的方法呢？这个改进就如同Java中一样，可以增加一些中间变量来保存中间值，而减少反射方法的调用。如在一个模板中要多次调用到$person.name，那么可以通过#set创建一个变量$name来保存$person.name这个反射方法的执行结果。如#set($name=$person.name)，这样虽然增加了一个#set节点，但是如果能减少多次反射调用仍然是很值得的。另外，Velocity本身提供了一个#macro语法，它类似于定义一个方法，然后可以调用这个方法，但在没有必要时尽量少用这种语法节点，这些语法节点比较耗时。还有一些大数计算等，最好定义在Java中，通过调用Java中的方法可以加快Velocity的执行效率。 其他： 改变Velocity的解释执行，变为编译执行。 方法调用的无反射优化 字符输出改成字节输出静态字符串直接是out.write(_S0)，这里的_S0是一个字节数组，而vm模板中是字符串，将字符串转成字节数组是在这个模板类初始化时完成的。字符的编码是非常耗时的，如果我们将静态字符串提前编码好，那么在最终写Socket流时就会省去这个编码时间，从而提高执行效率。从实际的测试来看，这对提升性能很有帮助。另外，从代码中还可以发现，如果是变量输出，调用的是out.write(_EVTCK(context,&quot;$str&quot;, context.get(&quot;str&quot;)))，而_EVTCK方法在输出变量之前检查是否有事件需要调用，如XSS安全检查、为空检查等。 去掉页面输出中多余的非中文空格。我们知道，页面的HTML输出中多余的空格是不会在HTML的展示时有作用的，多个连续的空格最终都只会显示一个空格的间距，除非你使用“ ”表示空格。虽然多余的空格并不能影响HTML的页面展示样式，但是服务端页面渲染和网络数据传输这些空格和其他字符没有区别，同样要做处理，这样的话，这些空格就会造成时间和空间维度上的浪费，所以完全可以将多个连续的空格合并成一个，从而既减少了字符又不会影响页面展示。 压缩TAB和换行。同样的道理，还可以将TAB字符合并成一个，以及将多余的换行也合并一下，也能减少不少字符。 合并相同的数据。在模板中有很多相同数据在循环中重复输出，如类目、商品、菜单等，可以将相同的重复内容提取出来合并在CSS中或者用JS来输出。异步渲染。将一些静态内容抽取出来改成异步渲染，只在用户确实需要时再向服务器去请求，也能够减少很多不必要的数据传输。 http://www.cnblogs.com/wade-luffy/p/5996848.html Velocity与JSPJSP文件渲染其实和Velocity的渲染机制很不一样，JSP文件实际上执行的是JSP对应的Java类，简单地说就是将JSP的HTML转化成out.write输出，而JSP中的Java代码直接复制到翻译后的Java类中。最终执行的是翻译后的Java类，而Velocity是按照语法规则解析成一棵语法树，然后执行这棵语法树来渲染出结果。 所以它们有如下这些区别: 执行方式不一样：JSP是编译执行，而Velocity是解释执行。如果JSP文件被修改了，那么对应的Java类也会被重新编译，而Velocity却不需要，只是会重新生成一棵语法树。 执行效率不同：从两者的执行方式不同可以看出，它们的执行效率不一样，从理论上来说，编译执行的效率明显好于解释执行，一个很明显的例子在JSP中方法调用是直接执行的，而Velocity的方法调用是反射执行的，JSP的效率会明显好于Velocity。当然如果JSP中有语法JSTL，语法标签的执行要看该标签的实现复杂度。需要的环境支持不一样：JSP的执行必须要有Servlet的运行环境，也就是需要ServletContext、HttpServletRequest和HttpServletResponse类。而要渲染Velocity完全不需要其他环境类的支持，直接给定Velocity模板就可以渲染出结果。所以Velocity不只应用在Servlet环境中。","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"springmvc","slug":"springmvc","permalink":"http://duyao.github.io/tags/springmvc/"},{"name":"mybatis","slug":"mybatis","permalink":"http://duyao.github.io/tags/mybatis/"},{"name":"velocity","slug":"velocity","permalink":"http://duyao.github.io/tags/velocity/"}]},{"title":"确定字符异或","slug":"确定字符异或","date":"2017-03-19T13:59:44.000Z","updated":"2017-03-19T14:07:56.000Z","comments":true,"path":"2017/03/19/确定字符异或/","link":"","permalink":"http://duyao.github.io/2017/03/19/确定字符异或/","excerpt":"","text":"题目描述请实现一个算法，确定一个字符串的所有字符是否全都不同。这里我们要求不允许使用额外的存储结构。给定一个string iniString，请返回一个bool值,True代表所有字符全都不同，False代表存在相同的字符。保证字符串中的字符为ASCII字符。字符串的长度小于等于3000。测试样例：“aeiou”返回：True“BarackObama”返回：False 使用位运算用int表示位图而int可以表示2^23个数字存在，因此足够比如当前为c首先将字符转化为数字str.charAt(i) - &#39;a&#39;则c=2然后将c化为为图中的位置1 &lt;&lt; val，即位图中倒数第2位为1，就是将1左移2位然后和原位图进行与，比较是否存在，比如存在的话原位图应该是0100&amp;转化结果100=1则存在如果不存在，记录下该值，比如1000|0100=1100，表示2和3都存在 1234567891011121314public static boolean isUniqueChars(String str) &#123; if (str.length() &gt; 128) &#123; return false; &#125; int checker = 0; for (int i = 0; i &lt; str.length(); i++) &#123; int val = str.charAt(i) - 'a'; int x = 1 &lt;&lt; val; int y = x&amp; checker; if ((checker &amp; (1 &lt;&lt; val)) &gt; 0) return false; checker |= (1 &lt;&lt; val); &#125; return true;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"cc150","slug":"cc150","permalink":"http://duyao.github.io/tags/cc150/"}]},{"title":"Servlet, Cookie & Session","slug":"Servlet-Cookie-Session","date":"2017-03-19T08:06:11.000Z","updated":"2017-05-13T14:46:32.000Z","comments":true,"path":"2017/03/19/Servlet-Cookie-Session/","link":"","permalink":"http://duyao.github.io/2017/03/19/Servlet-Cookie-Session/","excerpt":"","text":"Servlet生命周期Servlet 生命周期：Servlet 加载—&gt;实例化—&gt;服务—&gt;销毁。 init（）：在Servlet的生命周期中，仅执行一次init()方法。它是在服务器装入Servlet时执行的，负责初始化Servlet对象。可以配置服务器，以在启动服务器或客户机首次访问Servlet时装入Servlet。无论有多少客户机访问Servlet，都不会重复执行init（）。service（）：它是Servlet的核心，负责响应客户的请求。每当一个客户请求一个HttpServlet对象，该对象的Service()方法就要调用，而且传递给这个方法一个“请求”（ServletRequest）对象和一个“响应”（ServletResponse）对象作为参数。在HttpServlet中已存在Service()方法。默认的服务功能是调用与HTTP请求的方法相应的do功能。destroy（）： 仅执行一次，在服务器端停止且卸载Servlet时执行该方法。当Servlet对象退出生命周期时，负责释放占用的资源。一个Servlet在运行service()方法时可能会产生其他的线程，因此需要确认在调用destroy()方法时，这些线程已经终止或完成。 Tomcat 与 Servlet 的工作过程一个web应用对应一个context容器Context容器中可以解析web.xml文件，来完成初始化工作。 创建Servlet对象的时机Servlet容器启动时：读取web.xml配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，同时将ServletConfig对象作为参数来调用Servlet对象的init方法。ServletConfig代表当前Servlet在web.xml中的配置信息。在Servlet接口中init方法参数就是ServletConfig，在Servlet创建出来时，init方法立即被容器调用，由容器传入ServletConfig对象。在GenericServlet中，实现了这个方法，将ServletConfig设置成了类的成员变量，并提供了getServletConfig方法，获取该对象。我们的Servlet都间接继承子GenericServlet，所以可以在自己的Servlet中直接调用getServletConfig方法获取这个对象。 在Servlet容器启动后：客户首次向Servlet发出请求，Servlet容器会判断内存中是否存在指定的Servlet对象，如果没有则创建它，然后根据客户的请求创建HttpRequest、HttpResponse对象，从而调用Servlet 对象的service方法。 Servlet Servlet容器在启动时自动创建Servlet，这是由在web.xml文件中为Servlet设置的属性决定的。从中我们也能看到同一个类型的Servlet对象在Servlet容器中以单例的形式存在。 具体过程：1.Web Client 向Servlet容器（Tomcat）发出Http请求2.Servlet容器接收Web Client的请求3.Servlet容器创建一个HttpRequest对象，将Web Client请求的信息封装到这个对象中。4.Servlet容器创建一个HttpResponse对象5.Servlet容器调用HttpServlet对象的service方法，把HttpRequest对象与HttpResponse对象作为参数传给 HttpServlet 对象。6.HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息。7.HttpServlet调用HttpResponse对象的有关方法，生成响应数据。8.Servlet容器把HttpServlet的响应结果传给Web Client。 Servlet工作原理： 1、首先简单解释一下Servlet接收和响应客户请求的过程，首先客户发送一个请求，Servlet是调用service()方法对请求进行响应的，通过源代码可见，service()方法中对请求的方式进行了匹配，选择调用doGet,doPost等这些方法，然后再进入对应的方法中调用逻辑层的方法，实现对客户的响应。在Servlet接口和GenericServlet中是没有doGet（）、doPost（）等等这些方法的，HttpServlet中定义了这些方法，但是都是返回error信息，所以，我们每次定义一个Servlet的时候，都必须实现doGet或doPost等这些方法。 2、每一个自定义的Servlet都必须实现Servlet的接口，Servlet接口中定义了五个方法，其中比较重要的三个方法涉及到Servlet的生命周期，分别是上文提到的init(),service(),destroy()方法。GenericServlet是一个通用的，不特定于任何协议的Servlet,它实现了Servlet接口。而HttpServlet继承于GenericServlet，因此HttpServlet也实现了Servlet接口。所以我们定义Servlet的时候只需要继承HttpServlet即可。 3、Servlet接口和GenericServlet是不特定于任何协议的，而HttpServlet是特定于HTTP协议的类，所以HttpServlet中实现了service()方法，并将请求ServletRequest、ServletResponse 强转为HttpRequest 和 HttpResponse。 FilterFilter是一个可以复用的代码片段，可以用来转换HTTP请求、响应和头信息。Filter不像Servlet，它不能产生一个请求或者响应，它只是修改对某一资源的请求，或者修改从某一的响应。Servlet中的过滤器Filter是实现了javax.servlet.Filter接口的服务器端程序，主要的用途是过滤字符编码、做一些业务逻辑判断等。 过滤器分为request(默认)、forward、error、include、async servlet3.0中添加webfilter通过注解方式配置类过滤器 工作原理只要你在web.xml文件配置好要拦截的客户端请求，它都会帮你拦截到请求，此时你就可以对请求或响应(Request、Response)统一设置编码，简化操作；同时还可进行逻辑判断，如用户是否已经登陆、有没有权限访问该页面等等工作。它是随你的web应用启动而启动的，只初始化一次，以后就可以拦截相关请求，只有当你的web应用停止或重新部署的时候才销毁。Filter可认为是Servlet的一种“变种”，它主要用于对用户请求进行预处理，也可以对HttpServletResponse进行后处理，是个典型的处理链。 它与Servlet的区别在于：它不能直接向用户生成响应。完整的流程是：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。 Filter有如下几个用处:在HttpServletRequest到达Servlet之前，拦截客户的HttpServletRequest。根据需要检查HttpServletRequest，也可以修改HttpServletRequest头和数据。在HttpServletResponse到达客户端之前，拦截HttpServletResponse。根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。 Filter有如下几个种类:request(默认)、forward、error、include、async 创建一个Filter只需两个步骤：建Filter处理类；web.xml文件中配置Filter。web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter12345678910111213141516&lt;filter-name&gt;用于为过滤器指定一个名字，该元素的内容不能为空。&lt;filter-class&gt;元素用于指定过滤器的完整的限定类名。&lt;init-param&gt;元素用于为过滤器指定初始化参数，它的子元素&lt;param-name&gt;指定参数的名字，&lt;param-value&gt;指定参数的值。在过滤器中，可以使用FilterConfig接口对象来访问初始化参数。&lt;filter-mapping&gt;元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径&lt;filter-name&gt;子元素用于设置filter的注册名称。该值必须是在&lt;filter&gt;元素中声明过的过滤器的名字&lt;url-pattern&gt;设置 filter 所拦截的请求路径(过滤器关联的URL样式)&lt;servlet-name&gt;指定过滤器所拦截的Servlet名称。&lt;dispatcher&gt;指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST。用户可以设置多个&lt;dispatcher&gt; 子元素用来指定 Filter 对资源的多种调用方式进行拦截。&lt;dispatcher&gt; 子元素可以设置的值及其意义：REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。 1234567891011121314151617181920public class FilterDemo2 implements Filter&#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; // TODO Auto-generated method stub &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; // TODO Auto-generated method stub System.out.println(\"我是FilterDemo2，客户端向Servlet发送的请求被我拦截到了\"); //对请求放行，进入Servlet chain.doFilter(request, response); System.out.println(\"我是FilterDemo2，Servlet向客户端发送的响应被我拦截到了\"); &#125; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125;&#125; http://www.tuicool.com/articles/RFfMBr7http://www.jianshu.com/p/ee5bdbb0f37f listener：监听器listener主要用来监听只用。通过listener可以监听web服务器中某一个执行动作，并根据其要求作出相应的响应。通俗的语言说就是在application，session，request三个对象创建消亡或者往其中添加修改删除属性时自动执行代码的功能组件。 比如spring 的总监听器会在服务器启动的时候实例化我们配置的bean对象 、 hibernate 的 session 的监听器会监听session的活动和生命周期，负责创建，关闭session等活动。 Servlet的监听器Listener，它是实现了javax.servlet.ServletContextListener 接口的服务器端程序，它也是随web应用的启动而启动，只初始化一次，随web应用的停止而销毁。主要作用是： 做一些初始化的内容添加工作、设置一些基本的内容、比如一些参数或者是一些固定的对象等等。 Interceptor在面向切面编程的，就是在你的service或者一个方法，前调用一个方法，或者在方法后调用一个方法，是基于JAVA的反射机制。比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。 使用方法实现HandlerInterceptor接口，重写preHandle、postHandle、afterCompletion方法 preHandle：预处理回调方法，实现处理器的预处理（如登录检查），第三个参数为响应的处理器（如我们上一章的Controller实现）；返回值：true表示继续流程（如调用下一个拦截器或处理器）；false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response来产生响应；postHandle：后处理回调方法，实现处理器的后处理（但在渲染视图之前），此时我们可以通过modelAndView（模型和视图对象）对模型数据进行处理或对视图进行处理，modelAndView也可能为null。afterCompletion：整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于try-catch-finally中的finally，但仅调用处理器执行链中preHandle返回true的拦截器的afterCompletion。12345678910111213141516171819202122public class LoginRequiredInterceptor implements HandlerInterceptor &#123; @Autowired private HostHolder hostHolder; @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; if (hostHolder.getUser() == null) &#123; httpServletResponse.sendRedirect(\"/reglogin?next=\" + httpServletRequest.getRequestURI()); return false; &#125; return true; &#125; @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; &#125;&#125; 区别servlet、filter、listener是配置到web.xml中web.xml 的加载顺序是：context-param -&gt; listener -&gt; filter -&gt; servletinterceptor不配置到web.xml中，struts的拦截器配置到struts.xml中。spring的拦截器配置到spring.xml中。 过滤器和拦截器的区别： ①拦截器是基于Java的反射机制的，而过滤器是基于函数回调。 ②拦截器不依赖与servlet容器，过滤器依赖与servlet容器。 ③拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用。 ④拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问。 ⑤在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。 ⑥拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。 过滤器和拦截器的区别 spring优先使用拦截器，其功能更强大http://blog.csdn.net/chenleixing/article/details/44573495 jspJSP技术使用Java编程语言编写类XML的tags和scriptlets，来封装产生动态网页的处理逻辑。网页还能通过tags和scriptlets访问存在于服务端的资源的应用逻辑。JSP将网页逻辑与网页设计的显示分离，支持可重用的基于组件的设计，使基于Web的应用程序的开发变得迅速和容易。JSP(JavaServer Pages)是一种动态页面技术，它的主要目的是将表示逻辑从Servlet中分离出来。 与servlet的区别【1】JSP第一次运行的时候会编译成Servlet，驻留在内存中以供调用。【2】JSP是web开发技术，Servlet是服务器端运用的小程序，我们访问一个JSP页面时，服务器会将这个JSP页面转变成Servlet小程序运行得到结果后，反馈给用户端的浏览器。【3】Servlet相当于一个控制层再去调用相应的JavaBean处理数据,最后把结果返回给JSP。【4】Servlet主要用于转向，将请求转向到相应的JSP页面。【5】JSP更多的是进行页面显示，Servlet更多的是处理业务，即JSP是页面，Servlet是实现JSP的方法。【6】Servlet可以实现JSP的所有功能，但由于美工使用Servlet做界面非常困难，后来开发了JSP。【7】JSP技术开发网站的两种模式：JSP + JavaBean；JSP + Servlet + JavaBean（一般在多层应用中, JSP主要用作表现层,而Servlet则用作控制层,因为在JSP中放太多的代码不利于维护，而把这留给Servlet来实现,而大量的重复代码写在JavaBean中）。【8】二者之间的差别就是，开发界面是JSP直接可以编写。比如在JSP中写Table标记： &lt;table&gt;[数据]&lt;/table&gt;；Servlet需要加入：out.println(“&lt;table&gt;[数据]&lt;/table&gt;”)。JSP文件在被应用服务器(例如：Tomcat、Resin、Weblogic和Websphere),调用过之后，就被编译成为了Servlet文件。也就是说在网页上显示的其实是Servlet文件。Tomcat下面JSP文件编译之后生成的Servlet文件被放在了work文件夹下，JSP中的HTML代码在Servlet都被out出来，而JSP代码按照标签的不同会放在不同的位置。【9】JSP中嵌入JAVA代码，而Servlet中嵌入HTML代码。【10】在一个标准的MVC架构中，Servlet作为Controller接受用户请求并转发给相应的Action处理，JSP作为View主要用来产生动态页面，EJB作为Model实现你的业务代码。 Session 与 CookieSession的概念Session 是存放在服务器端的，类似于Session结构来存放用户数据，当浏览器 第一次发送请求时，服务器自动生成了一个Session和一个Session ID用来唯一标识这个Session，并将其通过响应发送到浏览器。当浏览器第二次发送请求，会将前一次服务器响应中的Session ID放在请求中一并发送到服务器上，服务器从请求中提取出Session ID，并和保存的所有Session ID进行对比，找到这个用户对应的Session。 一般情况下，服务器会在一定时间内（默认30分钟）保存这个 Session，过了时间限制，就会销毁这个Session。在销毁之前，程序员可以将用户的一些数据以Key和Value的形式暂时存放在这个 Session中。当然，也有使用数据库将这个Session序列化后保存起来的，这样的好处是没了时间的限制，坏处是随着时间的增加，这个数据库会急速膨胀，特别是访问量增加的时候。一般还是采取前一种方式，以减轻服务器压力。 Session的客户端实现形式（即Session ID的保存方法）一般浏览器提供了两种方式来保存，还有一种是程序员使用html隐藏域的方式自定义实现： [1] 使用Cookie来保存，这是最常见的方法，本文“记住我的登录状态”功能的实现正式基于这种方式的。服务器通过设置Cookie的方式将Session ID发送到浏览器。如果我们不设置这个过期时间，那么这个Cookie将不存放在硬盘上，当浏览器关闭的时候，Cookie就消失了，这个Session ID就丢失了。如果我们设置这个时间为若干天之后，那么这个Cookie会保存在客户端硬盘中，即使浏览器关闭，这个值仍然存在，下次访问相应网站时，同 样会发送到服务器上。 [2] 使用URL附加信息的方式，也就是像我们经常看到JSP网站会有aaa.jsp?JSESSIONID=*一样的。这种方式和第一种方式里面不设置Cookie过期时间是一样的。 [3] 第三种方式是在页面表单里面增加隐藏域，这种方式实际上和第二种方式一样，只不过前者通过GET方式发送数据，后者使用POST方式发送数据。但是明显后者比较麻烦。 cookie与session的区别cookie数据保存在客户端，session数据保存在服务器端。 简单的说，当你登录一个网站的时候，如果web服务器端使用的是session,那么所有的数据都保存在服务器上面，客户端每次请求服务器的时候会发送 当前会话的sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登录，或具有某种权限。由于数据是存储在服务器 上面，所以你不能伪造，但是如果你能够获取某个登录用户的sessionid，用特殊的浏览器伪造该用户的请求也是能够成功的。sessionid是服务器和客户端链接时候随机分配的，一般来说是不会有重复，但如果有大量的并发请求，也不是没有重复的可能性,显示别人的信息。 如果浏览器使用的是 cookie，那么所有的数据都保存在浏览器端，比如你登录以后，服务器设置了 cookie用户名(username),那么，当你再次请求服务器的时候，浏览器会将username一块发送给服务器，这些变量有一定的特殊标记。服务器会解释为 cookie变量。所以只要不关闭浏览器，那么 cookie变量便一直是有效的，所以能够保证长时间不掉线。如果你能够截获某个用户的 cookie变量，然后伪造一个数据包发送过去，那么服务器还是认为你是合法的。所以，使用 cookie被攻击的可能性比较大。如果设置了的有效时间，那么它会将 cookie保存在客户端的硬盘上，下次再访问该网站的时候，浏览器先检查有没有 cookie，如果有的话，就读取该 cookie，然后发送给服务器。如果你在机器上面保存了某个论坛 cookie，有效期是一年，如果有人入侵你的机器，将你的 cookie拷走，然后放在他的浏览器的目录下面，那么他登录该网站的时候就是用你的的身份登录的。所以 cookie是可以伪造的。当然，伪造的时候需要主意，直接copy cookie文件到 cookie目录，浏览器是不认的，他有一个index.dat文件，存储了 cookie文件的建立时间，以及是否有修改，所以你必须先要有该网站的 cookie文件，并且要从保证时间上骗过浏览器。 Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID,用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一 SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。 服务器也可以通过URL重写的方式来传递SessionID的值，因此不是完全依赖Cookie。如果客户端Cookie禁用，则服务器可以自动通过重写URL的方式来保存Session的值，并且这个过程对程序员透明。 可以试一下，即使不写Cookie，在使用request.getCookies();取出的Cookie数组的长度也是1，而这个Cookie的名字就是JSESSIONID，还有一个很长的二进制的字符串，是SessionID的值。 Session与Cookie区别和联系：Cookies是属于Session对象的一种。但有不同，Cookies不会占服务器资源，是存在客服端内存或者一个cookie的文本文件中；而“Session”则会占用服务器资源。所以，尽量不要使用Session，而使用Cookies。但是我们一般认为cookie是不可靠的，session是可靠地，但是目前很多著名的站点也都以来cookie。有时候为了解决禁用cookie后的页面处理，通常采用url重写技术，调用session中大量有用的方法从session中获取数据后置入页面。 Cookies与Session的应用场景：Cookies的安全性能一直是倍受争议的。虽然Cookies是保存在本机上的，但是其信息的完全可见性且易于本地编辑性，往往可以引起很多的安全问题。所以Cookies到底该不该用，到底该怎样用，就有了一个需要给定的底线。 登陆验证信息。一般采用Session(“Logon”)＝true or false的形式。用户的各种私人信息，比如姓名等，某种情况下，需要保存在Session里需要在页面间传递的内容信息，比如调查工作需要分好几步。每一步的信息都保存在Session里，最后在统一更新到数据库。 cookie最典型的应用是： （一）：判断用户是否登陆过网站，以便下次登录时能够直接登录。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。 （二）：另一个重要的应用是“购物车”中类的处理和设计。用户可能在一段时间内在同一家网站的不同页面选择不同的商品，可以将这些信息都写入cookie，在最后付款时从cookie中提取这些信息，当然这里面有了安全和性能问题需要我们考虑了。 分布式sessionsession共享原理是将session保存到分布式缓存数据库中如：redis， memcache等，然后多个服务器tomcat每次请求都通过NoSql数据库查询，如果存在，则获取值；反之存放值。通过redis来实现session的共享，其主要有一下两种方法：1、通过tomcat服务器的拓展功能实现 这种方式比较简单，主要是通过继承session的ManagerBase类，实现重写session相关的方法，这种比较简单，2、通过filter拦截request请求实现 下面主要介绍这样实现方式： （1）写HttpSessionWrapper实现HttpSession接口，实现里面session相关的方法。 （2）写HttpServletRequestWrapper继承javax.servlet.http.HttpServletRequestWrapper类，重写对于session 相关的方法。 （3）写SessionFilter拦截配置的请求url，过去cookie中 的sessionId，如果为空，对此次请求重写生成一个新的sessionId，在sessionId构造新的HttpServletRequestWrapper对象。 （4）写SessionService实现session到redis的保存和过去，其key为sessionId，value为session对于的Map。http://blog.csdn.net/fengshizty/article/details/50578639 粘性session原理：粘性Session是指将用户锁定到某一个服务器上，比如上面说的例子，用户第一次请求时，负载均衡器将用户的请求转发到了A服务器上，如果负载均衡器设置了粘性Session的话，那么用户以后的每次请求都会转发到A服务器上，相当于把用户和A服务器粘到了一块，这就是粘性Session机制。 优点：简单，不需要对session做任何处理。 缺点：缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的session信息都将失效。 适用场景：发生故障对客户产生的影响较小；服务器发生故障是低概率事件。 服务器session复制原理：任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。 优点：可容错，各个服务器间session能够实时响应。 缺点：会对网络负荷造成一定压力，如果session量大的话可能会造成网络堵塞，拖慢服务器性能。 Cookie相关跨域访问cookie具体思路：在a.com下设置cookie后，嵌入一个iframe框链接b.com的页面，b.com设置好页面cookie后，再嵌入一个a.com的页面，然后通过parent.parent就可以调用最外层的a.com的js方法，从而进行跳转或者一些其它的操作。http://www.tuicool.com/articles/E3iUva 或者可以再建一个系统，支持多个域名访问的，这个从一个域名下面获取到另一个域名的session、cookie，再写回去。比如tomcat、apache等。 Cookie防止xxsXSS攻击XSS(Cross Site Scripting)是跨站点脚本攻击的缩写. 其就是利用站点开放的文本编辑并发布的功能, 从而造成攻击.其实说的简单一点, 就是输入javascript脚本, 窃取并投递cookie信息到自己的站点. Cookie劫持的防基于XSS攻击, 窃取Cookie信息, 并冒充他人身份.给Cookie添加HttpOnly属性, 这种属性设置后, 只能在http请求中传递, 在脚本中, document.cookie无法获取到该Cookie值. 对XSS的攻击, 有一定的防御值. 但是对网络拦截, 还是泄露了.123Set-Cookie: =[; =][; expires=][; domain=][; path=][; secure][; HttpOnly]","categories":[],"tags":[]},{"title":"spring-ioc & aop","slug":"spring-ioc-aop","date":"2017-03-18T10:26:58.000Z","updated":"2017-05-13T14:35:16.000Z","comments":true,"path":"2017/03/18/spring-ioc-aop/","link":"","permalink":"http://duyao.github.io/2017/03/18/spring-ioc-aop/","excerpt":"","text":"spring知识点http://jinnianshilongnian.iteye.com/blog/1482071 Spring注入方式Spring注入是指在启动Spring容器加载bean配置的时候，完成对变量的赋值行为 设值注入 构造注入 设值注入通过set方法进行注入 spring-injection.xml12345&lt;bean id=&quot;injectionService&quot; class=&quot;com.imooc.ioc.injection.service.InjectionServiceImpl&quot;&gt; --&gt; &lt;property name=&quot;injectionDAO&quot; ref=&quot;injectionDAO&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;injectionDAO&quot; class=&quot;com.imooc.ioc.injection.dao.InjectionDAOImpl&quot;&gt;&lt;/bean&gt; InjectionServiceImpl.java1234//设值注入public void setInjectionDAO(InjectionDAO injectionDAO) &#123; this.injectionDAO = injectionDAO;&#125; 构造注入使用显示构造器来完成注入,构造器参数必须与配置文件的名字相同 spring-injection.xml1234&lt;bean id=&quot;injectionService&quot; class=&quot;com.imooc.ioc.injection.service.InjectionServiceImpl&quot;&gt; &lt;constructor-arg name=&quot;injectionDAO&quot; ref=&quot;injectionDAO&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;bean id=&quot;injectionDAO&quot; class=&quot;com.imooc.ioc.injection.dao.InjectionDAOImpl&quot;&gt;&lt;/bean&gt; InjectionServiceImpl.java12345//构造器注入//public InjectionServiceImpl(InjectionDAO injectionDAO1)无法实现注入public InjectionServiceImpl(InjectionDAO injectionDAO) &#123; this.injectionDAO = injectionDAO;&#125; Bean的配置项 Id：IOC容器中的唯一标示 Class：具体事例化的哪一个类 Scope：作用域，范围 Constructor arguments：构造器参数 Properties：属性 Autowiring mode：自动装配模式 lazy-initialization mode：懒加载模式 Initialization/destruction method：初始化/销毁方法 Bean作用域 singleton：单例，一个Bean容器只存在一份，比如一个context中存在一份，spring会缓存 prototype：每次请求都会创建新的实例，destroy方式不生效,spring不会缓存 request：每次http请求创建一个实例且尽在当前request内有效 session：同上，每次http请求创建，当前session内有效 global session：基于portlet(portlet可以登录多个系统定义了global session)的web中有效 Bean的生命周期 定义 初始化 使用 销毁 初始化 实现import org.springframework.beans.factory.InitializingBean接口，覆盖afterPropertiesSet方法 配置init-method 销毁 实现import org.springframework.beans.factory.DisposableBean接口，覆盖destroy方法 配置destroy-method 配置全局的初始化销毁方法12345&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot; default-init-method=&quot;defautInit&quot; default-destroy-method=&quot;defaultDestroy&quot;&gt; 例子BeanLifeCycle.java123456789101112131415161718192021222324252627282930313233//实现了接口public class BeanLifeCycle implements InitializingBean, DisposableBean &#123; //全局配置 public void defautInit() &#123; System.out.println(\"Bean defautInit.\"); &#125; public void defaultDestroy() &#123; System.out.println(\"Bean defaultDestroy.\"); &#125; //实现接口 @Override public void destroy() throws Exception &#123; System.out.println(\"Bean destroy.\"); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println(\"Bean afterPropertiesSet.\"); &#125; //配置文件 public void start() &#123; System.out.println(\"Bean start .\"); &#125; public void stop() &#123; System.out.println(\"Bean stop.\"); &#125;&#125; spring-lifecycle.xml12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" default-init-method=\"defautInit\" default-destroy-method=\"defaultDestroy\"&gt; &lt;!--配置文件--&gt; &lt;bean id=\"beanLifeCycle\" class=\"com.imooc.lifecycle.BeanLifeCycle\" init-method=\"start\" destroy-method=\"stop\"&gt;&lt;/bean&gt; &lt;/beans&gt; 总结优先级：实现接口 &gt; 配置文件 &gt; 全局配置在全局配置中的方法没有或者实现，其他两者不可以 Aware Spring中提供了一些以Aware结尾的接口，实现了Aware接口的bean在被初始化后，可以获取相应的资源 通过Aware接口，可以对Spring相应资源进行操作 为对Spring进行简单的扩展提供了方便的入口 MoocBeanName.java12345678910111213141516171819public class MoocBeanName implements BeanNameAware, ApplicationContextAware &#123; private String beanName; //实现BeanNameAware方法 @Override public void setBeanName(String name) &#123; this.beanName = name; System.out.println(\"MoocBeanName : \" + name); &#125; //实现ApplicationContextAware的方法 @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; System.out.println(\"setApplicationContext : \" + applicationContext.getBean(this.beanName).hashCode()); &#125;&#125; spring-aware.xml1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot; &gt; &lt;bean id=&quot;moocBeanName&quot; class=&quot;com.imooc.aware.MoocBeanName&quot; &gt;&lt;/bean&gt; &lt;/beans&gt; Bean的自动装配(Autowiring)不需要配置属性set或者constructor，完成Bean的注入 No不要任何操作 byName根据属性名自动装配。此选项经检查容器并根据名字查找与属性完全一致的bean，并将其与属性自动装配 byType如果容器中存在一个与指定属性类型相同的bean，那么将与该属性自动装配；如果存在多个该类型的bean，那么抛出异常，并指出不能使用byType方式进行自动装配；如果没有找到相匹配的bean，什么事也不发生配置bean时可以没有id Constructor与byType方式类似，不同之处在于它应用于构造器参数如果没有找到与构造器参数类型一致的bean，那么抛出异常 例子spring-autowiring.xml12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot; default-autowire=&quot;constructor&quot;&gt; &lt;!--default-autowire上面说的几种方法--&gt; &lt;bean id=&quot;autoWiringService&quot; class=&quot;com.imooc.autowiring.AutoWiringService&quot; &gt;&lt;/bean&gt; &lt;bean class=&quot;com.imooc.autowiring.AutoWiringDAO&quot; &gt;&lt;/bean&gt; &lt;/beans&gt; AutoWiringService.java 123456789101112131415161718192021 public class AutoWiringService &#123; private AutoWiringDAO autoWiringDAO; //构造器注入 public AutoWiringService(AutoWiringDAO autoWiringDAO) &#123; System.out.println(&quot;AutoWiringService&quot;); this.autoWiringDAO = autoWiringDAO; &#125; //set注入 public void setAutoWiringDAO(AutoWiringDAO autoWiringDAO) &#123; System.out.println(&quot;setAutoWiringDAO&quot;); this.autoWiringDAO = autoWiringDAO; &#125; public void say(String word) &#123; this.autoWiringDAO.say(word); &#125;&#125; AutoWiringDAO.java1234567public class AutoWiringDAO &#123; public void say(String word) &#123; System.out.println(&quot;AutoWiringDAO : &quot; + word); &#125;&#125; ioc原理一篇记录读tiny-spring的文章https://github.com/duyao/tiny-spring https://www.zybuluo.com/dugu9sword/note/382745 https://my.oschina.net/flashsword/blog/192551https://my.oschina.net/flashsword/blog/194481 BeanFactory 的构造与执行BeanFactory 的核心方法是 getBean(String) 方法，用于从工厂中取出所需要的 Bean 。AbstractBeanFactory 规定了基本的构造和执行流程。 getBean 的流程：包括实例化和初始化，也就是生成 Bean，再执行一些初始化操作。 1.doCreateBean ：实例化 Bean。 a.createInstance ：生成一个新的实例。 b.applyProperties ：注入属性，包括依赖注入的过程。在依赖注入的过程中，如果 Bean 实现了 BeanFactoryAware 接口，则将容器的引用传入到 Bean 中去，这样，Bean 将获取对容器操作的权限，也就允许了 编写扩展 IoC 容器的功能的 Bean。 2.initializeBean(bean) ： 初始化 Bean。 a. 从 BeanPostProcessor 列表中，依次取出 BeanPostProcessor 执行 bean = postProcessBeforeInitialization(bean,beanName) 。（为什么调用 BeanPostProceesor 中提供方法时，不是直接 post…(bean,beanName) 而是 bean = post…(bean,beanName) 呢？见分析1 。另外，BeanPostProcessor 列表的获取有问题，见分析2。） b. 初始化方法（tiny-spring 未实现对初始化方法的支持）。 c. 从 BeanPostProcessor 列表中， 依次取出 BeanPostProcessor 执行其 bean = postProcessAfterInitialization(bean,beanName)。 ApplicationContext 的构造和执行ApplicationContext 的核心方法是 refresh() 方法，用于从资源文件加载类定义、扩展容器的功能。 refresh 的流程： 总体来说，tiny-spring 的 ApplicaitonContext 使用流程是这样的： 1.loadBeanDefinitions(BeanFactory) ： 类定义的读取和加载，并注入到内置的 BeanFactory 中，这里的可扩展性在于，未对加载方法进行要求，也就是可以从不同来源的不同类型的资源进行加载。 2.registerBeanPostProcessors(BeanFactory) ： 获取所有的 BeanPostProcessor，并注册到 BeanFactory 维护的 BeanPostProcessor 列表去。 3.onRefresh ： a. preInstantiateSingletons ：以单例的方式，初始化所有 Bean。通过主动调用 getBean （见上面get过程） 实例化、注入属性、然后初始化 BeanFactory 中所有的 Bean。由于所有的 BeanPostProcessor 都已经在第 2 步中完成实例化了，因此接下来实例化的是普通 Bean，因此普通 Bean 的初始化过程可以正常执行。 BeanPostProcessor是Spring容器的一个扩展点，可以进行自定义的实例化、初始化、依赖装配、依赖检查等流程，即可以覆盖默认的实例化，也可以增强初始化、依赖注入、依赖检查等流程 AOP（Aspect Orient Programming）AOP（Aspect Orient Programming），也就是面向方面编程，作为面向对象编程的一种补充，专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点的问题，在 Java EE 应用中，常常通过 AOP 来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等。AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理，AOP 代理主要分为静态代理(预编译)和动态代理(运行期间)两大类，静态代理以 AspectJ 为代表；而动态代理则以 Spring AOP 为代表。 SpringAOP与 AspectJ 相同的是，Spring AOP 同样需要对目标类进行增强，也就是生成新的 AOP 代理类；与 AspectJ 不同的是，Spring AOP 无需使用任何特殊命令对 Java 源代码进行编译，它采用运行时动态地、在内存中临时生成“代理类”的方式来生成 AOP 代理。Spring 允许使用 AspectJ Annotation 用于定义方面（Aspect）、切入点（Pointcut）和增强处理（Advice），Spring 框架则可识别并根据这些 Annotation 来生成 AOP 代理。Spring 只是使用了和 AspectJ 5 一样的注解，但并没有使用 AspectJ 的编译器或者织入器（Weaver） ，底层依然使用的是 Spring AOP，依然是在运行时动态生成 AOP 代理，并不依赖于 AspectJ 的编译器或者织入器。 简单地说，Spring 依然采用运行时生成动态代理的方式来增强目标对象，所以它不需要增加额外的编译，也不需要 AspectJ 的织入器支持；而 AspectJ 在采用编译时增强，所以 AspectJ 需要使用自己的编译器来编译 Java 文件，还需要织入器。 不是为了提供强大的aop服务(AspectJ)，而侧重于提供与spring相关的基本aop服务 https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/#ibm-pcon 一些概念 AOP概念 Advice类型 advice、pointcut、aspect1234567891011121314151617181920&lt;!--这是一个切面，里面定义了切面要执行的逻辑，比如有after方法、before方法等--&gt;&lt;bean id=\"moocAspect\" class=\"com.imooc.aop.schema.advice.MoocAspect\"&gt;&lt;/bean&gt;&lt;!--这一个普通的bean，这个bean希望有切面注入来实现一些功能--&gt;&lt;bean id=\"aspectBiz\" class=\"com.imooc.aop.schema.advice.biz.AspectBiz\"&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;!--首先声明一个切面--&gt; &lt;aop:aspect id=\"moocAspectAOP\" ref=\"moocAspect\"&gt; &lt;!--pointcut指出这个切面到底在哪里执行--&gt; &lt;aop:pointcut expression=\"execution(* com.imooc.aop.schema.advice.biz.*Biz.*(..))\" id=\"moocPiontcut\"/&gt; &lt;!--下面这些方法都是用来表示pointcut执行的时候到底使用的是切面的什么方法，在什么时候--&gt; &lt;aop:before method=\"before\" pointcut-ref=\"moocPiontcut\"/&gt; &lt;aop:after-returning method=\"afterReturning\" pointcut-ref=\"moocPiontcut\"/&gt; &lt;aop:after-throwing method=\"afterThrowing\" pointcut-ref=\"moocPiontcut\"/&gt; &lt;aop:after method=\"after\" pointcut-ref=\"moocPiontcut\"/&gt; &lt;aop:around method=\"around\" pointcut-ref=\"moocPiontcut\"/&gt; &lt;aop:around method=\"aroundInit\" pointcut=\"execution(* com.imooc.aop.schema.advice.biz.AspectBiz.init(String, int)) and args(bizName, times)\"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; Introduction允许一个切面声明一个实现指定接口的通知对象，并且提供了一个接口实现类来代表这些对象&lt;/aop:aspect&gt;中&lt;aop:declare-parents&gt;元素声明该元素用于声明所匹配的类型拥有一个新的parent12345678&lt;aop:config&gt; &lt;aop:aspect id=\"moocAspectAOP\" ref=\"moocAspect\"&gt; &lt;!--interface表示匹配者的新父接口，default-impl是父接口的实现类--&gt; &lt;aop:declare-parents types-matching=\"com.imooc.aop.schema.advice.biz.*(+)\" implement-interface=\"com.imooc.aop.schema.advice.Fit\" default-impl=\"com.imooc.aop.schema.advice.FitImpl\"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; Advisoradvisor与aspect有相似的用法，通常与事务&lt;tx:advice&gt;一起使用区别：advisor只持有一个Pointcut和一个advice，而aspect可以多个pointcut和多个advice123456789101112131415161718192021&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;!-- propagation :事务传播行为 isolation :事务的隔离级别 read-only :只读 rollback-for:发生哪些异常回滚 no-rollback-for :发生哪些异常不回滚 timeout :过期信息 --&gt; &lt;tx:method name=\"transfer\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt; &lt;!-- 配置切面 --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点 --&gt; &lt;aop:pointcut expression=\"execution(* com.zs.spring.demo3.AccountService+.*(..))\" id=\"pointcut1\"/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut1\"/&gt;&lt;/aop:config&gt; AspectJAspectJ 是一个基于 Java 语言的 AOP 框架，提供了强大的 AOP 功能，其他很多 AOP 框架都借鉴或采纳其中的一些思想。AspectJ 是 Java 语言的一个 AOP 实现，其主要包括两个部分：第一个部分定义了如何表达、定义 AOP 编程中的语法规范，通过这套语言规范，我们可以方便地用 AOP 来解决 Java 语言中存在的交叉关注点问题；另一个部分是工具部分，包括编译器、调试工具等。AspectJ 是最早、功能比较强大的 AOP 实现之一，对整套 AOP 机制都有较好的实现，很多其他语言的 AOP 实现，也借鉴或采纳了 AspectJ 中很多设计。在 Java 领域，AspectJ 中的很多语法结构基本上已成为 AOP 领域的标准。 spring对AspectJ的支持@AspectJ类似于java注解运行时仍然是存spring aop 配置方式@AspectJ切面使用@Aspect配置注解，该注解的类可以有方法和字段，可能含有切入点pointcut、通知advice和引入introduction@Aspect不能通过类路径自动检测，因此需要使用@Component注解或者在xml中配置bean 步骤：1、在xml中开启&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;2、定义切面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Component@Aspectpublic class MoocAspect &#123; @Pointcut(\"execution(* com.imooc.aop.aspectj.biz.*Biz.*(..))\") public void pointcut() &#123;&#125; @Pointcut(\"within(com.imooc.aop.aspectj.biz.*)\") public void bizPointcut() &#123;&#125; //直接用已经定义好的pointcut @Before(\"pointcut()\") public void before() &#123; System.out.println(\"Before.\"); &#125; @Before(\"pointcut() &amp;&amp; args(arg)\") public void beforeWithParam(String arg) &#123; System.out.println(\"BeforeWithParam.\" + arg); &#125; @Before(\"pointcut() &amp;&amp; @annotation(moocMethod)\") public void beforeWithAnnotaion(MoocMethod moocMethod) &#123; System.out.println(\"BeforeWithAnnotation.\" + moocMethod.value()); &#125; @AfterReturning(pointcut=\"bizPointcut()\", returning=\"returnValue\") public void afterReturning(Object returnValue) &#123; System.out.println(\"AfterReturning : \" + returnValue); &#125; @AfterThrowing(pointcut=\"pointcut()\", throwing=\"e\") public void afterThrowing(RuntimeException e) &#123; System.out.println(\"AfterThrowing : \" + e.getMessage()); &#125; @After(\"pointcut()\") public void after() &#123; System.out.println(\"After.\"); &#125; @Around(\"pointcut()\") public Object around(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println(\"Around 1.\"); Object obj = pjp.proceed(); System.out.println(\"Around 2.\"); System.out.println(\"Around : \" + obj); return obj; &#125;&#125; 动态代理技术动态代理最常见应用是AOP(面向切面编程)。通过AOP，我们能够地拿到我们的程序运行到某个节点时的方法、对象、入参、返回参数，并动态地在方法调用前后新添一些新的方法逻辑，来满足我们的新需求，比如日志记录等。动态代理常见有两种方式：基于JDK的反射技术的动态代理（必须是接口）和基于CGLib(任何类都可以，不一定是接口)的动态代理。 JDK使用反射技术创建动态代理JDK创建动态代理的核心是java.lang.reflect.InvocationHandler接口和java.lang.reflect.Proxy类。123456789101112131415161718192021222324252627//实现InvocationHandler接口public class JdkDynamicAopProxy extends AbstractAopProxy implements InvocationHandler &#123; public JdkDynamicAopProxy(AdvisedSupport advised) &#123; super(advised); &#125;//重写方法 @Override public Object getProxy() &#123; return Proxy.newProxyInstance(getClass().getClassLoader(), advised.getTargetSource().getInterfaces(), this); &#125;//重写调用方法 @Override public Object invoke(final Object proxy, final Method method, final Object[] args) throws Throwable &#123; MethodInterceptor methodInterceptor = advised.getMethodInterceptor(); if (advised.getMethodMatcher() != null &amp;&amp; advised.getMethodMatcher().matches(method, advised.getTargetSource().getTarget().getClass())) &#123; return methodInterceptor.invoke(new ReflectiveMethodInvocation(advised.getTargetSource().getTarget(), method, args)); &#125; else &#123; return method.invoke(advised.getTargetSource().getTarget(), args); &#125; &#125;&#125; CGLib动态代理基本原理CGLib——Code Generation Library，它是一个动态字节代码生成库，基于asm。使用CGLib时需要导入asm相关的jar包。而asm又是何方神圣？ asm是一个java字节码操纵框架，它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。Java class 被存储在严格格式定义的 .class文件里，这些类文件拥有足够的元数据来解析类中的所有元素：类名称、方法、属性以及 Java 字节码（指令）。ASM从类文件中读入信息后，能够改变类行为，分析类信息，甚至能够根据用户要求生成新类。 用JDK的动态代理来模拟实现了一个性能监控的例子，用到了JDK内置的反射技术和java.lang.reflect.Proxy代理类通过例子我们发现，它只能通过让被代理类实现代理接口的方式来生成代理，而CGLib的区别在于通过在程序运行时动态生成一个被代理类的子类的方式来完成代理。 CGLib有几个核心类: Enhancer 它用于动态生成被代理的类的子类。使用此类生成子类的前奏是指定被代理类和指定CallBack接口 CallBack：它是一个很关键的接口，我们常常通过CallBack接口来配置我们的拦截方法， MethodInterceptor：是CallBack的实现类，他会拦截我们被代理类的所有方法，来实现自己的增强细节。比如做点日志记录，方法处理等，处理完后，还能通过MethodProxy重新调用拦截掉的方法。 MethodProxy：主要用于重新调用MethodInterceptor拦截掉的方法，是jdk反射包中Method的代理类。 CallbackFilter：一个Enhancer生成类可以指定多个Callback,这样我们可以设定条件过滤，让被代理类中不同的方法被调用时使用不同的CallBack来进行处理。https://yq.aliyun.com/articles/29130?spm=5176.8091938.0.0.kpT4Oshttps://yq.aliyun.com/articles/29131?spm=5176.8091938.0.0.kpT4Os 事务管理PlatformTransactionManager事务管理器123TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException;void commit(TransactionStatus status) throws TransactionException;void rollback(TransactionStatus status) throws TransactionException; PlatformTransactionManager实现类 TransactionDefinition事务定义信息1234567//主要方法int getPropagationBehavior();int getIsolationLevel();int getTimeout();boolean isReadOnly();String getName();TIMEOUT_DEFAULT 事务隔离级别//事务隔离级别ISOLATION_DEFAULT//默认的隔离级别，默认值为后台所使用的数据库的隔离级别，比如mysql是rrISOLATION_READ_UNCOMMITTEDISOLATION_READ_COMMITTEDISOLATION_REPEATABLE_READISOLATION_SERIALIZABLE 不同的事务隔离级别可能会引发的问题：脏读：一个事务读取了另一个事务改写但还未提交的数据，如果这个数据被回滚，则读到的数据是无效的不可重复读：在同一个事务中，多次读取同一个数据，而返回的结果是不一致的幻读：一个事务读取了几行记录后，后一个事务插入一些记录，幻读就发生了。再后来的查询中，第一个事务就会发现原来有些没有的记录。 脏读 不可重复读 幻读 未提交读 Y Y Y 提交读 N Y Y 可重复读 N N Y 可串行化 N N N 事务的传播特性事务的传播行为：解决业务层方法之间相互调用的问题比如有一个serviceA需要使用dao1.x()和dao2.y(),serviceB需要使用dao1.y()和dao2.x(),serviceC需要使用serviceA和serviceB来完成业务，那么事务的传播就来解决serviceC中事务的行为的 事务的传播特性 其实主要分为3类：第一类是支持支持当前事务，也就是说当前事务和新事务是在同一个事务中的第二类是不和当前事务混在一起，各走各的第三类是嵌套 TransactionStatus事务状态信息123456boolean isNewTransaction();boolean hasSavepoint();void setRollbackOnly();boolean isRollbackOnly();void flush();boolean isCompleted(); 配置声明式事务xml方式123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 配置业务层类 --&gt;&lt;bean id=\"accountService\" class=\"com.zs.spring.demo3.AccountServiceImpl\"&gt; &lt;property name=\"accountDao\" ref=\"accountDao\" /&gt;&lt;/bean&gt;&lt;!-- 配置DAO类(简化，会自动配置JdbcTemplate) --&gt;&lt;bean id=\"accountDao\" class=\"com.zs.spring.demo3.AccountDaoImpl\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt;&lt;!-- ==================================使用XML配置声明式的事务管理,基于tx/aop=============================================== --&gt;&lt;!-- 配置事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt;&lt;!-- 配置事务的通知 --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;!-- propagation :事务传播行为 isolation :事务的隔离级别 read-only :只读 rollback-for:发生哪些异常回滚 no-rollback-for :发生哪些异常不回滚 timeout :过期信息 --&gt; &lt;tx:method name=\"transfer\" propagation=\"REQUIRED\" isolation=\"SERIALIZABLE\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置切面 --&gt;&lt;aop:config&gt; &lt;!-- 配置切入点 --&gt; &lt;aop:pointcut expression=\"execution(* com.zs.spring.demo3.AccountService+.*(..))\" id=\"pointcut1\"/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"pointcut1\"/&gt;&lt;/aop:config&gt; 无需更改service的代码，就可以完成事务的操作 注解123456789&lt;!-- ==================================4.使用注解配置声明式事务============================================ --&gt;&lt;!-- 配置事务管理器 --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt;&lt;!-- 开启注解事务 --&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; service中的方法前面加上注解12345@Transactional(propagation = Propagation.REQUIRED,isolation = Isolation.REPEATABLE_READ,readOnly = true)public void myTransaction() &#123; ... System.out.println(\"myTransaction... \" ));&#125; 一些问题spring为什么默认为单例 When a bean is a singleton, only one shared instance of the bean will be managed and all requests for beans with an id or ids matching that bean definition will result in that one specific bean instance being returned. spring中的单例和设计模式中的单例是不一样的，在spring中单例意味着每一个bean只有一个实例一是我们不用每次创建bean，这样可以减小开销，提高性能二是减少了对象创建和垃圾收集的时间 http://stackoverflow.com/questions/21828664/why-spring-bean-is-singleton-scope spring保证线程安全吗不保证，spring的bean是单例的，但不一定是线程安全的，单例与线程安全无必然联系spring中bean还是无状态的,ejb是两者都有。Stateless无状态用单例Singleton模式，Stateful有状态就用原型Prototype模式。Stateful 有状态是多线程编码的天敌，所以在开发中尽量用Stateless无状态，无状态是不变(immutable)模式的应用，有很多优点：不用管线程和同步的问题，如果值是不可变的，程序不用担心多个线程改变共享状态，所以可以避免线程竞争的bugs. 因为没有竞争，就不用用locks等机制，所以无状态的不变机制，也可以避免产生死锁现象。有状态就是有数据存储功能。有状态对象(Stateful Bean)，就是有实例变量的对象，可以保存数据，是非线程安全的。在不同方法调用间不保留任何状态。无状态就是一次操作，不能保存数据。无状态对象(Stateless Bean)，就是没有实例变量的对象.不能保存数据，是不变类，是线程安全的。http://www.moosepp.top/2016/08/21/%E6%9C%89%E7%8A%B6%E6%80%81bean%E5%92%8C%E6%97%A0%E7%8A%B6%E6%80%81bean%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/ 我们知道在一般情况下，只有无状态的Bean才可以在多线程环境下共享，在Spring中，绝大部分Bean都可以声明为singleton作用域。就是因为Spring对一些Bean（如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等）中非线程安全的“状态性对象”采用ThreadLocal进行封装，让它们也成为线程安全的“状态性对象”，因此有状态的Bean就能够以singleton的方式在多线程中正常工作了。或者浅显的解决办法就是将多态bean的作用域由“singleton”变更为“prototype”。 How to Make/Design a Thread Safe “Object”?无状态、不变、Design your beans immutable: for example have no setters and only use constructor arguments to create a bean. There are other ways, such as Builder pattern, etc..Design your beans stateless: for example a bean that does something can be just a function (or several). This bean in most cases can and should be stateless, which means it does not have any state, it only does things with function arguments you provide each time (on each invocation) http://stackoverflow.com/questions/15745140/are-spring-objects-thread-safe","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://duyao.github.io/tags/spring/"}]},{"title":"IO相关","slug":"IO相关","date":"2017-03-17T13:33:44.000Z","updated":"2017-06-11T09:12:38.000Z","comments":true,"path":"2017/03/17/IO相关/","link":"","permalink":"http://duyao.github.io/2017/03/17/IO相关/","excerpt":"","text":"java.io中可以分为4个大类传输数据的格式可以分为字节和字符基于字节的I/O接口:InputStream和OutputSream基于字符的I/O接口:Writer和Reader传输数据的方式可以分为磁盘和网络基于磁盘的I/O接口:File基于网络的I/O接口:Socket(不是io包) 不管是网络还是磁盘，最小的存储单元仍然是字节而不是字符。而程序中经常是以字符为单位的，所以还是要有字符的接口的。http://www.jianshu.com/p/9fe3b51cf055 访问文件的方式标准的文件访问 标准的文件访问 直接的io方式直接就是不经过操作系统的内核数据缓冲区，直接访问磁盘数据，这样做的目的就是为了减少一次从内核缓冲区到用户缓存的数据复制。比如数据库管理系统。但是如果数据不在应用程序缓存中，每次从磁盘直接加载，就会很慢，所以直接io通常与异步io相结合。 同步/异步访问文件同步：只有数据被成功写入文件，才会返回成功给应用程序。异步：当访问数据的线程发出请求后，线程会接着处理其他事情，而不会阻塞，当请求的数据返回时才会继续处理下面的操作。 内存映射指的是操作系统将内存中的某一块区域与磁盘的文件关联起来，当要访问内存中一段数据时，转换为访问文件中国的一段数据，做到空间共享。http://www.jianshu.com/p/968d2c2d4471 编码编码分类字符集和字符编码1、字符集（charset）字符集指的是一个系统支持的所有抽象字符的集合。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等，常见的字符集有ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。2、字符编码（encoding）计算机要准确处理各种字符集文字，就要进行字符编码，以便计算机能够识别和存储各种文字。因此字符编码就是讲符号转换为计算机可以接受的数字系统的数，称为数字代码。 ASCII码计算机里面只有数字0和1（严格说连0和1都没有，只有开和关，无非是用0和1表示开关的状态罢了），在计算机软件里的一切都是用数字标识的额，屏幕上显示的一个一个字符也是数字。最初使用的计算机在美国，用到的字符很少，因此每一个字符都用一个数字表示，一个字节所能表示的数字反内卫足以容纳所有这些字符。实际上表示这些字符的数字的字节最高位都是0，也就是说这些数字都在0~127之间，如字符a对应97，字符b对应数字98，这种字符与数字的对应编码固定下来之后，这套编码规则被称为ASCII码（美国标准信息交换码）。 1、0~31是控制字符，如换行、回车、删除等2、32~126是打印字符，可以通过键盘输入并且能够显示出来 GB2312和GBK随着计算机在其它国家的普及，许多国家把本地字符集引入了计算机，大大扩展了计算机中字符的范围。一个字节所能表示的范围不足以容纳中文字符（看看上面的ASCII码表就知道了），中国大陆将每一个中文字符都用两个字节表示，原有的ASCII码字符的编码保持不变。 为了将一个中文字符与两个ASCII码字符相区别，中文字符的每个字节最高位为1，中国大陆为每一个中文字符都指定了一个对应的数字，并于1980年制定了一套《信息技术 中文编码字符集》，这套规范就是GB2312。GB2312是双字节编码，总的编码范围是A1~F7，其实A1~A9是富豪区，总共包含682个符号；B0~F7是汉字区，总共包含6763个汉字。 GBK是在1995年制定的后续标准，全称为《汉字内码扩展规范》，是国家技术监督局为Windows 95所制定的新的汉字内码规范。GBK的出现是为了扩展GBK2312，并加入更多的汉字。GBK的编码范围是8140~FEFE（去掉XX7F），总共有23940个码位，能表示21003个汉字，它的编码是和GB2312兼容的，也就是说用GB2312编码的汉字可以用GBK来解码，并且不会有乱码问题。GBK还是现如今中文Windows操作系统的系统默认编码。 Unicode在一个国家的本地化系统中出现的一个字符，通过电子邮件传送到另外一个国家的本地化系统中，看到的就不是那个原始字符了，而是另外那个国家的一个字符或乱码，因为计算机里面并没有真正的字符，字符都是以数字的形式存在的，通过邮件传送一个字符，实际上传送的是这个字符对应的字符编码，同一个数字在不同的国家和地区代表的很可能是不同的符号。 为了解决各个国家和地区之间各自使用不同的本地化字符编码带来的不便，人们将全世界所有的符号进行了统一编码，称之为Unicode（统一码、万国码）。所有字符不再区分国家和地区，都是人类共有的符号，如”中”字在Unicode中不再是GBK中的D6D0，而是在任何地方都是4e2d，如果所有的计算机系统都使用这种编码方式，那么4e2d这个字在任何地方都代表汉字中的”中”。Unicode编码的字符都占用两个字节的大小，也就是说全世界所有字符个数不会超过65536个。 当然Unicode只包含65536个字符就想包含全世界所有的字符是远远不够的，所以Unicode提供了字符平面映射。另外要提一点的是，Unicode是Java和XML的基础。 UTF-8和UTF-16 Unicode是一种字符集标准，而具体该标准应该如何应用到计算机中，则是另一个话题了，常用的Unicode编码方式有两种： 1、UTF-16。两个字节表示Unicode转换格式，这是定长的表示方法。也就是说不管什么字符都可以使用两个字节表示，两个字节是16Bit，所以叫做UTF-16。UTF-16编码非常方便，每两个字节表示一个字符，这个在字符串操作时大大简化了操作。 2、UTF-8。UTF-16统一采用了两个字节表示一个字符，虽然在表示上非常简单，但是很大一部分字符用一个字节表示就够了，现在需要两个字节，存储空间放大了一倍。UTF-8就采取了一种变长技术，每个编码区域有不同的字码长度，不同类型的字符可以是由1~6个字节组成。 两种编码方式比较，相对来说，UTF-16的编码效率较高，从字符到字节的相互转换可以更简单，进行字符串操作也更好，它更适合在本地磁盘和内存之间使用，可以进行字符和字节之间的快速切换。但是UTF-16并不适合在网络之间传输，因为网络传输易损坏字节流，一旦字节流损坏将很难恢复，所以相比较而言UTF-8更适合网络传输。另外UTF-8对ASCII字符采用单字节存储，单个字符损坏也不会影响后面的其他字符，在编码效率上介于GBK和UTF-16之间，所以，UTF-8在编码效率和编码安全性上做了平衡，是理想的中文编码方式。 Java中的字符使用的都是Unicode字符集，编码方式为UTF-16 转化桥梁数据持久化或者网络传输中都是以字节的进行的，因此有必要完成从字符到字节的转化。 标准的文件访问 InputStreamReader就是Reader和InputStream的转化桥梁 12345678910public class InputStreamReader extends Reader &#123; private final StreamDecoder sd; ...&#125;public class StreamDecoder extends Reader &#123; private Charset cs; private CharsetDecoder decoder; private InputStream in; ...&#125; 这也是适配器模式的一种体现。 序列化序列化就是将一个对象转化为一串二进制表示的字节数组，通过保存或转移这些字节数据来达到持久化(Java平台允许我们在内存中创建可复用的Java对象，但一般情况下，只有当JVM处于运行时，这些对象才可能存在，即，这些对象的生命周期不会比JVM的生命周期更长。但在现实应用中，就可能要求在JVM停止运行之后能够保存(持久化)指定的对象，并在将来重新读取被保存的对象。Java对象序列化就能够帮助我们实现该功能。)的目的。如果要持久化必须要继承java.io.Serializable。 如果仅仅只是让某个类实现Serializable接口，而没有其它任何处理的话，则就是使用默认序列化机制。使用默认机制，在序列化对象时，不仅会序列化当前对象本身，还会对该对象引用的其它对象也进行序列化，同样地，这些其它对象引用的另外对象也将被序列化，以此类推。所以，如果一个对象包含的成员变量是容器类对象，而这些容器所含有的元素也是容器类对象，那么这个序列化的过程就会较复杂，开销也较大。在纯java的情况下，序列化能很好地工作，但是多语言环境中，用java序列化存储之后。很难用其他语言还原回来。因此通常使用json或xml结构数据，或者比较好的序列化工具如protobuf 序列化并不保存静态变量 序列化方法假定一个Student类，它的对象需要序列化，可以有如下三种方法： 方法一：若Student类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化ObjectOutputStream采用默认的序列化方式，对Student对象的非transient的实例变量进行序列化。ObjcetInputStream采用默认的反序列化方式，对对Student对象的非transient的实例变量进行反序列化。 方法二：若Student类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。ObjectOutputStream调用Student对象的writeObject(ObjectOutputStream out)的方法进行序列化。ObjectInputStream会调用Student对象的readObject(ObjectInputStream in)的方法进行反序列化。 方法三：若Student类实现了Externalnalizable接口，且Student类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。ObjectOutputStream调用Student对象的writeExternal(ObjectOutput out))的方法进行序列化。ObjectInputStream会调用Student对象的readExternal(ObjectInput in)的方法进行反序列化。 方法二和方法三可以实现特殊字段的特殊系列化方法 JDK类库中序列化和反序列化的步骤 JDK类库中序列化步骤一：创建一个对象输出流，它可以包装一个其它类型的目标输出流，如文件输出流：ObjectOutputStream out = new ObjectOutputStream(new fileOutputStream(“D:\\\\objectfile.obj”));步骤二：通过对象输出流的writeObject()方法写对象：out.writeObject(“Hello”); out.writeObject(new Date()); JDK类库中反序列化的步骤：步骤一：创建一个对象输入流，它可以包装一个其它类型输入流，如文件输入流：ObjectInputStream in = new ObjectInputStream(new fileInputStream(“D:\\\\objectfile.obj”));步骤二：通过对象输出流的readObject()方法读取对象：String obj1 = (String)in.readObject(); Date obj2 = (Date)in.readObject(); 说明：为了正确读取数据，完成反序列化，必须保证向对象输出流写对象的顺序与从对象输入流中读对象的顺序一致。http://developer.51cto.com/art/201202/317181.htmhttps://www.ibm.com/developerworks/cn/java/j-lo-serial/ 序列化相关问题如何保证对象的引用关系比如123User u = new User(\"001\");Order o1 = new Order(1,u);Order o2 = new Order(2,u); 只有相同的ObjectOutputStream才能保证反序列化出来的两个order中的user是相同的另外，序列化和反序列化可以在不同的工程里面，但是前提是，反序列化的工程中必须有反序列化对象的class文件。 serialVersionId的作用可以保证class文件的兼容性，也就是说，即使序列化和反序列化中的对象属性不完全相同(序列化中的user只有name属性，反序列化中的user有name和age属性)，只要serialVersionId相同，就可以序列化成功但是，反序列化过程不会调用构造函数，同时变化的属性值为默认值，也就是说对于新的属性，使用构造函数初始化值，在反序列化过程中是无效的 IO简单总结总结一下流类的使用 1、File是一些文件/文件夹操作的源头，File代表的就是文件/文件夹本身，因此无论如何，使用IO的第一步是建议开发者根据路径实例化出一个File2、考虑使用字符流还是字节流。操作文本一般使用字符流，即Reader和Writer；操作字节文件使用字节流，即InputStream和OutputStream3、选择使用输入流还是输出流。把内容从文件读入Java内存使用输入流，即Reader和InputStream；把内容从Java内存读到文件使用输出流，即Writer和OutputStream4、使用字符流使用BufferedReader和BufferedWriter，它们的构造函数中的参数分别是Reader和Writer，因此既可以实例化出FileReader和FileWriter，也可以实例化出InputStreamReader和OutputStreamWriter，作为构造函数的参数传入BufferedReader和BufferedWriter5、FileInputStream和FileOutputStream可以直接操作文件的读写，它们没有做缓存6、ObjectOutputStream和ObjectInputStream，它们分别以OutputStream和InputStream作为构造函数的参数，因此可以实例化出FileOutputStream和FileInputStream并传入 Reader Writer InputStream OutputStream https://www.ibm.com/developerworks/cn/java/j-lo-javaio/ 设计模式适配器将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 Java I/O 库大量使用了适配器模式，例如 ByteArrayInputStream 是一个适配器类，它继承了 InputStream 的接口，并且封装了一个 byte 数组。换言之，它将一个 byte 数组的接口适配成 InputStream 流处理器的接口。我们知道 Java 语言支持四种类型：Java 接口，Java 类，Java 数组，原始类型（即 int,float 等）。前三种是引用类型，类和数组的实例是对象，原始类型的值不是对象。也即，Java 语言的数组是像所有的其他对象一样的对象，而不管数组中所存储的元素类型是什么。这样一来的话，ByteArrayInputStream 就符合适配器模式的描述，是一个对象形式的适配器类。 FileInputStream 是一个适配器类。在 FileInputStream 继承了 InputStrem 类型，同时持有一个对 FileDiscriptor 的引用。这是将一个 FileDiscriptor 对象适配成 InputStrem 类型的对象形式的适配器模式。FileOutputStream同理123456public class FileInputStream extends InputStream&#123; /* File Descriptor - handle to the open file */ private final FileDescriptor fd; ...&#125; 同样地，在 OutputStream 类型中，所有的原始流处理器都是适配器类。ByteArrayOutputStream 继承了 OutputStream 类型，同时持有一个对 byte 数组的引用。它一个 byte 数组的接口适配成 OutputString 类型的接口，因此也是一个对象形式的适配器模式的应用。 Reader 类型的原始流处理器都是适配器模式的应用。StringReader 是一个适配器类，StringReader 类继承了 Reader 类型，持有一个对 String 对象的引用。它将 String 的接口适配成 Reader 类型的接口。 https://www.ibm.com/developerworks/cn/java/j-lo-adapter-pattern/#ibm-pcon 装饰器装饰器模式又称为包装（Wrapper）模式。装饰器模式以多客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。 装饰器模式的结构通常给对象添加功能，要么直接修改对象添加相应的功能，要么派生子类来扩展，抑或是使用对象组合的方式。显然，直接修改对应的类的方式并不可取，在面向对象的设计中，我们应该尽量使用组合对象而不是继承对象来扩展和复用功能，装饰器模式就是基于对象组合的方式的。装饰器模式以对客户端透明的方式动态地给一个对象附加上了更多的责任。换言之，客户端并不会角色对象在装饰前和装饰后有什么不同。装饰器模式可以在不用创建更多子类的情况下，将对象的功能加以扩展。 装饰器在io中的分析 io类中装饰器模式分析 有了上面的图片，在使用基本io时就好办多了。首先根据需求来判断是操作字节（InputStream 和 OutputStream），还是操作字符（Reader 和 Writer）来选择不同的分支。然后根据是操作对象还是文件等来选择具体的组件（装饰者模式的 ConcreteComponent），最后根据是否需要缓冲区等功能来使用相应的装饰者类来包装具体组件类。 简单例子：以字节流方式读取图片。因为读取的是图片，因此不能选择字符操作的 Reader，应选择 InputStream；因为图片属于文件系统中的文件，所以选择FileInputStream；又因为我们觉得一次读取一个字节不合适，我们又使用 BufferedInputStream 来包装具体组件 FileInputStream。因此有了以下代码InputStream ips = new BufferedInputStream( new FileInputStream(&quot;...&quot;)) 我们这里实例化出了三个InputStream的实现类： 1234File file = new File(&quot;D:/aaa.txt&quot;);FileInputStream in0 = new FileInputStream(file);BufferedInputStream in1 = new BufferedInputStream(new FileInputStream(file));DataInputStream in2 = new DataInputStream(new BufferedInputStream(new FileInputStream(file))); 1、in0这个引用指向的是new出来的FileInputStream，这和装饰器模式无关，因为InputStream本身就是一个输入流，FileInputStream实现了最基本的功能罢了2、in1这个引用指向的是new出来的BufferedInputStream，这就和装饰器模式有关了，它给FileInputStream增加了功能，使得FileInputStream读取文件的内容保存在内存中，以提高读取的功能3、in2这个引用指向的是new出来的DataInputStream，这也和装饰器模式有关，因为它也给FileInputStream增加了功能，因为它有DataInputStream和BufferedInputStream两个附加的功能2和3这两点，对于客户端来说，只是使用InputStream的方法而已，根本不知道某个InputStream是否被装饰了，如果被装饰了，InputStream在装饰前和装饰后有什么区别。在客户端不知情的情况下，给这些方法附加上了额外的功能，这就是装饰器模式。 装饰器模式的优缺点优点 1、装饰器模式与继承关系的目的都是要扩展对象的功能，但是装饰器模式可以提供比继承更多的灵活性。装饰器模式允许系统动态决定贴上一个需要的装饰，或者除掉一个不需要的装饰。继承关系是不同，继承关系是静态的，它在系统运行前就决定了2、通过使用不同的具体装饰器以及这些装饰类的排列组合，设计师可以创造出很多不同的行为组合 缺点 由于使用装饰器模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是另一方面，由于使用装饰器模式会产生比使用继承关系更多的对象，更多的对象会使得查错变得困难，特别是这些对象看上去都很像。 装饰器模式和适配器模式的区别其实适配器模式也是一种包装（Wrapper）模式，它们看似都是起到包装一个类或对象的作用，但是它们使用的目的非常不一样： 1、适配器模式的意义是要将一个接口转变成另外一个接口，它的目的是通过改变接口来达到重复使用的目的2、装饰器模式不要改变被装饰对象的接口，而是恰恰要保持原有的接口，但是增强原有接口的功能，或者改变元有对象的处理方法而提升性能 所以这两种设计模式的目的是不同的。","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"java","slug":"java","permalink":"http://duyao.github.io/tags/java/"}]},{"title":"MapReduce分析","slug":"MapReduce分析","date":"2017-03-14T07:14:57.000Z","updated":"2017-03-19T07:59:58.000Z","comments":true,"path":"2017/03/14/MapReduce分析/","link":"","permalink":"http://duyao.github.io/2017/03/14/MapReduce分析/","excerpt":"","text":"input - map - combine - shuffle - reduce - output input如果输入为hdfs，先将块转化为InputSpilt，然后将InputSpilt作为map的输入，InputSpilt只是逻辑上的数据分片，不会真的在磁盘上存储，只记录原节点信息，默认会把InputSpilt设置为块大小，可以调整。然后FileInputFormat会将InputSpilt取出键值对，key为行号，作为map的输入 map执行用户写的map每一个map对应一个环形缓冲区，用于存储map的输出结果，缓冲区大小为100m，阈值为80当超过这个大小，就会在将缓冲区内容溢写spill到磁盘这个过程中，还会把缓冲的数据划分为若干干分区，，每个分区都会进行排序如果有combine，这个时候会执行，时间点在合并之前最后将这写spill文件系进行排序合并，作为map的输出为了提高io，还可以把map进行压缩 3.shuffle=copy+sortmap的结果在节点的本地磁盘上，因此reduce不会等到所有的任务都会才进行。只要有一个完成，reduce就会进行复制输出，这就是shuffle的copy阶段默认reduce会有5个复制线程数据复制到reduce节点上，也是先进缓冲区，超出阈值，spill到磁盘复制结束后进入到sort阶段，进行归排序默认的将归并因子设置为10从shuffle可以看出，map处理的是一个inputspilt，而reduce是一个分区的所有map中间结果 4.reduce这时候只需要对这些按键分区有序的结果调用reduce就可以了 mr过程一共有3次排序 主要有快排和归并 MapReduce理解 MapRedeuce，我们可以把它分开来理解： 映射（Mapping） ：对集合里的每个目标应用同一个操作。即，如果你想把表单里每个单元格乘以二，那么把这个函数单独地应用在每个单元格上的操作就属于mapping（这里体现了移动计算而不是移动数据）；化简（Reducing）：遍历集合中的元素来返回一个综合的结果。即，输出表单里一列数字的和这个任务属于reducing。计算框架简单理解，MapReduce计算框架：把需要计算的东西放入到MapReduce中进行计算，然后返回一个我们期望的结果。所以首先我们需要一个来源（需要计算的东西）即输入（input），然后MapReduce操作这个输入（input），通过定义好的计算模型，最后得到一个（期望的结果）输出（output）。计算模型在这里我们主要讨论的是MapReduce计算模型：在运行一个mapreduce计算任务时候，任务过程被分为两个阶段：map阶段和reduce阶段，每个阶段都是用键值对（key/value）作为输入（input）和输出（output）。而程序员要做的就是定义好这两个阶段的函数：map函数和reduce函数。实例代码以MapReduce统计单词次数为例（伪代码），主要四个模块来讲解，如上图计算框架：Input，数据读入123456// 设置数据输入来源FileInputFormat.setInputPaths(job, args[0]);FileInputFormat.setInputDirRecursive(job, true); //递归job.setInputFormatClass(TextInputFormat.class); //设置输入格式//TextInputFormat，一种默认的文本输入格式，Mapper一次读取文本中的一行数据。使用Mapper计算1234567891011121314151617181920212223242526272829303132333435//设置Job的Mapper计算类和K2、V2类型job.setMapperClass(WordCountMapper.class); //1.设置Mapper类job.setMapOutputKeyClass(Text.class); //设置Mapper输出Key的类型job.setMapOutputValueClass(LongWritable.class);//设置Mapper输出Value的类型//WordCountMapper类/ 自定义的Map 需要继承Mapper K1 : 行序号 V1 : 行信息 K2 : 单词 V2 : 次数 /public static class WordCountMapper extends Mapper&lt;LongWritable,Text,Text,LongWritable&gt; &#123; Text k2 = new Text() ; LongWritable v2 = new LongWritable(); @Override protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException &#123; //1. 获取行信息 String line = value.toString(); //2. 获取行的所用单词 String[] words = line.split(“\\t”);//这里假设一行文本单词分隔符为”\\t” for (String word : words) &#123; k2.set(word.getBytes()) ; //设置键 v2.set(1); //设置值 context.write(k2,v2); &#125; &#125;&#125;使用Reducer合并计算12345678910111213141516171819202122232425262728//设置Job的Reducer计算类和K3、V3类型job.setReducerClass(WordCountReducer.class); //自定义的Reducer类job.setOutputKeyClass(Text.class); //输出Key类型job.setOutputValueClass(LongWritable.class); //输出Value类型//WordCountReducer 类/ 自定义的Reduce 需要继承Reducer K2 : 字符串 V3 : 次数（分组） K3 : 字符串 V3 : 次数（统计总的） /public static class WordCountReducer extends Reducer&lt;Text,LongWritable,Text,LongWritable&gt;&#123; LongWritable v3 = new LongWritable() ; int sum = 0 ; @Override protected void reduce(Text key, Iterable&lt;LongWritable&gt; values, Context context) throws IOException, InterruptedException &#123; sum = 0 ; for (LongWritable value : values) &#123; sum +=value.get() ; &#125; v3.set(sum); context.write( key , v3 ); &#125;&#125;Output，数据写出1FileOutputFormat.setOutputPath(job, new Path(args[1]));运行机制下面从两个角度来讲解MapReduce的运行机制：各个角色实体;运行的时间先后顺序。各个角色实体程序运行时过程设计到的一个角色实体1.1. Client：编写mapreduce程序，配置作业，提交作业的客户端 ；1.2. ResourceManager：集群中的资源分配管理 ；1.3. NodeManager：启动和监管各自节点上的计算资源 ；1.4. ApplicationMaster：每个程序对应一个AM，负责程序的任务调度，本身也是运行在NM的Container中 ；1.5. HDFS：分布式文件系统，保存作业的数据、配置信息等等。客户端提交Job2.1. 客户端编写好Job后，调用Job实例的Submit()或者waitForCompletion()方法提交作业；2.2. 客户端向ResourceManager请求分配一个Application ID，客户端会对程序的输出、输入路径进行检查，如果没有问题，进行作业输入分片的计算。Job提交到ResourceManager3.1. 将作业运行所需要的资源拷贝到HDFS中（jar包、配置文件和计算出来的输入分片信息等）；3.2. 调用ResourceManager的submitApplication方法将作业提交到ResourceManager。给作业分配ApplicationMaster4.1. ResourceManager收到submitApplication方法的调用之后会命令一个NodeManager启动一个Container ；4.2. 在该NodeManager的Container上启动管理该作业的ApplicationMaster进程。ApplicationMaster初始化作业5.1. ApplicationMaster对作业进行初始化操作；5.2. ApplicationMaster从HDFS中获得输入分片信息(map、reduce任务数)任务分配6.1. ApplicationMaster为其每个map和reduce任务向RM请求计算资源；6.2. map任务优先于reduce任，map数据优先考虑本地化的数据。任务执行，在 Container 上启动任务（通过YarnChild进程来运行），执行map/reduce任务。时间先后顺序输入分片（input split）每个输入分片会让一个map任务来处理，默认情况下，以HDFS的一个块的大小（默认为128M，可以设置）为一个分片。map输出的结果会暂且放在一个环形内存缓冲区中（默认mapreduce.task.io.sort.mb=100M）,当该缓冲区快要溢出时（默认mapreduce.map.sort.spill.percent=0.8）,会在本地文件系统中创建一个溢出文件，将该缓冲区中的数据写入这个文件；map阶段：由我们自己编写，最后调用 context.write(…)；partition分区阶段3.1. 在map中调用 context.write(k2,v2)方法输出，该方法会立刻调用 Partitioner类对数据进行分区，一个分区对应一个 reduce task。3.2. 默认的分区实现类是 HashPartitioner ，根据k2的哈希值 % numReduceTasks，可能出现“数据倾斜”现象。3.3. 可以自定义 partition ，调用 job.setPartitioner(…)自己定义分区函数。combiner合并阶段：将属于同一个reduce处理的输出结果进行合并操作4.1. 是可选的；4.2. 目的有三个：1.减少Key-Value对；2.减少网络传输；3.减少Reduce的处理。shuffle阶段：即Map和Reduce中间的这个过程5.1. 首先 map 在做输出时候会在内存里开启一个环形内存缓冲区，专门用来做输出，同时map还会启动一个守护线程；5.2. 如缓冲区的内存达到了阈值的80%，守护线程就会把内容写到磁盘上，这个过程叫spill，另外的20%内存可以继续写入要写进磁盘的数据；5.3. 写入磁盘和写入内存操作是互不干扰的，如果缓存区被撑满了，那么map就会阻塞写入内存的操作，让写入磁盘操作完成后再继续执行写入内存操作;5.4. 写入磁盘时会有个排序操作，如果定义了combiner函数，那么排序前还会执行combiner操作；5.5. 每次spill操作也就是写入磁盘操作时候就会写一个溢出文件，也就是说在做map输出有几次spill就会产生多少个溢出文件，等map输出全部做完后，map会合并这些输出文件，这个过程里还会有一个Partitioner操作（如上）5.6. 最后 reduce 就是合并map输出文件，Partitioner会找到对应的map输出文件，然后进行复制操作，复制操作时reduce会开启几个复制线程，这些线程默认个数是5个（可修改），这个复制过程和map写入磁盘过程类似，也有阈值和内存大小，阈值一样可以在配置文件里配置，而内存大小是直接使用reduce的tasktracker的内存大小，复制时候reduce还会进行排序操作和合并文件操作，这些操作完了就会进行reduce计算了。reduce阶段：由我们自己编写，最终结果存储在hdfs上的。 http://blog.xiaoxiaomo.com/2016/07/03/Hadoop-MapReduce%E8%AF%A6%E8%A7%A3/http://blog.xiaoxiaomo.com/2016/07/08/Hadoop-MapReduce%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://duyao.github.io/tags/Hadoop/"}]},{"title":"HDFS分析","slug":"HDFS分析","date":"2017-03-14T07:11:36.000Z","updated":"2017-03-14T07:28:52.000Z","comments":true,"path":"2017/03/14/HDFS分析/","link":"","permalink":"http://duyao.github.io/2017/03/14/HDFS分析/","excerpt":"","text":"Namenode 重点掌握： NameNode 的作用；NameNode 元数据的底层结构；SecondaryNameNode 的作用以及工作流程，以及为什么需要SecondaryNameNode。NameNode简介管理节点核心元数据，包括文件(夹)的目录结构和属性信息，还有文件与其所在位置的映射信息。一切读写的操作必须经过NameNode，但是传输数据本身不经过NameNode（好好理解这句话）。NameNodeNameNode 包括以下文件：（保存在linux的文件系统中）fsimage：元数据镜像文件，存储某一时段NameNode内存元数据信息即保存了最新的元数据checkpoint。edits：操作日志文件。fstime：保存最近一次checkpoint的时间NameNode 元数据NameNode 为了保证交互速度，会在内存中保存这些元数据信息，但同时也会将这些信息保存到硬盘上进行持久化存储；fsimage文件是内存中的元数据在硬盘上的checkpoint，它是一种序列化的格式，不能直接修改。Hadoop在重启时就是通过fsimage+edits来状态恢复，fsimage相当于一个checkpoint，首先将最新的checkpoint的元数据信息从fsimage中加载到内存，然后逐一执行edits修改日志文件中的操作以恢复到重启之前的最终状态。Hadoop的持久化过程是将上一次checkpoint以后最近一段时间的操作保存到修改日志文件edits中。SecondaryNameNode上面出现的一个问题是：edits会随着时间增加而越来越大，导致以后重启时需要花费很长的时间来按照edits中记录的操作进行恢复，于是Hadoop就专门弄了一个进程SecondaryNameNode。SecondaryNameNode节点 的主要功能是周期性将元数据节点的命名空间镜像文件（fsimage）和修改日志（edits）进行合并，以防edits日志文件过大。下面来看一看合并的流程：SecondaryNameNode节点 需要合并时，首先通知NameNode节点生成新的日志文件，以后的日志都写到新的日志文件中。SecondaryNameNode节点 用http get从NameNode节点获得fsimage文件及旧的edits日志文件。SecondaryNameNode节点 将 fsimage 文件加载到内存中，并执行日志文件中的操作，然后生成新的fsimage文件。SecondaryNameNode 节点将新的fsimage文件用http post传回NameNode节点上。NameNode 节点可以将旧的fsimage文件及旧的日志文件，换为新的fsimage文件和新的日志文件(第一步生成的)，然后更新fstime文件，写入此次checkpoint的时间。这样NameNode 节点中的fsimage文件保存了最新的checkpoint的元数据信息，日志文件也重新开始，不会变的很大了注意：这种机制有个问题：因edits存放在NameNode中，当NameNode挂掉，edits也会丢失，导致利用Secondary NameNode恢复Namenode时，会有部分数据丢失。HDFS设置了两种机制进行条件合并（hdfs-site.xml）：第一种：当时间间隔大于或者等于dfs.namenode.checkpoint.period配置的时间是做合并（默认一小时）第二种：当最后一次往journalNode写入的TxId（这个可以在namenode日志或者50070界面可以看到）和最近一次做Checkpoint的TxId的差值大于或者等于dfs.namenode.checkpoint.txns配置的数量（默认1000000）时做一次合并底层文件查看保存的NameNode元数据信息，在HADOOP_HOME/etc/hadoop/hdfs-site.xml 的 dfs.namenode.name.dir配置，如下图：123456&lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;file:///usr/local/hadoop_repo/name&lt;/value&gt;&lt;/property&gt;&lt;!– 我切换到/usr/local/hadoop_repo/name/current就能查看元数据信息了 –&gt;&lt;!– value可以配置多个，用逗号隔开，这样也算是一种备份方式吧–&gt;第一步：开启服务，查看某个fsimage文件，开启服务命令：bin/hdfs oiv -i fsimage文件，不然提示：ls: Connection refused第二步：查看内容，命令：bin/hdfs dfs -ls -R webhdfs://127.0.0.1:5978/。我的hdfs里面有hbase和hive的数据，所以元数据也比较多，这里来个部分截图（这个看上去就和web以及hdfs dfs -ls查看的结果差不多）：第三步：导出结果，这是导出fsimage文件内容，命令：hdfs oiv -p XML -i /usr/local/hadoop_repo/name/current/fsimage_0000000000000003292 -o fsimage.xmlxml节点在上面大家也能看见，主要看inode节点，下面就是文件以及文件夹的基本信息；id、name、type、mtime、permission、nsquota、dsquota；如果是文件还有更多属性，比如atime、perferredBlockSize、blocks等fsimage 保存有如下信息：123456789101112131415161718192021一、加载Img头信息，如下： 1、imgVersion(int)：当前image的版本信息 2、namespaceID(int)：用来确保别的HDFS instance中的datanode不会误连上当前NN。 3、numFiles(long)：整个文件系统中包含有多少文件和目录 4、genStamp(long)：生成该image时的时间戳信息。二 、如果加载目录，包含以下信息： 1、path(String)：该目录的路径，如”/user/build/build-index” 2、replications(short)：副本数（目录虽然没有副本，但这里记录的目录副本数也为3） 3、mtime(long)：该目录的修改时间的时间戳信息 4、atime(long)：该目录的访问时间的时间戳信息 5、blocksize(long)：目录的blocksize都为0 6、numBlocks(int)：文件块数,-1表示目录,大于1时，表示该文件对应有多个block信息 7、nsQuota(long)：namespace Quota值，若没加Quota限制则为-1 8、dsQuota(long)：disk Quota值，若没加限制则也为-1 9、username(String)：该目录的所属用户名 10、group(String)：该目录的所属组 11、permission(short)：该目录的permission信息，如644等，有一个short来记录。三、如果加载文件，则还会额外包含如下信息： 1、blockid(long)：属于该文件的block的blockid， 2、numBytes(long)：该block的大小 3、genStamp(long)：该block的时间戳在namenode启动时，就需要对fsimage按照如下格式进行顺序的加载，以将fsimage中记录的HDFS元数据信息加载到内存中。第三步：继续导出，这是导出edits文件内容，命令：bin/hdfs oev -i /usr/local/hadoop_repo/name/current/edits_0000000000000003295-0000000000000003296 -o edits.xml最大的节点是EDITS，下面就是版本信息EDITS_VERSION和很多的RECORD节点;每个edits文件第一个RECORD的RECORD都是以OP_START_LOG_SEGMENT开头;RECORD类型有很多，比如 OP_ADD、OP_TIMES、OP_DELETE、OP_ALLOCATE_BLOCK_ID、OP_ADD_BLOCK、OP_RENAME_OLD、OP_CLOSE等总结：从上面我们就可以看出，edits文件的信息特别详细，记录了每一步操作，所以文件大小增长也特别的快；fsimage文件内容就是edits文件详细步骤的浓缩。 DateNode一、Block块（数据存储单元），二、文件备份数，掌握Block块信息，副本数的设置。http://blog.csdn.net/androidlushangderen/article/details/47945597 http://blog.xiaoxiaomo.com/2016/06/26/Hadoop-HDFS%E4%B9%8BDataNode/","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://duyao.github.io/tags/Hadoop/"}]},{"title":"大数据算法题目","slug":"大数据算法题目","date":"2017-03-14T06:16:37.000Z","updated":"2017-05-04T11:57:00.000Z","comments":true,"path":"2017/03/14/大数据算法题目/","link":"","permalink":"http://duyao.github.io/2017/03/14/大数据算法题目/","excerpt":"","text":"常见的大数据算法题目 主要的解决方法 BitSet、Bloom Filter Hash 归并排序、堆排序 Trie树、字典树 例题1、海量日志数据，提取出某日访问百度次数最多的那个IP 分析：百度作为国内第一大搜索引擎，每天访问它的IP数量巨大，如果想一次性把所有IP数据装进内存处理，则内存容量明显不够，故针对数据太大，内存受限的情况，可以把大文件转化成（取模映射）小文件，从而大而化小，逐个处理。 换言之，先映射，而后统计，最后排序。 解法：具体分为以下3个步骤 分而治之/hash映射首先把这一天访问百度日志的所有IP提取出来，然后逐个写入到一个大文件中，接着采用映射的方法，比如%1000，把整个大文件映射为1000个小文件。 hash_map统计当大文件转化成了小文件，那么我们便可以采用hash_map(ip, value)来分别对1000个小文件中的IP进行频率统计，再找出每个小文件中出现频率最大的IP。 堆/快速排序统计出1000个频率最大的IP后，依据各自频率的大小进行排序(可采取堆排序)，找出那个频率最大的IP，即为所求。注：Hash取模是一种等价映射，不会存在同一个元素分散到不同小文件中去的情况，即这里采用的是%1000算法，那么同一个IP在hash后，只可能落在同一个文件中，不可能被分散的。 2、寻找热门查询，300万个查询字符串中统计最热门的10个查询 原题：搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录，请你统计最热门的10个查询串，要求使用的内存不能超过1G。 分析：这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。 由上面第1题，我们知道，数据大则划为小的，例如一亿个ip求Top 10，可先%1000将ip分到1000个小文件中去，并保证一种ip只出现在一个文件中，再对每个小文件中的ip进行hash_map统计并按数量排序，最后归并或者最小堆依次处理每个小文件的top10以得到最后的结果。 但对于本题，数据规模比较小，能一次性装入内存。因为根据题目描述，虽然有一千万个Query，但是由于重复度比较高，故去除重复后，事实上只有300万的Query，每个Query255Byte，因此我们可以考虑把他们都放进内存中去（300万个字符串假设没有重复，都是最大长度，那么最多占用内存3M*1K/4=0.75G。所以可以将所有字符串都存放在内存中进行处理）。 所以我们放弃分而治之/hash映射的步骤，直接上hash_map统计，然后排序。So，针对此类典型的TOP K问题，采取的对策往往是：hash_map + 堆。 解法： hash_map统计先对这批海量数据预处理。具体方法是：维护一个Key为Query字串，Value为该Query出现次数的hash_map，即hash_map(Query, Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并将Value值设为1；如果该字串在Table中，那么将该字串的计数加1 即可。最终我们在O(N)的时间复杂度内用hash_map完成了统计； 堆排序借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。即借助堆结构，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。所以，我们最终的时间复杂度是：O(n) + N’ * O(logk），其中，N为1000万，N’为300万。关于第2步堆排序，可以维护k个元素的最小堆，即用容量为k的最小堆存储最先遍历到的k个数，并假设它们即是最大的k个数，建堆费时O（k），并调整堆(费时O(logk))后，有k1&gt;k2&gt;…kmin（kmin设为小顶堆中最小元素）。继续遍历数列，每次遍历一个元素x，与堆顶元素比较，若x&gt;kmin，则更新堆（x入堆，用时logk），否则不更新堆。这样下来，总费时O（klogk+（n-k）logk）=O（n*logk）。此方法得益于在堆中，查找等各项操作时间复杂度均为logk。 当然，你也可以采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。 3、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词 解法： 分而治之/hash映射顺序读取文件，对于每个词x，取hash(x)%5000，然后把该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。当然，如果其中有的小文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。 hash_map统计对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。 堆/归并排序取出出现频率最大的100个词（可以用含100个结点的最小堆）后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。 4、海量数据分布在100台电脑中，想个办法高效统计出这批数据的TOP10 解法一： 如果同一个数据元素只出现在某一台机器中，那么可以采取以下步骤统计出现次数TOP10的数据元素： 堆排序在每台电脑上求出TOP 10，可以采用包含10个元素的堆完成（TOP 10小，用最大堆，TOP 10大，用最小堆，比如求TOP10大，我们首先取前10个元素调整成最小堆，如果发现，然后扫描后面的数据，并与堆顶元素比较，如果比堆顶元素大，那么用该元素替换堆顶，然后再调整为最小堆。最后堆中的元素就是TOP 10大）。 组合归并求出每台电脑上的TOP 10后，然后把这100台电脑上的TOP 10组合起来，共1000个数据，再利用上面类似的方法求出TOP 10就可以了。 解法二： 但如果同一个元素重复出现在不同的电脑中呢，比如拿两台机器求top 2的情况来说： 第一台的数据分布及各自出现频率为：a(50)，b(50)，c(49)，d(49) ，e(0)，f(0)其中，括号里的数字代表某个数据出现的频率，如a(50)表示a出现了50次。第二台的数据分布及各自出现频率为：a(0)，b(0)，c(49)，d(49)，e(50)，f(50)这个时候，你可以有两种方法： 遍历一遍所有数据，重新hash取摸，如此使得同一个元素只出现在单独的一台电脑中，然后采用上面所说的方法，统计每台电脑中各个元素的出现次数找出TOP 10，继而组合100台电脑上的TOP 10，找出最终的TOP 10。或者，暴力求解：直接统计统计每台电脑中各个元素的出现次数，然后把同一个元素在不同机器中的出现次数相加，最终从所有数据中找出TOP 10。5、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序 解法一： hash映射顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件（记为a0,a1,..a9）中。这样新生成的文件每个的大小大约也1G（假设hash函数是随机的）。 hash_map统计找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。注：hash_map(query, query_count)是用来统计每个query的出现次数，不是存储他们的值，出现一次，则count+1。 堆/快速/归并排序利用快速/堆/归并排序按照出现次数进行排序，将排序好的query和对应的query_cout输出到文件中，这样得到了10个排好序的文件（记为）。最后，对这10个文件进行归并排序（内排序与外排序相结合）。解法二： 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。 解法三： 与解法1类似，但在做完hash，分成多个文件后，可以交给多个文件来处理，采用分布式的架构来处理（比如MapReduce），最后再进行合并。 6、给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url？ 解法： 可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。 分而治之/hash映射遍历文件a，对每个url求取，然后根据所取得的值将url分别存储到1000个小文件（记为，这里漏写个了a1）中。这样每个小文件的大约为300M。遍历文件b，采取和a相同的方式将url分别存储到1000小文件中（记为）。这样处理后，所有可能相同的url都在对应的小文件（）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。 hash_set统计求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。7、100万个数中找出最大的100个数 解法一：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100万*100)。 解法二：采用快速排序的思想，每次分割之后只考虑比主元大的一部分，直到比主元大的一部分比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100万*100)。 解法三：在前面的题中，我们已经提到了，用一个含100个元素的最小堆完成。复杂度为O(100万*lg100)。 8、给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？ 解法一：可以用位图/Bitmap的方法，申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。 https://github.com/julycoding/The-Art-Of-Programming-By-July/blob/master/ebook/zh/Readme.mdhttp://blog.csdn.net/u013291394/article/details/50211181 布隆过滤器http://blog.csdn.net/lvsaixia/article/details/51503231","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"448. Find All Numbers Disappeared in an Array","slug":"448-Find-All-Numbers-Disappeared-in-an-Array","date":"2017-03-13T11:46:43.000Z","updated":"2017-03-13T11:59:24.000Z","comments":true,"path":"2017/03/13/448-Find-All-Numbers-Disappeared-in-an-Array/","link":"","permalink":"http://duyao.github.io/2017/03/13/448-Find-All-Numbers-Disappeared-in-an-Array/","excerpt":"","text":"448. Find All Numbers Disappeared in an Array442. Find All Duplicates in an Array 两道非常相似的题目都是使用nums[nums[i]-1] = -nums[nums[i]-1]，前提是这个数组是[1,n]原理是数组中的下标是[0,n-1]，然后通过上述的转换，即访问过得数字变为了负数，其中减一的原因是数组和下标相差1 448找重复123456789101112131415public List&lt;Integer&gt; findDuplicates(int[] nums) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; int val = Math.abs(nums[i])-1; if(nums[val] &gt; 0)&#123; nums[val] = -nums[val]; &#125;else&#123; res.add(val+1); &#125; &#125; return res;&#125; 442找没有出现的1234567891011121314151617public List&lt;Integer&gt; findDisappearedNumbers(int[] nums) &#123; List&lt;Integer&gt; ret = new ArrayList&lt;Integer&gt;(); for(int i = 0; i &lt; nums.length; i++) &#123; int val = Math.abs(nums[i]) - 1; if(nums[val] &gt; 0) &#123; nums[val] = -nums[val]; &#125; &#125; for(int i = 0; i &lt; nums.length; i++) &#123; if(nums[i] &gt; 0) &#123; ret.add(i+1); &#125; &#125; return ret;&#125; http://blog.csdn.net/yutianzuijin/article/details/11384507","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"}]},{"title":"String相关","slug":"String相关","date":"2017-03-12T07:23:56.000Z","updated":"2017-04-06T01:47:46.000Z","comments":true,"path":"2017/03/12/String相关/","link":"","permalink":"http://duyao.github.io/2017/03/12/String相关/","excerpt":"","text":"String12345public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[];&#125; 1）String类是final类，也即意味着String类不能被继承，并且它的成员方法都默认为final方法。2）上面列举出了String类中所有的成员属性，从上面可以看出String类其实是通过char数组来保存字符串的 为什么是string是不可变的安全性：网络连接中的参数通常是string的数据库url、password Security: parameters are typically represented as String in network connections, database connection urls, usernames/passwords etc. If it were mutable, these parameters could be easily changed.Synchronization and concurrency: making String immutable automatically makes them thread safe thereby solving the synchronization issues.Caching: when compiler optimizes your String objects, it sees that if two objects have same value (a=”test”, and b=”test”) and thus you need only one string object (for both a and b, these two will point to the same object).Class loading: String is used as arguments for class loading. If mutable, it could result in wrong class being loaded (because mutable objects change their state).http://stackoverflow.com/questions/22397861/why-is-string-immutable-in-java hashCode 和 equal方法 hash code(散列码，也可以叫哈希码值)是对象产生的一个整型值。 其生成没有规律的。二者散列码可以获取对象中的信息，转成那个对象的“相对唯一”的整型值。所有对象都有一个散列码。h = 31 * h + val[i];这里的计算为什么要用31呢？看看《Effective Java》第二版第三章第42页中的原话：之所以选择31，是因为它是个奇素数，如果乘数是偶数，并且乘法溢出的话，信息就会丢失，因为与2相乘等价于移位运算。使用素数的好处并不是很明显，但是习惯上都使用素数来计算散列结果。31有个很好的特性，就是用移位和减法来代替乘法，可以得到更好的性能：31*i==(i&lt;&lt;5)-i。现在的VM可以自动完成这种优化。 123456789101112public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 如果传入参数地址相同，那一定是相等的。如果传入参数anObject是String类型，那么就循环迭代这两个字符串对应的字符数组中的每一个值是否相等，如有一个字符不相等，则返回false。123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; hash常见方法XXX.hashCode(primitive); // primitve 是基本类型，XXX 是 primitve 的 Wrapper ClassObjects.hashCode(obj); // obj 是对象Arrays.hashCode(ary); // ary 是各种数组Objects.hash(x, y, z); // 参数是 varargs，可以是多个各种类型，但不建议参数个数只有一个 重写equals根据《effective java》这本书的内容，进行总结一下： 我们若要重写equals方法时，必须遵守他的通用约定，否则会出现异常。 对称性（symmetric）：任何非空=null引用值x y，如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。 自反性（reflexive）：任何非空=null引用值 x，x.equals(x)必须返回是“true”。 传递性（transitive）：任何非空=null引用值x y z ，如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。 一致性（consistent）：任何非空=null引用值x y,如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。 任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回false 当我们重写equals方法时，也要重写hashCode方法，因为我们要保证，如果两个对象equals等于true，那么hashCode返回值必须也是相等的1、当两个对象equals方法返回true，那么hashCode返回值一定是相等的；如果两个对象equals方法返回值是false，那么这两个对象的hashCode的返回值有可能相等。2、当两个对象的hashCode返回值相等时，两个对象的equals方法不一定true（hash冲突）；但是如果两个对象的hashCode返回值不相等，那么这个对象equals返回值一定是false. 其他方法1234567891011121314151617181920212223242526public String substring(int beginIndex, int endIndex) &#123; if (beginIndex &lt; 0) &#123; throw new StringIndexOutOfBoundsException(beginIndex); &#125; if (endIndex &gt; value.length) &#123; throw new StringIndexOutOfBoundsException(endIndex); &#125; int subLen = endIndex - beginIndex; if (subLen &lt; 0) &#123; throw new StringIndexOutOfBoundsException(subLen); &#125; //当子串还是原来的就不会new，而是返回原来的 return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen);&#125;public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; char buf[] = new char[count + otherLen]; getChars(0, count, buf, 0); str.getChars(0, otherLen, buf, count); return new String(0, count + otherLen, buf);&#125; 可以看出，string 的方法都是返回new出来的新字符串，只有当结果不变的时候才是返回原字符串的“对String对象的任何改变都不影响到原对象，相关的任何change操作都会生成新的对象”。 一个例子先看java内存区域 执行String str = &quot;hello&quot;语句的过程首先编译，形成class文件然后进入加载阶段：把class文件加载到虚拟机中，class文件中大部分的数据会被加载到“运行常量池running time pool”中但是string不会，其中的“hello”的一个引用会被存在“字符串常量池中string pool”，而“hello”本体还是和所有对象一样创建在堆heap上这只是在Test类被类加载器加载时候的情形。主线程中的str变量这时候都还没有被创建，但Hello的实例已经在Heap里了，对它的引用也已经在字符串常量池里了。 等主线程开始创建str变量的时候，虚拟机就会到字符串常量池里找，看有没有能equals(“Hello”)的String。如果找到了，就在栈区当前栈帧的局部变量表里创建str变量，然后把字符串常量池里对Hello对象的引用复制给str变量。找不到的话，才会在heap堆重新创建一个对象，然后把引用驻留到字符串常量区。然后再把引用复制栈帧的局部变量表。 如果我们当时定义了很多个值为”Hello”的String，比如String str1 = &quot;hello&quot;;String str2 = &quot;hello&quot;;String str3 = &quot;hello&quot;;，有三个变量str1,str2,str3，也不会在堆上增加String实例。局部变量表里三个变量统一指向同一个堆内存地址。 但如果是用new关键字来创建字符串String str1 = &quot;Hello&quot;;String str2 = &quot;Hello&quot;;String str3 = new String(&quot;Hello&quot;);，情况就不一样了 这时候，str1和str2还是和之前一样。但str3因为new关键字会在Heap堆申请一块全新的内存，来创建新对象。虽然字面还是”Hello”，但是完全不同的对象，有不同的内存地址。 https://www.zhihu.com/question/29884421关于不同的常量池http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/ StringBuffer和StringBuilder初始大小都是16而StringBuffer是线程安全的，因为他的方法被synchronized修饰，而StringBuilder不安全所以通常来说StringBuilder &gt; StringBuffer &gt; String 12345678910111213//StringBufferpublic synchronized String toString() &#123; if (toStringCache == null) &#123; toStringCache = Arrays.copyOfRange(value, 0, count); &#125; return new String(toStringCache, true);&#125;//StringBuilderpublic String toString() &#123; // Create a copy, don't share the array return new String(value, 0, count);&#125; 与String的关系12345678910111213public static void main1(String[] args) &#123; String string = \"\"; for(int i=0;i&lt;10000;i++)&#123; string += \"hello\"; &#125;&#125;public static void main2(String[] args) &#123; StringBuilder stringBuilder = new StringBuilder(); for(int i=0;i&lt;10000;i++)&#123; stringBuilder.append(\"hello\"); &#125;&#125; 在main1中，每次循环会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象。也就是说这个循环执行完毕new出了10000个对象，试想一下，如果这些对象没有被回收，会造成多大的内存资源浪费。在main2中，new操作只进行了一次，也就是说只生成了一个对象，append操作是在原有对象的基础上进行的。因此在循环了10000次之后，这段代码所占的资源要比上面小得多。 1234567891011121314151617181920public static void test1String () &#123; long begin = System.currentTimeMillis(); for(int i=0; i&lt;time; i++)&#123; String s = \"I\"+\"love\"+\"java\"; &#125; long over = System.currentTimeMillis(); System.out.println(\"字符串直接相加操作：\"+(over-begin)+\"毫秒\");&#125;public static void test2String () &#123; String s1 =\"I\"; String s2 = \"love\"; String s3 = \"java\"; long begin = System.currentTimeMillis(); for(int i=0; i&lt;time; i++)&#123; String s = s1+s2+s3; &#125; long over = System.currentTimeMillis(); System.out.println(\"字符串间接相加操作：\"+(over-begin)+\"毫秒\");&#125; 由此可以得出结论：1）对于直接相加字符串，效率很高，因为在编译器便确定了它的值，也就是说形如&quot;I&quot;+&quot;love&quot;+&quot;java&quot;; 的字符串相加，在编译期间便被优化成了&quot;Ilovejava&quot;。这个可以用javap -c命令反编译生成的class文件进行验证。2）对于间接相加（即包含字符串引用），形如s1+s2+s3; 效率要比直接相加低，因为在编译器不会对引用变量进行优化。 一些例子1）下面这段代码的输出结果是什么？ String a = &quot;hello2&quot;; String b = &quot;hello&quot; + 2; System.out.println((a == b)); 输出结果为：true。原因很简单，”hello”+2在编译期间就已经被优化成”hello2”，因此在运行期间，变量a和变量b指向的是同一个对象。 2）下面这段代码的输出结果是什么？ String a = &quot;hello2&quot;; String b = &quot;hello&quot;; String c = b + 2; System.out.println((a == c)); 输出结果为:false。由于有符号引用的存在，所以 String c = b + 2;不会在编译期间被优化，不会把b+2当做字面常量来处理的，因此这种方式生成的对象事实上是保存在堆上的。因此a和c指向的并不是同一个对象。 3）下面这段代码的输出结果是什么？ String a = &quot;hello2&quot;; final String b = &quot;hello&quot;; String c = b + 2; System.out.println((a == c)); 输出结果为：true。对于被final修饰的变量，会在class文件常量池中保存一个副本，也就是说不会通过连接而进行访问，对final变量的访问在编译期间都会直接被替代为真实的值。那么String c = b + 2;在编译期间就会被优化成：String c = “hello” + 2; 4）下面这段代码输出结果为：123456789101112public class Main &#123; public static void main(String[] args) &#123; String a = \"hello2\"; final String b = getHello(); String c = b + 2; System.out.println((a == c)); &#125; public static String getHello() &#123; return \"hello\"; &#125;&#125; 输出结果为false。这里面虽然将b用final修饰了，但是由于其赋值是通过方法调用返回的，那么它的值只能在运行期间确定，因此a和c指向的不是同一个对象。 5）下面这段代码的输出结果是什么？ 12345678910111213public class Main &#123; public static void main(String[] args) &#123; String a = &quot;hello&quot;; String b = new String(&quot;hello&quot;); String c = new String(&quot;hello&quot;); String d = b.intern(); System.out.println(a==b); System.out.println(b==c); System.out.println(b==d); System.out.println(a==d); &#125;&#125; ffft这里面涉及到的是String.intern方法的使用。在String类中，intern方法是一个本地方法，在JAVA SE6之前，intern方法会在运行时常量池中查找是否存在内容相同的字符串，如果存在则返回指向该字符串的引用，如果不存在，则会将该字符串入池，并返回一个指向该字符串的引用。因此，a和d指向的是同一个对象。参考书57页 6）下面这段代码1）和2）的区别是什么？12345678public class Main &#123; public static void main(String[] args) &#123; String str1 = &quot;I&quot;; //str1 += &quot;love&quot;+&quot;java&quot;; 1) str1 = str1+&quot;love&quot;+&quot;java&quot;; //2) &#125;&#125; 1）的效率比2）的效率要高，1）中的”love”+”java”在编译期间会被优化成”lovejava”，而2）中的不会被优化。可以看出，在1）中只进行了一次append操作，而在2）中进行了两次append操作。 堆（Heap）：最大一块空间。存放对象实例和数组。全局共享 http://rednaxelafx.iteye.com/blog/774673/http://www.cnblogs.com/dolphin0520/p/3778589.html","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"java","slug":"java","permalink":"http://duyao.github.io/tags/java/"}]},{"title":"二叉树及其相关","slug":"二叉树及其相关","date":"2017-03-10T11:33:39.000Z","updated":"2017-04-03T11:40:28.000Z","comments":true,"path":"2017/03/10/二叉树及其相关/","link":"","permalink":"http://duyao.github.io/2017/03/10/二叉树及其相关/","excerpt":"","text":"本文用来整理二叉树的各种知识点 二叉树性质 性质1 一棵非空二叉树的第i层上最多有2i-1个结点(i≥1)。 性质2 若规定空树的深度为0，则深度为k的二叉树最多有2k-1个结点(k≥0)。 性质3 具有n个结点的完全二叉树的深度k为log2n+1。 性质4 对于一棵非空二叉树，如果度为0的结点数目为n0，度为2的结点数目为n2，则有n0= n2+1。 性质5 对于具有n个结点的完全二叉树，如果按照从上到下和从左到右的顺序对所有结点从1开始编号，则对于序号为i的结点，有：（1）如果i&gt;1，则序号为i的结点的双亲结点的序号为i/2(“/”表示整除)；如果i=1，则该结点是根结点，无双亲结点。（2）如果2i≤n，则该结点的左孩子结点的序号为2i；若2i&gt;n，则该结点无左孩子。（3）如果2i+1≤n，则该结点的右孩子结点的序号为2i+1；若2i+1&gt;n，则该结点无右孩子。 性质6 给定N个节点，能构成h(N)种不同的二叉树。h(N)为卡特兰数的第N项。h(n)=C(n,2*n)/(n+1) 满二叉树(Full Binary Tree)如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。 深度为k的满二叉树的结点个数为2^k-1 完全二叉树(Complete Binary Tree)深度为k，有n个结点的二叉树当且仅当其每一个结点都与深度为k，有n个结点的满二叉树中编号从1到n的结点一一对应时，称为完全二叉树。 完全二叉树的特点是叶子结点只可能出现在层次最大的两层上，并且某个结点的左分支下子孙的最大层次与右分支下子孙的最大层次相等或大1。 完全二叉树是由满二叉树引出来的，因此满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树。 各种二叉树 哈弗曼树哈弗曼树可以设计出总长度最短的二进制前缀编码其构造方法是不断的构造新节点，取出权值最小的节点作为树的两个节点，并将新节点的权值设为两个节点的权值之和WPL = 求和 ( 叶节点的权值 * 该叶节点到根节点的距离 )WPL为带权路径长度，也是最终编码得到二进制编码的长度 哈弗曼树 二叉查找树(Binary Search Tree)二叉查找树,也称二叉搜索树、有序二叉树（英语：ordered binary tree），排序二叉树（英语：sorted binary tree）. 是指一棵空树或者具有下列性质的二叉树 任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 删除时要注意，如果删除的节点有左右子树，那么用左子树的最右节点(推荐)或者右子树的最左节点取代该删除节点 二叉查找树的时间复杂度不是严格的log(N)，在最坏的情况下会出现“链表”的形式，复杂度退化到O(N)因此有了AVL树(利用平衡因子), RB Tree红黑树(利用颜色), Treap(树和堆的结合)等来优化BST的最坏情况 References:Binary_search_tree AVL树在AVL树中任何节点的两个子树的高度最大差别为一查找、插入和删除在平均和最坏情况下都是O(log n)增加和删除可能需要通过一次或多次树旋转来重新平衡这个树 节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来 References:AVL_tree 红黑树Red-Black Tree在O(log n)时间内做查找，插入和删除，这里的n是树中元素的数目。 红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求： 节点是红色或黑色。 根是黑色。 所有叶子都是黑色（叶子是NIL节点）。 每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。） 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。 红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高. 详细内容请看红黑树 Treap树和堆的合体，在树中维护一个”优先级”，”优先级”采用随机数的方法，但是”优先级”必须满足根堆的性质插入原理与AVL相似 References:树堆Treap 伸展树(Splay Tree)能在O(log n)内完成插入、查找和删除操作。 在伸展树上的一般操作都基于伸展操作：假设想要对一个二叉查找树执行一系列的查找操作，为了使整个查找时间更小，被查频率高的那些条目就应当经常处于靠近树根的位置。于是想到设计一个简单方法， 在每次查找之后对树进行重构，把被查找的条目搬移到离树根近一些的地方。伸展树应运而生。伸展树是一种自调整形式的二叉查找树，它会沿着从某个节点到树根之间的路径，通过一系列的旋转把这个节点搬移到树根去。 它的优势在于不需要记录用于平衡树的冗余信息。伸展树最显著的缺点是它有可能会变成一条链。这种情况可能发生在以非降顺序访问n个元素之后。然而均摊的最坏情况是对数级的——O(log n) References:伸展树Splay_tree 多向平衡查找树：B-树和B+树B-树1.定义任意非叶子结点最多只有M个儿子；且M&gt;2；2.根结点的儿子数为[2, M]；3.除根结点以外的非叶子结点的儿子数为[M/2, M]；4.每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）5.非叶子结点的关键字个数=指向儿子的指针个数-1；6.非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；7.非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；8.所有叶子结点位于同一层； b树和b+树 B+树B+树是B-树的变体，也是一种多路搜索树：1.其定义基本与B-树同，除了：2.非叶子结点的子树指针与关键字个数相同；3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）；5.为所有叶子结点增加一个链指针；6.所有关键字都在叶子结点出现； B+树是B树的变形，它把所有的附属数据都放在叶子结点中，只将关键字和子女指针保存于内结点，内结点完全是索引的功能 查找过程假如每个盘块可以正好存放一个B树的结点（正好存放2个文件名）。那么一个BTNODE结点就代表一个盘块，而子树指针就是存放另外一个盘块的地址。下面，咱们来模拟下查找文件29的过程： 根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘IO操作1次】 此时内存中有两个文件名17、35和三个存储其他磁盘页面地址的数据。根据算法我们发现：17&lt;29&lt;35，因此我们找到指针p2。 根据p2指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘IO操作 2次】 此时内存中有两个文件名26，30和三个存储其他磁盘页面地址的数据。根据算法我们发现：26&lt;29&lt;30，因此我们找到指针p2。 根据p2指针，我们定位到磁盘块8，并将其中的信息导入内存。【磁盘IO操作 3次】 此时内存中有两个文件名28，29。根据算法我们查找到文件名29，并定位了该文件内存的磁盘地址。分析上面的过程，发现需要3 3次磁盘IO操作和次磁盘IO操作和3次内存查找 次内存查找操作。关于内存中的文件名查找，由于是一个有序表结构，可以利用折半查找提高效率。至于IO操作是影响整个B树查找效率的决定因素。 B+树还有一个最大的好处，方便扫库，B树必须用中序遍历的方法按序扫库，而B+树直接从叶子结点挨个扫一遍就完了，B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因。由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。程序运行期间所需要的数据通常比较集中。 http://www.ruanyifeng.com/blog/2014/07/database_implementation.htmlhttp://blog.csdn.net/l_griselda/article/details/8266014 字典树通常用于查找字符串，比如在搜索框中搜索会自动提示，或者lucene常用操作有 插入和查找, 删除 代码习题 208. Implement Trie (Prefix Tree) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public static class TrieNode &#123; char val; TrieNode[] children; boolean leaf; // Initialize your data structure here. public TrieNode() &#123; this.children = new TrieNode[26]; leaf = false; &#125; public TrieNode(char c) &#123; this.val = c; children = new TrieNode[26]; leaf = false; &#125;&#125;public static class Trie &#123; private TrieNode root; public Trie() &#123; root = new TrieNode(); &#125; // Inserts a word into the trie. public void insert(String word) &#123; TrieNode cur = root; for (int i = 0; i &lt; word.length(); i++) &#123; int index = word.charAt(i) - &apos;a&apos;; TrieNode tmp = cur.children[index]; if (tmp == null) &#123; tmp = new TrieNode(word.charAt(i)); cur.children[index] = tmp; &#125; if (i == word.length() - 1) &#123; tmp.leaf = true; &#125; cur = tmp; &#125; &#125; // Returns if the word is in the trie. public boolean search(String word) &#123; TrieNode cur = root; for (int i = 0; i &lt; word.length(); i++) &#123; int index = word.charAt(i) - &apos;a&apos;; TrieNode tmp = cur.children[index]; if (tmp != null) &#123; if (i == word.length() - 1 &amp;&amp; tmp.leaf) &#123; return true; &#125; cur = tmp; &#125; else &#123; // 无此节点 return false; &#125; &#125; return false; &#125; // Returns if there is any word in the trie // that starts with the given prefix. public boolean startsWith(String prefix) &#123; TrieNode cur = root; for (int i = 0; i &lt; prefix.length(); i++) &#123; int index = prefix.charAt(i) - &apos;a&apos;; TrieNode tmp = cur.children[index]; if (tmp != null) &#123; cur = tmp; &#125; else &#123; // 无此节点 return false; &#125; &#125; //prefix是该字符串也可以 return true; &#125;&#125;// Your Trie object will be instantiated and called as such:// Trie trie = new Trie();// trie.insert(&quot;somestring&quot;);// trie.search(&quot;key&quot;); 布隆过滤器字典树是一种空间换时间的数据结构，子节点存储着每一个可能的值，所以可能节点个数非常多而布隆过滤器是一个大数据场景下的替换字典树的数据结构其原理是当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。 相比于其它的数据结构，布隆过滤器在空间和时间方面都有巨大的优势。布隆过滤器存储空间和插入/查询时间都是常数（O(k)）。另外，散列函数相互之间没有关系，方便由硬件并行实现。布隆过滤器不需要存储元素本身，在某些对保密要求非常严格的场合有优势。但是布隆过滤器的缺点和优点一样明显。误算率是其中之一。随着存入的元素数量增加，误算率随之增加。但是如果元素数量太少，则使用散列表足矣。另外，一般情况下不能从布隆过滤器中删除元素。我们很容易想到把位数组变成整数数组，每插入一个元素相应的计数器加1, 这样删除元素时将计数器减掉就可以了。然而要保证安全地删除元素并非如此简单。首先我们必须保证删除的元素的确在布隆过滤器里面。这一点单凭这个过滤器是无法保证的。另外计数器回绕也会造成问题。 布隆过滤器 上图中，m=18，k=3；插入x是，三个hash函数分别得到蓝线对应的三个值，并将对应的位向量改为1，插入y，z时，类似的，分别将红线，紫线对应的位向量改为1。查找时，当查找x时，三个hash值对应的位向量都为1，因此判断x在此数据集中。y，z也是如此。但是查找w时，w有个hash值对应的位向量为0，因此可以判断不在此集合中。但是，假如w的最后那个hash值比上图中的大1，这是就会认为w在此集合中，而事实上，w可能不在此集合中，因此可能出现误报。显然的，插入数据越多，1的位数越多，误报的概率越大。 https://zh.wikipedia.org/wiki/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8http://www.cnblogs.com/allensun/archive/2011/02/16/1956532.html 后缀树堆堆肯定是一棵平衡二叉树(×)因堆是二叉树，但不是二叉排序树，平衡二叉树是二叉排序树 jvm 堆栈kmp倒排索引","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://duyao.github.io/tags/java/"}]},{"title":"具体的集合","slug":"具体的集合","date":"2017-03-08T02:54:18.000Z","updated":"2017-04-26T03:23:14.000Z","comments":true,"path":"2017/03/08/具体的集合/","link":"","permalink":"http://duyao.github.io/2017/03/08/具体的集合/","excerpt":"","text":"Collection接口 Map接口 fast-fail快速报错，是指当有其他线程对一个容器（如ArrayList，HashMap）进行了结构性修改，另外一个线程在使用iterator进行迭代，那么这个迭代线程会抛出并发修改的异常ConcurrentModificationException。所谓结构性修改，是对原有容器的size造成影响的操作，如remove、add、clear操作等。这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数 链表 LinkedList 实现List和Deque接口java中使用LinkedList来实现链表的功能，其本质是双向链表，本身是有序集合http://blog.csdn.net/zw0283/article/details/51132161 方法的区分 方法名(添加，删除，取头) 特殊情况下的动作 相关接口 add, remove, element 抛异常 List offer, poll, peek 返回空值 Queue ListIterator接口添加元素是，使用LinkedList.add将对象添加到链表的尾部，如果需要在指定位置添加，则需要使用迭代器。但是对于自然有序的结合添加才有意义，因此类库提供了ListIterator 1234567891011121314public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123; //Iterator中的方法 boolean hasNext(); E next(); void remove(); //适用于自然有序的集合的方法 boolean hasPrevious();//反向遍历 E previous();//反向遍历 int nextIndex(); int previousIndex(); void set(E e); void add(E e);&#125; 如果链表中有n个元素，则有n+1个位置可以添加元素 12345678910111213141516171819202122232425262728293031323334353637383940public static void main(String[] args) &#123; List&lt;String&gt; a = new LinkedList&lt;&gt;(); a.add(&quot;Amy&quot;); a.add(&quot;Carl&quot;); a.add(&quot;Ercia&quot;); List&lt;String&gt; b = new LinkedList&lt;String&gt;(); b.add(&quot;Bob&quot;); b.add(&quot;Doug&quot;); b.add(&quot;Frances&quot;); b.add(&quot;Gloia&quot;); //Merge the word from b to a //listIterator和iterator是指向两个元素之间的，而不是某一个元素 ListIterator&lt;String&gt; aIterator = a.listIterator(); //bIterator是Iterator，因此无add方法 Iterator&lt;String&gt; bIterator = b.iterator(); while(bIterator.hasNext())&#123; if(aIterator.hasNext())&#123; aIterator.next(); &#125; //添加元素是在指针所指的中间添加元素 aIterator.add(bIterator.next()); &#125; System.out.println(a); bIterator = b.iterator(); while(bIterator.hasNext())&#123; bIterator.next(); if(bIterator.hasNext())&#123; bIterator.next(); //删除指针左边的元素 bIterator.remove(); &#125; &#125; System.out.println(b); //这里是List的方法，删除a中所有b的元素 a.removeAll(b); System.out.println(a);&#125; remove与next和previousE previous()与next用法相似，也是返回刚刚经过的元素，但是方向是与next相反因此调用next使用remove方法，删除左边元素调用previous使用remove，删除右边元素 set与next和previousset方法用一个新元素来取代调用next或previous返回的上一个元素123ListIterator&lt;String&gt; iterator = c.listIterator();String oldValue = iterator.next();iterator.set(newValue); 并发修改异常12345678Collection&lt;String&gt; a = new LinkedList&lt;String&gt;();a.add(&quot;A&quot;);a.add(&quot;B&quot;);Iterator&lt;String&gt; it1 = a.iterator();Iterator&lt;String&gt; it2 = a.iterator();it1.next();it1.remove();it2.next(); 由于并发修改，一个删除后，另一个访问，会抛出ConcurrentModificationException的错误因为每个迭代器内部都会维护一个独立的计数值。在迭代器开始方法前，先检查自己的修改次数和集合的修改次数是否一致，如果不一致就会抛出ConcurrentModificationException 因此迭代器使用有个简单的原则:每个集合可以有很多个迭代器，但是这些迭代器只能读。而专门只有一个迭代器既能读又能写。 当前位置索引由于迭代器指向两个元素的中间位置，因此可以产生两个索引int nextIndex()返回下一次调用next返回的元素的整数索引int previousIndex()返回下一次调用previous返回的元素的整数索引list.listIterator(n);返回迭代器，其指向整数索引为n的前面的元素 实现 内部为Node节点，包含了前驱、后继和值，故为双向链表 有全局变量first和last get方法由于链表支持随机查找，因此需要遍历，这里对遍历过程做了优化判断查找的位置是在前一半还是后一半。前一半就从第一个开始遍历，后一半就从最后一个倒着找。 数组列表 ArrayList, VectorArrayList和Vector实现了随机访问，其本质是动态再分配的对象数组ArrayList是不安全Vector是线程安全的 Resizable-array implementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.) 实现要点 内部使用数组实现 数组的开始大小为10 添加过程原内部数组中的对象数目加1，如果大于原内部数组长度，则以原长度的1.5倍新建一个对于原数组的拷贝(Arrays.copyOf)，并修改原数组，指向这个新建数组。原数组自动抛弃，size则自增1，向数组中添加对象。 删除根据给定索引值，判断合理性，之后取出对应这个索引位置的对象，之后将这个位置之后的所有对象向前移动一位即可 http://blog.csdn.net/zw0283/article/details/51122255 序列化与ArrayListArrayList中的数据是transient Object[] elementData;定义的，由于transient所以是无法序列化的，但是实际上ArrayList还是可以序列化的因为重写了readObject和writeObject，这么做的原因是为了防止一个包含大量空对象的数组被序列化http://www.hollischuang.com/archives/1140 ArrayList的生成在java中比较建议用List&lt;Object&gt; list = new ArrayList&lt;Object&gt;();而不是用ArrayList&lt;Object&gt; list = new ArrayList&lt;Object&gt;();这样做的原因是解耦和封装这是一种面向接口编程的思想，即以后做改变很容易，这样可以提高复用性同时可以动态地使用，比如反射一个东西，只需要先设接口，new出的对象转化为该接口即可，而需要用if判断http://stackoverflow.com/questions/9852831/polymorphism-why-use-list-list-new-arraylist-instead-of-arraylist-list-n?noredirect=1&amp;lq=1 映射表HashMap用来存放键值对，都实现map接口HashMap对键进行散列，而TreeMap用键的整体顺序对元素进行排序，构成搜索树。如果要求一定的顺序，使用TreeMap，否则使用HashMap(同HashSet和TreeSet相同)往映射表添加内容必须提供一个键，这个键值要唯一，否则会被覆盖http://www.importnew.com/20386.htmlhttp://blog.csdn.net/zw0283/article/details/51177547 Entry数组Entry是用于实现链表的一个节点、里面有key，value用于存储自身节点数据， 哈希值，还有next用于下个节点的引用。123456789101112131415static class Entry&lt;K, V&gt; implements Map.Entry&lt;K, V&gt; &#123; // Entry继承了Map接口中的静态子类Entry；Entry&lt;K,V&gt;是槽中的元素， // 用作链表来解决散列冲突 final K key;// 键 V value;// 值 Entry&lt;K, V&gt; next;// 用来实现链表结构， 同一链表中的key的hash是相同的 int hash; protected Entry(int hash, K key, V value, Entry&lt;K, V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125;&#125; HashMap的成员123456789public class HashMap&lt;K,V&gt;&#123; static final int DEFAULT_INITIAL_CAPACITY = 16 ; // 默认初始容量是16。 （ 必须是2的次方） static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30 ; // 即2的30次方 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认装载因子 Entry[] table; // Entry表 int size; // Entry[]实际存储的Entry个数 int threshold; // reash的阈值， =capacity * loadfactor final float loadFactor; //装填因子&#125; 负载因子负载因子越大，填满的元素越多，空间利用率增加，hash冲突的机会增加，每个元素下挂载的链表会越来越长，同时会导致查找元素的效率变得低下。负载因子越小，填满的元素越少，空间利用率降低，hash冲突减少，但是数组中的元素过于稀疏，导致数组中很多空间还没有用就开始扩容，不过好处是查找的元素的效率相对高一些。所以，必然要在“查找效率”和“空间利用率”之中做一个折中，让它们处在一个相对的平衡状态。0.75就是这样的一个相对平衡的状态 为什么容量是2的倍数？为了寻址的快速。 寻址是通过 hash(key) &amp; (table.length-1)实现的若数组长度为2的N次方，则数组的长度必然为偶数，则偶数-1必然为奇数，在2进制的表示中，奇数的最后一位为1，所以，与奇数做“&amp;”操作，最后的结果可能为奇数，也可能为偶数。其次，若数组长度不为偶数，则奇数-1为偶数，偶数在2进制中最后一位为0，那么与偶数做“&amp;”操作，最后的结果只可能是偶数，不可能为奇数，所以在奇数位置的空间不会存储到元素，所以会有二分之一的空间被浪费掉。综上所述，数组长度取2的N次方，目的是为了能让元素均匀的分布在数组中，减小发生冲突的机会。 get方法 对nullkey做单独处理， 其实就是放在table[0]中 根据key的hash值， 决定entry在哪个桶 对桶内的entry链表进行遍历， 当查找到时返回value 找不到， 返回null123456789public V get(Object key) &#123; //对空值做处理 if (key == null) return getForNullKey(); //非空情况 Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue();&#125; 空值处理getForNullKey 1234567891011private V getForNullKey() &#123; if (size == 0) &#123; return null; &#125; //对于空值table[0]中查找 for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null;&#125; 正常的处理getEntry 12345678910111213141516171819final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; //二次hash，得到hash值 int hash = (key == null) ? 0 : hash(key); //计算出在哪个桶indexFor(hash, table.length) //遍历桶内元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125; put方法使用key计算得到hashCode，之后得到该元素在数组中的存放位置，然后将其放入链表的头部，放入的过程中要对容量进行判断。1234567891011121314151617181920212223242526272829public V put(K key, V value) &#123; //判断是否空 if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); //二次hash得到hash值 int hash = hash(key); //得到该hash的桶号码 int i = indexFor(hash, table.length); //寻找过程，确保唯一 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; //如果存在，要覆盖 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; //添加Entry addEntry(hash, key, value, i); return null;&#125; put()方法中， 如果遇见的键值对是新的， 那么会调用addEntry()方法，将这个键值对存储在hash值相同的槽位的头部（ 链表的头插入） 12345678910111213141516171819void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; //容量扩大两倍 resize(2 * table.length); //二次hash hash = (null != key) ? hash(key) : 0; //找到槽位 bucketIndex = indexFor(hash, table.length); &#125; //添加 createEntry(hash, key, value, bucketIndex);&#125;void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex]; //头插 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e); size++;&#125; Map中有3个视图123Set&lt;K&gt; keySet(); //键集Collection&lt;V&gt; values(); //值集合Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet(); //键值集 多线程访问HashMap多线程访问HashMap，会出现错误，可能有两种1）hashmap放数据，扩容会导致内部一致性发生变化，出现越界等问题2）两个线程hashmap同时放数据，两个节点可能会相互指向，出现死循环http://coolshell.cn/articles/9606.html Referencehttp://www.ibm.com/developerworks/cn/java/j-lo-hash/http://www.cnblogs.com/skywang12345/p/3310835.html#b1 散列集 HashSetjava中使用HashSet表示散列集 实现Set接口 实际是HashMap的一个实例 允许空值 元素无重复的无序集合 使用链表数组实现每个列表被称为桶。 链表数组 查找要想查找对象的位置，计算其散列码，然后与总桶数取余，得到就是保存这个对象的索引。如果桶中没有其他元素，就可以直接插入；如果桶满了，这种现象被称作散列冲突，此时需要与这个桶中所有的元素进行比较。 装填因子和再散列The HashMap instance has default initial capacity (16) and load factor (0.75).如果需要更好的控制散列表的性能，需要制定一个初始的桶数，通常设置为元素个数的75%~150%。当然并不是总能很好的估计桶数，如果散列表装的太慢，就需要再散列。对散列表再散列，就需要一个桶数更多的表，将所有元素插入新表，将原表丢弃。装填因子决定表是否需要再散列，如果表中元素占有率大于表的装填因子，表就会用双倍的桶数在散列。 不同步本身不同步，可以下面的方法同步1Set s = Collections.synchronizedSet(new HashSet(...)); TreeMap 和 树集 TreeSet树集和散列集相似，但是比散列集有所改进。java用TreeSet表示树集 树集是有序集合，实现了SortedSet接口Class TreeSet implements NavigableSetInterface NavigableSet extends SortedSetInterface SortedSet extends Set TreeSet中元素实现了Comparable接口All elements inserted into a sorted set must implement the Comparable interface (or be accepted by the specified comparator)对于基本数据类型，已经实现了Comparable，但是对于自定义类，必须实现Comparable,否则会报错java.lang.ClassCastException 树集使用红黑树实现的 树集底层是调用TreeMap实现的 TreeSet 与 TreeMapTreeSet源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable &#123; // 使用 NavigableMap 的 key 来保存 Set 集合的元素 private transient NavigableMap&lt;E,Object&gt; m; // 使用一个 PRESENT 作为 Map 集合的所有 value。 private static final Object PRESENT = new Object(); // 包访问权限的构造器，以指定的 NavigableMap 对象创建 Set 集合 TreeSet(NavigableMap&lt;E,Object&gt; m) &#123; this.m = m; &#125; public TreeSet() // ① &#123; // 以自然排序方式创建一个新的 TreeMap， // 根据该 TreeSet 创建一个 TreeSet， // 使用该 TreeMap 的 key 来保存 Set 集合的元素 this(new TreeMap&lt;E,Object&gt;()); &#125; public TreeSet(Comparator&lt;? super E&gt; comparator) // ② &#123; // 以定制排序方式创建一个新的 TreeMap， // 根据该 TreeSet 创建一个 TreeSet， // 使用该 TreeMap 的 key 来保存 Set 集合的元素 this(new TreeMap&lt;E,Object&gt;(comparator)); &#125; public TreeSet(Collection&lt;? extends E&gt; c) &#123; // 调用①号构造器创建一个 TreeSet，底层以 TreeMap 保存集合元素 this(); // 向 TreeSet 中添加 Collection 集合 c 里的所有元素 addAll(c); &#125; public TreeSet(SortedSet&lt;E&gt; s) &#123; // 调用②号构造器创建一个 TreeSet，底层以 TreeMap 保存集合元素 this(s.comparator()); // 向 TreeSet 中添加 SortedSet 集合 s 里的所有元素 addAll(s); &#125; //TreeSet 的其他方法都只是直接调用 TreeMap 的方法来提供实现 ... public boolean addAll(Collection&lt;? extends E&gt; c) &#123; if (m.size() == 0 &amp;&amp; c.size() &gt; 0 &amp;&amp; c instanceof SortedSet &amp;&amp; m instanceof TreeMap) &#123; // 把 c 集合强制转换为 SortedSet 集合 SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c; // 把 m 集合强制转换为 TreeMap 集合 TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m; Comparator&lt;? super E&gt; cc = (Comparator&lt;? super E&gt;) set.comparator(); Comparator&lt;? super E&gt; mc = map.comparator(); // 如果 cc 和 mc 两个 Comparator 相等 if (cc == mc || (cc != null &amp;&amp; cc.equals(mc))) &#123; // 把 Collection 中所有元素添加成 TreeMap 集合的 key map.addAllForTreeSet(set, PRESENT); return true; &#125; &#125; // 直接调用父类的 addAll() 方法来实现 return super.addAll(c); &#125; ... &#125; 从上面代码可以看出，TreeSet 的 ① 号、② 号构造器的都是新建一个 TreeMap 作为实际存储 Set 元素的容器，而另外 2 个构造器则分别依赖于 ① 号和 ② 号构造器，由此可见，TreeSet 底层实际使用的存储容器就是 TreeMap。 比较如果TreeSet中不是基本数据类型，那么该类一定要实现comparable或者使用comparator比较器具体请参照comparable与comparator SortedSet12345678910111213141516171819202122232425262728293031323334public interface SortedSet&lt;E&gt; extends Set&lt;E&gt; &#123; Comparator&lt;? super E&gt; comparator(); /** * Returns a view of the portion of this set whose elements range * from &lt;tt&gt;fromElement&lt;/tt&gt;, inclusive, to &lt;tt&gt;toElement&lt;/tt&gt;, * exclusive. (If &lt;tt&gt;fromElement&lt;/tt&gt; and &lt;tt&gt;toElement&lt;/tt&gt; are * equal, the returned set is empty.) */ SortedSet&lt;E&gt; subSet(E fromElement, E toElement); /** * Returns a view of the portion of this set whose elements are * strictly less than &lt;tt&gt;toElement&lt;/tt&gt;. */ SortedSet&lt;E&gt; headSet(E toElement); /** * Returns a view of the portion of this set whose elements are * greater than or equal to &lt;tt&gt;fromElement&lt;/tt&gt;. */ SortedSet&lt;E&gt; tailSet(E fromElement); /** * Returns the first (lowest) element currently in this set. */ E first(); /** * Returns the last (highest) element currently in this set. */ E last();&#125; NavigableSet123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public interface NavigableSet&lt;E&gt; extends SortedSet&lt;E&gt; &#123; //不包括等于 /** * Returns the greatest element in this set strictly less than the * given element, or &#123;@code null&#125; if there is no such element. */ E lower(E e); /** * Returns the least element in this set strictly greater than the * given element, or &#123;@code null&#125; if there is no such element. */ E higher(E e); //包括等于 /** * Returns the greatest element in this set less than or equal to * the given element, or &#123;@code null&#125; if there is no such element. */ E floor(E e); /** * Returns the least element in this set greater than or equal to * the given element, or &#123;@code null&#125; if there is no such element. */ E ceiling(E e); /** * Retrieves and removes the first (lowest) element, * or returns &#123;@code null&#125; if this set is empty. */ E pollFirst(); /** * Retrieves and removes the last (highest) element, * or returns &#123;@code null&#125; if this set is empty. */ E pollLast(); /** * Returns an iterator over the elements in this set, in ascending order. */ Iterator&lt;E&gt; iterator(); /** * Returns a reverse order view of the elements contained in this set. */ NavigableSet&lt;E&gt; descendingSet(); /** * Returns an iterator over the elements in this set, in descending order. * Equivalent in effect to &#123;@code descendingSet().iterator()&#125;. */ Iterator&lt;E&gt; descendingIterator(); /** * Returns a view of the portion of this set whose elements range from * &#123;@code fromElement&#125; to &#123;@code toElement&#125;. If &#123;@code fromElement&#125; and * &#123;@code toElement&#125; are equal, the returned set is empty unless &#123;@code * fromInclusive&#125; and &#123;@code toInclusive&#125; are both true. */ NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive); /** * Returns a view of the portion of this set whose elements are less than * (or equal to, if &#123;@code inclusive&#125; is true) &#123;@code toElement&#125;. */ NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive); /** * Returns a view of the portion of this set whose elements are greater * than (or equal to, if &#123;@code inclusive&#125; is true) &#123;@code fromElement&#125;. */ NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive);&#125; ArrayDeque 和 StackArrayDeque@since 1.6 变长数组，长度无限增长Resizable-array implementation of the Deque interface.Array deques have no capacity restrictions; they grow as necessary to supportusage. 线程不安全They are not thread-safe; in the absence of externalsynchronization, they do not support concurrent access by multiple threads. 非空Null elements are prohibited. This class is likely to be faster than Stack when used as a stack,and faster than LinkedList when used as a queue. Stack栈，先进后出线程安全，继承Vector 优先级队PriorityQueue元素按照任意顺序插入，但是按照一定顺序排序检索。也就是说无论何时调用remove方法，都会删除最小的元素(The elements of the priority queue are ordered according to their natural ordering, or by a Comparator provided at queue construction time, depending on which constructor is used. )。 在优先队列内部并不会对所有的元素进行排序使用堆Heap的数据结构，只会保证最小或者最大的元素在第一个位置The head of this queue is the least element with respect to the specified ordering. If multiple elements are tied for least value, the head is one of those elements – ties are broken arbitrarily. The queue retrieval operations poll, remove, peek, and element access the element at the head of the queue. PriorityQueue is not thread safe, java provides PriorityBlockingQueue class that implements the BlockingQueue interface to use in java multi-threading environment. 例子12345678910111213141516171819202122public static void main(String[] args) &#123; Queue&lt;Integer&gt; prq = new PriorityQueue(); Random r = new Random(); System.out.println(&quot;--------------add----------------&quot;); for(int i = 0; i &lt; 5; i++)&#123; int addNum = r.nextInt(100); prq.add(addNum); System.out.println(&quot;add num&quot; + addNum); //通过打印的队列可以看出来，队列内部不一定有序，但是最小元素一定在队头 //添加的变化过程就是将新元素放在最后，然后调整堆 System.out.println(&quot;prq&quot; + prq); &#125; System.out.println(&quot;----------------remove-----------------------&quot;); for(int i = 0; i &lt; 5; i++)&#123; int x = prq.peek(); System.out.println(&quot;remove num&quot; + x); prq.remove(); //通过打印的队列可以看出来，队列内部不一定有序，但是最小元素一定在队头 //删除的变化过程就是将最后一个元素，放在堆顶，然后在进行调整 System.out.println(&quot;prq&quot; + prq); &#125;&#125; &gt;————–add—————-add num33prq[33]add num36prq[33, 36]add num45prq[33, 36, 45]add num38prq[33, 36, 45, 38]add num4prq[4, 33, 45, 38, 36]—————-remove———————–remove num4prq[33, 36, 45, 38]remove num33prq[36, 38, 45]remove num36prq[38, 45]remove num38prq[45]remove num45prq[] 堆的建立过程参考循环建立和递归建立 WeakHashMapWeakHashMap 继承于AbstractMap，实现了Map接口。和HashMap一样，WeakHashMap 也是一个散列表，它存储的内容也是键值对(key-value)映射，而且键和值都可以是null。 不过WeakHashMap的键是“弱键”。在 WeakHashMap 中，当某个键不再正常使用时，会被从WeakHashMap中被自动移除。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。某个键被终止时，它对应的键值对也就从映射中有效地移除了。 这个“弱键”的原理呢？大致上就是，通过WeakReference和ReferenceQueue实现的。WeakHashMap的key是“弱键”，即是WeakReference类型的；ReferenceQueue是一个队列，它会保存被GC回收的“弱键”。实现步骤是：(01) 新建WeakHashMap，将“键值对”添加到WeakHashMap中。实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。(02) 当某“弱键”不再被其它对象引用，并被GC回收时。在GC回收该“弱键”时，这个“弱键”也同时会被添加到ReferenceQueue(queue)队列中。(03) 当下一次我们需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的键值对；同步它们，就是删除table中被GC回收的键值对。这就是“弱键”如何被自动从WeakHashMap中删除的步骤了。 和HashMap一样，WeakHashMap是不同步的。可以使用 Collections.synchronizedMap 方法来构造同步的 WeakHashMap。 123456789101112131415161718192021222324public static void main(String[] args) throws Exception &#123; String a = new String(&quot;a&quot;); String b = new String(&quot;b&quot;); Map weakmap = new WeakHashMap(); Map map = new HashMap(); map.put(a, &quot;aaa&quot;); map.put(b, &quot;bbb&quot;); weakmap.put(a, &quot;aaa&quot;); weakmap.put(b, &quot;bbb&quot;); map.remove(a); a = null; b = null; System.gc(); Iterator i = map.entrySet().iterator(); while (i.hasNext()) &#123; Map.Entry en = (Map.Entry) i.next(); System.out.println(&quot;map:&quot; + en.getKey() + &quot;:&quot; + en.getValue()); &#125; Iterator j = weakmap.entrySet().iterator(); while (j.hasNext()) &#123; Map.Entry en = (Map.Entry) j.next(); System.out.println(&quot;weakmap:&quot; + en.getKey() + &quot;:&quot; + en.getValue()); &#125;&#125; 代码声明了两个 Map 对象，一个是 HashMap，一个是 WeakHashMap，同时向两个 map 中放入 A、B 两个对象.当 HashMap 删除 A，并且 A、B 都指向 Null 时，WeakHashMap 中的 A 将自动被回收掉。出现这个状况的原因是，对于 A 对象而言，当 HashMap 删除并且将 A 指向 Null 后，除了 WeakHashMap 中还保存 A 外已经没有指向 A 的指针了，所以 WeakHashMap 会自动舍弃掉 a，而对于 B 对象虽然指向了 null，但 HashMap 中还有指向 B 的指针，所以 WeakHashMap 将会保留 B 对象。 WeakHashMap 主要通过 expungeStaleEntries这个函数来实现移除其内部不用的条目，从而达到自动释放内存的目的。基本上只要对 WeakHashMap 的内容进行访问就会调用这个函数，从而达到清除其内部不再为外部引用的条目。但是如果预先生成了 WeakHashMap，而在 GC 以前又不曾访问该 WeakHashMap, 那不是就不能释放内存了吗？1234567891011List&lt;WeakHashMap&lt;byte[][], byte[][]&gt;&gt; maps = new ArrayList&lt;WeakHashMap&lt;byte[][], byte[][]&gt;&gt;();for (int i = 0; i &lt; 1000; i++) &#123; WeakHashMap&lt;byte[][], byte[][]&gt; d = new WeakHashMap&lt;byte[][], byte[][]&gt;(); d.put(new byte[1000][1000], new byte[1000][1000]); maps.add(d); System.gc(); System.err.println(i);// for (int j = 0; j &lt; i; j++) &#123;// System.err.println(j + &quot; size&quot; + maps.get(j).size());// &#125;&#125; 果不其然，WeakHashMap 这个时候并没有自动帮我们释放不用的内存总的来说，WeakHashMap并不是你什么也干它就能自动释放内部不用的对象的，而是在你访问它的内容的时候释放内部不用的对象。 WeakHashMap 实现弱引用，是因为它的 Entry是继承自 WeakReference的1234567private static class Entry&lt;K,V&gt; extends WeakReference&lt;K&gt;implements Map.Entry&lt;K,V&gt; Entry(K key, V value, ReferenceQueue&lt;K&gt; queue,int hash, Entry&lt;K,V&gt; next) &#123; super(key, queue); this.value = value; this.hash = hash; this.next = next;&#125; 请注意它构造父类的语句super(key, queue);，传入的是 Key，因此 Key 才是进行弱引用的，Value 是直接强引用关联在 this.value 之中。在 System.gc() 时，Key 中的 Byte 数组进行了回收，而 Value 依然保持 (Value 被强关联到 Entry 上，Entry 又关联在 Map 中，Map 关联在 ArrayList 中)。 For 循环中每次都 New 一个新的 WeakHashMap，在 Put 操作后，虽然 GC 将 WeakReference 的 Key 中的 Byte 数组回收了，并将事件通知到了 ReferenceQueue，但后续却没有相应的动作去触发 WeakHashMap 去处理 ReferenceQueue，所以 WeakReference 包装 Key 依然存在于 WeakHashMap 中，其对应的 value 也当然存在。 那 value 是何时被清除的呢?上面的注释代码中的 maps.get(j).size() 触发了 Value 的回收，那又如何触发的呢？查看 WeakHashMap 源码可知,Size 方法调用了 expungeStaleEntries 方法，该方法对 JVM 要回收的的 Entry(Quene 中) 进行遍历，并将 Entry 的 Value 置空，回收了内存。所以效果是 Key 在 GC 的时候被清除，Value 在 Key 清除后访问 WeakHashMap 被清除。 WeakHashMap 类是线程不同步的，可以使用 Collections.synchronizedMap 方法来构造同步的 WeakHashMap, 每个键对象间接地存储为一个弱引用的指示对象。因此，不管是在映射内还是在映射之外，只有在垃圾回收器清除某个键的弱引用之后，该键才会自动移除。 内容参考WeakHashMap LinkedHashMap 和 LinkedHashSetHashSet是调用HashMap实现的，同理适用于LinkedHashSet，因此下面主要讲LInkedHashMapLinkedHashMap是按照插入顺序和按访问顺序(构造时accessOrder设为true)的链表其中按访问顺序可以构建 LRU (Least Recently Used)缓存实现了记录顺序的LinkedHashMap,通过数组链表(HashMap)和循环双向链表(记录顺序)实现在链表中有head指针，head.before 最新，head.after 最老 http://blog.csdn.net/zw0283/article/details/51258683 结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123; /** * The head of the doubly linked list. */ private transient Entry&lt;K,V&gt; header; /** * The iteration ordering method for this linked hash map: &lt;tt&gt;true&lt;/tt&gt; * for access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order. */ private final boolean accessOrder; /** * Constructs an empty insertion-ordered &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance * with the specified initial capacity and load factor. */ public LinkedHashMap(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor); //初始化不记录访问顺序 accessOrder = false; &#125; /** * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the * specified initial capacity, load factor and ordering mode. */ public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder; &#125; /** * Called by superclass constructors and pseudoconstructors (clone, * readObject) before any entries are inserted into the map. Initializes * the chain. */ @Override void init() &#123; header = new Entry&lt;&gt;(-1, null, null, null); header.before = header.after = header; &#125;&#125;private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123; //双向循环链表 // These fields comprise the doubly linked list used for iteration. Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; /** * Removes this entry from the linked list. */ private void remove() &#123; before.after = after; after.before = before; &#125; /** * Inserts this entry before the specified existing entry in the list. */ private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this; &#125; //put方法会调用该方法 /** * This method is invoked by the superclass whenever the value * of a pre-existing entry is read by Map.get or modified by Map.set. * If the enclosing Map is access-ordered, it moves the entry * to the end of the list; otherwise, it does nothing. */ void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; //按照访问顺序记录 if (lm.accessOrder) &#123; lm.modCount++; //删除该节点 remove(); //由于被访问过，变为最新节点，放在head前面 addBefore(lm.header); &#125; &#125; void recordRemoval(HashMap&lt;K,V&gt; m) &#123; remove(); &#125;&#125; putLinkedHashMap 并未重写父类 HashMap 的 put 方法，而是重写了父类 HashMap 的 put 方法调用的子方法void recordAccess(HashMap m) ，void addEntry(int hash, K key, V value, int bucketIndex) 和void createEntry(int hash, K key, V value, int bucketIndex)，提供了自己特有的双向链接列表的实现。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public V put(K key, V value) &#123; if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; if (key == null) return putForNullKey(value); int hash = hash(key); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++; //添加了删除队头的操作 addEntry(hash, key, value, i); return null;&#125;//#####################重写方法#####################void addEntry(int hash, K key, V value, int bucketIndex) &#123; super.addEntry(hash, key, value, bucketIndex); //最老的在队头 // Remove eldest entry if instructed Entry&lt;K,V&gt; eldest = header.after; if (removeEldestEntry(eldest)) &#123; removeEntryForKey(eldest.key); &#125;&#125;void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; //按照访问顺序记录 if (lm.accessOrder) &#123; lm.modCount++; //删除该节点 remove(); //由于被访问过，变为最新节点，放在head前面 addBefore(lm.header); &#125;&#125;//在一个节点前面添加节点private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123; after = existingEntry; before = existingEntry.before; before.after = this; after.before = this;&#125; get12345678910111213141516171819public V get(Object key) &#123; Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)getEntry(key); if (e == null) return null; e.recordAccess(this); return e.value;&#125;void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; //按照访问顺序记录 if (lm.accessOrder) &#123; lm.modCount++; //删除该节点 remove(); //由于被访问过，变为最新节点，放在head前面 addBefore(lm.header); &#125;&#125; Referenceshttp://wiki.jikexueyuan.com/project/java-collection/linkedhashmap.htmlhttp://wiki.jikexueyuan.com/project/java-collection/linkedhashmap-lrucache.htmlhttp://zhouyunan2010.iteye.com/blog/1236220 EnumSet12345678910111213141516171819202122232425262728293031323334private enum Color &#123; RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255); private int r; private int g; private int b; Color(int r, int g, int b) &#123; this.r = r; this.g = g; this.b = b; &#125;&#125;public static void drawLine(Set&lt;Color&gt; colors) &#123; System.out.println(&quot;Requested Colors to draw lines : &quot; + colors); for (Color c : colors) &#123; System.out.println(&quot;drawing line in color : &quot; + c); &#125;&#125;public static void main(String[] args) &#123; // this will draw line in yellow color EnumSet&lt;Color&gt; yellow = EnumSet.of(Color.RED, Color.GREEN); drawLine(yellow); // RED + GREEN + BLUE = WHITE EnumSet&lt;Color&gt; white = EnumSet.of(Color.RED, Color.GREEN, Color.BLUE); drawLine(white); // RED + BLUE = PINK EnumSet&lt;Color&gt; pink = EnumSet.of(Color.RED, Color.BLUE); drawLine(pink);&#125; BitSet方法 void set(i) i位置置1 boolean get(i) 返回i的布尔值 void clear(i) 位置置0 int lenght() 逻辑值 int size() 长度 例子 素数筛法 123456789101112131415161718192021222324252627282930313233//bitset 被置1说明是素数public static void count(BitSet set)&#123; //length() -&gt; Returns the &quot;logical size&quot; of this BitSet for(int i = 2; i &lt; set.size(); i++)&#123; //初始化，全部置1 set.set(i); &#125; for(int i = 2; i &lt; Math.sqrt(set.size()) + 1; i++)&#123; if(set.get(i))&#123; for(int j = 2 * i; j &lt; set.length(); j += i)&#123; //素数的倍数全部标记为非素数 set.clear(j); &#125; &#125; &#125;&#125;public static void main(String[] args) &#123; BitSet b = new BitSet(2000000); count(b); int count = 0; for(int i = 2; i &lt; b.length(); i++)&#123; if(b.get(i))&#123; count ++; if(i &lt; 100)&#123; System.out.println(i); &#125; &#125; &#125; System.out.println(&quot;count&quot; + count);&#125; 逻辑运算 123456789101112131415161718192021222324252627282930313233public static void main(String args[]) &#123; BitSet bits1 = new BitSet(16); BitSet bits2 = new BitSet(16); // set some bits for (int i = 0; i &lt; 16; i++) &#123; //偶数都会被置1 if ((i % 2) == 0) bits1.set(i); //5的倍数都会被置1 if ((i % 5) != 0) bits2.set(i); &#125; System.out.println(&quot;Initial pattern in bits1: &quot;); System.out.println(bits1); System.out.println(&quot;\\nInitial pattern in bits2: &quot;); System.out.println(bits2); // AND bits bits2.and(bits1); System.out.println(&quot;\\nbits2 AND bits1: &quot;); System.out.println(bits2); // OR bits bits2.or(bits1); System.out.println(&quot;\\nbits2 OR bits1: &quot;); System.out.println(bits2); // XOR bits bits2.xor(bits1); System.out.println(&quot;\\nbits2 XOR bits1: &quot;); System.out.println(bits2);&#125; PropertiesProperties Tutorial","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"java","slug":"java","permalink":"http://duyao.github.io/tags/java/"}]},{"title":"138. Copy List with Random Pointer","slug":"138-Copy-List-with-Random-Pointer","date":"2017-03-06T12:08:18.000Z","updated":"2017-03-06T13:49:14.000Z","comments":true,"path":"2017/03/06/138-Copy-List-with-Random-Pointer/","link":"","permalink":"http://duyao.github.io/2017/03/06/138-Copy-List-with-Random-Pointer/","excerpt":"","text":"138. Copy List with Random Pointer https://leetcode.com/problems/clone-graph/?tab=Description可以和复制图一样，弄个map放节点，一次复制next,一次复制random与复制图相比，复制链表是可以做到o(1)空间的 做法是遍历3次，1）复制原节点，使得新节点是原节点的next2）添加新节点的random3）在原节点中删去添加的节点前两次新节点都不是直接相连的，而是通过原节点相连接的方法如图所示 方法 代码有问题 类似题目https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree12345678910111213141516171819202122232425262728public TreeNode sortedListToBST(ListNode head) &#123; if (head == null) &#123; return null; &#125; return addNode(head, null);&#125;public TreeNode addNode(ListNode head, ListNode tail) &#123; //边界条件是这个队列中只有一个元素 if(head == tail)&#123; return null; &#125; ListNode slow = head; ListNode fast = head; while (slow.next != tail &amp;&amp; fast != tail &amp;&amp; fast.next != tail) &#123; slow = slow.next; fast = fast.next.next; &#125; TreeNode root = new TreeNode(slow.val); root.left = addNode(head, slow); root.right = addNode(slow.next, tail); return root;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"}]},{"title":"juc之线程池","slug":"juc之线程池","date":"2017-03-05T08:40:21.000Z","updated":"2017-04-25T02:31:04.000Z","comments":true,"path":"2017/03/05/juc之线程池/","link":"","permalink":"http://duyao.github.io/2017/03/05/juc之线程池/","excerpt":"","text":"基本使用 比较图 Executor是一个顶层接口，在它里面只声明了一个方法execute(Runnable)，返回值为void，参数为Runnable类型，从字面意思可以理解，就是用来执行传进去的任务的；然后ExecutorService接口继承了Executor接口，并声明了一些方法：submit、invokeAll、invokeAny以及shutDown等；抽象类AbstractExecutorService实现了ExecutorService接口，基本实现了ExecutorService中声明的所有方法；然后ThreadPoolExecutor继承了类AbstractExecutorService。 线程池的种类我们可以通过ThreadPoolExecutor来创建一个线程池。12345new ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler); 创建一个线程池需要输入几个参数： corePoolSize（线程池的基本大小）当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。 runnableTaskQueue（任务队列）用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。 ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列此队列按 FIFO（先进先出）原则对元素进行排序。 LinkedBlockingQueue：一个基于链表结构的阻塞队列此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。 SynchronousQueue：一个不存储元素的阻塞队列每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。 PriorityBlockingQueue：一个具有优先级的无限阻塞队列。 直接提交。工作队列的默认选项是 SynchronousQueue，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 它将任务直接提交给线程而不保存它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。SynchronousQueue线程安全的Queue，可以存放若干任务（但当前只允许有且只有一个任务在等待），其中每个插入操作必须等待另一个线程的对应移除操作，也就是说A任务进入队列，B任务必须等A任务被移除之后才能进入队列，否则执行异常策略。你来一个我扔一个，所以说SynchronousQueue没有任何内部容量。 比如：核心线程数为2，最大线程数为3；使用SynchronousQueue。当前有2个核心线程在运行，又来了个A任务，两个核心线程没有执行完当前任务，根据如果运行的线程等于或多于 corePoolSize，则 Executor 始终首选将请求加入队列，而不添加新的线程。所以A任务被添加到队列，此时的队列是SynchronousQueue，当前不存在可用于立即运行任务的线程，因此会构造一个新的线程，此时又来了个B任务，两个核心线程还没有执行完。新创建的线程正在执行A任务，所以B任务进入Queue后，最大线程数为3，发现没地方仍了。就只能执行异常策略(RejectedExecutionException)。 无界队列。使用无界队列（例如，不具有预定义容量的 LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 有界队列。当使用有限的 maximumPoolSizes时，有界队列（如 ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。 maximumPoolSize（线程池最大大小）线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。 ThreadFactory用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。 RejectedExecutionHandler（饱和策略）当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。 AbortPolicy：直接抛出异常。 CallerRunsPolicy：只用调用者所在线程来运行任务。 DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。 DiscardPolicy：不处理，丢弃掉。当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。 keepAliveTime（线程活动保持时间）线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。 TimeUnit（线程活动保持时间的单位）可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。 线程池可以分为以下几个种类 固定大小线程池newFixedThreadPool超过最大数量就会加入到LinkedBlockingQueue，这个队列的数量是没有限制的，因此如果一直插入就会消耗内存 12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行： 1234567public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory));&#125; newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。CachedThreadPool中线程实例默认超时时间为60s，超过这个时间，线程实例停止并被移出CachedThreadPool，适用于生存期短、异步的线程任务。 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。 状态当创建线程池后，初始时，线程池处于RUNNING状态；如果调用了shutdown()方法，则线程池处于SHUTDOWN状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕；如果调用了shutdownNow()方法，则线程池处于STOP状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务；当线程池处于SHUTDOWN或STOP状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为TERMINATED状态 原理12345678910111213141516//任务缓存队列，用来存放等待执行的任务private final BlockingQueue&lt;Runnable&gt; workQueue; //线程池的主要状态锁，对线程池状态（比如线程池大小、runState等）的改变都要使用这个锁 private final ReentrantLock mainLock = new ReentrantLock();//用来存放工作集private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); private volatile long keepAliveTime; //线程存货时间 private volatile boolean allowCoreThreadTimeOut; //是否允许为核心线程设置存活时间private volatile int corePoolSize; //核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）private volatile int maximumPoolSize; //线程池最大能容忍的线程数private volatile int poolSize; //线程池中当前的线程数private volatile RejectedExecutionHandler handler; //任务拒绝策略private volatile ThreadFactory threadFactory; //线程工厂，用来创建线程private int largestPoolSize; //用来记录线程池中曾经出现过的最大线程数private long completedTaskCount; //用来记录已经执行完毕的任务个数 执行规则这规则主要体现在execute方法中，里面有很多if语句的判断： 1）如果当前线程池中的线程数目小于corePoolSize，则每来一个任务，就会创建一个线程去执行这个任务； 2）如果当前线程池中的线程数目&gt;=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务； 3）如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理； 4）如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize； 5）如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。 同时线程池中的线程主要靠workers这个set来管理线程，添加删除等操作都需要获得锁mainLock。提交的线程都是被封装后的Worker，其中有一个runWorker()的方法就是线程执行的过程，里面会调用afterExecute等方法，实现自己的策略。 当前线程运行完后，再到workQueue阻塞队列中去获取一个task出来，继续运行，这样就保证了线程池中有一定的线程一直在运行；此时若跳出了while循环，只有workQueue队列为空才会出现或出现了类似于shutdown的操作，自然运行队列会减少1，当再有新的线程进来的时候，就又开始向worker里面放数据了，这样以此类推，实现了线程池的功能。 同时需要注意的是在线程池中实现线程的使用run方法启动启动线程，因为run方法直接调用不会启动新的线程，也是因为这样，导致了你无法获取到你自己的线程的状态，因为线程池是直接调用的run方法，而不是start方法来运行。 这里有一个非常巧妙的设计方式，假如我们来设计线程池，可能会有一个任务分派线程，当发现有线程空闲时，就从任务缓存队列中取一个任务交给空闲线程执行。但是在这里，并没有采用这样的方式，因为这样会要额外地对任务分派线程进行管理，无形地会增加难度和复杂度，这里直接让执行完任务的线程去任务缓存队列里面取任务来执行。 线程池监控通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用 taskCount：线程池需要执行的任务数量。completedTaskCount：线程池在运行过程中已完成的任务数量。小于或等于taskCount。largestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。getPoolSize:线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减。getActiveCount：获取活动的线程数。 扩展和增强线程池在线程池中，如果一个线程抛异常，并不会影响其他线程的执行，这个线程会被停止，同时该线程池也不会报错，只是结果输出的时候少一个。这时候可以使用future.get()每一个结果。这样就能找出错误来。或者可以使用回调接口增强线程池。 回调接口 beforeExecute afterExecute terminated 通过继承线程池并重写线程池的beforeExecute，afterExecute和terminated方法，我们可以在任务执行前，执行后和线程池关闭前干一些事情。如监控任务的平均执行时间，最大执行时间和最小执行时间等。12345678910111213141516171819class ExtendedExecutor extends ThreadPoolExecutor &#123; // ... protected void afterExecute(Runnable r, Throwable t) &#123; super.afterExecute(r, t); if (t == null &amp;&amp; r instanceof Future&lt;?&gt;) &#123; try &#123; Object result = ((Future&lt;?&gt;) r).get(); &#125; catch (CancellationException ce) &#123; t = ce; &#125; catch (ExecutionException ee) &#123; t = ee.getCause(); &#125; catch (InterruptedException ie) &#123; Thread.currentThread().interrupt(); // ignore/reset &#125; &#125; if (t != null) System.out.println(t); &#125;&#125; 拒绝策略自定义ThreadFactory使用new ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory);传入一个ThreadFactory，实现方法比如123456789ExecutorService ctp = Executors.newCachedThreadPool(new ThreadFactory() &#123; private AtomicInteger count = new AtomicInteger(); public Thread newThread(Runnable r) &#123; int c = count.incrementAndGet(); System.out.println(\"create no \" + c + \" Threads\"); return new WorkThread(r,count); &#125; &#125;); ThreadFactory是一个接口123456789101112public interface ThreadFactory &#123; /** * Constructs a new &#123;@code Thread&#125;. Implementations may also initialize * priority, name, daemon status, &#123;@code ThreadGroup&#125;, etc. * * @param r a runnable to be executed by new thread instance * @return constructed thread, or &#123;@code null&#125; if the request to * create a thread is rejected */ Thread newThread(Runnable r);&#125; 线程池数量的选择线程池的大小需要考虑cpu数量、内存大小等因素。Ncpu = cpu数量Ucpu = 目标cpu的使用率，0&lt;=Ucpu&lt;=1W/C = 等待时间与计算时间的比率为了保持处理器达到期望的使用率，最优的池大小等于Nthread = Ncpu * Ucpu * (1 + W\\/C)我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。 要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：任务的性质：CPU密集型任务，IO密集型任务和混合型任务。任务的优先级：高，中和低。任务的执行时间：长，中和短。任务的依赖性：是否依赖其他系统资源，如数据库连接。 任务性质不同的任务可以用不同规模的线程池分开处理。 CPU密集型任务配置尽可能小的线程，如配置Ncpu+1个线程的线程池。 IO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu。 混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。 优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。 执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。 依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。 建议使用有界队列，有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了，不断的抛出抛弃任务的异常，通过排查发现是数据库出现了问题，导致执行SQL变得非常缓慢，因为后台任务线程池里的任务全是需要向数据库查询和插入数据的，所以导致线程池里的工作线程全部阻塞住，任务积压在线程池里。如果当时我们设置成无界队列，线程池的队列就会越来越多，有可能会撑满内存，导致整个系统不可用，而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的，而我们使用不同规模的线程池跑不同类型的任务，但是出现这样问题时也会影响到其他任务。http://www.infoq.com/cn/articles/java-threadPool ForkJoin其思想是分而治之底层使用双端队列(就是数组)实现，使用的是unsafe中的无锁CAS机制，所以有很锁算地址的操作同时将很多变量放在一个int中表示，这样可以保证数值之间的一致性，另一个方面就是CAS操作仅仅是面向一个变量的，多个变量是不支持CAS操作的 比较图 工作窃取（work-stealing）工作窃取算法是指某个线程从其他队列里窃取任务来执行。工作窃取的运行流程 比较图 那么为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，于是把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列一一对应，比如A线程负责处理A队列里的任务。但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。 工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，比如创建多个线程和多个双端队列。 ForkJoin计算过程第一步分割任务。首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，所以还需要不停的分割，直到分割出的子任务足够小。 第二步执行任务并合并结果。分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。 Fork/Join使用两个类来完成以上两件事情： ForkJoinTask我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制，通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类： RecursiveAction：用于没有返回结果的任务。 RecursiveTask ：用于有返回结果的任务。 ForkJoinPoolForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。 例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class ForkJoinDemo extends RecursiveTask&lt;Long&gt; &#123; private static final int THREADHOLD = 10000; private long start; private long end; public ForkJoinDemo(long start, long end) &#123; this.start = start; this.end = end; &#125; @Override protected Long compute() &#123; long sum = 0; boolean canCompute = (end - start) &lt; THREADHOLD; //分为可以执行和不能执行 if (canCompute) &#123; for (long i = start; i &lt; end; i++) &#123; sum += i; &#125; &#125; else &#123; //分成100个小任务 long step = (start + end) / 100; ArrayList&lt;ForkJoinDemo&gt; subTasks = new ArrayList&lt;&gt;(); long pos = start; for (int i = 0; i &lt; 100; i++) &#123; long lastOne = pos + step; //最后一个任务不够100 if (lastOne &gt; end) &#123; lastOne = end; &#125; ForkJoinDemo subTask = new ForkJoinDemo(pos, lastOne); pos += step+1; subTasks.add(subTask); //提交到大任务 subTask.fork(); &#125; for (ForkJoinDemo t : subTasks) &#123; //等待 sum += t.join(); &#125; &#125; return sum; &#125; public static void main(String[] args) &#123; ForkJoinPool forkJoinPool = new ForkJoinPool(); ForkJoinDemo task = new ForkJoinDemo(0, 200000L); ForkJoinTask&lt;Long&gt; result = forkJoinPool.submit(task); try &#123; //会抛出异常 long res = result.get(); System.out.println(\"sum = \" + res); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; http://www.infoq.com/cn/articles/fork-join-introduction","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://duyao.github.io/tags/jvm/"}]},{"title":"网络知识点总结","slug":"网络知识点总结","date":"2017-03-02T02:38:48.000Z","updated":"2017-05-16T09:09:12.000Z","comments":true,"path":"2017/03/02/网络知识点总结/","link":"","permalink":"http://duyao.github.io/2017/03/02/网络知识点总结/","excerpt":"","text":"结构网络结构体系 网络层次划分 层次 面向对象 作用 应用层 提供访问网络服务的接口 为操作系统或网络应用程序提供访问网络服务的接口 传输层 端到端进程到进程的层次。 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题 网络层 路由选择和存储转发 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能 数据链路层 可以分为逻辑链路控制子层LLC和媒体访问控制子层MAC 数据链路层为网络层提供可靠的数据传输 应用层常见协议及端口号 协议 端口号 传输层协议 注释 ftp 21 TCP 文件传输协议 telnet 23 TCP Internet远程登陆服务 smtp 25 TCP Simple Mail Transfer Protocol,简单邮件传输协议 DNS 39 UDP Domain Name System，域名系统 HTTP 80 TCP 超文本传输协议（HTTP，HyperText Transfer Protocol) POP3 110 TCP Post Office Protocol - Version 3, 邮局协议版本3 https 443 TCP Hyper Text Transfer Protocol over Secure Socket Layer, HTTP的安全版 Snmp 161 UDP 简单网络管理协议 DHCP 67 UDP Dynamic Host Configuration Protocol,动态主机配置协议,自动分配IP地址 IMAP 143 TCP 交互式邮件存取协议 https和httphttpHTTP协议的主要特点可概括如下：1.支持客户/服务器模式。2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 http报文格式 HTTP请求由三部分组成，分别是：请求行、消息报头、请求正文 http请求 请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文 http响应 状态行格式如下：HTTP-Version Status-Code Reason-Phrase CRLF常见状态代码、状态描述、说明：200 OK //客户端请求成功206 Partial Content //客户发送了一个带有Range头的GET请求，服务器完成了它。通常使用在MIME机制上，其为多个部分的对象集合，来容纳多个不同类型的数据301（永久移动） //请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。302（暂时移动） //服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 此代码与响应 GET 或 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编入索引。304 Not Modified 如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。该响应必须包含以下的头信息：Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将Date字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。ETag和／或Content-Location，假如同样的请求本应返回200响应。Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的GET请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误502 Bad Gateway //作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后，可能恢复正常 主要的请求报头主要字段:123456789101112Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding:gzip, deflate, sdchAccept-Language:zh-CN,zh;q=0.8,en;q=0.6Cache-Control:max-age=0，可以指定no-cache或者no-store，no-cache防止从缓存读取过期的资源，no-store中表示请求或者响应包含机密，因此不会进行缓存Connection:keep-aliveHost:blog.duyaokeep.cnIf-Modified-Since:Thu, 13 Apr 2017 02:37:24 GMTReferer:http://blog.duyaokeep.cn/Upgrade-Insecure-Requests:1User-Agent:Mozilla/5.0 (Windows NT 10.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.76 Safari/537.36Authorization：xxxx 用来告知服务器认证信息，如果客户端没有认证，则服务器会返回401，客户端认证后带上该字段进行第二次返回Location：一般服务器返回3xx会配合该字段返回给客户端，表示原来的uri重定向值新的location get与post区别幂等性：对参数的数据类型，GET只接受ASCII字符，而POST没有限制。GET在浏览器回退时是无害的，而POST会再次提交请求。其他：POST所对应的URI并非创建的资源本身，而是资源的接收者。比如：POST http://www.forum.com/articles的语义是在http://www.forum.com/articles下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。而PUT所对应的URI是要创建或更新的资源本身。比如：PUT http://www.forum/articles/4231的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。 http://coolshell.cn/articles/4787.html 缓存：GET请求会被浏览器主动cache，而POST不会，除非手动设置。GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 编码：GET请求只能进行url编码，而POST支持多种编码方式。对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 长度限制：GET请求在URL中传送的参数是有长度限制的，而POST没有。GET参数通过URL传递，POST放在Request body中。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 http://www.tuicool.com/articles/Ufmy6j head与get类似，只是head不返回报文主体，单单返回报文首部options询问支持的方法，响应时返回服务器支持的方法(post,get,head…)connect与代理服务器建立隧道进行tcp通信 httpsHTTPS 可以认为是 HTTP + TLS。HTTP 协议大家耳熟能详了，目前大部分 WEB 应用和网站都是使用 HTTP 协议传输的。TLS 是传输层加密协议，它的前身是 SSL 协议，最早由 netscape 公司于 1995 年发布，1999 年经过 IETF 讨论和规范后，改名为 TLS。如果没有特别说明，SSL 和 TLS 说的都是同一个协议。HTTPS 区别于 HTTP，它多了加密(encryption)，认证(verification)，鉴定(identification)。它的安全源自非对称加密以及第三方的 CA 认证。 使用 HTTPS 协议主要是为了保护用户隐私，防止流量劫持。HTTP 本身是明文传输的，没有经过任何安全处理。例如用户在百度搜索了一个关键字，比如“苹果手机”，中间者完全能够查看到这个信息，并且有可能打电话过来骚扰用户。也有一些用户投诉使用百度时，发现首页或者结果页面浮了一个很长很大的广告，这也肯定是中间者往页面插的广告内容。如果劫持技术比较低劣的话，用户甚至无法访问百度。总体来说，HTTPS 协议提供了三个强大的功能来对抗上述的劫持行为：1， 内容加密。浏览器到百度服务器的内容都是以加密形式传输，中间者无法直接查看原始内容。2， 身份认证。保证用户访问的是百度服务，即使被 DNS 劫持到了第三方站点，也会提醒用户没有访问百度服务，有可能被劫持3， 数据完整性。防止内容被第三方冒充或者篡改。 第一步，客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。第二步，服务器确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。第三步，客户端确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务器。第四步，服务器使用自己的私钥，获取客户端发来的随机数（即Premaster secret）。第五步，客户端和服务器根据约定的加密方法，使用前面的三个随机数，生成”对话密钥”（session key），用来加密接下来的整个对话过程。 握手阶段有三点需要注意。（1）生成对话密钥一共需要三个随机数。（2）握手之后的对话使用”对话密钥”加密（对称加密），服务器的公钥和私钥只用于加密和解密”对话密钥”（非对称加密），无其他作用。（3）服务器公钥放在服务器的数字证书之中。 HTTPS 的访问过程，相比 HTTP 要复杂很多，在部分场景下，使用 HTTPS 访问有可能增加 7 个 RTT。HTTPS 首次请求需要的网络耗时解释如下：1， 三次握手建立 TCP 连接。耗时一个 RTT。2， 使用 HTTP 发起 GET 请求，服务端返回 302 跳转到 https://www.baidu.com。需要一个 RTT 以及 302 跳转延时。 a) 大部分情况下用户不会手动输入 https://www.baidu.com 来访问 HTTPS，服务端只能返回 302 强制浏览器跳转到 https。 b) 浏览器处理 302 跳转也需要耗时。3， 三次握手重新建立 TCP 连接。耗时一个 RTT。 a) 302 跳转到 HTTPS 服务器之后，由于端口和服务器不同，需要重新完成三次握手，建立 TCP 连接。4， TLS 完全握手阶段一。耗时至少一个 RTT。a) 这个阶段主要是完成加密套件的协商和证书的身份认证。b) 服务端和浏览器会协商出相同的密钥交换算法、对称加密算法、内容一致性校验算法、证书签名算法、椭圆曲线（非 ECC 算法不需要）等。c) 浏览器获取到证书后需要校验证书的有效性，比如是否过期，是否撤销。5， 解析 CA 站点的 DNS。耗时一个 RTT。a) 浏览器获取到证书后，有可能需要发起 OCSP 或者 CRL 请求，查询证书状态。b) 浏览器首先获取证书里的 CA 域名。c) 如果没有命中缓存，浏览器需要解析 CA 域名的 DNS。6， 三次握手建立 CA 站点的 TCP 连接。耗时一个 RTT。a) DNS 解析到 IP 后，需要完成三次握手建立 TCP 连接。7， 发起 OCSP 请求，获取响应。耗时一个 RTT。8， 完全握手阶段二，耗时一个 RTT 及计算时间。a) 完全握手阶段二主要是密钥协商。9， 完全握手结束后，浏览器和服务器之间进行应用层（也就是 HTTP）数据传输。 http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.htmlhttp://op.baidu.com/2015/04/https-s01a02/ 加密算法====对称加密===========DES、AES====非对称加密===========RSA====散列加密===========MD5、SHA1、SHA2http://zoucz.com/blog/2016/12/29/understand-crypto-1/ 邮件协议 邮件协议 SMTPSMTP 的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。SMTP 认证，简单地说就是要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器，这就使得那些垃圾邮件的散播者无可乘之机。 增加 SMTP 认证的目的是为了使用户避免受到垃圾邮件的侵扰。POP3POP3是Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。IMAPIMAP全称是Internet Mail Access Protocol，即交互式邮件存取协议，它是跟POP3类似邮件访问标准协议之一。不同的是，开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端软件登录邮箱，看到的邮件以及状态都是一致的。 总之，IMAP 整体上为用户带来更为便捷和可靠的体验。POP3 更易丢失邮件或多次下载相同的邮件，但 IMAP 通过邮件客户端与webmail 之间的双向同步功能很好地避免了这些问题。 在浏览器中输入 www.baidu.com 后执行的全部过程 现在假设如果我们在客户端（客户端）浏览器中输入 http://www.baidu.com ,而baidu.com为要访问的服务器（服务器），下面详细分析客户端为了访问服务器而执行的一系列关于协议的操作： 1）客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。 2）在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。 3）客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。 4）客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。 https://www.nowcoder.com/discuss/3853?pos=264&amp;type=1&amp;order=0http://fex.baidu.com/blog/2014/05/what-happen/http://www.jianshu.com/p/c1dfc6caa520 DNS解析过程 DNS解析过程 1、浏览器会检查缓存中有没有这个域名对应的解析过的IP地址，如果缓存中有，这个解析过程就结束。浏览器缓存域名也是有限制的，不仅浏览器缓存大小有限制，而且缓存的时间也有限制，通常情况下为几分钟到几小时不等，域名被缓存的时间限制可以通过TTL属性来设置。这个缓存时间太长和太短都不太好，如果时间太长，一旦域名被解析到的IP有变化，会导致被客户端缓存的域名无法解析到变化后的IP地址，以致该域名不能正常解析，这段时间内有一部分用户无法访问网站。如果设置时间太短，会导致用户每次访问网站都要重新解析一次域名。 2、如果用户浏览器缓存中没有数据，浏览器会查找操作系统缓存中是否有这个域名对应的DNS解析结果。其实操作系统也有一个域名解析的过程，在Windows中可以通过C:\\Windows\\System32\\drivers\\etc\\hosts文件来设置，在Linux中可以通过/etc/hosts文件来设置，用户可以将任何域名解析到任何能够访问的IP地址。例如，我们在测试时可以将一个域名解析到一台测试服务器上，这样不用修改任何代码就能测试到单独服务器上的代码的业务逻辑是否正确。正是因为有这种本地DNS解析的规程，所以有黑客就可能通过修改用户的域名来把特定的域名解析到他指定的IP地址上，导致这些域名被劫持。 3、前两个过程无法解析时，就要用到我们网络配置中的”DNS服务器地址”了。操作系统会把这个域名发送给这个LDNS，也就是本地区的域名服务器。这个DNS通常都提供给用户本地互联网接入的一个DNS解析服务，例如用户是在学校接入互联网，那么用户的DNS服务器肯定在学校；如果用户是在小区接入互联网，那么用户的DNS就是再提供接入互联网的应用提供商，即电信或联通，也就是通常说的SPA，那么这个DNS通常也会在用户所在城市的某个角落，不会很远。Windows环境下通过命令行输入ipconfig，Linux环境下通过cat /etc/resolv.conf就可以查询配置的DNS服务器了。这个专门的域名解析服务器性能都会很好，它们一般都会缓存域名解析结果，当然缓存时间是受到域名的失效时间控制的。大约80%的域名解析到这里就结束了，所以LDNS主要承担了域名的解析工作。 4、如果LDNS仍然没有命中，就直接到Root Server域名服务器请求解析 5、根域名服务器返回给本地域名服务器一个所查询的主域名服务器（gTLD Server = Generic top-level domains servers）地址。gTLD是国际顶级域名服务器，如.com、.cn、.org等，全球只有13台左右 6、本地域名服务器LDNS再向上一步返回的gTLD服务器发送请求 7、接受请求的gTLD服务器查找并返回此域名对应的Name Server域名服务器的地址，这个Name Server通常就是用户注册的域名服务器，例如用户在某个域名服务提供商申请的域名，那么这个域名解析任务就由这个域名提供商的服务器来完成 8、Name Server域名服务器会查询存储的域名和IP的映射关系表，在正常情况下都根据域名得到目标IP地址，连同一个TTL值返回给DNS Server域名服务器 9、返回该域名对应的IP和TTL值，LDNS会缓存这个域名和IP的对应关系，缓存时间由TTL值控制 10、把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束 在实际的DNS解析过程中，可能还不止这10步，如Name Server可能有很多级，或者有一个GTM来负载均衡控制，这都有可能会影响域名解析过程。http://www.cnblogs.com/xrq730/p/4931418.html 传输层 TCP头格式 TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。 一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。注意上图中的四个非常重要的东西： Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。 Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。 Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。 TCP Flag ，也就是包的类型，主要是用于操控TCP的状态机的。 由于一个主机可以有多个进程，因此还有复用和分用的功能。分用是把运输层segment中的信息发送给正确的socket的服务复用是把所有socket中的数据集中并加头信息封装，然后发送到网络层的服务 TCP握手和放手 注意clint和server端状态的变化Clinet：SYNC_SENT-&gt;ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAITServer：LISTEN-&gt;SYNC_RCVD-&gt;ESTABLISHED-&gt;CLOSE_WAIT-&gt; LASK_ACK-&gt;CLOSED 三次握手建立连接服务器必须接受外来的连接，这通过socket,bind,listen实现被动打开的过程然后客户端使用connect实现主动打开，发送SYN J到服务器，然年进入阻塞状态服务器监听到请求，使用accept接受请求，发送SYN K, ACK J+1,然后进入阻塞客户端收到后，connect返回，发送ACK K+1进行确认，这时connect返回至此三次握手完毕，已经建立连接 然后传输数据，并确认回复 四次挥手释放连接客户端扣个应用调用close进行主动关闭，发送FIN M服务器收到后执行被动关闭，对这个FIN进行确认ACK M+1。同时作为文件结束符传送给应用程序，表示应用程序再也接收不到额外的数据，因为发了FIN就表示客户端不再发送数据了一段时间后，应用调用close关闭套接口，同时发送了FIN M客户端进行确认(主动关闭的一端) 进程终止时所有的tcp都会发出FIN执行主动关闭的那一端进入到time_wait阶段 必要性为什么要三次挥手？防止已失效的请求报文段突然又传送到了服务端而造成连接的误判。在只有两次“握手”的情形下，假设Client想跟Server建立连接，但是却因为中途连接请求的数据报丢失了，故Client端不得不重新发送一遍；这个时候Server端仅收到一个连接请求，因此可以正常的建立连接。但是，有时候Client端重新发送请求不是因为数据报丢失了，而是有可能数据传输过程因为网络并发量很大在某结点被阻塞了，这种情形下Server端将先后收到2次请求，并持续等待两个Client请求向他发送数据…问题就在这里，Cient端实际上只有一次请求，而Server端却有2个响应，极端的情况可能由于Client端多次重新发送请求数据而导致Server端最后建立了N多个响应在等待，因而造成极大的资源浪费！所以，“三次握手”很有必要！ 为什么要四次挥手？这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 为什么要有time_wait阶段？ 可靠的实现TCP全双工链接的终止。这是因为虽然双方都同意关闭连接了，而且握手的4个报文也都协调和发送完毕，按理可以直接回到CLOSED状态（就好比从SYN_SEND状态到ESTABLISH状态那样）；但是因为我们必须要假想网络是不可靠的，你无法保证你最后发送的ACK报文会一定被对方收到，因此对方处于LAST_ACK状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。 允许老的重复的分节在网络中消逝。TCP中是可靠的服务，当数据包丢失会重传，当有数据包迷路的情况下，如果不等待2MSL时，当客户端以同样地方式重新和服务建立连接后，上一次迷路的数据包这时可能会到达服务，这时会造成旧包被重新读取 http://wetest.qq.com/lab/view/81.html SYN Flood攻击关于建连接时SYN超时。试想一下，如果server端接到了clien发的SYN后回了SYN-ACK后client掉线了，server端没有收到client回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。 关于SYN Flood攻击。一些恶意的人就为此制造了SYN Flood攻击——给服务器发了一个SYN后，就下线了，于是服务器需要默认等63s才会断开连接，这样，攻击者就可以把服务器的syn连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫tcp_syncookies的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。请注意，请先千万别用tcp_syncookies来处理正常的大负载的连接的情况。因为，synccookies是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大SYN连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。 http://coolshell.cn/articles/11564.html TCP重传机制TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。 注意，接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。 超时重传机制一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。 但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。 对此有两种选择： 一种是仅重传timeout的包。也就是第3份数据。另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等timeout，timeout可能会很长（在下篇会说TCP是怎么动态地计算出timeout的） 快速重传机制于是，TCP引入了一种叫Fast Retransmit 的算法，不以时间驱动，而以数据驱动重传。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不 用等timeout了再重传。 比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。 快速重传机制 Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。 TCP的RTT算法从前面的TCP重传机制我们知道Timeout的设置对于重传非常重要。 设长了，重发就慢，丢了老半天才重发，没有效率，性能差；设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP引入了RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 http://coolshell.cn/articles/11609.html 流量控制TCP必需要解决：可靠传输以及包乱序（reordering）的问题对于流量控制，有两个方面可以优化：一是TCP利用滑动窗口实现流量控制的机制；二是如何考虑流量控制中的传输效率。 滑动窗口TCP必需要解决的可靠传输以及包乱序（reordering）的问题，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。 所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。 TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。 接收端在给发送端回ACK中会汇报自己的AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。 滑动窗口 上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口） 已收到ack确认的数据。 发还没收到ack的。 在窗口中还没有发出的（接收方还有空间） 窗口以外的数据（接收方没空间）下面是个滑动后的示意图（收到36的ack，并发出了46-51的字节）： 滑动窗口 Silly Window SyndromeSilly Window Syndrome翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走Receive Windows里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的window，而我们的发送方会义无反顾地发送这几个字节。 要知道，我们的TCP+IP头有40个字节，为了几个字节，要达上这么大的开销，这太不经济了。 如果你的网络包可以塞满MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽。（大于MTU的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个MTU就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。 所以，Silly Windows Syndrome这个现像就像是你本来可以坐200人的飞机里只做了一两个人。 要解决这个问题也不难，就是避免对小的window size做出响应，直到有足够大的window size再响应，这个思路可以同时实现在sender和receiver两端。 拥塞控制Congestion Handling拥塞控制主要是四个算法：A. 慢启动，B. 拥塞避免，C. 拥塞发生，D. 快速恢复。 慢热启动算法 – Slow Start A. 慢启动的算法如下(cwnd全称Congestion Window)： 1）连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。2）每当收到一个ACK，cwnd++; 呈线性上升3）每当过了一个RTT，cwnd = cwnd*2; 呈指数让升4）还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法） B. 拥塞避免算法 – Congestion Avoidance 前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：1）收到一个ACK时，cwnd = cwnd + 1/cwnd2）当每过一个RTT时，cwnd = cwnd + 1这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。 C. 拥塞状态时的算法 前面我们说过，当丢包的时候，会有两种情况： 1）等到RTO超时，重传数据包。TCP认为这种情况太糟糕，反应也很强烈。sshthresh = cwnd /2cwnd 重置为 1进入慢启动过程 2）Fast Retransmit算法，也就是在收到3个duplicate ACK时就开启重传，而不用等到RTO超时。TCP Tahoe的实现和RTO超时一样。TCP Reno的实现是：cwnd = cwnd /2sshthresh = cwnd进入快速恢复算法——Fast Recovery上面我们可以看到RTO超时后，sshthresh会变成cwnd的一半，这意味着，如果cwnd&lt;=sshthresh时出现的丢包，那么TCP的sshthresh就会减了一半，然后等cwnd又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。 D. 快速恢复算法 – Fast Recovery TCP Reno快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有3个Duplicated Acks说明网络也不那么糟糕，所以没有必要像RTO超时那么强烈。注意，正如前面所说，进入Fast Recovery之前，cwnd 和 sshthresh已被更新： cwnd = cwnd /2sshthresh = cwnd然后，真正的Fast Recovery算法如下： cwnd = sshthresh + 3 * MSS （3的意思是确认有3个数据包被收到了）重传Duplicated ACKs指定的数据包如果再收到 duplicated Acks，那么cwnd = cwnd +1如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。 如果你仔细思考一下上面的这个算法，你就会知道，上面这个算法也有问题，那就是——它依赖于3个重复的Acks。注意，3个重复的Acks并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到RTO超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发Fast Recovery算法了。 http://coolshell.cn/articles/11609.html TCP和UDP区别UDP用户数据报协议，是面向无连接的通讯协议，UDP数据包括目的端口号和源端口号信息，由于通讯不需要连接，所以可以实现广播发送。UDP通讯时不需要接收方确认，属于不可靠的传输，可能会出现丢包现象，实际应用中要求程序员编程验证。UDP与TCP位于同一层，但它不管数据包的顺序、错误或重发。因此，UDP不被应用于那些使用虚电路的面向连接的服务，UDP主要用于那些面向查询—应答的服务，例如NFS。相对于FTP或Telnet，这些服务需要交换的信息量较小。UDP是无连接协议，，因为客户端与服务器端不存在长期的关系，比如客户端创建一个套接字发送给服务器，然后还可以用该套接字发送另一个数据给另一个服务，同样UDP服务器也可以用同一个套接字从若干不同的客户接受多个数据报。 使用UDP协议包括：TFTP（简单文件传输协议）、SNMP（简单网络管理协议）、DNS（域名解析协议）、NFS、BOOTP。TCP 与 UDP 的区别：TCP是面向连接的，可靠的字节流服务；UDP是面向无连接的，不可靠的数据报服务。 TCP TCP http://blog.csdn.net/ce123_zhouwei/article/details/8976006 注意：tcp是有状态协议，而ip、http都是无状态的 网络层在TCP/IP 体系结构中，直接为 ICMP 提供服务的协议是ip协议 ip地址1）网络地址IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。 2）广播地址广播地址通常称为直接广播地址，是为了区分受限广播地址。广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。 3）组播地址D类地址就是组播地址。 A类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255； B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255; C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。 D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）； E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。 注：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。 4）255.255.255.255该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。注：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。 5）0.0.0.0常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。 6）回环地址127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。 7）A、B、C类私有地址私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255 路由选择常见的路由选择协议有：RIP协议、OSPF协议。RIP协议 ：它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。OSPF协议 ：Open Shortest Path First开放式最短路径优先，底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。 NAT协议NAT网络地址转换(Network Address Translation)属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。 ARP-地址解析协议ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。1：首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。2：当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机 IP地址，源主机MAC地址，目的主机的IP 地址。3：当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。4：源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。广播发送ARP请求，单播发送ARP响应。 数据链路层长度问题 报文的关系 ip和tcp报文的格式 MTU:最大传输单元,以太网的MTU为1500Bytes 以太帧中数据长度为46-1500字节 太网帧的最小长度为64字节（6目的mac＋6源mac＋2类型＋46数据＋4校验），最大长度为1518字节（6＋6＋2＋1500＋4） ip报文和tcp报文的头部是20B TCP最小数据长度为1460BytesTCP数据包大小 1500(MTU) - IP头（20B）- TCP头（20B） = 1460B 这也是最大的MSSUDP数据包 1500 - IP头（20B） - UDP头（8B） = 1472B） IP数据包的最大长度是64K字节(65535),TCP最大负载65535-40BTCP报文段的最大负载为65495字节，因为每个数据段必须适合IP的载荷能力，不能超过65535字节，IP头20B，TCP包头20B，故最大负载为65535- 20-20=65495B ip分片虽然IP报文的范围在64KB到65535，但受到二层MTU的限制。IP MTU=MSS+20bytes（IP包头）+20bytes（TCP包头）。tcp里有个字段MSS说的是TCP最大能携带的数据大小（不包括报头大小）。这个会在SYN协商时确定。一般TCP实际载荷为1500-20（IP报头）-20（TCP报头）=1460字节如果TCP数据不大于1460就不需要进行分段处理。 协议IEEE802.3 以“以太网”为技术原形，本质特点是采用CSMA/CD 的介质访问控制技术。“以太网”与IEEE 802.3略有区别。但在忽略网络协议细节时, 人们习惯将IEEE 802.3称为”以太网”。EEE 802.11—无线局域网。 mac地址MAC地址的长度为48位（6个字节），其中前24位代表网络硬件制造商的编号，它由IEEE（Istitute of Electrical and Electronics Engineers，电气与电子工程师协会）分配，而后24代表该制造商所制造的某个网络产品（如网卡）的系列号。每个网络制造商必须确保它所制造的每个以太网设备都具有相同的前三字节以及不同的后三个字节。这样就可保证世界上每个以太网设备都具有唯一的MAC地址。 其他知识点大端法和小端法其实 big endian 是指低地址存放最高有效字节（ MSB ），而 little endian 则是低地址存放最低有效字节（ LSB ）。大弟高，小弟低所有网络协议也都是采用 big endian 的方式来传输数据的。所以有时我们也会把 big endian 方式称之为网络字节序。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进行传输。12345低地址 高地址-----------------------------------------&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| 12 | 34 | 56 | 78 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Little Endian12345低地址 高地址-----------------------------------------&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| 78 | 56 | 34 | 12 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ QoSQoS(Quality of Service)，中文名为”服务质量”。它是指网络提供更高优先服务的一种能力，包括专用带宽、抖动控制和延迟（用于实时和交互式流量情形）、丢包率的改进以及不同WAN、LAN 和 MAN 技术下的指定网络流量等，同时确保为每种流量提供的优先权不会阻碍其它流量的进程只要涉及到带宽分配和对业务服务质量有要求的地方，就会有QoS设计。QoS技术多应用于广域网络和语音、视频等媒体业务系统。","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"网络","slug":"网络","permalink":"http://duyao.github.io/tags/网络/"}]},{"title":"juc之无锁","slug":"juc之无锁","date":"2017-03-01T00:40:21.000Z","updated":"2017-04-23T09:36:40.000Z","comments":true,"path":"2017/03/01/juc之无锁/","link":"","permalink":"http://duyao.github.io/2017/03/01/juc之无锁/","excerpt":"","text":"无锁java.util.concurrent.atomic包中的类 CASCAS-compareAndSet算法的过程是这样：它包含3个参数CAS(V,E,N)。V表示要更新的变量，E表示预期值，N表示新值。仅当V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS返回当前V的真实值。CAS操作是抱着乐观的态度进行的，它总是认为自己可以成功完成操作。当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS操作即时没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。 无锁类的使用AtomicInteger继承于Number，主要使用处理器提供的CMPXCHG指令实现的 主要接口其内部有一个volatile的value，unsafe是一个底层调用c语言来实现的类，offset是偏移量123private volatile int value;private static final Unsafe unsafe = Unsafe.getUnsafe();private static final long valueOffset; 所有的操作都是调用cas实现，比较value和期望值来实现的public final boolean compareAndSet(int expect, int u)//如果当前值为expect，则设置为u value的get和set方法public final int get() //取得当前值public final void set(int newValue) //设置当前值 其余的函数基本是就是调用cas来实现的public final int getAndSet(int newValue) //设置新值，并返回旧值public final int getAndIncrement() //当前值加1，返回旧值public final int getAndDecrement() //当前值减1，返回旧值public final int getAndAdd(int delta) //当前值增加delta，返回旧值public final int incrementAndGet() //当前值加1，返回新值public final int decrementAndGet() //当前值减1，返回新值public final int addAndGet(int delta) //当前值增加delta，返回新值 接口实现在jdk1.7中大部分的方法都是使用cas函数，在死循环中不停的比较，得出正确结果后退出的1234567891011public final int getAndIncrement() &#123; for (;;) &#123; int current = get(); int next = current + 1; if (compareAndSet(current, next)) return current; &#125;&#125;public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update);&#125; 在jdk1.8中，使用unsafe实现，jdk1.8中更新了unsafe123public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125; unsafeJava无法直接访问底层操作系统，而是通过本地（native）方法来访问。不过尽管如此，JVM还是开了一个后门，JDK中有一个类Unsafe，它提供了硬件级别的原子操作。Unsafe类是一个可以执行不安全、容易犯错的操作的一个特殊类。虽然Unsafe类中所有方法都是public的，但是这个类只能在一些被信任的代码中使用。 根据偏移量设置值根据offset得到一个数值的位置，这样就可以设置 park()停止操作 底层的CAS操作 非公开API，在不同版本的JDK中， 可能有较大差异 AtomicReference对引用进行修改，是一个模板类，抽象化了数据类型12345678910111213141516171819public static void main(String[] args) &#123; AtomicReference&lt;String&gt; string = new AtomicReference&lt;&gt;(\"abc\"); for (int i = 0; i &lt; 10; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; if (string.compareAndSet(\"abc\", \"def\")) &#123; System.out.println(Thread.currentThread().getId() + \"changed\"); &#125; else &#123; System.out.println(Thread.currentThread().getId() + \"failed\"); &#125; &#125; &#125;).start(); &#125;&#125; AtomicStampedReference主要解决了ABA问题，aba是不仅要求结果的正确性还对数据修改的过程敏感。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新。但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。 实现过程中加入了版本号pair1234567891011private static class Pair&lt;T&gt; &#123; final T reference; final int stamp; private Pair(T reference, int stamp) &#123; this.reference = reference; this.stamp = stamp; &#125; static &lt;T&gt; Pair&lt;T&gt; of(T reference, int stamp) &#123; return new Pair&lt;T&gt;(reference, stamp); &#125;&#125; AtomicIntegerArray支持无锁的数组通过计算每个数字在位置(利用base和shift)该改变数值1234private static final Unsafe unsafe = Unsafe.getUnsafe();private static final int base = unsafe.arrayBaseOffset(int[].class);private static final int shift;private final int[] array; 主要接口//获得数组第i个下标的元素public final int get(int i)//获得数组的长度public final int length()//将数组第i个下标设置为newValue，并返回旧的值public final int getAndSet(int i, int newValue)//进行CAS操作，如果第i个下标的元素等于expect，则设置为update，设置成功返回truepublic final boolean compareAndSet(int i, int expect, int update)//将第i个下标的元素加1public final int getAndIncrement(int i)//将第i个下标的元素减1public final int getAndDecrement(int i)//将第i个下标的元素增加delta（delta可以是负数） AtomicIntegerFieldUpdater让普通变量也享受原子操作 主要方法//构造方法public static &lt;U&gt; AtomicIntegerFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; tclass, String fieldName) 其余方法和AtomicInteger类似 使用 Updater只能修改它可见范围内的变量因为Updater使用反射得到这个变量。如果变量不可见，就会出错。比如如果变量为private，就是不可行的。 必须是volatile类型为了确保变量被正确的读取，它必须是volatile类型的。如果我们原有代码中未申明这个类型，那么简单得申明一下就行，这不会引起什么问题 不支持static字段由于CAS操作会通过对象实例中的偏移量直接进行赋值，因此，它不支持static字段（Unsafe.objectFieldOffset()不支持静态变量）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class AtomicIntegerFieldUpdaterDemo &#123; public static class Student &#123; int id; //必须为volatile类型 volatile int score; &#125; public static void main(String[] args) &#123; //构造方法，一个参数是类，第二是参数名 AtomicIntegerFieldUpdater updater = AtomicIntegerFieldUpdater. newUpdater(Student.class, \"score\"); Random r = new Random(); Student stu = new Student(); //验证结果是否正确 AtomicInteger comparedInteger = new AtomicInteger(); Thread[] threads = new Thread[1000]; for (int i = 0; i &lt; 1000; i++) &#123; threads[i] = new Thread(new Runnable() &#123; @Override public void run() &#123; if (r.nextInt() &gt; 10) &#123; updater.incrementAndGet(stu); comparedInteger.incrementAndGet(); &#125; &#125; &#125;); threads[i].start(); &#125; //等待所有线程完成 for (int i = 0; i &lt; 1000; i++) &#123; try &#123; threads[i].join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"comparedInteger = \" + comparedInteger.get()); System.out.println(\"stu.score = \" + stu.score); &#125;&#125; 其他问题Long、AtomicLong、LongAdder在java中对于long的操作不是原子性，尤其是32位操作系统，因为long是64bit的 因此要使用AtomicLong，涉及并发的地方都是使用CAS操作，在硬件层次上去做 compare and set操作。效率非常高。AtomicLong的实现方式是内部有个value 变量，当多线程并发自增，自减时，均通过CAS 指令从机器指令级别操作保证并发的原子性 LongAdder是java8中新添加的类唯一会制约AtomicLong高效的原因是高并发，高并发意味着CAS的失败几率更高， 重试次数更多，越多线程重试，CAS失败几率又越高，变成恶性循环，AtomicLong效率降低。因此在LongAdder中，在低并发时，还是CAS操作，因为低并发时，casBase操作基本都会成功，只有并发高到一定程度了，才会进入分支中分段更新的操作，将单一value的更新压力分担到多个value中去，降低单个value的 “热度”，这样就减少并发。低并发时LongAdder和AtomicLong性能差不多，高并发时LongAdder更高效！ http://coolshell.cn/articles/11454.html 无锁的Vector实现待完成","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://duyao.github.io/tags/jvm/"}]},{"title":"问答-个性化展示","slug":"问答-个性化展示","date":"2017-02-27T06:46:05.000Z","updated":"2017-03-04T12:46:02.000Z","comments":true,"path":"2017/02/27/问答-个性化展示/","link":"","permalink":"http://duyao.github.io/2017/02/27/问答-个性化展示/","excerpt":"","text":"推拉模式 推：反应快 拉：防止僵尸号，不是活跃用户存储的空间timeline 内容合并","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"wenda","slug":"wenda","permalink":"http://duyao.github.io/tags/wenda/"}]},{"title":"问答-redis互动踩赞","slug":"问答-redis互动踩赞","date":"2017-02-27T06:45:18.000Z","updated":"2017-04-26T10:11:30.000Z","comments":true,"path":"2017/02/27/问答-redis互动踩赞/","link":"","permalink":"http://duyao.github.io/2017/02/27/问答-redis互动踩赞/","excerpt":"","text":"Redis是一个开源，高级的键值存储和一个适用的解决方案，用于构建高性能，可扩展的Web应用程序。传统数据库中经常要查询最新的、最热的，很可能因为访问请求大的时候写硬盘可能导致锁竞争从而导致程序阻塞变慢，而redis就能解决这个问题 Redis有三个主要特点，使它优越于其它键值数据存储系统 Redis将其数据库完全保存在内存中，仅使用磁盘进行持久化。 与其它键值数据存储相比，Redis有一组相对丰富的数据类型。 Redis可以将数据复制到任意数量的从机中。 以下是Redis的一些优点。 异常快Redis非常快，每秒可执行大约110000次的设置(SET)操作，每秒大约可执行81000次的读取/获取(GET)操作。 支持丰富的数据类型Redis支持开发人员常用的大多数数据类型，例如列表，集合，排序集和散列等等。这使得Redis很容易被用来解决各种问题，因为我们知道哪些问题可以更好使用地哪些数据类型来处理解决。 操作具有原子性所有Redis操作都是原子操作，这确保如果两个客户端并发访问，Redis服务器能接收更新的值。 多实用工具Redis是一个多实用工具，可用于多种用例，如：缓存，消息队列(Redis本地支持发布/订阅)，应用程序中的任何短期数据，例如，web应用程序中的会话，网页命中计数等。 缺点 Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复。 主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性。 Redis的主从复制采用全量复制，复制过程中主机会fork出一个子进程对内存做一份快照，并将子进程的内存快照保存为文件发送给从机，这一过程需要确保主机有足够多的空余内存。若快照文件较大，对集群的服务能力会产生较大的影响，而且复制过程是在从机新加入集群或者从机和主机网络断开重连时都会进行，也就是网络波动都会造成主机和从机间的一次全量的数据复制，这对实际的系统运营造成了不小的麻烦。 Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。 http://www.yiibai.com/redis/https://redis.io/ java中实现redis需要导包12345&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt; redis使用其中主要的数据类型有 字符串 hasheshash表https://redis.io/commands#hash sorted lists双向链表，其中bp开头的可是实现阻塞的功能https://redis.io/commands#list lists sets集，不允许元素重复,同时还可以做一些运算，比如交集、并集、补集等https://redis.io/commands#set sets sorted sets有序集，每个点都有自己的分数，用来排序https://redis.io/commands#sorted_set sorted 1234//选择数据库，一共是1-16个select 6//查找所有的键值，可以用正则表达式keys * sorted set数据结构在java中实现sortedset使用的是红黑树，redis使用了跳表，查询、插入、删除时间复杂度期望值O（logn） 分数，节点，表头 http://redisbook.com/preview/skiplist/datastruct.htmlhttp://blog.csdn.net/ict2014/article/details/17394259http://www.leoox.com/?p=347 java中调用redis需要建立一个redisAdaptor来开启redis，封装各种命令1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Servicepublic class JedisAdapter implements InitializingBean &#123; private static final Logger logger = LoggerFactory.getLogger(JedisAdapter.class); private JedisPool pool; @Override public void afterPropertiesSet() throws Exception &#123; pool = new JedisPool(&quot;redis://localhost:6379/10&quot;); &#125; public Jedis getJedis() &#123; return pool.getResource(); &#125; //开启线程 public Transaction multi(Jedis jedis) &#123; try &#123; return jedis.multi(); &#125; catch (Exception e) &#123; logger.error(&quot;发生异常&quot; + e.getMessage()); &#125; finally &#123; &#125; return null; &#125; //执行事务 public List&lt;Object&gt; exec(Transaction tx, Jedis jedis) &#123; try &#123; return tx.exec(); &#125; catch (Exception e) &#123; logger.error(&quot;发生异常&quot; + e.getMessage()); tx.discard(); &#125; finally &#123; if (tx != null) &#123; try &#123; tx.close(); &#125; catch (IOException ioe) &#123; // .. &#125; &#125; if (jedis != null) &#123; jedis.close(); &#125; &#125; return null; &#125; //封装，因为这里面要用到关闭资源等 public long sadd(String key, String value) &#123; Jedis jedis = null; try &#123; jedis = pool.getResource(); return jedis.sadd(key, value); &#125; catch (Exception e) &#123; logger.error(&quot;发生异常&quot; + e.getMessage()); &#125; finally &#123; if (jedis != null) &#123; jedis.close(); &#125; &#125; return 0; &#125;&#125; redis持久化 RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。 AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite） ，使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。 Redis 还可以同时使用 AOF 持久化和 RDB 持久化。在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。 你甚至可以关闭持久化功能，让数据只在服务器运行时存在。 RDB 的优点RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。 RDB 非常适用于灾难恢复（disaster recovery） ：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。 RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。 RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。 RDB 的缺点如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。 每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。 AOF 的优点使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。 AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。 Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。举个例子， 如果你对一个计数器调用了 100 次 INCR ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry）。然而在实际上， 只使用一条 SET 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。为了处理这种情况， Redis 支持一种有趣的特性： 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。执行 BGREWRITEAOF 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。 AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。 AOF 的缺点对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。 http://doc.redisfans.com/topic/persistence.html 踩赞的实现基本原理是将踩赞等记录存到redis中，redis使用set存储实体与点赞人的关系key = LIKE:实体类型:实体idvalue = 用户id 比如用户2点赞了评论(实体类型是1)5 添加赞sadd LIKE:1:5 2同时还要去掉踩的记录srem DISLIKE:1:5:2Java代码实现 123456//事务Jedis jedis = jedisAdapter.getJedis();Transaction tx = jedisAdapter.multi(jedis);jedisAdapter.sadd(likeKey, String.valueOf(userId));jedisAdapter.srem(disLikeKey, String.valueOf(userId));List&lt;Object&gt; ret = jedisAdapter.exec(tx, jedis); 取出喜欢的记录smembers LIKE:2:1 统计喜欢的记录数scard LIKE:2:1 互粉的实现原理和踩赞的实现相似，但是粉丝使用sorted set存储数据，因为涉及到排序 key = FOLLOWER:实体类型:实体idvalue = 用户id 比如用户2关注了当前用户(实体类型是1)5 添加关注要同时添加两个实体的集合，所以加上事务zadd 关键字 分数 值，这里分数是用来排序的实体粉丝关注当前用户zadd FOLLOWER:1:5 9 2分数是9当前用户对实体关注加1zadd FOLLOWEE:2:1 9 5 查看关注者zrange 关键字 位置1 位置2，zrange是查看位置的元素，即从第0个到第-1个，-1表示倒数第一个zrange FOLLOWER:1:5 0 -1 withscoreszrevrange 关键字 位置1 位置2，倒序查看zrange FOLLOWER:1:5 0 10 withscores如果以时间为分数，那么反向查看就是查看最新的 得到粉丝个数zcard 关键字zecard FOLLOWER:1:5 取消关注要同时取消双方的，且为一个事务zrem FOLLOWER:1:5 1 找出几个用户最近关注的10个问题ZUNIONSTORE 求并集http://www.runoob.com/redis/sorted-sets-zunionstore.html 找出两个人共同关注的ZINTERSTORE 求交集http://www.runoob.com/redis/sorted-sets-zinterstore.html","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"wenda","slug":"wenda","permalink":"http://duyao.github.io/tags/wenda/"}]},{"title":"问答-异步队列","slug":"问答-异步队列","date":"2017-02-27T06:44:22.000Z","updated":"2017-04-16T09:06:56.000Z","comments":true,"path":"2017/02/27/问答-异步队列/","link":"","permalink":"http://duyao.github.io/2017/02/27/问答-异步队列/","excerpt":"","text":"异步队列主要完成了异步的事件，比如a关注b，那么系统会给b发一份站内信，则发站内信的事件就可以作为异步的，也就是说a关注b后就返回结果，而发站内信会不会立刻完成的。这个生产者消费者模型非常相似，就是说a生产事件，b这边只有在a生产事件后才会去取，而不是一直的等着a的生产。再比如发系统通知就是异步事件，每个用户不会只等着系统通知，而是做其他事情，留下一个线程监视着系统的通知。异步事件还可以完成更高级的功能，比如优先级，就拿打印来说，一个用户不停地提交打印任务后，那么其他用户一直得不到打印机会，因此可以设置一个用户再次提交任务，优先级就回降低，对队列实现排序(priority queue)就可以完成带有优先级的打印了。这里异步队列使用redis实现存储，同时我们也可以使用juc中blocking queue实现。 https://zhuanlan.zhihu.com/p/21649950 消息队列消息队列是可以实现时间的异步功能，可以是 原理生产消费者模型在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度。 http://www.infoq.com/cn/articles/producers-and-consumers-mode/ 订阅发布者也类似于生产消费者，也是有放有拿的问题区别在于订阅发布者是中订阅者也能会使发布者，两者的关系不是很绝对。 那么到底什么是观察者模式(订阅发布者)呢. 先看看生活中的观察者模式。好莱坞有句名言. “不要给我打电话， 我会给你打电话”. 这句话就解释了一个观察者模式的来龙去脉。 其中“我”是发布者， “你”是订阅者。 再举个例子，我来公司面试的时候，完事之后每个面试官都会对我说：“请留下你的联系方式， 有消息我们会通知你”。 在这里“我”是订阅者， 面试官是发布者。所以我不用每天或者每小时都去询问面试结果， 通讯的主动权掌握在了面试官手上。而我只需要提供一个联系方式。http://www.cnblogs.com/lori/p/5413369.html 实现 生产者消费者 上图中抽象了生产者和消费者 因为消息队列中存放的事件，因此需要记录事件的信息。123456789101112131415161718192021222324252627282930313233343536public class EventModel &#123; //事件类型代码 private EventType type; //发出事件的id private int actorId; //这个事件的实体，比如是评论还是问题 private int entityType; private int entityId; //事件实体的拥有者，比如拥有这条评论的人 private int entityOwnerId; //事件的其他存储信息，比如可以存放优先级、时间等 private Map&lt;String, String&gt; exts = new HashMap&lt;String, String&gt;(); //set、get方法 public EventModel setType(EventType type) &#123; this.type = type; return this; &#125; public EventModel setActorId(int actorId) &#123; this.actorId = actorId; return this; &#125; public int getActorId() &#123; return actorId; &#125; //... //set、get方法全部是返回的是事件本身，这样就可以进行链式调用 public static void main(String[] args) &#123; EventModel model = new EventModel(); model.setActorId(12).setEntityId(45).setEntityType(23); &#125;&#125; 不同的类都可能是消费者，因此要设计成一个处理接口，然后不同的消费类都实现这个接口，然后调用消费者1234567public interface EventHandler &#123; //具体的业务处理 void doHandle(EventModel model); //支持的处理对象，比如对于私信来说有可能是邮件处理也可能是站内信处理，所以设置为list List&lt;EventType&gt; getSupportEventTypes();&#125; 不同的事件处理类1234567891011121314151617181920212223242526@Componentpublic class LikeHandler implements EventHandler &#123; @Override public void doHandle(EventModel model) &#123; &#125; @Override public List&lt;EventType&gt; getSupportEventTypes() &#123; return Arrays.asList(EventType.LIKE); &#125;&#125;@Componentpublic class FollowHandler implements EventHandler &#123; @Override public void doHandle(EventModel model) &#123; &#125; @Override public List&lt;EventType&gt; getSupportEventTypes() &#123; return Arrays.asList(EventType.FOLLOW); &#125;&#125; redis消息列队对于生产者和消费者使用redis构造队列 redis可以构造队列和栈等 L开头的是从队头或者说是左边进行操作，R表示从队尾或者右边进行操作如果想构造队列，那么取和放的操作就要在不同的方向，如果想构造栈，方向就要相同 B开头是带有阻塞功能的，后面的参数可以设置超时时间，如果超时其他客户端就回来操作超时参数设为 0 表示阻塞时间可以无限期延长(block indefinitely)BLPOP key1 [key2 ] timeout取出并获取列表中的第一个元素，或阻塞，直到有可用BRPOP key1 [key2 ] timeout取出并获取列表中的最后一个元素，或阻塞，直到有可用 实现使用lpush实现生产者放队列的功能,因为redis存放对象需要持久化，因此使用json来持久化对象123456789101112131415161718@Servicepublic class EventProducer &#123; @Autowired JedisAdapter jedisAdapter; public boolean fireEvent(EventModel eventModel) &#123; try &#123; //持久化对象 String json = JSONObject.toJSONString(eventModel); String key = RedisKeyUtil.getEventQueueKey(); //放入队列 jedisAdapter.lpush(key, json); return true; &#125; catch (Exception e) &#123; return false; &#125; &#125;&#125; 消费者是开启一个线程，然后使用brpop从队列中取事件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Servicepublic class EventConsumer implements InitializingBean, ApplicationContextAware &#123; private static final Logger logger = LoggerFactory.getLogger(EventConsumer.class); //存放着消费者所有能处理的handler private Map&lt;EventType, List&lt;EventHandler&gt;&gt; config = new HashMap&lt;EventType, List&lt;EventHandler&gt;&gt;(); //获得初始化的上下文 private ApplicationContext applicationContext; @Autowired JedisAdapter jedisAdapter; @Override public void afterPropertiesSet() throws Exception &#123; //启动项目的时候用applicationContext获得所有实现EventHandler的类 Map&lt;String, EventHandler&gt; beans = applicationContext.getBeansOfType(EventHandler.class); if (beans != null) &#123; //初始化能处理的handler - config对象 for (Map.Entry&lt;String, EventHandler&gt; entry : beans.entrySet()) &#123; List&lt;EventType&gt; eventTypes = entry.getValue().getSupportEventTypes(); for (EventType type : eventTypes) &#123; if (!config.containsKey(type)) &#123; config.put(type, new ArrayList&lt;EventHandler&gt;()); &#125; config.get(type).add(entry.getValue()); &#125; &#125; &#125; //开启一个线程不同的读取队列中的事件 Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; while(true) &#123; String key = RedisKeyUtil.getEventQueueKey(); //从队伍里面取出被持久化的事件，timeout为0时 List&lt;String&gt; events = jedisAdapter.brpop(0, key); for (String message : events) &#123; //跳过自己的key if (message.equals(key)) &#123; continue; &#125; //还原事件 EventModel eventModel = JSON.parseObject(message, EventModel.class); if (!config.containsKey(eventModel.getType())) &#123; logger.error(&quot;不能识别的事件&quot;); continue; &#125; //执行事件 for (EventHandler handler : config.get(eventModel.getType())) &#123; handler.doHandle(eventModel); &#125; &#125; &#125; &#125; &#125;); thread.start(); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; &#125;&#125; 优先级上面的队列只是一个普通的队列，还可以设置带有优先级的队列有两种方案设置两个队列，一个等级高，一个等级低,一个高优先级一个低优先级的队列。高优先级任务放到高队列中，低的放在低优先队列中。redis可以要求队列消费者从哪个队列里面先读。顺序就是命令的顺序1BRPOP queue.task.1 queue.task.2 0 假设有个这样的需求，优先级不是简单的高中低或者0-10这些固定的级别。而是类似0-99999这么多级别上面的方案就不合适了。虽然redis有sorted set这样的可以排序的数据类型，看是很可惜它没有阻塞版的接口。于是我们还是只能使用list类型通过其他方式来完成目的。 有个简单的做法我们可以只设置一个队列，并保证它是按照优先级排序号的。然后通过二分查找法查找一个任务合适的位置，并通过 lset 命令插入到相应的位置。例如队列里面包含着写优先级的任务[1, 3, 6, 8, 9, 14]，当有个优先级为7的任务过来，我们通过自己的二分算法一个个从队列里面取数据出来反和目标数据比对，计算出相应的位置然后插入到指定地点即可。因为二分查找是比较快的，并且redis本身也都在内存中，理论上速度是可以保证的。但是如果说数据量确实很大的话我们也可以通过一些方式来调优。例如数据量十万的队列，它们的优先级也是随机0-十万的区间。我们可以设置10个或者100个不同的队列，0-一万的优先级任务投放到1号队列，一万-二万的任务投放到2号队列。这样将一个队列按不同等级拆分后它单个队列的数据就减少许多，这样二分查找匹配的效率也会高一点。但是数据所占的资源基本是不变的，十万数据该占多少内存还是多少。只是系统里面多了一些队列而已。 可靠性一般来讲，设计消息队列的整体思路是先build一个整体的数据流,例如producer发送给broker,broker发送给consumer,consumer回复消费确认，broker删除/备份消息等。利用RPC将数据流串起来。然后考虑RPC的高可用性，尽量做到无状态，方便水平扩展。之后考虑如何承载消息堆积，然后在合适的时机投递消息，而处理堆积的最佳方式，就是存储，存储的选型需要综合考虑性能/可靠性和开发维护成本等诸多因素。为了实现广播功能，我们必须要维护消费关系，可以利用zk/config server等保存消费关系。在完成了上述几个功能后，消息队列基本就实现了。然后我们可以考虑一些高级特性，如可靠投递，事务特性，性能优化等。 缺点1)redis崩溃的时候队列功能失效2)如果入队端一直在塞数据，而出队端没有消费数据，或者是入队的频率大而多，出队端的消费频率慢会导致内存暴涨4)假如有多个消费者同时监听一个队列，其中一个出队了一个元素，另一个则获取不到该元素5)Redis的队列应用场景是一对多或者一对一的关系，即有多个入队端，但是只有一个消费端(出队) java中的消息队列BlockingQueue在java中可以使用BlockingQueue来实现消息队列，但是效率不是非常高，因为其内部不是无锁方式。 DisruptorDisruptor可以实现高性能生产者和消费者模式Diruptor 页面：https://github.com/LMAX-Exchange/disruptor待完成https://zhuanlan.zhihu.com/p/21355046https://www.bittiger.io/classpage/QHkP5QobvhNWGZv9fhttp://coolshell.cn/articles/9169.html","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"wenda","slug":"wenda","permalink":"http://duyao.github.io/tags/wenda/"}]},{"title":"问答-敏感词过滤","slug":"问答-敏感词过滤","date":"2017-02-27T06:44:02.000Z","updated":"2017-03-04T12:20:48.000Z","comments":true,"path":"2017/02/27/问答-敏感词过滤/","link":"","permalink":"http://duyao.github.io/2017/02/27/问答-敏感词过滤/","excerpt":"","text":"实现原理布隆过滤器建立bitset，将一个词都hash映射到bitset中，如果查找一个词全1那么就是敏感词，非全1就不是这是一种空间换时间的方法，因为映射空间非常小，就会产生冲突http://www.cnblogs.com/heaad/archive/2011/01/02/1924195.html tire树这一种树，每一个节点是一个字母或者汉字，同时一个节点有多个子节点，还有标志位用来记录是不是结束，比如色情这个词汇中情字节点就会有标志位 http://blog.duyaokeep.cn/2016/03/24/%E5%AD%97%E5%85%B8%E6%A0%91/ 复杂度分析（1） 插入、查找的时间复杂度均为O(N)，其中N为字符串长度。（2） 空间复杂度是26^n级别的，非常庞大（可采用双数组实现改善）。 结构结构如下：其中map记录了所有的子节点，对于英文字就可以用数组实现，因为总数固定12345678910111213141516171819202122232425262728293031323334353637383940private class TrieNode &#123; /** * true 关键词的终结 ； false 继续 */ private boolean end = false; /** * key下一个字符，value是对应的节点 */ private Map&lt;Character, TrieNode&gt; subNodes = new HashMap&lt;&gt;(); /** * 向指定位置添加节点树 */ void addSubNode(Character key, TrieNode node) &#123; subNodes.put(key, node); &#125; /** * 获取下个节点 */ TrieNode getSubNode(Character key) &#123; return subNodes.get(key); &#125; boolean isKeywordEnd() &#123; return end; &#125; void setKeywordEnd(boolean end) &#123; this.end = end; &#125; public int getSubNodeCount() &#123; return subNodes.size(); &#125;&#125; 查找过程添加过程就是有三个指针begin、position、root分别指向回滚位置、当期位置和树的根节点不停比较position和root位置的字符，会产生2种结果 相等说明有可能是敏感词可以继续后移比较，同时检查如果树中root位置已经到了标记位，说明从begin到pos都是敏感词，记录并开始新的一轮 不相等root和pos都后移 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 过滤敏感词 */public String filter(String text) &#123; if (StringUtils.isBlank(text)) &#123; return text; &#125; String replacement = DEFAULT_REPLACEMENT; StringBuilder result = new StringBuilder(); TrieNode tempNode = rootNode; int begin = 0; // 回滚数 int position = 0; // 当前比较的位置 while (position &lt; text.length()) &#123; char c = text.charAt(position); // 空格直接跳过 if (isSymbol(c)) &#123; if (tempNode == rootNode) &#123; result.append(c); ++begin; &#125; ++position; continue; &#125; tempNode = tempNode.getSubNode(c); // 当前位置的匹配结束 if (tempNode == null) &#123; // 以begin开始的字符串不存在敏感词 result.append(text.charAt(begin)); // 跳到下一个字符开始测试 position = begin + 1; begin = position; // 回到树初始节点 tempNode = rootNode; &#125; else if (tempNode.isKeywordEnd()) &#123; // 发现敏感词， 从begin到position的位置用replacement替换掉 result.append(replacement); position = position + 1; begin = position; tempNode = rootNode; &#125; else &#123; ++position; &#125; &#125; result.append(text.substring(begin)); return result.toString();&#125; 添加节点就是判断该节点是不是和字符相等，不相等就继续查，节点空说明查到叶子节点了，需要添加123456789101112131415161718192021222324private void addWord(String lineTxt) &#123; TrieNode tempNode = rootNode; // 循环每个字节 for (int i = 0; i &lt; lineTxt.length(); ++i) &#123; Character c = lineTxt.charAt(i); // 过滤空格 if (isSymbol(c)) &#123; continue; &#125; TrieNode node = tempNode.getSubNode(c); if (node == null) &#123; // 没初始化 node = new TrieNode(); tempNode.addSubNode(c, node); &#125; tempNode = node; if (i == lineTxt.length() - 1) &#123; // 关键词结束， 设置结束标志 tempNode.setKeywordEnd(true); &#125; &#125;&#125; 其余过滤过滤过程中，同时会出现*色*情等加入空格或者其他符号的现象，因此通过其ascii值就能过滤掉12345678/** * 判断是否是一个符号 */private boolean isSymbol(char c) &#123; int ic = (int) c; // 0x2E80-0x9FFF 东亚文字范围 return !CharUtils.isAsciiAlphanumeric(c) &amp;&amp; (ic &lt; 0x2E80 || ic &gt; 0x9FFF);&#125; 还要过滤html等标签1HtmlUtils.htmlEscape(question.getTitle()); 过滤服务这个service需要初始化来导入敏感词，因此要实现InitializingBean在afterPropertiesSet()方法中实现读取敏感词文件的过程 1234567891011121314151617181920212223242526272829303132333435363738394041public class SensitiveService implements InitializingBean &#123; private static final Logger logger = LoggerFactory.getLogger(SensitiveService.class); /** * 默认敏感词替换符 */ private static final String DEFAULT_REPLACEMENT = &quot;敏感词&quot;; /** * 根节点 */ private TrieNode rootNode = new TrieNode(); @Override public void afterPropertiesSet() throws Exception &#123; rootNode = new TrieNode(); try &#123; InputStream is = Thread.currentThread().getContextClassLoader() .getResourceAsStream(&quot;SensitiveWords.txt&quot;); InputStreamReader read = new InputStreamReader(is); BufferedReader bufferedReader = new BufferedReader(read); String lineTxt; while ((lineTxt = bufferedReader.readLine()) != null) &#123; lineTxt = lineTxt.trim(); addWord(lineTxt); &#125; read.close(); &#125; catch (Exception e) &#123; logger.error(&quot;读取敏感词文件失败&quot; + e.getMessage()); &#125; &#125; public static void main(String[] argv) &#123; SensitiveService s = new SensitiveService(); s.addWord(&quot;色情&quot;); s.addWord(&quot;好色&quot;); System.out.print(s.filter(&quot;你好X色**情XX&quot;)); &#125;&#125; http://www.cnblogs.com/heaad/archive/2011/01/02/1924195.html","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"wenda","slug":"wenda","permalink":"http://duyao.github.io/tags/wenda/"}]},{"title":"线程与并发","slug":"线程与并发","date":"2017-02-25T05:40:21.000Z","updated":"2017-05-04T09:22:10.000Z","comments":true,"path":"2017/02/25/线程与并发/","link":"","permalink":"http://duyao.github.io/2017/02/25/线程与并发/","excerpt":"","text":"一些概念同步(synchronous)和异步(asynchronous)同步是指一直做一个事情，直到完成异步是指应用并没有完成这个事情，但是返回结果继续执行其他事情，对于没有完成的开启一个新的线程完成。 并发(Concurrency)和并行(Parallelism)并发是有能力完成多个任务，但不一定同时并行是有能力同时完成多个任务 临界区临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其他线程要想使用这个资源，就必须等待。 阻塞(Blocking)和非阻塞(Non-Blocking)阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其它所有需要这个资源的线程就必须在这个临界区中进行等待，等待会导致线程挂起。这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其它所有阻塞在这个临界区上的线程都不能工作。非阻塞允许多个线程同时进入临界区 死锁(Deadlock)、饥饿(Starvation)和活锁(Livelock)死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。 饥饿是指某一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。 活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。 活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。 生活中的典型例子： 两个人在窄路相遇，同时向一个方向避让，然后又向另一个方向避让，如此反复。通信中也有类似的例子，多个用户共享信道(最简单的例子是大家都用对讲机)，同一时刻只能有一方发送信息。发送信号的用户会进行冲突检测， 如果发生冲突，就选择避让，然后再发送。 假设避让算法不合理，就导致每次发送，都冲突，避让后再发送，还是冲突。 并行的级别阻塞的控制方式是悲观策略，而非阻塞的方式乐观的策略。阻塞方式以保护数据为目的，而非阻塞方式认为多个线程可能不会发生冲突，但是一旦发生冲突就会立刻回滚。 阻塞当一个线程进入临界区后，其他线程必须等待。比如synchronized或者ReentrantLock 无饥饿锁公平 无障碍(Obstruction-Free) 无障碍是一种最弱的非阻塞调度 自由出入临界区，有竞争时，回滚数据 依赖一致性标记 无锁(Lock-Free) 是无障碍的，同时保证了必然有一个线程在有限步完成 保证有一个线程可以胜出 通常包含一个无穷循环1234while (!atomicVar.compareAndSet(localVar, localVar+1))&#123; localVar = atomicVar.get();&#125; 无等待(Wait-Free) 无锁的，同时要求所有的线程都必须在有限步内完成 无饥饿的 RCU(read-copy-update) java内存模型Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样底层细节。此处的变量与Java编程时所说的变量不一样，指包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享。 Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量(这些变量是从主内存中拷贝而来)。线程对变量的所有操作(读取，赋值)都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 java内存模型 这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区不是同一层次内存划分 特性原子性原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其它线程干扰。1234x = 10; //语句1y = x; //语句2x++; //语句3x = x + 1; //语句4 只有语句1是原子性操作，其他三个语句都不是原子性操作。 语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。所以上面4个语句只有语句1的操作具备原子性。 只有简单的读取、赋值(而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作)才是原子操作。 根据Java规范，对于基本类型的赋值或者返回值操作，是原子操作。但这里的基本数据类型不包括long和double, 因为JVM看到的基本存储单位是32位，而long 和double都要用64位来表示。所以无法在一个时钟周期内完成 有序性在并发时，程序的执行可能就会出现乱序 一条指令的执行是可以分为很多步骤的 取指 IF 译码和取寄存器操作数 ID 执行或者有效地址计算 EX 存储器访问 MEM 写回 WB由于指令重排可以使流水线更加顺畅，但是却影响了指令的有序执行 可见性可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。 编译器优化由于是现在的处理器大部分是多核的，而每个处理器都有自己工作空间，有自己的cache、闪存、内存等。所以对于多线程来说每个变量不一定载入到同一个位置，这影响了可见性 硬件优化(如写吸收，批操作)写吸收是指多次写操作只记录最后一次的值 Java虚拟机层面的可见性http://hushi55.github.io/2015/01/05/volatile-assembly 保证可见性的方法 volatile synchronized (unlock之前，写变量值回主存) final(一旦初始化完成，其他线程就可见) Happen-Before规则该规则说明了那些指令不能重排 程序顺序原则：一个线程内保证语义的串行性 volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性 锁规则：解锁(unlock)必然发生在随后的加锁(lock)前 传递性：A先于B，B先于C，那么A必然先于C 线程的start()方法先于它的每一个动作 线程的所有操作先于线程的终结(Thread.join()) 线程的中断(interrupt())先于被中断线程的代码 对象的构造函数执行结束先于finalize()方法 volatile保证可见性，不保证原子性 原理一旦一个共享变量(类的成员变量、类的静态成员变量)被volatile修饰之后，那么就具备了两层语义：1)保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。使用volatile关键字会强制将修改的值立即写入主存；使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效(反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效)；由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。那么在线程2修改stop值时(当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存)，会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。那么线程1读取到的就是最新的正确的值。2)禁止进行指令重排序。 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行 在进行指令优化时，不能将在对volatile变量的读操作或者写操作的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行 应用场景synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：1)对变量的写操作不依赖于当前值2)该变量没有包含在具有其他变量的不变式中 下面列举几个Java中使用volatile的几个场景。①.状态标记量123456789volatile boolean flag = false; //线程1while(!flag)&#123; doSomething();&#125; //线程2public void setFlag() &#123; flag = true;&#125; 根据状态标记，终止线程。 ②.单例模式中的double check1234567891011121314151617class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 为什么要使用volatile 修饰instance？主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情:a.给 instance 分配内存b.调用 Singleton 的构造函数来初始化成员变量c.将instance对象指向分配的内存空间(执行完这步 instance 就为非 null 了)。但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了(但却没有初始化)，所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。 https://mp.weixin.qq.com/s/JY1totcwH0E-nboQ_I01Rw 线程http://www.cnblogs.com/zhguang/p/3330676.html#thread04 线程与进程1.线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；2.一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；3.进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；4.调度和切换：线程上下文切换比进程上下文切换要快得多。 多线程、多进程与多cpu的关系 多线程和多进程比较 1)需要频繁创建销毁的优先用线程这种原则最常见的应用就是Web服务器了，来一个连接建立一个线程，断了就销毁线程，要是用进程，创建和销毁的代价是很难承受的2)需要进行大量计算的优先使用线程所谓大量计算，当然就是要耗费很多CPU，切换频繁了，这种情况下线程是最合适的。这种原则最常见的是图像处理、算法处理。3)强相关的处理用线程，弱相关的处理用进程什么叫强相关、弱相关？理论上很难定义，给个简单的例子就明白了。一般的Server需要完成如下任务：消息收发、消息处理。“消息收发”和“消息处理”就是弱相关的任务，而“消息处理”里面可能又分为“消息解码”、“业务处理”，这两个任务相对来说相关性就要强多了。因此“消息收发”和“消息处理”可以分进程设计，“消息解码”、“业务处理”可以分线程设计。当然这种划分方式不是一成不变的，也可以根据实际情况进行调整。4)可能要扩展到多机分布的用进程，多核分布的用线程http://blog.csdn.net/lishenglong666/article/details/8557215 一般可以使用一个进程有多个线程的好处：对于单核 CPU 而言，CPU每次只能调度 1 个线程，但是若当前线程阻塞了， CPU 可以不必等待，而是先调用别的线程执行，这样就提高了 CPU 的利用率 cpu对线程感知，对进程不感知，进程是os的概念 线程有两种： 一种是 “用户态线程” ，对内核不可见，内核不可以调度，现在一般叫做纤程或协程。有了系统内核的支持，被阻塞不会影响整个进程，但是需要在用户态和内核态切换代价高，且内核线程数量有限 另一种是 “内核态线程”，由内核调度，也称作轻量进程 LWP 。现在说的线程，一般不特殊指定，都是内核线程。系统不会感知到用户线程的存在，不需要切换到内核态，切换速度快，支持更大规模的数量，但是需要线程间的切换调度等问题 内核线程和用户线程的关系可以是一对一、多对一和多对多(现代操作系统都是这样的) 能不能利用多核的关键是能不能被内核调度，既然内核态线程可以被调度，自然可以利用多核。所以如果cpu已经塞满了计算任务，再开多线程或进程也没有用，而现在是io比较多任务，这样cpu比较空闲(现代操作系统io操作都交给了DMA处理器，所以无需cpu操心)，可以多开些线程进行其他任务。 http://blog.csdn.net/luoweifu/article/details/46595285 线程的安全线程安全的强弱可以分为：不可变、绝对线程安全、相对线程安全、线程兼容、线程独立 不可变不可变的对象一定是线程安全的，比如String类型、枚举类、Number的部分子类、Long和Double的包装类、BIgInteger等保证对象不行为不影响自己状态的途径有很多，比如用关键字final 绝对线程安全不管运行时环境如何，调用者都不需要任何额外的同步措施Java API中注明线程安全的类大部分不是绝对的线程安全比如vector多线程使用的时候仍然要加锁1234567891011121314151617181920Thread removeThread=new Thread(new Runnable()&#123; @Override public void run()&#123; synchronized(vector)&#123;//加锁 for(int i=0；i＜vector.size()；i++)&#123; vector.remove(i); &#125; &#125; &#125; &#125;); Thread printThread=new Thread(new Runnable()&#123; @Override public void run()&#123; synchronized(vector)&#123;//加锁 for(int i=0；i＜vector.size()；i++)&#123; System.out.println((vector.get(i)))； &#125; &#125; &#125; &#125;); 这里一个添加一个移除vetor中的元素，如果不加锁，一定会出问题 相对线程安全相对线程安全就是通常意义的线程安全，他要保证这个对象单独的操作是线程安全的，但是对于特定顺序的调用，必须使用额外的手段来保证调用的正确性比如Vector、HashTable、Collections.synchronizedCollection() 线程兼容线程兼容指对象本身不是线程安全的，但是可以通过调用段正确的使用同步手段保证对象在并发环境中安全地使用。Java API中大部分的类都时都是线程兼容的，比如ArrayList、HashMap 线程独立线程独立是指无论调用段是否采用了同步措施，多线程环境中都无法使用的。java语言天生能带有多线程特性，线程独立的代码是很少的，同时要尽量避免比如Thread中suspend和resume，总是会有死锁风险的。http://www.cnblogs.com/duanxz/p/6099983.html 线程的实现方法 实现Runnable接口 1234567891011121314151617181920class MyThread implements Runnable&#123; private int ticket = 5; public void run()&#123; for (int i=0;i&lt;10;i++) &#123; if(ticket &gt; 0)&#123; System.out.println(\"ticket = \" + ticket--); &#125; &#125; &#125; &#125; public class RunnableDemo&#123; public static void main(String[] args)&#123; MyThread my = new MyThread(); new Thread(my).start(); new Thread(my).start(); new Thread(my).start(); &#125; &#125; 继承Thread类 12345678910111213141516171819class MyThread extends Thread&#123; private int ticket = 5; public void run()&#123; for (int i=0;i&lt;10;i++) &#123; if(ticket &gt; 0)&#123; System.out.println(\"ticket = \" + ticket--); &#125; &#125; &#125; &#125; public class ThreadDemo&#123; public static void main(String[] args)&#123; new MyThread().start(); new MyThread().start(); new MyThread().start(); &#125; &#125; 在第二种方法中，我们new了3个Thread对象，即三个线程分别执行三个对象中的代码，因此便是三个线程去独立地完成卖票的任务；而在第一种方法中，我们同样也new了3个Thread对象，但只有一个Runnable对象，3个Thread对象共享这个Runnable对象中的代码，因此，便会出现3个线程共同完成卖票任务的结果。如果我们new出3个Runnable对象，作为参数分别传入3个Thread对象中，那么3个线程便会独立执行各自Runnable对象中的代码，即3个线程各自卖5张票。 在第一种方法中，由于3个Thread对象共同执行一个Runnable对象中的代码，因此可能会造成线程的不安全，比如可能ticket会输出-1(如果我们System.out….语句前加上线程休眠操作，该情况将很有可能出现)，这种情况的出现是由于，一个线程在判断ticket为1&gt;0后，还没有来得及减1，另一个线程已经将ticket减1，变为了0，那么接下来之前的线程再将ticket减1，便得到了-1。这就需要加入同步操作(即互斥锁)，确保同一时刻只有一个线程在执行每次for循环中的操作。而在第二种方法中，并不需要加入同步操作，因为每个线程执行自己Thread对象中的代码，不存在多个线程共同执行同一个方法的情况。 高级的线程创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。 CallableCallable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：123public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; 一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本123&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task); Future和FutureTaskFuture就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。Future类位于java.util.concurrent包下，它是一个接口：12345678public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 在Future接口中声明了5个方法，下面依次解释每个方法的作用： cancel方法用来取消任务如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。 isCancelled方法表示任务是否被取消成功如果在任务正常完成前被取消成功，则返回 true。 isDone方法表示任务是否已经完成,若任务完成，则返回true； get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回； get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。 也就是说Future提供了三种功能：1)判断任务是否完成；2)能够中断任务；3)能够获取任务执行结果。 因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。12345public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125; RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。 FutureTask提供了2个构造器：12public FutureTask(Callable&lt;V&gt; callable) &#123;&#125;public FutureTask(Runnable runnable, V result) &#123;&#125; 事实上，FutureTask是Future接口的一个唯一实现类。 例子1.使用Callable+Future获取执行结果12345678910111213141516171819202122232425262728293031323334353637public class Test &#123; public static void main(String[] args) &#123; ExecutorService executor = Executors.newCachedThreadPool(); Task task = new Task(); Future&lt;Integer&gt; result = executor.submit(task); executor.shutdown(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; System.out.println(\"主线程在执行任务\"); try &#123; System.out.println(\"task运行结果\"+result.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; System.out.println(\"所有任务执行完毕\"); &#125;&#125;class Task implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; System.out.println(\"子线程在进行计算\"); Thread.sleep(3000); int sum = 0; for(int i=0;i&lt;100;i++) sum += i; return sum; &#125;&#125; 2.使用Callable+FutureTask获取执行结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Test &#123; public static void main(String[] args) &#123; //第一种方式 ExecutorService executor = Executors.newCachedThreadPool(); Task task = new Task(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task); executor.submit(futureTask); executor.shutdown(); //第二种方式，注意这种方式和第一种方式效果是类似的， //只不过一个使用的是ExecutorService，一个使用的是Thread /*Task task = new Task(); FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task); Thread thread = new Thread(futureTask); thread.start();*/ try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; System.out.println(\"主线程在执行任务\"); try &#123; System.out.println(\"task运行结果\"+futureTask.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; System.out.println(\"所有任务执行完毕\"); &#125;&#125;class Task implements Callable&lt;Integer&gt;&#123; @Override public Integer call() throws Exception &#123; System.out.println(\"子线程在进行计算\"); Thread.sleep(3000); int sum = 0; for(int i=0;i&lt;100;i++) sum += i; return sum; &#125;&#125; http://www.cnblogs.com/dolphin0520/p/3949310.html 线程状态 线程状态 中断线程中断线程是不推荐使用stop()方法的，因为会破坏对象。1234public void Thread.interrupt() // 中断线程public boolean Thread.isInterrupted() // 判断是否被中断public static boolean Thread.interrupted() // 判断是否被中断，并清除当前中断状态public static native void sleep(long millis) throws InterruptedException //等待，会抛出异常，同时会修改中断标志 中断的做法表面理解中断就是让目标线程终止执行的意思，但是事实并非如此。严格地讲，中断并不会是线程退出，而是给线程发个信号，告诉目标线程有人想让你退出。至于目标线程接到通知如何处理，则完全由目标线程决定。如果中断就是无条件退出，那么就是和stop方法一样了。 下面这段代码执行后并不会中断线程的，只是调用interrupt中断位被设置了1234567//不会中断线程public void run()&#123; while(true)&#123; Thread.yield(); &#125;&#125;t1.interrupt(); 所以想中断线程，就需要对中断做出响应，因此对run方法进行修改，首先判断是否处于中断的状态，如果是，就要进行响应12345678910//优雅地中断线程，因为跳出了循环public void run()&#123; while(true)&#123; if(Thread.currentThread().isInterrupted())&#123; System.out.println(\"Interruted!\"); break; &#125; Thread.yield(); &#125;&#125; 另外，在调用sleep方法的时候，需要进行中断捕捉。在线程sleep时候，如果线程被中断，那么该线程的中断标志位将会清除，所以捕捉sleep的中断时候，要再次设置中断标志位Thread.currentThread().interrupt()1234567891011121314151617public void run()&#123; while(true)&#123; if(Thread.currentThread().isInterrupted())&#123; System.out.println(\"Interruted!\"); break; &#125; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; //中间等待过程中需要对中断方法做出反应 System.out.println(\"Interruted When Sleep\"); //设置中断状态，抛出异常后会清除中断标记位 Thread.currentThread().interrupt(); &#125; Thread.yield(); &#125;&#125; 一般来讲可以这样响应中断，其实还可以设置一个flag来表示是否中断，执行的时候同样要先判断flag的状态123456789try&#123; while(!Thread.currentThread().isInterrupted() &amp;&amp; more work)&#123; //do more work &#125;&#125;catch(InterruptedException ex)&#123; //sleep or wait&#125;finally&#123;&#125; stop和suspend、resume废弃原因 stop对破坏对象比如一个账户向另一个账户转钱的过程被终止，但是此时钱已经转出，却没有转向目的地，即这个账户对象被破坏 挂起(suspend)和继续执行(resume)线程造成死锁如果suspend挂起一个持有锁的线程，那么该线程在恢复之前是不可用的，suspend()不会释放锁。如果调用suspend的线程试图获得同一个锁，那么程序死锁，被挂起的线程等着被恢复，而挂起的线程等着获得锁。比如转账线程获得bank锁，而用户点击暂停转账，该转账线程被挂起，但是他拥有锁，用户又重新开始工作，需要转账线程的钱，而转账线程要获得锁，但是却被挂起如果加锁发生在resume()之前 ，则死锁发生 yield谦让和join等待线程结束 public final void join() throws InterruptedExceptionjoin：有两个线程想一起进行，其中一个结束，那么就会使用join等待另一个线程，然后一起进行下去 yield意味着放手，放弃，投降。一个调用yield()方法的线程告诉虚拟机它乐意让其他线程占用自己的位置，并释放当前资源。 为什么Thread类的sleep()和yield()方法是静态的？Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。 线程属性优先级最高10级 守护线程12t.setDaemon(true);t.start(); 守护线程就是为其他线程服务的，当只剩下守护线程了，虚拟机就自动退出了。 线程间的通信问题正常情况下，每个子线程完成各自的任务就可以结束了。不过有的时候，我们希望多个线程协同工作来完成某个任务，这时就涉及到了线程间通信了。涉及到的知识点：thread.join(),object.wait(), object.notify(), CountdownLatch, CyclicBarrier, FutureTask, Callable 等。 几个例子作为切入点来讲解下 Java 里有哪些方法来实现线程间通信。 如何让两个线程依次执行？ 那如何让两个线程按照指定方式有序交叉运行呢？ 四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的 三个运动员各自准备，等到三个人都准备好后，再一起跑 子线程完成某件任务后，把得到的结果回传给主线程 http://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/ 监视器Java中的每一个对象都可以作为锁，而不同的场景锁是不一样的。 对象头与锁HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。 HotSpot虚拟机的对象头(Object Header)包括两部分信息：第一部分用于存储对象自身的运行时数据， 如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机(暂 不考虑开启压缩指针的场景)中分别为32个和64个Bits，官方称它为“Mark Word”。对象头的另外一部分是类型指针，即是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说查找对象的元数据信息并不一定要经过对象本身。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。 实例数据：是对象真正存储的有效信息。包括原生类型(primitive type)和对象引用(reference)。对齐填充：Java对象占用空间是8字节对齐的，即所有Java对象占用bytes数必须是8的倍数。 从上面可以看出每个对象的对象头都存放着锁的信息，在堆中。在运行期间java对象头里Mark Word里存储的数据会随着锁标志位的变化而变化。 实现在HotSpot虚拟机中，monitor采用ObjectMonitor实现。每个线程都有两个ObjectMonitor对象列表，分别为free和used列表，如果当前free列表为空，线程将向全局global list请求分配ObjectMonitor。ObjectMonitor对象中有两个队列：_WaitSet 和_EntryList，用来保存ObjectWaiter对象列表；_owner指向获得ObjectMonitor对象的线程。锁存在Java对象头里。如果对象是数组类型，则虚拟机用3个Word(字宽)存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，一字宽等于四字节，即32bit。 https://segmentfault.com/a/1190000006933272 锁的四种状态锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率 锁 优点 缺点 使用场景 偏向锁 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 适用于只有一个线程访问同步块场景。 轻量级锁 竞争的线程不会阻塞，提高了程序的响应速度。 如果始终得不到锁竞争的线程使用自旋会消耗CPU。 追求响应时间。同步块执行速度非常快。 重量级锁 线程竞争不使用自旋，不会消耗CPU。 线程阻塞，响应时间缓慢。 追求吞吐量。同步块执行速度较长。 http://www.infoq.com/cn/articles/java-se-16-synchronized synchronizedsynchronized关键字基于monitorenter和monitorexit两个指令实现了锁的获取和释放过程。同时值得注意的是，synchronized关键字不支持继承，也就是说父类是synchronized,而子类继承后是没有synchronized的 同步方法块对于同步方法块,锁是Synchonized括号里配置的对象。1234567public void run() &#123; for(int j=0;j&lt;10000000;j++)&#123; synchronized(instance)&#123; i++; &#125; &#125;&#125; 直接作用于实例方法相当于对当前实例加锁，进入同步代码前要获得当前实例的锁。注意实例方法的调用者必须是同一个，才能加锁成功。如果不同，那么就会是两个锁。同时，如果访问该对象的其他synchronized方法是不能并行的，但是可以访问非synchronized方法123public synchronized void increase()&#123; i++;&#125; 直接作用于静态方法相当于对当前类加锁，进入同步代码前要获得当前类的锁。因此访问该类的其他任何方法都是不可以的，因为需要获得类锁123public static synchronized void increase()&#123; i++;&#125; 区别Java中的每一个对象都可以作为锁，而不同的场景锁是不一样的。 对于实例同步方法，锁是当前实例对象。对于静态同步方法，锁是当前对象的Class对象。对于同步方法块，锁是Synchonized括号里配置的对象。 a) 静态同步方法问题如下代码是两个静态同步方法123456789Class A&#123; public static synchronized void write(boolean b)&#123; isTrue = b; &#125; public static synchronized boolean read()&#123; return isTrue; &#125;&#125; 几个问题: 线程1访问A.write(true)方法时，线程2能访问A.read()方法吗？线程1访问new A().write(false)方法时，线程2能访问new A().read()方法吗？线程1访问A.write(false)方法时，线程2能访问new A().read()方法吗？ 回答： 线程1访问A.write()方法时，线程2能访问A.read()方法吗？不能，因为静态方法的锁都是A.Class对象,线程1拿到锁之后，线程2就拿不到锁了。线程1访问new A().write()方法时，线程2能访问new A().read()方法吗？不能，原因同上。线程1访问A.write()方法时，线程2能访问new A().read()方法吗？不能，原因同上 b)实例同步方法问题如下代码是两个实例同步方法123456public synchronized void write(boolean b)&#123; isTrue = b;&#125;public synchronized boolean read()&#123; return isTrue;&#125; 同样问两个问题： A a=new A(); 线程1访问a.write(false)方法，线程2能访问a.read()方法吗？A a=new A(); A b=new A();线程1访问a.write(false)方法，线程2能访问b.read()方法吗？ 答案: A a=new A(); 线程1访问a.write()方法，线程2能访问a.read()方法吗？不能，因为这两个方法的锁都是对象a，线程1拿到了锁，线程2就不能访问了。A a=new A(); A b=new A();线程1访问a.write()方法，线程2能访问b.read()方法吗？可以，因为线程1拿到的是锁是 a,而线程2访问b.read()需要的是锁是b。 http://ifeve.com/who-is-lock/ 类似的还有：123456pulbic class Something()&#123; public synchronized void isSyncA()&#123;&#125; public synchronized void isSyncB()&#123;&#125; public static synchronized void cSyncA()&#123;&#125; public static synchronized void cSyncB()&#123;&#125;&#125; 那么，加入有Something类的两个实例a与b，那么下列组方法何以被1个以上线程同时访问呢? a. x.isSyncA()与x.isSyncB()b. x.isSyncA()与y.isSyncA()c. x.cSyncA()与y.cSyncB()d. x.isSyncA()与Something.cSyncA() 这里，很清楚的可以判断：a，都是对同一个实例的synchronized域访问，因此不能被同时访问b，是针对不同实例的，因此可以同时被访问c，因为是static synchronized，所以不同实例之间仍然会被限制,相当于Something.isSyncA()与 Something.isSyncB()了，因此不能被同时访问。那么，第d呢?，书上的答案是可以被同时访问的，答案理由是synchronzied的是实例方法与synchronzied的类方法由于锁定(lock)不同的原因。个人分析也就是synchronized 与static synchronized 相当于两帮派，各自管各自，相互之间就无约束了，可以被同时访问。目前还不是分清楚java内部设计synchronzied是怎么样实现的。 结论：A: synchronized static是某个类的范围，synchronized static cSync{}防止多个线程同时访问这个 类中的synchronized static 方法。它可以对类的所有对象实例起作用。B: synchronized 是某实例的范围，synchronized isSync(){}防止多个线程同时访问这个实例中的synchronized 方法。 不管是 synchronized锁住的是谁，都不影响非synchronized的方法的访问！ synchronized方法与synchronized代码快的区别synchronized methods(){} 与synchronized(this){}之间没有什么区别，只是synchronized methods(){} 便于阅读理解，而synchronized(this){}可以更精确的控制冲突限制访问区域，有时候表现更高效率。 wait、notify、notifyAll我们知道JAVA每个对象(Object/class) 都关联一个监视器，更好的说法应该是每个对象(Object/class)都有一个监视器，对象可以有它自己的临界区，并且能够监视线程序列为了使线程协作。JAVA为提供了wait()和notifyAll以及notify()实现挂起线程，并且唤醒另外一个等待的线程。wait、notify、notifyAll必须写在synchronized方法中，即必须拥有该线程的对象监视器 wait会释放对象监视器，同时阻塞自己而notify、notifyAll会唤醒对象，但是即使wait被唤醒后，也不会立刻执行，因为首先要获得对象监视器notify随机唤醒一个notifyAll唤醒全部 a) 为什么线程通信的方法wait(), notify()和notifyAll()被定义在Object类里，而不是在Thread中？这是个设计相关的问题，它考察的是面试者对现有系统和一些普遍存在但看起来不合理的事物的看法。回答这些问题的时候，你要说明为什么把这些方法放在Object类里是有意义的，还有不把它放在Thread类里的原因。一个很明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，Java的每个对象中都有一个锁(monitor，也可以成为监视器) 并且wait()，notify()等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在Java的线程中并没有可供任何对象使用的锁和同步器。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。 b) 为什么wait(), notify()和notifyAll()必须在同步方法或者同步块中被调用？当一个线程需要调用对象的wait()方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的notify()方法。同样的，当一个线程需要调用对象的notify()方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。 http://www.blogjava.net/xylz/archive/2010/07/08/325587.htmlhttp://blog.csdn.net/ns_code/article/details/17539599 sleep()和wait()的区别这两个方法主要来源是，sleep用于线程控制，而wait用于线程间的通信，与wait配套的方法还有notify和notifyAll. 区别一：sleep是Thread类的方法，是线程用来 控制自身流程的，比如有一个要报时的线程，每一秒中打印出一个时间，那么我就需要在print方法前面加上一个sleep让自己每隔一秒执行一次。wait是Object类的方法，用来线程间的通信，这个方法会使当前拥有该对象锁的进程等待知道其他线程调用notify方法时再醒来，不过你也可以给他指定一个时间，自动醒来。这个方法主要是用走不同线程之间的调度的。 区别二 ：关于锁的释放,调用sleep方法不会释放锁(ownership of any monitors)。调用wait方法会释放当前线程的锁(其实线程间的通信是靠对象来管理的，所有操作一个对象的线程是这个对象通过自己的wait方法来管理的) 区别三：使用区域:wait函数应该放在同步语句块中的. 注意：两个方法都需要抛出异常 http://mp.weixin.qq.com/s/v1EiV4Gvq5ScF3YLK4DNGw ThreadLocalThreadLocal本意是123This class provides thread-local variables.These variables differ from their normal counterparts in that each thread that accesses one (via its &#123;@code get&#125; or &#123;@code set&#125; method) has its own, independently initialized copy of the variable. &#123;@code ThreadLocal&#125; instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID) ThreadLocal类用来提供线程内部的局部变量。这些变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量，ThreadLocal实例通常来说都是private static类型.ThreadLocal的主要应用场景为按线程多实例(每个线程对应一个实例)的对象的访问，并且这个对象很多地方都要用到。例如：同一个网站登录用户，每个用户服务器会为其开一个线程，每个线程中创建一个ThreadLocal，里面存用户基本信息等，在很多页面跳转时，会显示用户信息或者得到用户的一些信息等频繁操作，这样多线程之间并没有联系而且当前线程也可以及时获取想要的数据。 实现原理ThreadLocal可以看做是一个容器，容器里面存放着属于当前线程的变量。ThreadLocal类提供了四个对外开放的接口方法，这也是用户操作ThreadLocal类的基本方法：(1) void set(Object value)设置当前线程的线程局部变量的值。值得注意的是，set方法中设置的值应该是new出来的对象，而不是在外面new好的对象指针！(2) public Object get()该方法返回当前线程所对应的线程局部变量。(3) public void remove()将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。(4) protected Object initialValue()返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次，ThreadLocal中的缺省实现直接返回一个null。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** Returns the value in the current thread's copy of this thread-local variable. If the variable has no value for thecurrent thread, it is first initialized to the value returned by an invocation of the &#123;@link #initialValue&#125; method. @return the current thread's value of this thread-local */public T get() &#123; Thread t = Thread.currentThread();//当前线程 ThreadLocalMap map = getMap(t);//获取当前线程对应的ThreadLocalMap if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this);//获取对应ThreadLocal的变量值 if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();//若当前线程还未创建ThreadLocalMap，则返回调用此方法并在其中调用createMap方法进行创建并返回初始值。&#125;//设置变量的值public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125;/**为当前线程创建一个ThreadLocalMap的threadlocals,并将第一个值存入到当前map中@param t the current thread@param firstValue value for the initial entry of the map*/void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125;//删除当前线程中ThreadLocalMap对应的ThreadLocalpublic void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);&#125; 从线程Thread的角度来看，每个线程内部都会持有一个对ThreadLocalMap实例的引用ThreadLocals，ThreadLocalMap实例相当于线程的局部变量空间，存储着线程各自的数据。其实在ThreadLocal类中有一个静态内部类ThreadLocalMap(其类似于Map)，用键值对的形式存储每一个线程的变量副本，ThreadLocalMap中元素的key为当前ThreadLocal对象，而value对应线程的变量副本，每个线程可能存在多个ThreadLocal。 ThredLocal ThreadLocal类在维护变量时,实际使用了当前线程(Thread)中的一个叫做ThreadLocalMap的独立副本,每个线程可以独立修改属于自己的副本而不会互相影响,从而隔离了线程和线程,避免了线程访问实例变量发生冲突的问题.ThreadLocal本身并不是一个线程,而是通过操作当前线程(Thread)中的一个内部变量来达到与其他线程隔离的目的.之所以取名为ThreadLocal,所期望表达的含义是其操作的对象是线程(Thread)的一个本地变量1234567891011121314151617181920static class ThreadLocalMap &#123; //map中的每个节点Entry,其键key是ThreadLocal并且还是弱引用，这也导致了后续会产生内存泄漏问题的原因。 static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; /** * 初始化容量为16，以为对其扩充也必须是2的指数 */ private static final int INITIAL_CAPACITY = 16; // 真正用于存储线程的每个ThreadLocal的数组，将ThreadLocal和其对应的值包装为一个Entry。 private Entry[] table; ///....其他的方法和操作都和map的类似 &#125;&#125; ThreadLocalMap跟随着当前的线程而存在.不同的线程Thread,拥有不同的ThreadLocalMap的本地实例变量,这也就是“副本”的含义1234public class Thread implements Runnable &#123; // 这里省略了许多其他的代码 ThreadLocal.ThreadLocalMap threadLocals = null; &#125; 结论: ThreadLocalMap变量属于线程(Thread)的内部属性,不同的线程(Thread)拥有完全不同的ThreadLocalMap变量. 线程(Thread)中的ThreadLocalMap变量的值是在ThreadLocal对象进行set或者get操作时创建的. 在创建ThreadLocalMap之前,会首先检查当前线程(Thread)中的ThreadLocalMap变量是否已经存在,如果不存在则创建一个；如果已经存在,则使用当前线程(Thread)已创建的ThreadLocalMap. 使用当前线程(Thread)的ThreadLocalMap的关键在于使用当前的ThreadLocal的实例作为key进行存储ThreadLocal模式,至少从两个方面完成了数据访问隔离,有了横向和纵向的两种不同的隔离方式,ThreadLocal模式就能真正地做到线程安全：纵向隔离 —— 线程(Thread)与线程(Thread)之间的数据访问隔离.这一点由线程(Thread)的数据结构保证.因为每个线程(Thread)在进行对象访问时,访问的都是各自线程自己的ThreadLocalMap.横向隔离 —— 同一个线程中,不同的ThreadLocal实例操作的对象之间的相互隔离.这一点由ThreadLocalMap在存储时,采用当前ThreadLocal的实例作为key来保证 http://www.iteye.com/topic/1141743http://www.jianshu.com/p/33c5579ef44f 内存泄漏 每个thread中都存在一个map, map的类型是ThreadLocal.ThreadLocalMap.Map中的key为一个threadlocal实例. 这个Map的确使用了弱引用,不过弱引用只是针对key. 每个key都弱引用指向threadlocal. 当把threadlocal实例置为null以后,没有任何强引用指向threadlocal实例,所以threadlocal将会被gc回收.但是,我们的value却不能回收,因为存在一条从current thread连接过来的强引用. 只有当前thread结束以后, current thread就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收. http://www.cnblogs.com/onlywujun/p/3524675.htmlhttp://www.importnew.com/22039.htmlhttps://my.oschina.net/xianggao/blog/392440?fromerr=CLZtT4xC","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://duyao.github.io/tags/jvm/"}]},{"title":"java语法糖","slug":"java语法糖","date":"2017-02-24T06:08:13.000Z","updated":"2017-02-25T08:25:04.000Z","comments":true,"path":"2017/02/24/java语法糖/","link":"","permalink":"http://duyao.github.io/2017/02/24/java语法糖/","excerpt":"","text":"语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家Peter.J.Landin发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。Java中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。虚拟机并不支持这些语法，它们在编译阶段就被还原回了简单的基础语法结构，这个过程成为解语法糖。 泛型与泛型擦除泛型实际上只在程序源码中存在，在编译后的字节码文件中，就已经被替换为了原来的原生类型，并且在相应的地方插入了强制转型代码。因此对于运行期的Java语言来说，ArrayList和ArrayList就是同一个类。所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型被称为伪泛型。 12345678public class FanxingTest&#123; public void method(List&lt;String&gt; list)&#123; System.out.println(\"List String\"); &#125; public void method(List&lt;Integer&gt; list)&#123; System.out.println(\"List Int\"); &#125; &#125; 当我用Javac编译器编译这段代码时，报出了如下错误：1234567891011121314151617FanxingTest.java:3: 名称冲突：method(java.util.List&lt;java.lang.String&gt;) 和 method(java.util.List&lt;java.lang.Integer&gt;) 具有相同疑符 public void method(List&lt;String&gt; list)&#123; ^FanxingTest.java:6: 名称冲突：method(java.util.List&lt;java.lang.Integer&gt;) 和 method(java.util.List&lt;java.lang.String&gt;) 具有相同疑符 public void method(List&lt;Integer&gt; list)&#123; ^2 错误 这是因为泛型List和List编译后都被擦除了，变成了一样的原生类型List，擦除动作导致这两个方法的特征签名变得一模一样，在Class类文件结构一文中讲过，Class文件中不能存在特征签名相同的方法。 12345678910public class FanxingTest&#123; public int method(List&lt;String&gt; list)&#123; System.out.println(\"List String\"); return 1; &#125; public boolean method(List&lt;Integer&gt; list)&#123; System.out.println(\"List Int\"); return true; &#125; &#125; 修改后发现这时编译可以通过了（注意：Java语言中true和1没有关联，二者属于不同的类型，不能相互转换，不存在C语言中整数值非零即真的情况）。两个不同类型的返回值的加入，使得方法的重载成功了。 Java代码中的方法特征签名只包括了方法名称、参数顺序和参数类型，并不包括方法的返回值，因此方法的返回值并不参与重载方法的选择，这样看来为重载方法加入返回值貌似是多余的。对于重载方法的选择来说，这确实是多余的，但我们现在要解决的问题是让上述代码能通过编译，让两个重载方法能够合理地共存于同一个Class文件之中，这就要看字节码的方法特征签名，它不仅包括了Java代码中方法特征签名中所包含的那些信息，还包括方法返回值及受查异常表。为两个重载方法加入不同的返回值后，因为有了不同的字节码特征签名，它们便可以共存于一个Class文件之中。 注：（A）、Java语言层面的方法特征签名： 特征签名 = 方法名 + 参数类型 + 参数顺序；（B）、JVM层面的方法特征签名： 特征签名 = 方法名 + 参数类型 + 参数顺序 + 返回值类型； 自动装箱拆箱12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//装箱就是 自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。//主要是看等号左边的定义的类型public static void main(String[] args) &#123;// Integer i1 = 59;// int i2 = 59;// Integer i3 = Integer.valueOf(59);// Integer i4 = new Integer(59); Integer i1 = 111111; int i2 = 111111; Integer i3 = Integer.valueOf(111111); Integer i4 = new Integer(111111); //当为59时，1-3都是true //因为jvm对于小于1字节的以下的整数都会加载进内存，除非用new Integer()显示声明新建对象 //因此1-3都是指向同一个对象,因此12真，4假 //而3是对于int进行比较值的大小 //当为111111时，13true，24false //i3的valueof会先判断数字是都小于1字节(127)，若小于不产生新对象，大于127则产生新对象 System.out.println(i1 == i2); System.out.println(i1 == i3); //24和23何时都相等，因为2是int3是Integer，因为一个是基本类型，一个是封装类 System.out.println(i2 == i4); System.out.println(i3 == i4); System.out.println(i2 == i3); //无论何时14不等1与4是不同的对象，因为4被new，虽然他们都是integer System.out.println(i1 == i4); //Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。 /* public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; */ //Double、Float的valueOf方法的实现是类似的。 /* public static Double valueOf(double d) &#123; return new Double(d); &#125; */ Double d1 = 34.0; Double d2 = 34.0; System.out.println(\"d1 == d2 -&gt; \" + (d1 == d2)); //false //当 \"==\"运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象， //而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程） Long ll = 3l; int a = 1; int b = 2;// long b = 2; System.out.println(ll == (a + b)); //true //对于包装器类型，equals方法并不会进行类型转换,比较是否类型相同 System.out.println(ll.equals(a + b)); //b是int结果是false，b是long结果是true //byte运算 //加数是常量，先运算后赋值 //加数是变量，先转类型，再运算 byte b1=1,b2=2,b3,b6; final byte b4=4,b5=6; //b4b5是byte相加计算后升为int，而其实final，因此编译时就已经是10了 b6=b4+b5; //b1+b2计算时候提升为int，而b3是byte不是同一类型，会报错，需要强制转换// b3=(b1+b2);// System.out.println(b3+b6); System.out.println(b6); Byte b7 = 8+2; System.out.println(b7);&#125;","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://duyao.github.io/tags/jvm/"}]},{"title":"399. Evaluate Division","slug":"399-Evaluate-Division","date":"2017-02-23T13:51:51.000Z","updated":"2017-02-24T03:08:50.000Z","comments":true,"path":"2017/02/23/399-Evaluate-Division/","link":"","permalink":"http://duyao.github.io/2017/02/23/399-Evaluate-Division/","excerpt":"","text":"399. Evaluate Division递归的问题： 递归中的参数只在该层有效吗？返回失效？ 递归结束后是否应该加撤回语句","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"}]},{"title":"虚拟机执行","slug":"虚拟机执行","date":"2017-02-23T03:07:19.000Z","updated":"2017-04-25T06:47:06.000Z","comments":true,"path":"2017/02/23/虚拟机执行/","link":"","permalink":"http://duyao.github.io/2017/02/23/虚拟机执行/","excerpt":"","text":"一个程序需要先编译javac，然后才能够运行java。代码编译的结果是从本地机器码变为字节码，是存储格式发展的一小步，却是编程语言的一大步。java语言中，类型的加载、连接和初始化过程都是在运行期间完成的。源码(.java文件) -&gt; 编译(命令为javac xx.java，字节码文件，以.class结尾，与源码在同一目录下) -&gt; 运行(命令为java xx,这时候java虚拟机将会启动，执行编译好的文件) Class文件将java文件编译为*.class文件，然后虚拟机就可以识别其中的内容，从而完成程序的执行class文件是以8字节为基础单位的二进制流组成部分有 每个class文件的前4个字节成为魔数，作用是确定这个文件能否被虚拟所有接受，其值为0xCAFEBABE 常量池 类索引和接口索引 字段表、方法表和属性表 分析class文件的指令javap -verbose classnameclass文件是字节有序、大端存储的 大端法和小端法其实 big endian 是指低地址存放最高有效字节（ MSB ），而 little endian 则是低地址存放最低有效字节（ LSB ）。大弟高，小弟低所有网络协议也都是采用 big endian 的方式来传输数据的。所以有时我们也会把 big endian 方式称之为网络字节序。当两台采用不同字节序的主机通信时，在发送数据之前都必须经过字节序的转换成为网络字节序后再进行传输。12345低地址 高地址-----------------------------------------&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| 12 | 34 | 56 | 78 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ Little Endian12345低地址 高地址-----------------------------------------&gt;+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| 78 | 56 | 34 | 12 |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 字节码指令java虚拟机的指令是由一个字节长度的、操作数和参数而构成，又称作字节码指令。 类的加载虚拟机的加载机制是：虚拟机把描述类的数据从class文件加载到内存中，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类型 类的生命周期 在java语言中，类型的加载、连接和初始化都是在程序运行期间完成的，虽然这样会稍微增加性能开销，但是却为java程序提供了高度的灵活性。java可以扩展语言的特性就是依赖运行期动态加载和动态连接完成的。 加载加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情： 通过一个类的全限定名来获取其定义的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在方法区中生成一个代表这个类的 java.lang.Class 对象，作为对方法区中这些数据的访问入口 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在方法区中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。 注意：类加载(class loading)与加载(loading)是完全不同的概念 类的加载器类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。 站在Java虚拟机的角度来讲，只存在两种不同的类加载器： 启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分。 所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。 站在Java开发人员的角度来看，类加载器可以大致划分为以下三类： 启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在JDK\\jre\\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。 扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\\jre\\lib\\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。 应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。 双亲委派模型 双亲委派模型 这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上。因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是Java类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系，这对于保证Java程序的稳定运作很重要。因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，保证了Object类在程序中的各种类加载器中都是同一个类。 比如Tomcat服务器就是的类加载就是双亲委派模型 tomcat服务器的类加载架构 WebApp和Jsp加载器通常会对应多个实例，每个一个WebApp对应一个加载器，每个一个Jsp文件对应一个Jsp类加载器以 Apache Tomcat 来说，每个 Web 应用都有一个对应的类加载器实例。该类加载器也使用代理模式，所不同的是它是首先尝试去加载某个类，如果找不到再代理给父类加载器。这与一般类加载器的顺序是相反的。这是 Java Servlet 规范中的推荐做法，其目的是使得 Web 应用自己的类的优先级高于 Web 容器提供的类。这种代理模式的一个例外是：Java 核心库的类是不在查找范围之内的。这也是为了保证 Java 核心库的类型安全。 OSGI加载器的关系不再是双亲委派的树形结构，而是复杂的运行时才能确定的网状结构。 验证验证的目的是为了确保 Class 文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证： 文件格式的验证 元数据的验证 字节码验证 符号引用验证 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意： 这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。 这里所设置的初始值通常情况下是数据类型默认的零值(如 0、0L、null、false 等)，而不是被在 Java 代码中被显式地赋予的值。 final修饰的类变量会设置成所需要的值 解析解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。 1、类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。2、字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。 初始化初始化阶段是根据程序员制定的计划执行的，也就是初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程 何时初始化顺序静态代码块(静态变量和静态代码块) -&gt; main方法 -&gt; 构造代码块 -&gt; 构造方法都是先父后子的顺序 构造块：直接在类中定义且没有加static关键字的代码块称为{}构造代码块。构造代码块在创建对象时被调用，每次创建对象都会被调用，并且构造代码块的执行次序优先于类构造函数。 普通代码块：在方法或语句中出现的{}就称为普通代码块。普通代码块和一般的语句执行顺序由他们在代码中出现的次序决定–“先出现先执行” 静态代码块:在java中使用static关键字声明的代码块。静态块用于初始化类，为类的属性初始化。每个静态代码块只会执行一次。由于JVM在加载类时会执行静态代码块，所以静态代码块先于主方法执行。如果类中包含多个静态代码块，那么将按照”先定义的代码先执行，后定义的代码后执行”。注意：1 静态代码块不能存在于任何方法体内。2 静态代码块不能直接访问静态实例变量和实例方法，需要通过类的实例对象来访问。 12345678910111213141516171819202122232425262728293031323334353637383940414243class B extends Object&#123; &#123; System.out.println(\"构造块 B\"); &#125; static &#123; System.out.println(\"静态块 B\"); &#125; public B() &#123; System.out.println(\"构造方法 B\"); &#125; public static void main(String[] args) &#123; System.out.println(\"main B\"); &#125;&#125;class A extends B&#123; &#123; System.out.println(\"构造块 A\"); &#125; static &#123; System.out.println(\"静态块 A\"); &#125; public A() &#123; System.out.println(\"构造方法 A\"); &#125; public static void main(String[] args) &#123; System.out.println(\"main A\"); &#125;&#125; class Testclass&#123; public static void main(String[] args) &#123; new A(); &#125;&#125; 结果：静态块 B静态块 A构造块 B构造方法 B构造块 A构造方法 A http://www.cnblogs.com/sophine/p/3531282.htmlhttp://blog.csdn.net/owenchan1987/article/details/52879774 条件 遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的Java代码场景是： 使用new关键字实例化对象时 读取或设置一个类的静态字段（static）时（被static修饰又被final修饰的，已在编译期把结果放入常量池的静态字段除外） 调用一个类的静态方法时 使用Java.lang.refect包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先执行该主类。 这几种场景被称为是主动引用，，而其余引用成为被动引用，被动引用是不会出发初始化的 例子 子类引用父类中定义的静态字段，只会触发父类的初始化，而不会触发子类的初始化 123456789101112131415161718class Father&#123; public static int m = 33; static&#123; System.out.println(&quot;父类被初始化&quot;); &#125; &#125; class Child extends Father&#123; static&#123; System.out.println(&quot;子类被初始化&quot;); &#125; &#125; public class StaticTest&#123; public static void main(String[] args)&#123; System.out.println(Child.m); &#125; &#125; 结果输出12父类被初始化33 对于静态字段，只有直接定义这个字段的类才会被初始化。因此对于子类引用父类中定义的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 通过数组来定义引用类，不会触发此类的初始化 1234567891011class MyArray&#123; static&#123; System.out.println(&quot;初始化MyArray类&quot;); &#125; &#125; public class ArrayTest&#123; public static void main(String[] args)&#123; MyArray[] myArray = new MyArray[5]; &#125; &#125; 结果没有输出初始化MyArray类通过数组来定义引用类，不会触发此类的初始化 常量的引用不会触发定义常量的类的初始化 123456789101112class ConstClass&#123; public static final String NAME = &quot;我是常量&quot;; static&#123; System.out.println(&quot;初始化ConstClass类&quot;); &#125; &#125; public class Test&#123; public static void main(String[] args)&#123; System.out.println(ConstClass.NAME); &#125; &#125; 结果并没有输出初始化ConstClass类常量在编译阶段会存入常量池中，本质上没有直接引用到定义常量的类，因此常量的引用不会触发定义常量的类的初始化 类构造器&lt;clinit&gt;()初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的 Java 程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。 &lt;clinit&gt;()方法是由编译器自动收集所有类变量的赋值动作和静态语句块中的语句合并产生的，收集的顺序是语句在源文件出现的顺序。即在静态语句块只能访问在块前的变量，而块后的变量只能复制不能访问 1234567public class Test()&#123; static&#123; i = 0; // 编译通过 System.out.println(i); //编译出错，非法向前引用 &#125; static int i = 1;&#125; &lt;clinit&gt;()与类的构造函数不同，他不需要显示调用父类构造器，虚拟机会保证在子类的&lt;clinit&gt;()方法执行之前，父类的&lt;clinit&gt;()方法已经执行完毕。因此虚拟机中第一个被执行的&lt;clinit&gt;()方法一定是java.lang.Object 由于父类的&lt;clinit&gt;()会先执行，因此父类的静态语句块会比子类先执行 123456789101112static class Parent&#123; public static int A = 1; static&#123; A = 2; &#125;&#125;static class Sub extends Parent&#123; public static int B = A;&#125;public static void main(String[] args)&#123; System.out.println(Sub.B);&#125; 结果是2 &lt;clinit&gt;()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法 接口中不能使用静态语句块，但仍然有类变量(final static)初始化的赋值操作，因此接口与类一样会生成&lt;clinit&gt;()方法。但是接口与类不同的是：执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit&gt;()方法。 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕。如果在一个类的&lt;clinit&gt;()方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。 jvm启动后创建的线程 Attach Listener Finalizer Signal Dispatcher Reference Handler main 程序所在的线程 Attach Listener ：线程是负责接收到外部的命令，而对该命令进行执行的并且吧结果返回给发送者。通常我们会用一些命令去要求jvm给我们一些反馈信息，如：java -version、jmap、jstack等等。如果该线程在jvm启动的时候没有初始化，那么，则会在用户第一次执行jvm命令时，得到启动。signal dispather： 前面我们提到第一个Attach Listener线程的职责是接收外部jvm命令，当命令接收成功后，会交给signal dispather线程去进行分发到各个不同的模块处理命令，并且返回处理结果。signal dispather线程也是在第一次接收外部jvm命令时，进行初始化工作。Finalizer： 用来执行所有用户Finalizer 方法的线程Reference Handler ：它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题。http://supben.iteye.com/blog/2267828 分派调用方法调用不等同于方法执行，方法调用只是用来确定执行方法的哪个版本，不涉及到内部运行。一切方法调用在class文件中存储的只是符号引用。在类的解析阶段，会将一部分符号引用转化为直接引用，前提是运行之前就可以知道调用的版本，并且版本在运行期间不可变。符合这样的方法主要有：静态方法、私有方法、实例构造器、父方法。他们在类加载的过程中会将符号引用转化为直接引用。其中实例方法构造是&lt;init&gt;方法，对JVM来说所有实例初始化动作都要收集到“特殊的实例初始化方法”（名为&lt;init&gt;，内容对应所有实例初始化器+构造器）里，所以上面的代码从JVM的角度看会是这样：这个合成的&lt;init&gt;()V里，先是构造器里隐式或显式的super()调用，然后是按代码顺序把实例初始化动作（包括实例字段初始化与匿名的实例初始化器）收集起来，然后是构造器自身的内容。https://www.zhihu.com/question/36643366/answer/68519999 方法分派分派指的是在Java中对方法的调用。Java中有三大特性：封装、继承和多态。分派是多态性的体现，Java虚拟机底层提供了我们开发中“重写”和“重载”的底层实现。其中重载属于静态分派，而重写则是动态分派的过程。除了使用分派的方式对方法进行调用之外，还可以使用解析调用，解析调用是在编译期间就已经确定了，在类装载的解析阶段就会把符号引用转化为直接引用，不会延迟到运行期间再去完成。而分派调用则可能是静态的也可能是动态的，根据分派依据的宗量数（方法的调用者和方法的参数统称为方法的宗量）又可分为单分派和多分派。两类分派方式两两组合便构成了静态单分派、静态多分派、动态单分派、动态多分派四种分派情况。 Java语言（JDK1.6）是一门静态(编译)多分派(重载)、动态(运行)单分派(重写) 的语言 静态分派 静态分派的最典型应用就是多态性中的方法重载Overload 静态分派发生在编译阶段，因此确定静态分配的动作实际上不是由虚拟机来执行的 因此，在重载的时候是通过参数的静态类型而不是实际类型作为判断依据的 123456789101112131415161718192021222324252627class Human&#123; &#125; class Man extends Human&#123; &#125; class Woman extends Human&#123; &#125; public class StaticPai&#123; public void say(Human hum)&#123; System.out.println(\"I am human\"); &#125; public void say(Man hum)&#123; System.out.println(\"I am man\"); &#125; public void say(Woman hum)&#123; System.out.println(\"I am woman\"); &#125; public static void main(String[] args)&#123; Human man = new Man(); Human woman = new Woman(); StaticPai sp = new StaticPai(); sp.say(man); sp.say(woman); &#125; &#125; 上面代码的执行结果如下12I am humanI am human 动态分派 动态分派的一个最直接的例子是重写Override 在运行期根据实际类型确定方法执行版本的分派过程称为动态分派 12345678910111213141516171819202122232425262728293031class Eat&#123; &#125; class Drink&#123; &#125; class Father&#123; public void doSomething(Eat arg)&#123; System.out.println(\"爸爸在吃饭\"); &#125; public void doSomething(Drink arg)&#123; System.out.println(\"爸爸在喝水\"); &#125; &#125; class Child extends Father&#123; public void doSomething(Eat arg)&#123; System.out.println(\"儿子在吃饭\"); &#125; public void doSomething(Drink arg)&#123; System.out.println(\"儿子在喝水\"); &#125; &#125; public class SingleDoublePai&#123; public static void main(String[] args)&#123; Father father = new Father(); Father child = new Child(); father.doSomething(new Eat()); child.doSomething(new Drink()); &#125; &#125; 运行结果应该很容易预测到，如下：12爸爸在吃饭儿子在喝水 我们首先来看编译阶段编译器的选择过程，即静态分派过程。这时候选择目标方法的依据有两点：一是方法的接受者（即调用者）的静态类型是Father还是Child，二是方法参数类型是Eat还是Drink。因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。再来看运行阶段虚拟机的选择，即动态分派过程。由于编译期已经了确定了目标方法的参数类型（编译期根据参数的静态类型进行静态分派），因此唯一可以影响到虚拟机选择的因素只有此方法的接受者的实际类型是Father还是Child。因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。 字节码执行相关栈帧是虚拟机进行方法调用和方法执行的数据结构，是虚拟机的栈元素。每一个栈帧都包含了局部变量表、操作数栈、动态连接、方法返回地址和一些额外信息。 对于每一个线程来说都有自己的程序计数器和栈线程中的每个方法对应着栈中的一个栈桢一个栈有多个栈桢，每个栈帧里有局部变量表，操作数栈等 局部变量表用于存放方法参数和方法内部定义的局部变量表。局部变量表以slot为单位，一个slot可以存放32位的数据，而long、double需要2个slot但是由于局部变量表是建立在栈中的，是线程私有的，是原子操作，因此不存在数据安全问题 类变量是有2次赋值机会的，一次是准备阶段，为系统值；另一次是初始化阶段，为程序员定义的值而局部变量就不一样了，如果一个局部变量定义了，而没有赋值，是不能使用的，不能编译通过的。 局部变量：在栈中，每个方法一个，无默认值，必须赋值成员变量：在堆中，每个实例一个,在init&lt;&gt;中初始化,有默认值类变量：在方法区，每个类一个,在类中用static修饰，有默认值12345678910111213141516171819202122232425class Test &#123; //类变量 static int i; //成员变量 int a; public void fun() &#123; //局部变量 int x; // System.out.println(x); System.out.println(\"成员变量：a=\"+a); &#125; public static void main(String[] args) &#123; //成员变量 int ii; //System.out.println(\"ii=\"+ii);// System.out.println(a); System.out.println(\"类变量：i=\" + i); Test t = new Test(); t.fun(); System.out.println(\"成员变量：\"+t.a); &#125;&#125; http://blog.csdn.net/du_minchao/article/details/48881637 操作数栈为什么局部变量是线程安全的？每一个线程都有自己的stack，线程中的方法对应着该栈的栈帧，而该方法所以定义的局部变量是保存在该栈帧中的。栈帧中包含着局部变量表和操作数栈等，这些都是私有的，当当方法执行结束，栈帧就会被销毁pop。如果这些局部变量是基本类型，那么一定是线程安全的。如果是对象，该对象存在堆里，那么就不一定了。http://stackoverflow.com/questions/12825847/why-are-local-variables-thread-safe-in-javahttp://stackoverflow.com/questions/4251282/java-threads-variables-local-to-the-thread?rq=1 编译器相关前端编译器：将java代码转化为字节码的编译器。主要工作有：词法分析、语法分析、注解器、语义分析(检查、解语法糖)和字节码生成 后端运行期编译器JIT：将字节码转化为机器码的过程 JVM即时编译器JIT即时编译器（Just In Time Compiler) 简称JITJAVA程序最初是通过解释器（Interpreter）进行解释执行的，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。为了提高热点代码的执行效率，就会将这些“热点代码”编译成与本地机器相关的机器码，进行各个层次的优化。 完成这个任务的编译器就是即时编译器（JIT）。 即时编译器的性能好坏，代码的优化程度高低是衡量一款商用虚拟机优秀与否的最关键指标之一，它是虚拟机最核心最能体现技术水平的部分。 JVM的两款即时编译器JITJVM中默认内置了两款即时编译器，称为Client Compiler和Server Compiler。可以用指定参数的方式，指定采用Client模式和Server模式。默认是mixed模式。 java –Xint 解析 java –Xcomp 编译解析器与编译器并存：1、当程序需要迅速启动和执行的时候，解析器首先发挥作用，省去编译的时间，立即执行。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。2、当机器内存限制比较大，可以用解析方式节约内存，反之可以用编译提升效率。3、解析器还可以作为编译器的“逃生门”。当例如加载了新类后类型结构发生变化，可以采用逆优化，退回到解析状态继续执行。 优化技术程序员都有一个共识：以编译方式执行本地代码比解释方式更快即时编译器产生的本地代码会比javac产生的字节码更优秀虚拟机团队在即时编译上做了很多优化 公共子式表达式消除：如果一个表达式已经计算过，未发生变化，那么就不需要重复计算，成为公共子式 数组范围检查消除 方法内联：将目标方法的代码复制到发起调用的方法之中，避免真实的调用发生。 逃逸分析：逃逸分析的基本行为即使分析对象动态作用域，如果它能被其他方法所引用，则称为方法逃逸；如果被赋值给其他线程的实例变量等，则称为线程逃逸。如果能证明一个对象不会逃逸到方法或者线程之外，就会做一些优化，比如：栈上分配(减小gc)、同步消除(锁消除)、标量替换(不创建对象而创建基本类型标量)等。 Client Compiler和Server CompilerClient Compiler和Server Compiler会实现分层编译（JDK 1.7默认有）。第0层 程序解析执行，解析器不开启性能监控，可触发第一层编译。第1层 编译成本地相关代码，进行简单优化第2层 除编译成本地相关代码外，还进行成编译耗时较长的优化。Client Compiler获得更高的编译速度 Server Compiler获得更好的编译质量，无须承担性能监控的任务","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://duyao.github.io/tags/jvm/"}]},{"title":"java内存区域","slug":"java内存区域","date":"2017-02-22T01:31:32.000Z","updated":"2017-04-21T08:01:44.000Z","comments":true,"path":"2017/02/22/java内存区域/","link":"","permalink":"http://duyao.github.io/2017/02/22/java内存区域/","excerpt":"","text":"简介在一台物理机中，内存可以分为物理内存和虚拟内存(Linux中swap的空间活跃度反应着物理内存)而对于内存的使用是由该机器的操作系统完成，因此有可以划分为内核空间和用户空间。在java中，需要向操作系统申请内存的主要有：java堆、线程、类和类加载器、NIO、JNI(native memory) java内存分配java虚拟机运行时数据区主要分为5个部分：方法区(常量池)、堆、虚拟机栈、本地方法栈和程序计数器隔离vpn，方法堆共享(vpn指的是v虚拟机栈virtual machine stack,p指的是program counter register程序计数器，n指的是本地方法栈native methid stack) 程序计数器Program Counter Register不共享，用来记录当前线程所执行的字节码行号，每个线程都有自己的程序计数器 java虚拟机栈 Java Virtual Machine Stack线程私有，与线程生命周期相同，存放基本类型和对象引用其内部存放java方法的内存模型，每一个线程的执行都会创建一个栈，而线程内部每个方法执行的时候都会创建一个栈帧stack frame，方法完成时就会将该栈帧移除。栈帧中有局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中。因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。栈帧的入栈出栈过程对应着方法的执行与完成 本地方法栈 Native Method Stackjava虚拟机栈为java方法（字节码）服务，本地方法栈为虚拟机使用到的Native方法服务 Java堆 Heap共享，存放着对象实例和数组，都是非静态属性，是垃圾回收的主要区域所有的对象实例都会在堆上分配。这句话随着逃逸分析技术的成熟变得不是那么绝对了。逃逸分析就是分析一个实例是否会被其他对象拥有甚至改变，如果没有，说明这个对象是私有的，那么为了减小gc压力，完全可以放在堆上分配。java堆可以划分为新生代和老年代，新生代还可以划分为eden、from survivor、to survivor。java堆是物理上不连续的内存空间，只要是逻辑上连续即可，就像磁盘空间。 方法区Method Area共享，用于存放class的相关信息，存放“类”被加载后的信息，常量，静态变量其中包含运行时常量池，具有动态性，运行期间也可能有新的常量放入池中，比如String类的intern()方法和大量产生class文件的应用，比如CGLib字节码增强技术，Jsp文件的应用(Jsp第一次运行时需要便以为java类)、基于OSGI的应用 直接内存javaNIO通过通道与缓冲区的方法分配使用 对象的创建过程1、 遇到new指令，先去常量池定位这个类的引用，如果没有加载过，就执行类的加载过程2、 类加载检查完成后，为新生对象分配内存，这个大小是在加载过程中就可以确定的3、 虚拟机对对象进行必要的设置，即gc分代年龄、锁、元数据等信息放在对象头中。HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。 HotSpot虚拟机的对象头(Object Header)包括两部分信息：第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂 不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。对象头的另外一部分是类型指针，即是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说查找对象的元数据信息并不一定要经过对象本身。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。 实例数据：是对象真正存储的有效信息。包括原生类型（primitive type）和对象引用（reference）。对齐填充：Java对象占用空间是8字节对齐的，即所有Java对象占用bytes数必须是8的倍数。 从上面可以看出每个对象的对象头都存放着锁的信息，在堆中。在运行期间java对象头里Mark Word里存储的数据会随着锁标志位的变化而变化。 4、 执行init方法，按照程序意愿执行-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 对象实例化分析对内存分配情况分析最常见的示例便是对象实例化:1Object obj = new Object(); 这段代码的执行会涉及java栈、Java堆、方法区三个最重要的内存区域。 obj会作为引用类型（reference）的数据保存在Java栈的本地变量表中 Java堆中保存该引用的实例化对象 Java堆中还必须包含能查找到此对象类型数据的地址信息（如对象类型、父类、实现的接口、方法等） 这些对象类型数据则保存在方法区中。 可以看出，一个对象的建立，会在堆和栈都分配空间在堆中分配的内存实际建立对象，而栈中分配的内存只是一个指向这个堆对象的指针。 另外，由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄池和直接使用指针。 通过句柄池访问的方式如下： 句柄池访问 通过直接指针访问的方式如下： 直接指针访问 java调优参数-Xmx:MaxHeapSize堆内存最大的大小-Xms:InitialHeapSize堆内存初始大小-Xss:设置每个线程的堆栈大小-Xmn:新生代的大小-SuriviorRatio:新生代中Eden与Surivior的比值比如Eden：Survivor=3，Survivor区有两个，即将年轻代分为5份，每个Survivor区占一份-XX:PretenureSizeThreshold：大于这个数值大小的对象直接在老年代分配-XX:MaxPermSize:永久代的最大值 垃圾回收对象已死吗在垃圾回收前，要判断对象是否已经死去 引用计数法引用计数法很难解决相互循环引用的问题比如obja = ojbb,objb =ojba他们互相引用，但是却再也没有其他对象引用他们 可达性分析算法该方法用了从GC Roots作为起点，向下搜索，这样走过的路径叫做引用链当一个对象到达RCRoots没有引用链的时候，证明这个对象不可用通常GCRoots有 虚拟机栈中本地变量表 方法区中常量引用对象 方法区中静态类引用对象 本地方法栈中引用对象 引用 强引用类似于Object obj = new Object()，只要强引用还在就不会被回收 软引用有用但是非必须，发生系统内存溢出之前，会列入垃圾回收 弱引用非必须对象，只能活到下一次回收前 虚拟引用无法通过虚拟引用获得一个对象设置幽灵引用目的是对象回收时会得到系统通知 finalize()在可达性分析之后，一个对象不是被被宣判死刑，而是死缓宣告一个对象死亡要经过至少两次标记1、 可达性分析，发现没有与GCRoots链接，标记2、 执行过finalize()方法后，标记被第一次标记后，还可以在finalize方法中重新建立与其他对象的联系，这就可以逃逸了值得注意的是finalize方法只能被执行一次 垃圾收集算法标记清除Mask-Sweep 标记清除Mask-Sweep 不足：效率低和产生大量不连续内存碎片 复制算法Copying 复制算法Copying 将内存分为两块，每次只使用其中的一块，这一块使用完了，就将存活的对象复制到另一块上面去代价是将内存减半，同时如果对象存活率高，就要进行多次复制现代的虚拟机用这种算法回收新生代将一个内存分为较大的Eden和两个较小的Survovor区每次使用Eden和其中一块Survior，回收时，将存活对象复制到另一个Survior区，最后清理Eden和用过的SurviorHotSpot默认的Eden和Survior比例为8:1 标记整理法Mask-Compact 标记整理法Mask-Compact 过程与标记清除一样，但是后续不是清理而是移动存活对象，然后清理掉端边界以外的对象 分代收集算法把java堆分为新生代Young和老年代Old 将新生代Young分为较大的Eden和两个较小的Survovor区，新创建的对象一定都在eden中每次使用Eden和其中一块Survior，当Eden空间不足触发minor GC，就会将存活对象复制到另一个Survior区，最后清理Eden和用过的Survior，保证始终都有一个Surivior区是空的HotSpot默认的Eden和Survior比例为8:1 老年代Old存放的是新生代的Survovor区满后触发minor GC仍然存活的对象。当Eden区满后会将对象存放到Survivor区，如果Survivor区仍然存不下这些对象时，GC收集器会将这些对象放大Old区。如果Old也满了就会出发Full GC，回收整个堆内存。 方法区中被称为是永久区Perm永久区主要存放的是Class的类对象。如果一个类被频繁加载，很可能会导致Perm区满。Perm的垃圾回收是有Full GC触发的。 新生代每次有大量对象死去，所以用复制法老年代存活率高，用标记清除或者标记整理 垃圾收集器 垃圾收集器 连线表示可以配合使用 对比 收集器 特点 场景 其他 Serial 单线程 新生代 经常在用在Client模式下 ParNew 并行parallel 新生代 多线程版的Serial，复制算法 Parellel Scavenge 并行parallel 新生代 关注吞吐量，复制算法 Serial Old 单线程 老年代 多线程版的Serial，标记整理 Parellel Old 并行parallel 老年代 多线程版的Serial，标记整理 CMS 并发concurrent 老年代 目标是获得最短回收停顿，标记清除MS G1 p&amp;C 新生代&amp;老年代 新一代收集器，将堆划分为独立区域 并发concurrent的关键是你有处理多个任务的能力，不一定要同时。并行parallel的关键是你有同时处理多个任务的能力。 GC分类 Minor GC 新生代当Eden区满时，触发Minor GC。因为大多数对象是朝生熄灭，所以Minor GC很频繁，而且速度很快 Major GC / Full GC 老年代发生在老年代的动作，出现Major GC，至少会伴随一次Minor GC，且速度比Minor GC慢10倍（1）调用System.gc时，系统建议执行Full GC，但是不必然执行（2）老年代空间不足（3）方法区空间不足（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存（5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小 内存分配对象优先分配在Eden新生代大对象直接进入老年代比如很长的字符串和数组 长期存活的对象将进入老年代 适用对象年龄计数器，每经过一次Minor GC年龄增加，到达一定的阈值(15)转为老年代 动态设定年龄的阈值，相同年龄的占一半就动态改变 性能分析工具 jps显示所有虚拟机线程 jstat虚拟机各方面数据 jinfo虚拟机配置信息 jmap内存快照 jstack线程快照 jconsole 可视化工具 VisualVM插件需要下载 调优经验https://www.ibm.com/developerworks/cn/java/j-lo-jvm-optimize-experience/index.html 一些问题内存溢出和内存泄漏内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。其实说白了就是该内存空间使用完毕之后未回收。典型的内存泄漏比如我们自己用数组实现一个stack，当pop出去后http://www.importnew.com/12961.htmlhttps://www.ibm.com/support/knowledgecenter/en/SSEQTP_9.0.0/com.ibm.websphere.base.doc/ae/ctrb_memleakdetection.html上面的代码实现了一个栈（先进后出（FILO））结构，乍看之下似乎没有什么明显的问题，它甚至可以通过你编写的各种单元测试。然而其中的pop方法却存在内存泄露的问题，当我们用pop方法弹出栈中的对象时，该对象不会被当作垃圾回收，即使使用栈的程序不再引用这些对象，因为栈内部维护着对这些对象的过期引用（obsolete reference）。在支持垃圾回收的语言中，内存泄露是很隐蔽的，这种内存泄露其实就是无意识的对象保持。如果一个对象引用被无意识的保留起来了，那么垃圾回收器不会处理这个对象，也不会处理该对象引用的其他对象，即使这样的对象只有少数几个，也可能会导致很多的对象被排除在垃圾回收之外，从而对性能造成重大影响，极端情况下会引发Disk Paging（物理内存与硬盘的虚拟内存交换数据），甚至造成OutOfMemoryError。http://blog.csdn.net/jackfrued/article/details/44921941","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://duyao.github.io/tags/jvm/"}]},{"title":"图及其相关","slug":"图及其相关","date":"2017-02-21T12:22:23.000Z","updated":"2017-05-04T02:59:18.000Z","comments":true,"path":"2017/02/21/图及其相关/","link":"","permalink":"http://duyao.github.io/2017/02/21/图及其相关/","excerpt":"","text":"术语 完全图任何 两个顶点都有边 数量关系n表示顶点数量，e表示边的数量，无向图中的e为[0, n(n-1)/2]有向图中的e为[0, n(n-1)/2]图中所有的顶点度数之和(出度+入度)为2*e 简单路径、简单回路一条路径中，除了起点和终点外，若其余顶点各不相同，则称改路径为简单路径；由简单路径构成的回路成为简单回路 连通图、强连通图无向图中，如果任意两个顶点都可以互相到达，则称为连通，图中的任意两点都连通为连通图，其极大连通子图成为连通分量有向图中，如果任意两个顶点都有路径，则称为强连通，图中任意两个点都强连通则为强连通图，其极大连通子图成为强连通分量 生成树一个含有n个顶点的的连通图的生成树是一个极小连通子图，它含有图中的全部顶点，，但有且只有足以构成一棵树的n-1条边生成树上添加1条边必定构成一个环有n-1条边的不一定是生成树一个图的生成树不唯一 AOV网：结点表示活动的网； AOE网：边表示活动的持续时间的网； 图的表示 邻接矩阵无向图一定是对称的，有向图不一定对称int [][]二维数组 邻接表 List&lt;List&lt;Node&gt;&gt; 图的遍历 DFS 12345678910111213141516DFS(u)&#123;//访问顶点u vis[u] = true; for(u能到达的所有顶点v)&#123; if(vis[v] == false)&#123; DFS[v]; &#125; &#125;&#125;DFSTrave(G)&#123;//遍历图G for(G的所有顶点u)&#123; if(vis[u] == false)&#123; DFS(u); &#125; &#125;&#125; BFS 1234567891011121314151617181920BFS(u)&#123; while(q 不为空)&#123;//q为队列,LinkedList u = q.remove();//取出头结点 for(u出发可以到达的所有顶点v)&#123; if(inq(v) == false)&#123;//没有入过队列 q.add(v);//v入队 inq[v] = true;//已经入队列 &#125; &#125; &#125;&#125;BFSTrave(G)&#123; for(G的所有顶点u)&#123; if(inq[u] == false)&#123; Queue&lt;&gt; q = new LinkedList&lt;&gt;();//产生队列 BFS(u);//访问 inq[u] = true;//标记进队 &#125; &#125;&#125; 最短路径 单源最短路径Dij123456789101112131415161718192021//d为源点到每个点的最短距离记录，s为起点//pre为最短路径的记录顺序,pre[v] = u表示v的前驱结点是uDij(G, d[], s,pre[])&#123; 初始化; for(循环n次)&#123; u= 使得d[u]最小且没有被访问的节点;//这里可以用priorityQueue等 标记u访问过; for(u 能到达的所有点v)&#123; if(v未访问 &amp;&amp; 以u为中介点使得s到v的距离更短)&#123; 优化d[v]; pre[v] = u;//记录最短路径 &#125; /* else(距离相等)&#123; 其他标尺 &#125; */ &#125; &#125;&#125; Dij+DFS：很可能在求最短路径的时候不止有一条，因此最短路径得到顺序pre后，还可以用dfs得到权值最小的路径 全源最短路径Floyd3层遍历,枚举节点k123456789for(int k = 0; k &lt; n; k++)&#123; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(d[i][k] + d[k][j] &lt; d[i][j])&#123; d[i][j] = d[i][k] + d[k][j]; &#125; &#125; &#125;&#125; 最小生成树MST 性质1.只在无向图中有2.最小生成树是树，边数 = 点数 - 1,且一定无环3.最小生成树不一定唯一，但是其边权之和一定唯一 Prim算法思想和Dij相似，但是Prim是一个集合的最小距离，而Dij到一个点的最小距离 12345678910111213141516//d为源点到每个点的最短距离记录，s为起点//pre为最短路径的记录顺序,pre[v] = u表示v的前驱结点是uint Prim(G, d[], s)&#123; int ans = 0;//初始化 for(循环n次)&#123; u= 使得d[u]最小且没有被访问的节点;//这里可以用priorityQueue等 标记u访问过; ans += d[u]; for(u 能到达的所有点v)&#123; if(v未访问 &amp;&amp; 以u为中介点使得已选中的集合到v的距离更短)&#123; 优化d[v]; &#125; &#125; &#125; return ans;&#125; Kruskal对边排序，然后选择最小的，合并到一起使用了并查集和排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class Kruskal &#123; //点数 int numv = 100; ArrayList&lt;Edge&gt; edges = new ArrayList&lt;&gt;(); int father[] = new int[numv]; //并查集 public int findfather(int x)&#123; int a = x; while(x != father[x])&#123; x = father[x]; &#125; //路径压缩,放置树太高，影响查找效率 while(a != father[a])&#123; int z = a; a = father[a]; father[z] = a; &#125; return x; &#125; public int Kru(int v, int e)&#123; //最小生成树的权值 int ans = 0; //生成树的边数 int vis = 0; //初始化并查集 for (int i = 0; i &lt; v; i++) &#123; father[i] = i; &#125; //对边的权值进行排序 Collections.sort(edges); for(int i = 0; i &lt; e; i++)&#123; int uu = edges.get(i).u; int vv = edges.get(i).v; //查看vv和uu是不是在同一个集合中 int fau = findfather(uu); int fav = findfather(vv); if(fau != fav)&#123; //加入到集合中去 father[fau] = fav; //生成树权值增加 ans += edges.get(i).cost; //生成树边数增加 vis++; //生成树的边数为n-1，结束生成树查找 if(vis == v - 1)&#123; break; &#125; &#125; &#125; if(vis == v - 1)&#123; //返回生成树权值 return ans; &#125;else&#123; //不能生成生成树 return -1; &#125; &#125;&#125;class Edge implements Comparable&lt;Edge&gt;&#123; int u,v; int cost; @Override public int compareTo(Edge o) &#123; return Integer.compare(o.cost, this.cost); &#125;&#125; 拓扑序列判断一个图是不是有向无环图准备所有顶点的入度数组1、定义一个队列，把所有入度为0的点加入队列中2、取出队首，对其所有相邻的边进行操作：将该边到达的点的入度减1，如果该点的入度为0，则加入到队列，删除这条边3、重复执行2直到队列为空，判断遍历过的点的数目是不是等于该图的节点数","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[]},{"title":"java知识点记录","slug":"java知识点记录","date":"2017-02-20T11:10:05.000Z","updated":"2017-04-25T14:42:16.000Z","comments":true,"path":"2017/02/20/java知识点记录/","link":"","permalink":"http://duyao.github.io/2017/02/20/java知识点记录/","excerpt":"","text":"类方法就是静态方法，方法内不能使用this关键字比较问题对于==号，如果两边是int型，则比较的数值如果两边是Integer，则比较的是地址如果一个是Integer，另一个是int，比较的是值，因为Integer会自动拆箱123456789101112131415161718192021Integer i1 = 59; //自动装箱，调用Integer.valueOf()，指向常量池中的59int i2 = 59;Integer i3 = Integer.valueOf(59); //Integer.valueOf()中，如果数字属于[-128,127]，那么不会产生新的对象，而是指向常量池中的59Integer i4 = new Integer(59); //有new关键字，一定会产生一个新的对象System.out.println(i1 == i3);//true，都会指向常量池中的59//12,24和23何时都相等，因为2是int,1和3、4是Integer，因为一个是基本类型，一个是封装类,比较的是数值System.out.println(i1 == i2);//trueSystem.out.println(i2 == i4);System.out.println(i2 == i3);//无论何时14不等1与4是不同的对象，因为4被new，虽然他们都是integerSystem.out.println(i1 == i4);//false//基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型int a = 1;int b =2;Integer c =3;System.out.println(c.equals(a+b));//true valueOf方法12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 加入byte1234567byte b1=1,b2=2,b3,b6,b8;final byte b4=4,b5=6,b7;b3=(b1+b2); /*语句1*/b6=b4+b5; /*语句2*/b8=(b1+b4); /*语句3*/b7=(b2+b5); /*语句4*/System.out.println(b3+b6); 这里只有语句1正确，因为右边都是final，所以编译时就是int了其余的语句因为是有变量的，所以int+byte=byte的，需要类型转换 list与array互相转化1234567public String[] toArray(List&lt;String&gt; list)&#123; String [] strings = new String[list.size()]; return list.toArray(strings);&#125;public List&lt;String&gt; toArray(String[] strings)&#123; return Arrays.asList(strings);&#125; 但是当list转化为int数组就不可以，因为list中是包装类，而返回时基本类型123456789public int[] toArray(List&lt;Integer&gt; list)&#123; int [] ints = new int[list.size()]; //ERROR: toArray (java.lang.Object[]) in List cannot be applied to (int[]) return list.toArray(ints); Integer [] ints = new Integer[list.size()]; //ERROR: toArray (T[]) in List cannot be applied to (Integer[]) return list.toArray(ints);&#125; 取反~-n = ~n + 1 负数的补码等于原码取反加一 enum枚举123456789101112131415enum AccountType&#123; SAVING, FIXED, CURRENT; private AccountType() &#123; System.out.println(“It is a account type”); &#125;&#125;class EnumOne&#123; public static void main(String[]args) &#123; System.out.println(AccountType.FIXED); &#125;&#125; 结果It is a account type It is a account type It is a account type FIXED每个枚举都是实例，在实例化的时候都要调用AAA的构造器,因此要打印3次 反射中，Class.forName和classloader的区别Java中class.forName()和classLoader都可用来对类进行加载。class.forName()除了将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块。而classLoader只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。Class.forName(name, initialize, loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象123456//Class.forName(String className) 这是1.8的源码 public static Class&lt;?&gt; forName(String className) throws ClassNotFoundException &#123; Class&lt;?&gt; caller = Reflection.getCallerClass(); return forName0(className, true, ClassLoader.getClassLoader(caller), caller); &#125; //注意第二个参数，是指Class被loading后是不是必须被初始化。 不初始化就是不执行static的代码即静态代码 LoadClass（）方法加载类及初始化过程：类加载（loadclass（））（加载）——》newInstance（）（链接+初始化）newInstance（）:（开始连接）静态代码块——》普通变量分配准备（a=0;b=0;c=null）——》（开始初始化）普通变量赋值（a=1;b=2;c=”haha”）——》构造方法——》初始化成功。 Class.forName(Stirng className)一个参数方法加载类及初始化过程：类加载(Class.forName())（加载）——》静态代码块——》newInstance（）（链接+初始化） newInstance（）：（开始连接）普通变量分配准备（a=0;b=0;c=null）——》（开始初始化）普通变量赋值（a=1;b=2;c=”haha”）——》构造方法——》初始化成功。 继承问题在调用子类构造器之前，会先调用父类构造器 当子类构造器中没有使用”super(参数或无参数)”指定调用父类构造器时，是默认调用父类的无参构造器，如果父类中包含有参构造器，却没有无参构造器，则在子类构造器中一定要使用“super(参数)”指定调用父类的有参构造器，不然就会报错。https://www.nowcoder.com/questionTerminal/af8cf04602e045958d13d16d20a1bf021234567891011121314151617181920212223242526272829303132333435class Test &#123; public static void main(String [] args)&#123; System.out.println(new B().getValue()); &#125; static class A&#123; protected int value; public A(int v) &#123; setValue(v); &#125; public void setValue(int value)&#123; this.value = value; &#125; public int getValue()&#123; try&#123; value++; return value; &#125; catch(Exception e)&#123; System.out.println(e.toString()); &#125; finally &#123; this.setValue(value); System.out.println(value); &#125; return value; &#125; &#125; static class B extends A&#123; public B() &#123; super(5); setValue(getValue() - 3); &#125; public void setValue(int value)&#123; super.setValue(2 * value); &#125; &#125;&#125; 这里执行setValue是调用b的而不是a的，因为这里是new b Statement、PreparedStatement和CallableStatement 接口 推荐使用 Statement 使用通用访问数据库。当在运行时使用静态SQL语句。 Statement接口不能接受的参数。 PreparedStatement 当计划多次使用SQL语句。 那么可以PreparedStatement接口接收在运行时输入参数。 CallableStatement 当要访问数据库中的存储过程中使用。 CallableStatement对象的接口还可以接受运行时输入参数。 （1）Statement：每次执行sql语句，数据库都要执行sql语句的编译 ，最好用于仅执行一次查询并返回结果的情形，效率高于PreparedStatement.但存在sql注入风险 （2）PreparedStatement：是预编译执行的。在执行可变参数的一条SQL时，PreparedStatement比Statement的效率高，因为DBMS预编译一条SQL当然会比多次编译一条SQL的效率要高。安全性更好，有效防止sql注入问题。对于多次重复执行的语句，使用PreparedStament效率会更高一点，并且在这种情况下也比较适合使用batch。 执行的SQL语句中是可以带参数的,并支持批量执行SQL。由于采用Cache机制，则预先编译的语句，就会放在Cache中，下次执行相同SQL语句时，则可以直接从Cache中取出来。例：1234PreparedStatement pstmt = con.prepareStatement(&quot;UPDATE EMPLOYEES SET name= ? WHERE ID = ?&quot;);pstmt.setString(1, &quot;李四&quot;);pstmt.setInt(2, 1);pstmt. executeUpdate(); 但是对于in来说不是很友好，需要自己定义写多少个问号123456String[] names = new String[]&#123;&apos;name1&apos;,&apos;name2&apos;,&apos;name3&apos;&#125;; String sql = &quot;select e.* from employee e where e.name in (?,?,?)&quot;; rs = pstmt.excuteQuery(sql); pstmt.setString(1,names[0]); pstmt.setString(2,names[1]); pstmt.setString(3,names[2]); （3）CallableStatement：扩展 PreparedStatement接口，用来调用存储过程,它提供了对输出和输入/输出参数的支持。CallableStatement 接口还有对 PreparedStatement 接口提供的输入参数的sql查询的支持。 http://www.importnew.com/5006.html == equals==== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不试同一个对象。对于基本类型使用==比如int和Integer比较，会要拆装箱，然后进行值比较大小 equalsequals() 的作用是 用来判断两个对象是否相等。equals() 定义在JDK的Object.java中。通过判断两个对象的地址是否相等(即，是否是同一个对象)来区分它们是否相等123public boolean equals(Object obj) &#123; return (this == obj);&#125; 但是java中很多类对于equals方法进行了重写。比如String中首先比较是否是同一个类型，比较字符串内容是否相等。总结：equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：情况1，类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。情况2，类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。 hashCode()hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。 hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数，同时object中hashcode使用的是native方法。虽然，每个Java类都包含hashCode() 函数。但是，仅仅当创建并某个“类的散列表”(关于“散列表”见下面说明)时，该类的hashCode() 才有用(作用是：确定该类的每一个对象在散列表中的位置；其它情况下(例如，创建类的单个对象，或者创建类的对象数组等等)，类的hashCode() 没有作用。上面的散列表，指的是：Java集合中本质是散列表的类，如HashMap，Hashtable，HashSet。也就是说：hashCode() 在散列表中才有用，在其它情况下没用。在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。 hashCode() 和 equals() 的关系第一种 不会创建“类对应的散列表”这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。在这种情况下，该类的“hashCode() 和 equals() ”没有半毛钱关系的！这种情况下，equals() 用来比较该类的两个对象是否相等。而hashCode() 则根本没有任何作用，所以，不用理会hashCode()。第二种 会创建“类对应的散列表”这里所说的“会创建类对应的散列表”是说：我们会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，会创建该类的HashSet集合。在这种情况下，该类的“hashCode() 和 equals() ”是有关系的：1)、如果两个对象相等，那么它们的hashCode()值一定相同。 这里的相等是指，通过equals()比较两个对象时返回true。2)、如果两个对象hashCode()相等，它们并不一定相等。 因为在散列表中，hashCode()相等，即两个键值对的哈希值相等。然而哈希值相等，并不一定能得出键值对相等。补充说一句：“两个不同的键值对，哈希值相等”，这就是哈希冲突。此外，在这种情况下。若要判断两个对象是否相等，除了要覆盖equals()之外，也要覆盖hashCode()函数。否则，equals()无效。http://www.cnblogs.com/skywang12345/p/3324958.htm 接口与抽象类的区别抽象类：抽象类是用来捕捉子类的通用特性的 。它不能被实例化，只能被用作子类的超类。抽象类是被用来创建继承层级里子类的模板接口：接口是抽象方法的集合。如果一个类实现了某个接口，那么它就继承了这个接口的抽象方法。这就像契约模式，如果实现了这个接口，那么就必须确保使用这些方法。接口只是一种形式，接口自身不能做任何事情。 接口与抽象类的区别 如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类。如果你想声明一些非公共的成员，使用抽象类，因为接口中所有的方法都是public。如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。http://www.importnew.com/12399.htmlhttp://www.programmerinterview.com/index.php/java-questions/interface-vs-abstract-class/ java三大特性面向对象编程有三大特性：封装、继承、多态。 封装隐藏了类的内部实现机制，可以在不影响使用的情况下改变类的内部结构，同时也保护了数据。对外界而已它的内部细节是隐藏的，暴露给外界的只是它的访问方法。 继承是为了重用父类代码。两个类若存在IS-A的关系就可以使用继承。同时继承也为实现多态做了铺垫。 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。静态单分派，动态多分派 http://www.bkjia.com/Javabc/1112062.html springMVC注解http://www.cnblogs.com/leskang/p/5445698.html https://wapwenku.baidu.com/view/ebbb24558f9951e79b89680203d8ce2f006665ba.html?pn=7&amp;vw=all&amp;pu=usm@1,sz@320_1001,ta@iphone_2_7.0_3_537","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"java","slug":"java","permalink":"http://duyao.github.io/tags/java/"}]},{"title":"24. Swap Nodes in Pairs","slug":"24-Swap-Nodes-in-Pairs","date":"2017-02-18T13:33:39.000Z","updated":"2017-02-24T07:21:14.000Z","comments":true,"path":"2017/02/18/24-Swap-Nodes-in-Pairs/","link":"","permalink":"http://duyao.github.io/2017/02/18/24-Swap-Nodes-in-Pairs/","excerpt":"","text":"","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"}]},{"title":"问答-登录注册","slug":"问答-登录注册","date":"2017-02-17T12:48:25.000Z","updated":"2017-04-11T01:24:36.000Z","comments":true,"path":"2017/02/17/问答-登录注册/","link":"","permalink":"http://duyao.github.io/2017/02/17/问答-登录注册/","excerpt":"","text":"技术要点注册登录 密码不是原密码加上salt，再MD5加密存入数据库 TokenToken是一个任意字符串。只有服务器和微信后台知道这个字符串，token成了这两台服务器之间的密钥，可以防止恶意请求，Token机制在服务端不需要存储session信息有了token，就可以实现免密码登录对Token认证机制注意的地方： 一个Token就是一些信息的集合； 在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率； 服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查； 基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端 token结构 每个用户设置一个token，服务器端token关联userid 12345private int id;private int userId;private Date expired;//date.setTime(date.getTime() + 1000*3600*24);private int status;// 0有效，1无效private String ticket;//uuid 服务器端还有一张表，用来记录token，这个思想类似于session共享。可应用在免密码登录的场景中，电脑登录了网站，现在用手机扫码登录网站，扫码的过程就是讲这个用户的token从数据库取出，然后传递给手机端，这样无需密码登陆了。token存在数据中，这样所有的服务就可以获取到，再比如登录淘宝就能直接登录支付宝 如何保存token 对于浏览器端只需要保存在cookie中，用户登录的时候就把token与用户关联起来，同时使用HttpServletResponse设置cookie 对于服务器端首先需要数据库保存各种token另一方面，由于token把用户关联起来了，因此我们在得到token的同时也可以得到该用户的信息。这个用户信息在网页间请求是需要的，因此服务器应该保存所有在线的用户信息，这就用到了ThreadLocal同时这个用户信息在网页间请求是需要验证的，因此需要拦截器interceptor ThreadLocalThreadLocal本意是123This class provides thread-local variables.These variables differ from their normal counterparts in that each thread that accesses one (via its &#123;@code get&#125; or &#123;@code set&#125; method) has its own, independently initialized copy of the variable. &#123;@code ThreadLocal&#125; instances are typically private static fields in classes that wish to associate state with a thread (e.g.,a user ID or Transaction ID) ThreadLocal类用来提供线程内部的局部变量。这些变量在多线程环境下访问(通过get或set方法访问)时能保证各个线程里的变量相对独立于其他线程内的变量，ThreadLocal实例通常来说都是private static类型.ThreadLocal的主要应用场景为按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。例如：同一个网站登录用户，每个用户服务器会为其开一个线程，每个线程中创建一个ThreadLocal，里面存用户基本信息等，在很多页面跳转时，会显示用户信息或者得到用户的一些信息等频繁操作，这样多线程之间并没有联系而且当前线程也可以及时获取想要的数据。 实现原理 ThreadLocal可以看做是一个容器，容器里面存放着属于当前线程的变量。ThreadLocal类提供了四个对外开放的接口方法，这也是用户操作ThreadLocal类的基本方法：(1) void set(Object value)设置当前线程的线程局部变量的值。值得注意的是，set方法中设置的值应该是new出来的对象，而不是在外面new好的对象指针！(2) public Object get()该方法返回当前线程所对应的线程局部变量。(3) public void remove()将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。(4) protected Object initialValue()返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次，ThreadLocal中的缺省实现直接返回一个null。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** Returns the value in the current thread's copy of this thread-local variable. If the variable has no value for thecurrent thread, it is first initialized to the value returned by an invocation of the &#123;@link #initialValue&#125; method. @return the current thread's value of this thread-local */public T get() &#123; Thread t = Thread.currentThread();//当前线程 ThreadLocalMap map = getMap(t);//获取当前线程对应的ThreadLocalMap if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this);//获取对应ThreadLocal的变量值 if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();//若当前线程还未创建ThreadLocalMap，则返回调用此方法并在其中调用createMap方法进行创建并返回初始值。&#125;//设置变量的值public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125;/**为当前线程创建一个ThreadLocalMap的threadlocals,并将第一个值存入到当前map中@param t the current thread@param firstValue value for the initial entry of the map*/void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125;//删除当前线程中ThreadLocalMap对应的ThreadLocalpublic void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);&#125; 从线程Thread的角度来看，每个线程内部都会持有一个对ThreadLocalMap实例的引用ThreadLocals，ThreadLocalMap实例相当于线程的局部变量空间，存储着线程各自的数据。其实在ThreadLocal类中有一个静态内部类ThreadLocalMap(其类似于Map)，用键值对的形式存储每一个线程的变量副本，ThreadLocalMap中元素的key为当前ThreadLocal对象，而value对应线程的变量副本，每个线程可能存在多个ThreadLocal。 ThredLocal 1234567891011121314151617181920static class ThreadLocalMap &#123; //map中的每个节点Entry,其键key是ThreadLocal并且还是弱引用，这也导致了后续会产生内存泄漏问题的原因。 static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125; /** * 初始化容量为16，以为对其扩充也必须是2的指数 */ private static final int INITIAL_CAPACITY = 16; /** * 真正用于存储线程的每个ThreadLocal的数组，将ThreadLocal和其对应的值包装为一个Entry。 */ private Entry[] table; ///....其他的方法和操作都和map的类似&#125; http://www.iteye.com/topic/1141743http://www.jianshu.com/p/33c5579ef44f 内存泄漏 每个thread中都存在一个map, map的类型是ThreadLocal.ThreadLocalMap.Map中的key为一个threadlocal实例. 这个Map的确使用了弱引用,不过弱引用只是针对key. 每个key都弱引用指向threadlocal. 当把threadlocal实例置为null以后,没有任何强引用指向threadlocal实例,所以threadlocal将会被gc回收.但是,我们的value却不能回收,因为存在一条从current thread连接过来的强引用. 只有当前thread结束以后, current thread就不会存在栈中,强引用断开, Current Thread, Map, value将全部被GC回收. http://www.cnblogs.com/onlywujun/p/3524675.htmlhttp://www.importnew.com/22039.htmlhttps://my.oschina.net/xianggao/blog/392440?fromerr=CLZtT4xC 实现HostHolder通过aop可以在服务器端任何一个位置使用12345678910111213141516@Componentpublic class HostHolder &#123; private static ThreadLocal&lt;User&gt; users = new ThreadLocal&lt;User&gt;(); public User getUser() &#123; return users.get(); &#125; public void setUser(User user) &#123; users.set(user); &#125; public void clear() &#123; users.remove();; &#125;&#125; 拦截器Interceptor HandlerInterceptor 一般情况下，一个拦截器功能 注册拦截器1234567891011121314151617@Componentpublic class WendaWebConfiguration extends WebMvcConfigurerAdapter &#123; @Autowired PassportInterceptor passportInterceptor; @Autowired LoginRequiredInterceptor loginRequiredInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) &#123; //拦截器有顺序问题，注意先后 registry.addInterceptor(passportInterceptor); //第二个拦截器 registry.addInterceptor(loginRequiredInterceptor).addPathPatterns(&quot;/user/*&quot;); super.addInterceptors(registry); &#125;&#125; 未登录跳转再注册一个拦截器，访问/user/ *这样的页面，就回执行该拦截器registry.addInterceptor(loginRequiredInterceptor).addPathPatterns(&quot;/user/ *&quot;);同时，能返回原来要访问的网址，在request中添加一个参数，记录当前访问的页面，然后进拦截器跳转 123456789101112131415161718192021public class LoginRequredInterceptor implements HandlerInterceptor &#123; @Autowired HostHolder hostHolder; @Override public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception &#123; if (hostHolder.getUser() == null) &#123; //next字段记录该值 httpServletResponse.sendRedirect(&quot;/reglogin?next=&quot; + httpServletRequest.getRequestURI()); &#125; return true; &#125; @Override public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception &#123; &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; &#125;&#125; 同样地功能还有，查看付费内容等 邮件注册技术细节简单服务器1234567891011121314151617//访问的网址@RequestMapping(path = &#123;&quot;/&quot;, &quot;/index&quot;&#125;)@ResponseBodypublic String Index() &#123; return &quot;hello, world!&quot;;&#125;@RequestMapping(path = &#123;&quot;/profile/&#123;groupId&#125;/&#123;userId&#125;&quot;&#125;)@ResponseBodypublic String Profile(@PathVariable(&quot;userId&quot;) int userId, @PathVariable(&quot;groupId&quot;) String groupId, @RequestParam(&quot;key&quot;) int key, //看文档时，函数名字是填写的字段的名称，这种默认字段可以用在查询某个值是没有指定页数，可以默认为第一页 @RequestParam(name = &quot;value&quot;, defaultValue = &quot;default&quot; , required = false) String value) &#123; return String.format(&quot;profile: groupId - %s, userId - %d , key = %d, value = %s&quot;, groupId , userId ,key, value);&#125; Http Method get 获取接口信息 post 提交数据到服务器 put 支持幂等性的POST，就是提交很多次post结果都一样，只产生一次效果 delete 删除服务器的资源 head 紧急查看http的头 opitions 查看支持的方法 velocity相关语法规则 $!表示变量 #表示一个函数 foreach遍历 parse解析变量，include不解析变量 macro定义宏 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#*注释块*#types:$!&#123;types&#125;#foreach($t in $types) this is type-&gt; index:$!&#123;foreach.index&#125;, type name :$t, count:$!&#123;foreach.count&#125;#end#foreach($key in $map.keySet()) key = $key, value = $map.get($key)#end#foreach($key in $map.entrySet()) key = $key.key, value = $key.value#end传递对象User : $!&#123;u.name&#125;,$!&#123;u.des&#125;,$!&#123;u.getDes()&#125;设置变量#set($title = &quot;home&quot;)title is $!&#123;title&#125;引入其他页面parse:#parse(&quot;head.html&quot;)include:#include(&quot;head.html&quot;)区别：parse会将变量进行解析，而include不会对变量进行解析，他们主要用在网页的头尾引入设置宏,就是定义一个函数，很多地方都可以使用#macro(render_type, $index, $type) type rendering $index, $type#end使用宏#foreach($t in $types) #render_type($foreach.index, $t)#end双引号解析，单引号不解析#set($hello = &quot;hello&quot;)#set($hw1 = &quot;$!&#123;hello&#125; world&quot;)#set($hw2 = &apos;$!&#123;hello&#125; world&apos;)$!&#123;hello&#125;$!&#123;hw1&#125;$!&#123;hw2&#125; response 和 request1234567891011121314151617181920212223242526272829303132333435@RequestMapping(&quot;/req&quot;)@ResponseBodypublic String Request(HttpServletRequest request, HttpServletResponse response, HttpSession session, Model model, @CookieValue(&quot;JSESSIONID&quot;) String cookieId) &#123; StringBuffer sb = new StringBuffer(); sb.append(&quot;COOKIEID=&quot;+cookieId); sb.append(request.getMethod() + &quot;&lt;br&gt;&quot;); sb.append(request.getPathInfo() + &quot;&lt;br&gt;&quot;); sb.append(request.getQueryString() + &quot;&lt;br&gt;&quot;); sb.append(&quot;&lt;br&gt;headers&lt;br&gt;&quot;); Enumeration headerNames = request.getHeaderNames(); while (headerNames.hasMoreElements()) &#123; String name = (String) headerNames.nextElement(); sb.append(name + &quot; : &quot; + request.getHeader(name) + &quot;&lt;br&gt;&quot;); &#125; response.addCookie(new Cookie(&quot;user&quot;, &quot;amy&quot;)); response.addHeader(&quot;tttt&quot;, &quot;sss&quot;); sb.append(&quot;&lt;br&gt;cookie&lt;br&gt;&quot;); Cookie[] cookies = request.getCookies(); for (Cookie cc : cookies ) &#123; sb.append(cc.getName() + &quot; : &quot; + cc.getValue() + &quot;&lt;br&gt;&quot;); &#125; return sb.toString();&#125; 重定向和error 301 永久转移与302临时转移 1234567891011121314151617//302@RequestMapping(value = &#123;&quot;/redirect/&#123;code&#125;&quot;&#125;, method = &#123;RequestMethod.GET&#125;)public String redirect(@PathVariable(&quot;code&quot;) int code) &#123; return &quot;redirect:/&quot;;&#125;//301@RequestMapping(value = &#123;&quot;/redirect/&#123;code&#125;&quot;&#125;,method = &#123;RequestMethod.GET&#125;)public RedirectView redirect(@PathVariable(&quot;code&quot;) int code)&#123; RedirectView red = new RedirectView(&quot;/&quot;,true); if(code == 301)&#123; red.setStatusCode(HttpStatus.MOVED_PERMANENTLY); &#125; return red;&#125; 异常处理 12345678910111213141516//异常处理@RequestMapping(&quot;/admin&quot;)@ResponseBodypublic String admin(@RequestParam(&quot;key&quot;) String key) &#123; if (key.equals(&quot;admin&quot;)) &#123; return &quot;hello, admin!&quot;; &#125; else &#123; throw new IllegalArgumentException(&quot;参数错误&quot;); &#125;&#125;@ExceptionHandler()@ResponseBodypublic String error(Exception e) &#123; return &quot;error: &quot; + e.getMessage();&#125; IoC在编程过程中，有很多对象及其依赖的对象，他们都需要初始化和相互调用，这样很多对象就会形成一张巨大的网，里面包含了各种调用关系。传统模式中：通过main函数对每个对象进行初始化，赋值等操作。而在IoC中，通过Autowired依赖注入的方式完成这个过程，也就是说对象主要在一个地方产生，在剩余的其他地方需要调用该对象时候，只需要通过注入方式声明该对象，即可完成对其初始化的过程。12@AutowiredExampleService service; 同时有个类就是ExampleService 类似于享元模式 AOP面向切面编程，就是在不改变原有程序的基础上，在执行某个方法的之前或者之后完成一些功能比如拦截器、记日志","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"wenda","slug":"wenda","permalink":"http://duyao.github.io/tags/wenda/"}]},{"title":"112. Path Sum","slug":"112-Path-Sum","date":"2017-02-16T13:25:30.000Z","updated":"2017-02-18T12:40:48.000Z","comments":true,"path":"2017/02/16/112-Path-Sum/","link":"","permalink":"http://duyao.github.io/2017/02/16/112-Path-Sum/","excerpt":"","text":"112. Path Sum此题目是树的遍历 由于树的遍历采用的递归方式，因此在遍历过程中可以记录很多信息，但是要注意递归过程中返回上一层时，记录的基本类型的值都会变为原来的 1234567891011121314public boolean hasPathSum(TreeNode root, int sum) &#123; if(root == null)&#123; return false; &#125;else&#123; if(root.left == null &amp;&amp; root.right ==null &amp;&amp; sum - root.val == 0)&#123; return true; &#125; //这里是或运算 //因为每一层递归都会记录状态，同时返回时状态会消失 return hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum - root.val); &#125;&#125; 113. Path Sum II1234567891011121314151617181920212223public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); visit(root, new ArrayList&lt;&gt;(), sum, res); return res;&#125;public void visit(TreeNode root, List&lt;Integer&gt; list, int sum, List&lt;List&lt;Integer&gt;&gt; res) &#123; if(root != null)&#123; list.add(root.val); if(root.left == null &amp;&amp; root.right == null &amp;&amp; sum - root.val == 0 )&#123; res.add(new ArrayList&lt;&gt;(list)); &#125; visit(root.left, list, sum - root.val, res); visit(root.right, list, sum - root.val, res); list.remove(list.size()-1); &#125;&#125; 129. Sum Root to Leaf Numbers值传递的递归12345678910111213141516171819202122232425262728public int sumNumbers(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int sum = cal(root, new StringBuffer()); return sum;&#125;public int cal(TreeNode cur, StringBuffer sb) &#123; sb.append(cur.val); if (cur.left == null &amp;&amp; cur.right == null) &#123; int tmp = Integer.valueOf(sb.toString()); sb.deleteCharAt(sb.length()-1); return tmp; &#125; else &#123; int sum = 0; if (cur.left != null) &#123; sum += cal(cur.left, sb); &#125; if (cur.right != null) &#123; sum += cal(cur.right, sb); &#125; sb.deleteCharAt(sb.length()-1); return sum; &#125;&#125; 非值传递1234567891011121314151617181920212223242526272829303132public int sumNumbers(TreeNode root) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); visit(root, new StringBuffer(), res); int sum = 0; for (Integer i: res ) &#123; sum += i; &#125; return sum;&#125;public void visit(TreeNode root, StringBuffer sb, List&lt;Integer&gt; res)&#123; if(root != null)&#123; sb.append(root.val); if(root.left == null &amp;&amp; root.right == null)&#123; res.add(Integer.valueOf(sb.toString())); &#125; visit(root.left, sb, res); visit(root.right, sb, res); sb.deleteCharAt(sb.length()-1); &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"Hadoop安装及配置","slug":"Hadoop安装及配置","date":"2017-01-05T07:01:54.000Z","updated":"2017-02-21T01:02:14.000Z","comments":true,"path":"2017/01/05/Hadoop安装及配置/","link":"","permalink":"http://duyao.github.io/2017/01/05/Hadoop安装及配置/","excerpt":"","text":"hadoop搭建vmware网络模式 host-only 虚拟机的网关是物理机 bridge 所有虚拟机的网关是物理机的网关，虚拟机是与物理机的地位相等 nat 虚拟出一个网卡，所有的虚拟机都连接在该网卡上面 配置linux 编辑sudovim /etc/sudoers 改ipifconfig 查看网络信息vim /etc/sysconfig/network-scripts/eth0 更改ip等curl ifconfig.me 查看公网地址 改启动模式vim /etc/inittab 配置域名vim /etc/sysconfig/network 改主机名scp 源 目的， 远程复制 -r表示强制执行，尤其是复制文件夹的时候 1scp -r /app/hadoop-2.7.3/etc/ gxq:/app/hadoop-2.7.3 关闭防火墙service iptables stop 关闭防火墙service iptables status 检查防火墙状态chkconfig iptables off 关闭防火墙开机启动 安装jdktar -zxvf jdk-7u55-linux-i586.tar.gz -C /home/hadoop/app C是指定目录vim /etc/profileexport JAVA_HOME=/home/hadoop/app/jdk-7u_65-i585export PATH=$PATH:$JAVA_HOME/binsource /etc/profile 安装及配置hadoop vim hadoop-env.shJAVA_HOME = /home/hadoop/app/jdk_7u65 vim core-site.xml最好写主机名，就是host中配置的 1234567891011&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;value&gt;hdfs://115.159.65.146:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/home/hadoop/app/hadoop-2.4.1/hdpdata&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; vim mapred-site.xmlmv mapred-site.xml.template mapred-site.xml 改名 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; vim yarn-site.xml 123456789101112&lt;configuration&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;115.159.65.146&lt;/value&gt; &lt;!--namenode &lt;value&gt;localhost&lt;/value&gt;--&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; vim hdfs-site.xml这里表示一共有2个副本 123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;2&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; vim slaves文件 slaves，将作为 DataNode 的主机名写入该文件，每行一个，默认为 localhost，配置可以保留 localhost，也可以删掉，让该节点仅作为 NameNode 使用。 12localhosthadoop-node01 #已经在hosts中设置好 vim /etc/profile123export JAVA_HOME=/app/jdk1.8.0_101export HADOOP_HOME=/app/hadoop-2.7.3export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin 集群内部的SSH免密登陆1234ssh-keygenssh-copy-id hdp-node01 //hdp-node01已经在/etc/hosts中配置过ssh-copy-id hdp-node02ssh-copy-id hdp-node03 启动hadoop 格式化namenode1hadoop namenode -format 在sbin目录下面有很多自动脚本12345678910111213141516171819202122232425262728-rwxr-xr-x 1 root root 2752 Aug 18 09:49 distribute-exclude.sh-rwxr-xr-x 1 root root 6452 Aug 18 09:49 hadoop-daemon.sh-rwxr-xr-x 1 root root 1360 Aug 18 09:49 hadoop-daemons.sh-rwxr-xr-x 1 root root 1597 Aug 18 09:49 hdfs-config.cmd-rwxr-xr-x 1 root root 1427 Aug 18 09:49 hdfs-config.sh-rwxr-xr-x 1 root root 2291 Aug 18 09:49 httpfs.sh-rwxr-xr-x 1 root root 3128 Aug 18 09:49 kms.sh-rwxr-xr-x 1 root root 4080 Aug 18 09:49 mr-jobhistory-daemon.sh-rwxr-xr-x 1 root root 1648 Aug 18 09:49 refresh-namenodes.sh-rwxr-xr-x 1 root root 2145 Aug 18 09:49 slaves.sh-rwxr-xr-x 1 root root 1727 Aug 18 09:49 start-all.cmd-rwxr-xr-x 1 root root 1471 Aug 18 09:49 start-all.sh-rwxr-xr-x 1 root root 1128 Aug 18 09:49 start-balancer.sh-rwxr-xr-x 1 root root 1360 Aug 18 09:49 start-dfs.cmd-rwxr-xr-x 1 root root 3734 Aug 18 09:49 start-dfs.sh-rwxr-xr-x 1 root root 1357 Aug 18 09:49 start-secure-dns.sh-rwxr-xr-x 1 root root 1524 Aug 18 09:49 start-yarn.cmd-rwxr-xr-x 1 root root 1347 Aug 18 09:49 start-yarn.sh-rwxr-xr-x 1 root root 1718 Aug 18 09:49 stop-all.cmd-rwxr-xr-x 1 root root 1462 Aug 18 09:49 stop-all.sh-rwxr-xr-x 1 root root 1179 Aug 18 09:49 stop-balancer.sh-rwxr-xr-x 1 root root 1414 Aug 18 09:49 stop-dfs.cmd-rwxr-xr-x 1 root root 3206 Aug 18 09:49 stop-dfs.sh-rwxr-xr-x 1 root root 1340 Aug 18 09:49 stop-secure-dns.sh-rwxr-xr-x 1 root root 1595 Aug 18 09:49 stop-yarn.cmd-rwxr-xr-x 1 root root 1340 Aug 18 09:49 stop-yarn.sh-rwxr-xr-x 1 root root 4295 Aug 18 09:49 yarn-daemon.sh-rwxr-xr-x 1 root root 1353 Aug 18 09:49 yarn-daemons.sh 如果单个启动，可以使用123hadoop-daemon.sh start -namenodehadoop-daemon.sh start -datanodehadoop-daemon.sh start -secondarynamenode 停止时改为stop，yarn同理 如果想一键启动或停止12345678start-dfs.shstop-dfs.shstart-yarn.shstop-yarn.sh//启动hsfs和yarnstart-all.shstop-all.sh jps 仅查找当前用户的Java进程，而不是当前系统中的所有进程123456789101112netstat -nltp -a (all)显示所有选项，默认不显示LISTEN相关 -t (tcp)仅显示tcp相关选项 -u (udp)仅显示udp相关选项 -n 拒绝显示别名，能显示数字的全部转化成数字。 -l 仅列出有在 Listen (监听) 的服務状态 -p 显示建立相关链接的程序名 -r 显示路由信息，路由表 -e 显示扩展信息，例如uid等 -s 按各个协议进行统计 -c 每隔一个固定时间，执行该netstat命令 错误 host文件在namenode中自己的地址是内网ip在datanode中自己的地址是公网ip rpc端口随机导致执行mapreduce时候失败，因为服务器中的安全组没有开放 拒绝，可能是因为服务器端口没有打开[root@dy hadoop-2.7.3]# hdfs dfsadmin -reportJava HotSpot(TM) Client VM warning: You have loaded library /app/hadoop-2.7.3/lib/native/libhadoop.so.1.0.0 which might have disabled stack guard. The VM will try to fix the stack guard now.It’s highly recommended that you fix the library with ‘execstack -c ‘, or link it with ‘-z noexecstack’.16/10/03 00:28:25 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform… using builtin-java classes where applicablereport: Call From dy/115.159.65.146 to dy:9000 failed on connection exception: java.net.ConnectException: Connection refused; For more details see: http://wiki.apache.org/hadoop/ConnectionRefused 前面出现，可能是版本错误Java HotSpot(TM) Client VM warning: You have loaded library /app/hadoop-2.7.3/lib/native/libhadoop.so.1.0.0 which might have disabled stack guard. The VM will try to fix the stack guard now.It’s highly recommended that you fix the library with ‘execstack -c ‘, or link it with ‘-z noexecstack’. -org.apache.hadoop.yarn.exceptions.YarnRuntimeException: java.net.BindException: Problem binding to [dy:8031] java.net.BindException: Cannot assign requested address; For more details see: http://wiki.apache.org/hadoop/BindException12345678910111213141516171819202122232425262728293031323334353637383940414243444546 &lt;name&gt;dfs.namenode.rpc-bind-host&lt;/name&gt; &lt;value&gt;0.0.0.0&lt;/value&gt; &lt;description&gt; The actual address the RPC server will bind to. If this optional address is set, it overrides only the hostname portion of dfs.namenode.rpc-address. It can also be specified per name node or name service for HA/Federation. This is useful for making the name node listen on all interfaces by setting it to 0.0.0.0. &lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;dfs.namenode.servicerpc-bind-host&lt;/name&gt; &lt;value&gt;0.0.0.0&lt;/value&gt; &lt;description&gt; The actual address the service RPC server will bind to. If this optional address is set, it overrides only the hostname portion of dfs.namenode.servicerpc-address. It can also be specified per name node or name service for HA/Federation. This is useful for making the name node listen on all interfaces by setting it to 0.0.0.0. &lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;dfs.namenode.http-bind-host&lt;/name&gt; &lt;value&gt;0.0.0.0&lt;/value&gt; &lt;description&gt; The actual adress the HTTP server will bind to. If this optional address is set, it overrides only the hostname portion of dfs.namenode.http-address. It can also be specified per name node or name service for HA/Federation. This is useful for making the name node HTTP server listen on all interfaces by setting it to 0.0.0.0. &lt;/description&gt;&lt;/property&gt;&lt;property&gt; &lt;name&gt;dfs.namenode.https-bind-host&lt;/name&gt; &lt;value&gt;0.0.0.0&lt;/value&gt; &lt;description&gt; The actual adress the HTTPS server will bind to. If this optional address is set, it overrides only the hostname portion of dfs.namenode.https-address. It can also be specified per name node or name service for HA/Federation. This is useful for making the name node HTTPS server listen on all interfaces by setting it to 0.0.0.0. &lt;/description&gt;&lt;/property&gt; 同时，要将namenode机器上面的网址全部改为localhost(core-site和yarn-site)，datanode上面的还是写公网ip","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[]},{"title":"gitpage 配置","slug":"gitpage-配置","date":"2016-12-19T06:37:29.000Z","updated":"2017-02-22T07:21:14.000Z","comments":true,"path":"2016/12/19/gitpage-配置/","link":"","permalink":"http://duyao.github.io/2016/12/19/gitpage-配置/","excerpt":"","text":"git中的两个分支设置完成gitpage后，要再新建一个分支，用来存放hexo下面的配置及文件，这样电脑重装系统后，只需要下载相关组件，而不用重新配置即在duyao.github.io下面有两个分支，一个是master，另一个是hexo我在hexo中把blog内容更新到master中而在hexo分支中存放的是hexo的配置文件和master的内容因此对于日常的写博客，首先使用 hexo g -d发布，这时候内容是同步到master中然后用git push origin hexo将这些内容同步到hexo中 git快捷键有两种方法设置快捷键，一个是通过.gitconfig,另一种是.bashrc。 在.gitconfig添加如下内容 12345678910111213141516171819[user] name = Amy email = duyao.dy1993@gmail.com...[alias] aa = add . cm = commit -m c = commit co = checkout dt = difftool mt = mergetool po = push origin pom = push origin master praise = blame ff = merge --ff-only st = status sync = !git pull &amp;&amp; git push 在c://User/user中建立文件.bashrc，并添加如下内容 123456789101112alias gs=&apos;git status&apos;alias gd=&apos;git diff&apos;alias ga=&apos;git add&apos;alias gc=&apos;git commit&apos;alias gck=&apos;git checkout&apos;alias gb=&apos;git branch&apos;alias gl=&apos;git log&apos;alias gthis=&apos;git rev-parse --abbrev-ref HEAD&apos;alias gpushthis=&apos;git push origin `gthis`&apos;alias gpullthis=&apos;git pull origin `gthis`&apos;alias gup=&apos;git remote update&apos;alias gpl=&apos;git pull origin&apos;","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[]},{"title":"Scala","slug":"Scala","date":"2016-10-13T01:57:50.000Z","updated":"2016-10-13T14:06:02.000Z","comments":true,"path":"2016/10/13/Scala/","link":"","permalink":"http://duyao.github.io/2016/10/13/Scala/","excerpt":"","text":"重要概念 纯函数(pure function)无副作用的函数 函数的纯粹性(purity) 无副作用(side effect)无状态mutation的变化12345678int x;public int f1(int y)&#123; return x+y;&#125;public int f2(int y)&#123; x = x+y; return x+y;&#125; 这里f1是无副作用，因为没有改变x的值，而f2具有副作用，改变了x的值 引用透明性(referential transparency)相同的输入，总是得到相同的输出123StringBuffer x = &quot;hello&quot;;StringBuffer y = x.append(&quot;world&quot;);StringBuffer z = x.append(&quot;world&quot;); 这里append函数不具有引用透明性，因为y和z的输出并不相同 不变形(immutability)为了获得引用透明性，任何值都不会引起不变化 函数是一等公民first-class function 高阶函数high order function 闭包closure 表达式求值策略-严格求值和非严格求值一切都是表达式call by value VS call by name 惰性求值lazy evaluation 数据类型语法 val 常量 var 变量 lazy val 懒加载常量 字符串插值使用s+${} 12val s : String = &quot;hello&quot;;s&quot;$&#123;s&#125; world&quot;; 函数 123def functionName (param : ParamType)[: ReturnType] = &#123; //function body&#125; 1234例子def hello1(name: String) = &#123; s&quot;hell0 $&#123;name&#125;&quot;&#125; if表达式if(logical_exp) valA else valB 1234val a = 1; a: Int = 1if (a == 1) a res4: AnyVal = 1 if (a != 1) &quot;not one&quot; res5: Any = () if (a != 1) &quot;not one&quot; else 1 res6: Any = 1 for comprehension 123456789101112val l = List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)for &#123; s &lt;- l //generator if (s.length &lt; 3) //filter&#125; println(s)val result_for = for &#123; s &lt;- l sup = s.toUpperCase(); //variable binding if (sup != &quot;&quot;)&#125; yield (sup) //generate new collection try, catch, finally 1234567try &#123; Integer.parseInt(&quot;dog&quot;)&#125; catch &#123; case _ =&gt; 0; //_是通配符，=&gt;赋值&#125; finally &#123; println(&quot;always be printed&quot;)&#125; match 123456exp match&#123; case p1 =&gt; val1 case p2 =&gt; val2 ... case _ =&gt; valn&#125; 123456val code = 4code match &#123; case 1 =&gt; &quot;one&quot; case 2 =&gt; &quot;two&quot; case _ =&gt; &quot;others&quot;&#125; 求值策略call by value 一般都是=使用，调用就计算call by name 调用不计算，只有等到执行才会计算 1234def bar(x : Int, y : =&gt; Int) = 1def loop():Int = loopbar(1,loop) //res2: Int = 1bar(loop,1) //死循环 高阶函数用函数作为形参或返回值的函数成为高阶函数 匿名函数匿名函数anonymous function就是函数常量，也成为函数文字量function literal在scala中匿名函数的定义格式为(形参列表) =&gt; {函数体}12345678def operate(f:(Int,Int) =&gt; Int) =&#123; f(4,4)&#125; //&gt; operate: (f: (Int, Int) =&gt; Int)Intdef tr(x:Int,y:Int)=x+y //tr: (x: Int, y: Int)Intoperate(tr) //res0: Int = 8def greeting() =(name:String) =&gt; &#123;&quot;hello&quot;+&quot; &quot;+name&#125;greeting() (&quot;123&quot;) 柯里化 curried functoin把具有多个参数的函数转化为一条函数链，每个节点上是单一参数1234def curriedAdd(a:Int)(b:Int)=a+b //curriedAdd: (a: Int)(b: Int)IntcurriedAdd(2)(2) //res1: Int = 4val addOne = curriedAdd(1)_ //addOne: Int =&gt; Int = &lt;function1&gt;addOne(2) //res2: Int = 3 上面的例子可以看出来，柯里化可以复用函数 递归函数recuritive function123456789101112def f(n: Int): Int = if (n &lt; 0) 1 else n * f(n - 1)f(5)@annotation.tailrecdef f(n: Int, m: Int): Int = if (n &lt;= 0) m else f(n - 1, m*n)f(5,1) 上面的m是计算的最新结果 例子$$\\sum_{i=a}^b f(x)=0$$求a到b的区间和 1234567891011121314def sum(f: Int =&gt; Int)(a: Int)(b: Int): Int = &#123; def loop(n: Int, acc: Int): Int = &#123; if (n &gt; b) &#123; println(s&quot;n=$&#123;n&#125;, acc=$&#123;acc&#125;&quot;) acc &#125; else &#123; println(s&quot;n=$&#123;n&#125;, acc=$&#123;acc&#125;&quot;) loop(n + 1, acc + f(n)) &#125; &#125; loop(a,0)&#125;sum(x=&gt;x)(1)(5)sum(x=&gt;x*x)(1)(5) 打印结果1234567891011121314n=1, acc=0n=2, acc=1n=3, acc=3n=4, acc=6n=5, acc=10n=6, acc=15res0: Int = 15n=1, acc=0n=2, acc=1n=3, acc=5n=4, acc=14n=5, acc=30n=6, acc=55res1: Int = 55","categories":[],"tags":[]},{"title":"148. Sort List","slug":"148-Sort-List","date":"2016-07-16T13:45:40.000Z","updated":"2016-07-16T13:57:40.000Z","comments":true,"path":"2016/07/16/148-Sort-List/","link":"","permalink":"http://duyao.github.io/2016/07/16/148-Sort-List/","excerpt":"","text":"链表的归并操作148. Sort List23. Merge k Sorted Lists 23. Merge k Sorted Lists123456789101112131415161718192021222324252627282930313233343536373839404142434445public ListNode mergeKLists(ListNode[] lists) &#123; return sort(lists,0 ,lists.length-1);&#125;private ListNode sort(ListNode[] lists, int s ,int e)&#123; if(s &lt; e)&#123; int mid = (s + e) / 2; ListNode head1 = sort(lists, s, mid); ListNode head2 = sort(lists, mid+1, e); return merge(head1, head2); &#125;else if(s == e)&#123; return lists[s]; &#125;else&#123; return null; &#125;&#125;private ListNode merge(ListNode a, ListNode b)&#123; ListNode head = new ListNode(0); ListNode cur = head; while(a != null &amp;&amp; b != null)&#123; if(a.val &lt; b.val)&#123; cur.next = a; a = a.next; &#125;else&#123; cur.next = b; b = b.next; &#125; cur = cur.next; &#125; while(a != null)&#123; cur.next = a; a = a.next; cur = cur.next; &#125; while(b != null)&#123; cur.next = b; b = b.next; cur = cur.next; &#125; return head.next; &#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"73. Set Matrix Zeroes","slug":"73-Set-Matrix-Zeroes","date":"2016-07-16T12:41:29.000Z","updated":"2016-07-16T13:39:42.000Z","comments":true,"path":"2016/07/16/73-Set-Matrix-Zeroes/","link":"","permalink":"http://duyao.github.io/2016/07/16/73-Set-Matrix-Zeroes/","excerpt":"","text":"原地重置问题根据特定的条件将数组变化，不用额外的空间73. Set Matrix Zeroes289. Game of Life 73. Set Matrix Zeroes73. Set Matrix Zeroes该题目是用第一行和第一列记录状态，然后其余部分根据第一行和第一列来改变 设置row和col来标记第一行和第一列是否需要改变 遍历其余部分，该位置为0，那么将该位置对应的第一行和第一列的值设置为0 根据第一行和第一列，只有其中有1个为0，就设置其值为0 根据第一步的row和col，来改变第一行和第一列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public void setZeroes(int[][] matrix) &#123; int m = matrix.length; int n = matrix[0].length; // 设置row和col boolean col = false; boolean row = false; for (int i = 0; i &lt; m; i++) &#123; if (matrix[0][i] == 0) &#123; col = true; break; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; if (matrix[i][0] == 0) &#123; row = true; break; &#125; &#125; // 根据数组设置第一行第一列 for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (matrix[i][j] == 0) &#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; // 根据第一行和第一列设置数组 for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (matrix[i][0] == 0 || matrix[0][j] == 0) &#123; matrix[i][j] = 0; &#125; &#125; &#125; // 设置第一行和第一列 if (row) &#123; for (int i = 0; i &lt; m; i++) &#123; matrix[i][0] = 0; &#125; &#125; if (col) &#123; for (int i = 0; i &lt; n; i++) &#123; matrix[0][1] = 0; &#125; &#125;&#125; 289. Game of Life289. Game of Life利用变色法来记录状态1-&gt;0 == 20-&gt;1 == -1统计个数是查看1(原来和现在都是1)和2(原来是1现在是0)个数先更新成带变色的数组，然后再还原 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void gameOfLife(int[][] board) &#123; //1-&gt;0 == 2 //0-&gt;1 == -1 //使用假色，1的个数=大于零的个数，因为可能有1-&gt;0 == 2 for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[0].length; j++)&#123; int k = f(board, i , j); if(board[i][j] == 1 &amp;&amp; (k &lt; 2 || k &gt; 3))&#123; //1-&gt;0 == 2 board[i][j] = 2; &#125;else if(board[i][j] == 0 &amp;&amp; k == 3)&#123; //0-&gt;1 == -1 board[i][j] = -1; &#125; &#125; &#125; //恢复 for(int i = 0; i &lt; board.length; i++)&#123; for(int j = 0; j &lt; board[0].length; j++)&#123; if(board[i][j] == 2)&#123; //1-&gt;0 == 2 board[i][j] = 0; &#125;else if(board[i][j] == -1)&#123; //0-&gt;1 == -1 board[i][j] = 1; &#125; &#125; &#125; &#125;//计算个数public int f(int[][] x, int a, int b)&#123; int cnt = 0; int[] k = &#123;-1, 0, 1&#125;; for(int i = 0; i &lt; 3; i++)&#123; int curi = a + k[i]; for(int j = 0; j &lt; 3; j++)&#123; int curj = b + k[j]; if(curi &gt;= 0 &amp;&amp; curj &gt;= 0 &amp;&amp; curi &lt; x.length &amp;&amp; curj &lt; x[0].length &amp;&amp; x[curi][curj] &gt; 0 &amp;&amp; !(k[i] == 0 &amp;&amp; k[j] == 0))&#123; cnt++; &#125; &#125; &#125; return cnt;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"287. Find the Duplicate Number","slug":"287-Find-the-Duplicate-Number","date":"2016-07-05T13:10:32.000Z","updated":"2016-07-05T14:10:56.000Z","comments":true,"path":"2016/07/05/287-Find-the-Duplicate-Number/","link":"","permalink":"http://duyao.github.io/2016/07/05/287-Find-the-Duplicate-Number/","excerpt":"","text":"287. Find the Duplicate Number 思路1该题目思路是与处理链表中带环位置相同的142. Linked List Cycle II过程1 - 设置快慢两个指针，快指针一次走两步，慢指针一次走一步，在点a两个指针相遇过程2 - 快指针从头开始，慢指针从A点开始，两个指针都一次走一步，则他们必在入环位置相遇 证明 过程1 - 快指针走的路程为2s，慢指针走的路程为s，圆环长度为c，n为绕的圈数则 s + n c = 2s ==&gt; s = n c …..①从开始到入环位置距离为x，相遇点A到入环位置为a则 s = x + a …②结合①②得到 x + a = n c ==&gt; x = (n-1) c + c-a即过程2 就是 x = (n-1) * c + c-a的过程 在本题目中没有链表和指针，但是题目已经表示nums中的值都是[1 , n]的数字因此可以模拟指针的过程 代码1234567891011121314public int findDuplicate(int[] nums) &#123; int fast = nums[0]; int slow = 0; while (fast != slow) &#123; fast = nums[nums[fast]]; slow = nums[slow]; &#125; fast = 0; while (fast != slow) &#123; fast = nums[fast]; slow = nums[slow]; &#125; return slow;&#125; 思路2二分找到中间数，然后计算数组中小于和大于中间数的个数，个数哪边大就说明那个方向有重复数字继续遍历，缩小范围，直到找到该数字为止 123456789101112131415161718192021public int findDuplicate1(int[] nums) &#123; int s = 0; int e = nums.length - 1; while (s &lt; e) &#123; int cnt = 0; int m = (s + e) / 2; // 遍历所有的数字 for (int i = 0; i &lt; nums.length; i++) &#123; if (nums[i] &lt;= m) &#123; cnt++; &#125; &#125; if (m &lt; cnt) &#123; e = m; &#125; else &#123; s = m + 1; &#125; &#125; return s;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"268. Missing Number","slug":"268-Missing-Number","date":"2016-07-05T05:11:04.000Z","updated":"2016-08-07T02:45:12.000Z","comments":true,"path":"2016/07/05/268-Missing-Number/","link":"","permalink":"http://duyao.github.io/2016/07/05/268-Missing-Number/","excerpt":"","text":"268. Missing Number 方法一思路利用[0, n]的区间内和是(0 + n) * (n + 1) / 2因为缺少一个数，那么和减去数组中的所有数字就是剩下的 方法二思路利用a ^ b ^b = a由于nums[i] = i因此最后剩下的就是缺少的数字例如k = k ^ i ^ nums[i]i = {0,1,2,3}nums = {0,2,3,4}k = 4最后只剩下1没有消除因此缺少1 与改题目类似的还有136. Single Numbera ^ b ^b = a 代码1234567891011public int missingNumber(int[] nums) &#123; int k = nums.length; for (int i = 0; i &lt; nums.length; i++) &#123; // 可能会溢出 // k = k ^ i ^ nums[i]; k ^= i; k ^= nums[i]; &#125; System.out.println(k); return k;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"363. Max Sum of Rectangle No Larger Than K","slug":"363-Max-Sum-of-Rectangle-No-Larger-Than-K","date":"2016-06-27T13:22:49.000Z","updated":"2017-02-24T07:23:32.000Z","comments":true,"path":"2016/06/27/363-Max-Sum-of-Rectangle-No-Larger-Than-K/","link":"","permalink":"http://duyao.github.io/2016/06/27/363-Max-Sum-of-Rectangle-No-Larger-Than-K/","excerpt":"","text":"363. Max Sum of Rectangle No Larger Than K Max Sum of Rectangle思路Max Sum of Rectangle 通过控制左右来遍历区间列的和，对于每个列的和，找到最大值 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546//找出最大的public int maxSumSubmatrix0(int[][] matrix, int k) &#123; int maxSum = Integer.MIN_VALUE; int up = 0; int down = 0; int right = 0; int left = 0; for (int i = 0; i &lt; matrix[0].length; i++) &#123; int a[] = new int[matrix.length]; for (int j = i; j &lt; matrix[0].length; j++) &#123; // 填充a for (int h = 0; h &lt; matrix.length; h++) &#123; a[h] += matrix[h][j]; &#125; // 找到该列最大值 int tmpSum = 0; int s = 0; int e = 0; int dp[] = new int[a.length]; dp[0] = a[0] &gt; 0 ? a[0] : 0; for (int h = 1; h &lt; a.length; h++) &#123; dp[h] = dp[h-1] + a[h] &gt; 0 ? dp[h-1] + a[h] : 0; if (dp[h] &gt; tmpSum) &#123; tmpSum = dp[h]; if (dp[h - 1] &gt; 0) &#123; e = h; &#125; else &#123; s = h; &#125; &#125; &#125; if (tmpSum &gt; maxSum) &#123; maxSum = tmpSum; up = s; down = e; left = i; right = j; &#125; &#125; &#125; System.out.println(&quot;up&quot;+up+&quot;down&quot;+down+&quot;left&quot;+left+&quot;right&quot;+right); return maxSum;&#125; Max Sum of Rectangle No Larger Than K思路与前面的方法相似，对于处理列和有所变化这里使用set来记录所有子串的和(从0到所有位置),sum表示当前从0到该位置的和a + b = suma是set中记录的值，b是我们所有的值，题目中要求 b &lt;= k那么 sum - a &lt;= k , a &gt;= sum - k那么只要找到set中最小的sum-k即可，这就是treeset中的ceiling方法 Integer java.util.TreeSet.ceiling(Integer e)Returns the least element in this set greater than or equal to the given element, or null if there is no such element. 代码1234567891011121314151617181920212223242526272829303132333435363738//最大且小于kpublic int maxSumSubmatrix(int[][] matrix, int k) &#123; int maxSum = Integer.MIN_VALUE; int up = 0; int down = 0; int right = 0; int left = 0; for (int i = 0; i &lt; matrix[0].length; i++) &#123; int a[] = new int[matrix.length]; for (int j = i; j &lt; matrix[0].length; j++) &#123; // 填充a for (int h = 0; h &lt; matrix.length; h++) &#123; a[h] += matrix[h][j]; &#125; // 找到最大值 int tmpSum = 0; TreeSet&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;(); //结果是本身，比如a=[1,2],k=1 set.add(0); for (Integer integer : a) &#123; tmpSum += integer; Integer tmp = set.ceiling(tmpSum - k); if(tmp != null)&#123; maxSum = Math.max(maxSum, tmpSum - tmp); &#125; set.add(tmpSum); &#125; &#125; &#125; return maxSum;&#125; Smallest subarray with sum greater than a given valuegreater than a given value","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"}]},{"title":"316. Remove Duplicate Letters","slug":"316-Remove-Duplicate-Letters","date":"2016-05-12T09:06:52.000Z","updated":"2016-05-12T12:52:20.000Z","comments":true,"path":"2016/05/12/316-Remove-Duplicate-Letters/","link":"","permalink":"http://duyao.github.io/2016/05/12/316-Remove-Duplicate-Letters/","excerpt":"","text":"316. Remove Duplicate Letters 区间寻找思路找到每个字母出现的最后位置，把整个串化为若干个区间，找到每个区间的最小值，然后把字符串中最小值删除 TIPS 区间开始一定是最小值第一次出现的地方 区间结束是该原来的end或者新的end 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public static int findMinPos(HashMap&lt;Character, Integer&gt; map) &#123; int pos = Integer.MAX_VALUE; for (char c : map.keySet()) &#123; int x = map.get(c); if (x &lt; pos) &#123; pos = x; &#125; &#125; return pos;&#125;/** * 找到所有字母最后出现的位置，然后按照这些位置依次划分区间，找到每个区间中最小的字母 * * @param s * @return */public String removeDuplicateLetters(String s) &#123; if (s == null || s.length() == 0) &#123; return &quot;&quot;; &#125; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); char[] c = s.toCharArray(); for (int i = 0; i &lt; c.length; i++) &#123; map.put(c[i], i); &#125; int start = 0, end = findMinPos(map); char[] res = new char[map.size()]; char min = &apos;z&apos; + 1; for (int j = 0; j &lt; res.length; j++) &#123; // 区间内部找最小值 for (int i = start; i &lt;= end; i++) &#123; //这里一定是c[i] &lt; min，无等号，这样才能找到一个min出现的位置 if (c[i] &lt; min &amp;&amp; map.containsKey(c[i])) &#123; min = c[i]; start = i + 1; &#125; &#125; // 先remove掉min，后面才可以重新查找 res[j] = min; map.remove(min); if (min == c[end]) &#123; end = findMinPos(map); &#125; // 重置min min = &apos;z&apos; + 1; &#125; return new String(res);&#125; referenceeasy-to-understand-iterative-java-solution 栈思路 int[] count: 记录每个字母出现的次数 boolean[] b: 是否已经被记录过 Stack stack: 结果集当栈中栈顶元素比当前元素大，且元素没有被记录过，以后还会出现的，出栈顶即栈中元素就是结果集，比栈顶大的元素才可以进栈 代码1234567891011121314151617181920212223242526public String removeDuplicateLetters(String s) &#123; int[] count = new int[26]; boolean[] b = new boolean[26]; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); char[] c = s.toCharArray(); for (int i = 0; i &lt; c.length; i++) &#123; count[c[i]-&apos;a&apos;]++; &#125; for (int i = 0; i &lt; c.length; i++) &#123; count[c[i]-&apos;a&apos;]--; while(!stack.isEmpty() &amp;&amp; stack.peek() &gt; c[i] &amp;&amp; !b[c[i]-&apos;a&apos;]&amp;&amp; count[stack.peek()-&apos;a&apos;] &gt; 0)&#123; b[stack.peek()-&apos;a&apos;] = false; stack.pop(); &#125; if(!b[c[i]-&apos;a&apos;])&#123; stack.push(c[i]); b[c[i]-&apos;a&apos;] = true; &#125; &#125; StringBuffer sb = new StringBuffer(); while(!stack.isEmpty())&#123; sb.insert(0,stack.pop()); &#125; return sb.toString();&#125; referencejava-solution-using-stack-with-comments","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"315. Count of Smaller Numbers After Self","slug":"315-Count-of-Smaller-Numbers-After-Self","date":"2016-05-10T13:20:45.000Z","updated":"2016-05-12T09:07:30.000Z","comments":true,"path":"2016/05/10/315-Count-of-Smaller-Numbers-After-Self/","link":"","permalink":"http://duyao.github.io/2016/05/10/315-Count-of-Smaller-Numbers-After-Self/","excerpt":"","text":"315. Count of Smaller Numbers After Self 多种解法 二分搜索思路 list存储有序的数字 从最后开始，将该数组分为两部分一部分是没有排序的前面一部分是有序的后面，存储在list中 对于位置i的元素x利用二分找到x应该插入的list的坐标po，因为list 有序，所以po同时也表示在list中有po个数字小于x则这个po就是应该整个数组中小于x的右边元素的个数 代码12345678910111213141516171819202122232425262728293031323334353637//binary searchpublic static List&lt;Integer&gt; countSmaller(int[] nums) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if(nums == null || nums.length == 0)&#123; return list; &#125; //init List&lt;Integer&gt; sorted = new ArrayList&lt;Integer&gt;(); sorted.add(nums[nums.length-1]); list.add(0); for(int i = nums.length-2; i &gt;= 0; i--)&#123; int po = getIndex(nums[i], sorted); sorted.add(po,nums[i]); list.add(po); &#125; //reverse Collections.reverse(list); return list; &#125;//smaller exclude equalpublic static int getIndex(int val, List&lt;Integer&gt; sorted)&#123; int i = 0; int j = sorted.size(); int mid; while(i &lt; j)&#123; mid = (i+j)/2; if(val &lt;= sorted.get(mid))&#123; j = mid; &#125;else&#123; i = mid+1; &#125; &#125; return i;&#125; Merge Sort思路利用merge sort思想，排序保存下标在index中将数组分为左右两个组，左边组合并时候要加上右边组合并的个数 过程分析int[] nums = {12,34,4,3,7,5,2,6,1};start = 0, end = 1nums-&gt;12,34,4,3,7,5,2,6,1,index-&gt;0,1,2,3,4,5,6,7,8,result-&gt;0,0,0,0,0,0,0,0,0,start = 0, end = 2nums-&gt;12,34,4,3,7,5,2,6,1,index-&gt;2,0,1,3,4,5,6,7,8,result-&gt;1,1,0,0,0,0,0,0,0,start = 3, end = 4nums-&gt;12,34,4,3,7,5,2,6,1,index-&gt;2,0,1,3,4,5,6,7,8,result-&gt;1,1,0,0,0,0,0,0,0,start = 0, end = 4nums-&gt;12,34,4,3,7,5,2,6,1,index-&gt;3,2,4,0,1,5,6,7,8,result-&gt;3,3,1,0,0,0,0,0,0,start = 5, end = 6nums-&gt;12,34,4,3,7,5,2,6,1,index-&gt;3,2,4,0,1,6,5,7,8,result-&gt;3,3,1,0,0,1,0,0,0,start = 7, end = 8nums-&gt;12,34,4,3,7,5,2,6,1,index-&gt;3,2,4,0,1,6,5,8,7,result-&gt;3,3,1,0,0,1,0,1,0,start = 5, end = 8nums-&gt;12,34,4,3,7,5,2,6,1,index-&gt;3,2,4,0,1,8,6,5,7,result-&gt;3,3,1,0,0,2,1,1,0,start = 0, end = 8nums-&gt;12,34,4,3,7,5,2,6,1,index-&gt;8,6,3,2,5,7,4,0,1,result-&gt;7,7,3,2,4,2,1,1,0,[7, 7, 3, 2, 4, 2, 1, 1, 0] 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public List&lt;Integer&gt; countSmaller(int[] nums) &#123; if (nums == null || nums.length == 0) &#123; return new ArrayList&lt;Integer&gt;(); &#125; int[] result = new int[nums.length]; int[] sorted = new int[nums.length]; // 对该数组排序，存储的是该数字的序号，而不是值 for (int i = 0; i &lt; nums.length; i++) &#123; sorted[i] = i; &#125; mergeSort(0, nums.length - 1, nums, sorted, result); List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; result.length; i++) &#123; list.add(result[i]); &#125; return list;&#125;public void mergeSort(int start, int end, int[] nums, int[] sorted, int[] result) &#123; if (end &lt;= start) &#123; return; &#125; int mid = (start + end) / 2; mergeSort(start, mid, nums, sorted, result); mergeSort(mid + 1, end, nums, sorted, result); merge(start, end, nums, sorted, result);&#125;public void merge(int start, int end, int[] nums, int[] sorted, int[] result) &#123; int mid = (start + end) / 2; int leftIndex = start; int rightIndex = mid + 1; // 记录右边合并过的个数 int rightCnt = 0; //记录本次排序好的下标 int[] newIndex = new int[end - start + 1]; int cnt = 0; while (leftIndex &lt;= mid &amp;&amp; rightIndex &lt;= end) &#123; //比较的时候时根据已经排好序的数字进行比较 if (nums[sorted[leftIndex]] &lt;= nums[sorted[rightIndex]]) &#123; //记录较小值的下标 newIndex[cnt] = sorted[leftIndex]; //result中仍然是对应下标的小于right值 //分为两组，左边组合并时，加上右边已经合并的个数 result[sorted[leftIndex]] += rightCnt; leftIndex++; &#125; else &#123; newIndex[cnt] = sorted[rightIndex]; rightIndex++; rightCnt++; &#125; cnt++; &#125; //剩余合并 while(leftIndex &lt;= mid)&#123; newIndex[cnt++] = sorted[leftIndex]; result[sorted[leftIndex]] += rightCnt; leftIndex++; &#125; while(rightIndex &lt;= end)&#123; newIndex[cnt++] = sorted[rightIndex]; rightIndex++; &#125; //更新排序 for(int i = start; i &lt;= end; i++)&#123; sorted[i] = newIndex[i - start]; &#125;&#125; reference11ms-java-solution-using-merge-sort-with-explanationnlogn-time-space-mergesort-solution-with-detail-explanation BSThttp://www.cnblogs.com/yrbbest/p/5068550.html","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"42. Trapping Rain Water","slug":"42-Trapping-Rain-Water","date":"2016-05-06T03:49:15.000Z","updated":"2017-02-24T07:23:36.000Z","comments":true,"path":"2016/05/06/42-Trapping-Rain-Water/","link":"","permalink":"http://duyao.github.io/2016/05/06/42-Trapping-Rain-Water/","excerpt":"","text":"easy version11. Container With Most Water hard version42. Trapping Rain Water Both are Two Pointers 11. Container With Most Water1234567891011121314151617public int maxArea(int[] height) &#123; int i = 0; int j = height.length-1; int res = 0; while(i &lt; j)&#123; //面积 int tmp = (j-i) * Math.min(height[i], height[j]); res = Math.max(res, tmp); if(height[i] &gt; height[j])&#123; j--; &#125;else&#123; i++; &#125; &#125; return res;&#125; 42. Trapping Rain Water123456789101112131415161718192021222324252627282930313233public int trap(int[] height) &#123;int i = 0;int j = height.length - 1;//记录当前最大高度int curh = 0;//记录每个值的高度int[] res = new int[height.length];while (i &lt;= j) &#123; if (height[i] &gt; height[j]) &#123; // curh = Math.max(curh, height[i]); curh = Math.max(curh, height[j]); res[j] = curh; j--; &#125; else if (height[i] &lt; height[j]) &#123; curh = Math.max(curh, height[i]); res[i] = curh; i++; &#125; else &#123; curh = Math.max(curh, height[i]); res[i] = curh; res[j] = curh; i++; j--; &#125;&#125;int cnt = 0;for (int k = 0; k &lt; height.length; k++) &#123; cnt += (res[k] - height[k]);&#125;return cnt;&#125; More Reference11. Container With Most Water42. Trapping Rain Water","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"}]},{"title":"179. Largest Number","slug":"179-Largest-Number","date":"2016-05-05T13:43:16.000Z","updated":"2016-05-06T01:02:36.000Z","comments":true,"path":"2016/05/05/179-Largest-Number/","link":"","permalink":"http://duyao.github.io/2016/05/05/179-Largest-Number/","excerpt":"","text":"179. Largest Number 12345678910111213141516171819202122232425262728293031public class cp implements Comparator&lt;String&gt;&#123; @Override public int compare(String o1, String o2) &#123; //逆序 return -1*(o1+o2).compareTo(o2+o1); &#125; &#125;public String largestNumber(int[] nums) &#123; StringBuffer res = new StringBuffer(); if(nums == null || nums.length == 0)&#123; return res.toString(); &#125; ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; list.add(String.valueOf(nums[i])); &#125; Collections.sort(list, new cp()); for (String string : list) &#123; res.append(string); &#125; if(res.toString().startsWith(&quot;0&quot;))&#123; return &quot;0&quot;; &#125; return res.toString(); &#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"48. Rotate Image","slug":"48-Rotate-Image","date":"2016-05-04T13:47:43.000Z","updated":"2017-02-24T07:24:20.000Z","comments":true,"path":"2016/05/04/48-Rotate-Image/","link":"","permalink":"http://duyao.github.io/2016/05/04/48-Rotate-Image/","excerpt":"","text":"48. Rotate Image 思路clockwise rotate first reverse up to down then swap the symmetry 1231 2 3 7 8 9 7 4 14 5 6 =&gt; 4 5 6 =&gt; 8 5 27 8 9 1 2 3 9 6 3 anticlockwise rotate first reverse left to right then swap the symmetry 1231 2 3 3 2 1 3 6 94 5 6 =&gt; 6 5 4 =&gt; 2 5 87 8 9 9 8 7 1 4 7 代码123456789101112131415161718192021222324252627282930// clockwise// 1.up to down// 2. swap symmetry// anticlockwise// 1.left to right// 2.swap symmetrypublic void rotate(int[][] matrix) &#123; if (matrix == null || matrix.length == 0) &#123; return; &#125; // 1.up to down for (int i = 0; i &lt; matrix.length / 2; i++) &#123; for (int j = 0; j &lt; matrix.length; j++) &#123; int k = matrix.length - 1 - i; int tmp = matrix[i][j]; matrix[i][j] = matrix[k][j]; matrix[k][j] = tmp; &#125; &#125; // 2. swap symmetry for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = i + 1; j &lt; matrix.length; j++) &#123; int tmp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = tmp; &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"}]},{"title":"310. Minimum Height Trees","slug":"310-Minimum-Height-Trees","date":"2016-04-18T09:30:38.000Z","updated":"2017-02-23T11:35:16.000Z","comments":true,"path":"2016/04/18/310-Minimum-Height-Trees/","link":"","permalink":"http://duyao.github.io/2016/04/18/310-Minimum-Height-Trees/","excerpt":"","text":"310. Minimum Height Trees类似题目:210. Course Schedule II 思路剥洋葱法从度是1的节点开始，遍历所有的叶子节点，把该节点从其邻接点集合中删除并且当该邻接的邻接边只有1条时，加入下次将要遍历的序列中 Reference-BFS topological sort 代码1234567891011121314151617181920212223242526272829303132333435363738public List&lt;Integer&gt; findMinHeightTrees(int n, int[][] edges) &#123; if (n == 1) return Collections.singletonList(0); List&lt;Set&lt;Integer&gt;&gt; adj = new ArrayList&lt;&gt;(n); for (int i = 0; i &lt; n; ++i) &#123; adj.add(new HashSet&lt;Integer&gt;()); &#125; for (int[] edge : edges) &#123; adj.get(edge[0]).add(edge[1]); adj.get(edge[1]).add(edge[0]); &#125; List&lt;Integer&gt; leaves = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; ++i)&#123; if(adj.get(i).size() == 1)&#123; leaves.add(i); &#125; &#125; while(n &gt; 2)&#123; n -= leaves.size(); //临时存放下次要遍历的叶子 ArrayList&lt;Integer&gt; tleaves = new ArrayList&lt;Integer&gt;(); for (Integer cur : leaves) &#123; //遍历叶子队列中的点 for (Integer edge : adj.get(cur)) &#123; adj.get(edge).remove(cur); //次遍历过程中的邻接边，且改变的邻接边个数为1，添加到下次的叶子队列中 if(adj.get(edge).size() == 1)&#123; tleaves.add(edge); &#125; &#125; &#125; leaves = tleaves; &#125; return leaves;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"}]},{"title":"221. Maximal Square","slug":"221-Maximal-Square","date":"2016-04-15T07:17:00.000Z","updated":"2016-04-30T06:29:46.000Z","comments":true,"path":"2016/04/15/221-Maximal-Square/","link":"","permalink":"http://duyao.github.io/2016/04/15/221-Maximal-Square/","excerpt":"","text":"221. Maximal Square 12345678910111213141516171819202122232425262728293031public int maximalSquare(char[][] matrix) &#123; if (matrix == null || matrix.length == 0) &#123; return 0; &#125; //dp[i][j]表示以ij为右下角的含1正方型的最大边长 int res = matrix[0][0] - 48; int[][] dp = new int[matrix.length][matrix[0].length]; for (int i = 0; i &lt; matrix.length; i++) &#123; dp[i][0] = matrix[i][0] - 48; res = Math.max(res, dp[i][0]); &#125; for (int i = 0; i &lt; matrix[0].length; i++) &#123; dp[0][i] = matrix[0][i] - 48; res = Math.max(res, dp[0][i]); &#125; for (int i = 1; i &lt; matrix.length; i++) &#123; for (int j = 1; j &lt; matrix[0].length; j++) &#123; if (matrix[i][j] == &apos;0&apos;) &#123; dp[i][j] = 0; &#125; else &#123; //tmp是最该的覆盖区域 int tmp = Math.min(dp[i - 1][j], dp[i][j - 1]); //matrix[i - tmp][j - tmp]-48表示该形状左上角的数字 dp[i][j] = tmp + matrix[i - tmp][j - tmp]-48; &#125; res = Math.max(res, dp[i][j]); &#125; &#125; return res*res;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"9. Palindrome Number","slug":"9-Palindrome-Number","date":"2016-04-13T14:28:40.000Z","updated":"2016-04-18T11:23:34.000Z","comments":true,"path":"2016/04/13/9-Palindrome-Number/","link":"","permalink":"http://duyao.github.io/2016/04/13/9-Palindrome-Number/","excerpt":"","text":"9. Palindrome Number key points negative numbers overflow no extra space The break point is sum &gt;= x –&gt; (sum ==x)||(sum/10==x) source code1234567891011public boolean isPalindrome(int x) &#123; if(x &lt; 0 || (x!=0 &amp;&amp; x%10==0))&#123; return false; &#125; int sum = 0; while(x &gt; sum)&#123; sum = x%10 + sum*10; x/=10; &#125; return (sum ==x)||(sum/10==x);&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"89. Gray Code","slug":"89-Gray-Code","date":"2016-04-10T09:03:18.000Z","updated":"2016-04-10T11:30:36.000Z","comments":true,"path":"2016/04/10/89-Gray-Code/","link":"","permalink":"http://duyao.github.io/2016/04/10/89-Gray-Code/","excerpt":"","text":"89. Gray Code 方法一思路 n = 2 00 -&gt; 01 -&gt; 11 -&gt; 10 n = 3 000 -&gt; 001 -&gt; 011 -&gt; 010 -&gt;||||| 110 -&gt; 111 -&gt; 101 -&gt; 100 因此可以看出来求n的格雷码与n-1有关n的格雷码可以分为两部分第1部分是第1位，新添加的0或者1第2部分是后面的数字，可以看出来是n-1的格雷码的结果 而n的结果集是镜面对称的前一部分是0开头加上n-1结果集后一部分是1开头加上n-1结果集，而两部分结果集的顺序相反 代码12345678910111213141516171819202122232425262728public List&lt;Integer&gt; grayCode(int n) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); list.add(&quot;&quot;); if(n == 0)&#123; res.add(0); return res; &#125; for (int i = 0; i &lt; n; i++) &#123; List&lt;String&gt; tlist = new ArrayList&lt;String&gt;(); for (String s : list) &#123; String a = &quot;0&quot; + s; tlist.add(a); &#125; //mirror situation for (int j = list.size()-1; j &gt;= 0; j--) &#123; String s = list.get(j); String a = &quot;1&quot; + s; tlist.add(a); &#125; list = tlist; &#125; for (int i = 0; i &lt; list.size(); i++) &#123; int tmp = Integer.parseInt(list.get(i),2); res.add(tmp); &#125; return res;&#125; Reference : 89. Gray Code 方法二12345678public List&lt;Integer&gt; grayCode(int n) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; 1 &lt;&lt; n; i++) &#123; System.out.println(i +&quot; ^ &quot;+(i &gt;&gt; 1) +&quot; = &quot;+(i ^ (i &gt;&gt; 1))); list.add(i ^ i &gt;&gt; 1); &#125; return list;&#125; Reference : wikipedia","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"22. Generate Parentheses","slug":"22-Generate-Parentheses","date":"2016-04-09T14:34:00.000Z","updated":"2016-04-10T05:56:54.000Z","comments":true,"path":"2016/04/09/22-Generate-Parentheses/","link":"","permalink":"http://duyao.github.io/2016/04/09/22-Generate-Parentheses/","excerpt":"","text":"22. Generate Parentheses 方法一思路addPairs添加括号l表示该字符串s末尾还可以添加左括号的个数r表示该字符串s末尾还可以添加右括号的个数 对于添加括号的过程 如果r不为0，则r-1，这是添加右括号的过程 如果l不为0，则先l-1，这是添加左括号的过程，然后r+1，因为添加左括号，就要有对应的右括号进行匹配123456789101112public void addPairs(List&lt;String&gt; res, String s, int l, int r)&#123; if(l == 0 &amp;&amp; r == 0)&#123; res.add(s); return; &#125; if(r &gt; 0)&#123; addPairs(res, s+&quot;)&quot;, l, r-1); &#125; if(l &gt; 0)&#123; addPairs(res, s+&quot;(&quot;, l-1, r+1); &#125;&#125; 调用过程 string l r 3 0 ( 2 1 () 2 0 ()( 1 1 ()() 1 0 ()()( 0 1 ()()() 0 0 ()(( 0 2 ()(() 0 1 ()(()) 0 0 (( 1 2 (() 1 1 (()) 1 0 (())( 0 1 (())() 0 0 (()( 0 2 (()() 0 1 (()()) 0 0 ((( 0 3 ((() 0 2 ((()) 0 1 ((())) 0 0 代码123456789101112131415161718public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); addPairs(res, &quot;&quot;, n, 0); return res;&#125;public void addPairs(List&lt;String&gt; res, String s, int l, int r)&#123; System.out.println(&quot;|&quot;+s+&quot;|&quot;+l+&quot;|&quot;+r+&quot;|&quot;); if(l == 0 &amp;&amp; r == 0)&#123; res.add(s); return; &#125; if(r &gt; 0)&#123; addPairs(res, s+&quot;)&quot;, l, r-1); &#125; if(l &gt; 0)&#123; addPairs(res, s+&quot;(&quot;, l-1, r+1); &#125;&#125; 方法二思路全排列的思路 46. Permutations把一对括号看成一个整体插入，利用StringBuffer.insert(int offSet, String s) 代码12345678910111213141516public List&lt;String&gt; generateParenthesis(int n) &#123; Set&lt;String&gt; res = new HashSet&lt;String&gt;(); res.add(&quot;&quot;); for (int i = 0; i &lt; n; i++) &#123; Set&lt;String&gt; tres = new HashSet&lt;String&gt;(); for (int j = 0; j &lt;= i; j++) &#123; for (String string : res) &#123; StringBuffer sb = new StringBuffer(string); sb.insert(j,&quot;()&quot;); tres.add(sb.toString()); &#125; &#125; res = tres; &#125; return new ArrayList&lt;String&gt;(res);&#125; 延伸如果此题目只要求求出方法个数，用dp思路类似于96. Unique Binary Search Trees 图示中#代表空位, n表示有括号的对数, f(n)表示有n对括号时的方法总数 n = 0 //1 n = 1 //1() n = 2 //2 ()## //2.1 f(0)f(1)(##) //2.2 f(1)f(0) n = 3 ()#### //3.1 f(0)f(2)(##)## //3.2 f(1)f(1)(####) //3.3 f(2)*f(0) n = 4 ()###### //4.1 f(0)f(3)(##)#### //4.2 f(1)f(2)(####)## //4.3 f(2)f(1)(######) //4.4 f(3)f(0) 比如n = 4,4.1中，1对括号相隔0个位置，剩余3对括号的排列方法就是f(3)4.2中，1对括号相隔1个位置，则被分为2个批次，一批是f(1)，另一批是f(2)… 因此得到递推公式f(n) = f(0) * f(n-1) + f(1) * f(n-2) + f(2) * f(n-3) + … + f(n-2) * f(1) + f(n-1) * f(0)f(0) = 1","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"91. Decode Ways","slug":"91-Decode-Ways","date":"2016-04-08T12:54:24.000Z","updated":"2016-04-30T06:30:00.000Z","comments":true,"path":"2016/04/08/91-Decode-Ways/","link":"","permalink":"http://duyao.github.io/2016/04/08/91-Decode-Ways/","excerpt":"","text":"91. Decode Ways 方法一暴力递归–超时 1234567891011121314151617181920212223242526272829303132333435363738394041public int numDecodings(String s) &#123; if(s == null || s.length() == 0)&#123; return 0; &#125;else if(s.length() == 1)&#123; return 1; &#125; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); int sum = f(s, 0, 1, new ArrayList&lt;Integer&gt;()) + f(s, 0, 2, new ArrayList&lt;Integer&gt;()); System.out.println(sum); return sum;&#125;public int f(String s, int i, int j, List&lt;Integer&gt; path) &#123; int cnt = 0; //System.out.println(&quot;i=&quot; + i + &quot;,j=&quot; + j); if (j == s.length()) &#123; Integer tmp = Integer.valueOf(s.substring(i, j)); if (tmp &gt; 0 &amp;&amp; tmp &lt; 27) &#123; path.add(tmp); cnt++; path.remove(path.size() - 1); &#125; &#125; else &#123; Integer tmp = Integer.valueOf(s.substring(i, j)); if (tmp &gt; 0 &amp;&amp; tmp &lt; 27) &#123; path.add(tmp); if (j + 1 &lt;= s.length()) &#123; cnt += f(s, j, j + 1, path); &#125; if (j + 2 &lt;= s.length()) &#123; cnt += f(s, j, j + 2, path); &#125; path.remove(path.size() - 1); &#125; &#125; return cnt;&#125; 相似题目利用递归寻找所有方法131. Palindrome Partitioning解法Q131.java 方法二dp从后向前面遍历递推公式1memo[i] = (Integer.parseInt(s.substring(i, i + 2)) &lt;= 26) ? memo[i + 1] + memo[i + 2] : memo[i + 1]; 比如1314 |i|0 |1 |2 |3 |4 |||-|-|-|-|-||a[i]|1| 3| 1| 4|-||dp |4| 2| 2| 1| 1||add|{1},{4};{14}|{3}|{1},{4};{14}|-|-| 12345678910111213141516171819public int numDecodings(String s) &#123; int n = s.length(); if (n == 0) return 0; int[] memo = new int[n + 1]; memo[n] = 1; memo[n - 1] = s.charAt(n - 1) != &apos;0&apos; ? 1 : 0; for (int i = n - 2; i &gt;= 0; i--) if (s.charAt(i) == &apos;0&apos;) continue; else &#123; memo[i] = (Integer.parseInt(s.substring(i, i + 2)) &lt;= 26) ? memo[i + 1] + memo[i + 2] : memo[i + 1]; &#125; return memo[0];&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"307. Range Sum Query - Mutable","slug":"307-Range-Sum-Query-Mutable","date":"2016-04-05T14:00:14.000Z","updated":"2016-05-10T11:14:04.000Z","comments":true,"path":"2016/04/05/307-Range-Sum-Query-Mutable/","link":"","permalink":"http://duyao.github.io/2016/04/05/307-Range-Sum-Query-Mutable/","excerpt":"","text":"307. Range Sum Query - Mutable 位运算 运算 含义 x&gt;&gt;1 右移一位，x /= 2 x&lt;&lt;1 左移一位，x *= 2 `x 1` 或，如果x = 2*i,那么`x 1` = 2*i +1 x^1 异或，奇偶互换 x&amp;1 是否为奇数，x%2 线段树segment tree 原型是二叉树，叶子节点是数组元素，非叶子节点代表一段序列的和 代码1234567891011121314151617181920212223242526272829303132333435363738394041public class NumArray &#123; int[] array; int n; public NumArray(int[] nums) &#123; n = nums.length; array = new int[2*n]; //init leaves for(int i = 0; i &lt; nums.length; i++)&#123; array[n+i] = nums[i]; &#125; //init node for(int i = n - 1; i &gt;= 0; i--)&#123; array[i] = array[i &lt;&lt; 1] + array[i &lt;&lt; 1 | 1]; &#125; &#125; void update(int i, int val) &#123; array[i+n] = val; for(int j = i+n; j &gt; 0; j &gt;&gt;= 1)&#123; array[j &gt;&gt; 1] = array[j] + array[j ^ 1]; &#125; &#125; public int sumRange(int i, int j) &#123; int sum = 0; for(int l = i+n, r = j+n; l &lt; r; l &gt;&gt;= 1 , r &gt;&gt;= 1)&#123; //if left is right child, sum does not contain parent if((l&amp;1) == 1)&#123; sum += array[l++]; &#125; if((r&amp;1) == 1)&#123; sum += array[--r]; &#125; &#125; return sum+array[j+n]; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"78. Subsets","slug":"78-Subsets","date":"2016-04-04T06:18:10.000Z","updated":"2016-04-04T14:50:32.000Z","comments":true,"path":"2016/04/04/78-Subsets/","link":"","permalink":"http://duyao.github.io/2016/04/04/78-Subsets/","excerpt":"","text":"78. Subsets相似问题46. Permutations题解46 Answer 方法一思路利用bitmap所给数组是a[n]，则所有的方法总数是2^n的个数所有的组合形式是0-2^n-1的二进制数 &gt;Number of subsets for {1 , 2 , 3 } = 2^3 . why ?case possible outcomes for the set of subsets 1 -&gt; Take or dont take = 2 2 -&gt; Take or dont take = 2 3 -&gt; Take or dont take = 2therefore , total = 222 = 2^3 = { { } , {1} , {2} , {3} , {1,2} , {1,3} , {2,3} , {1,2,3} }Lets assign bits to each outcome -&gt; First bit to 1 , Second bit to 2 and third bit to 3Take = 1Dont take = 00) 0 0 0 -&gt; Dont take 3 , Dont take 2 , Dont take 1 = { }1) 0 0 1 -&gt; Dont take 3 , Dont take 2 , take 1 = {1 }2) 0 1 0 -&gt; Dont take 3 , take 2 , Dont take 1 = { 2 }3) 0 1 1 -&gt; Dont take 3 , take 2 , take 1 = { 1 , 2 }4) 1 0 0 -&gt; take 3 , Dont take 2 , Dont take 1 = { 3 }5) 1 0 1 -&gt; take 3 , Dont take 2 , take 1 = { 1 , 3 }6) 1 1 0 -&gt; take 3 , take 2 , Dont take 1 = { 2 , 3 }7) 1 1 1 -&gt; take 3 , take 2 , take 1 = { 1 , 2 , 3 }In the above logic ,Insert S[i] only if (j&gt;&gt;i)&amp;1 ==true { j E { 0,1,2,3,4,5,6,7 } i = ith element in the input array }element 1 is inserted only into those places where 1st bit of j is 1 if( j &gt;&gt; 0 &amp;1 ) ==&gt; for above above eg. this is true for sl.no.( j )= 1 , 3 , 5 , 7element 2 is inserted only into those places where 2nd bit of j is 1 if( j &gt;&gt; 1 &amp;1 ) == for above above eg. this is true for sl.no.( j ) = 2 , 3 , 6 , 7element 3 is inserted only into those places where 3rd bit of j is 1 if( j &gt;&gt; 2 &amp; 1 ) == for above above eg. this is true for sl.no.( j ) = 4 , 5 , 6 , 7Time complexity : O(n*2^n) , for every input element loop traverses the whole solution set length i.e. 2^n reference:bitmap solution 代码123456789101112131415161718192021public List&lt;List&lt;Integer&gt;&gt; subsets(int[] S) &#123; Arrays.sort(S); //所有的结果数是2^n //&lt;&lt;是左移 int totalNumber = 1 &lt;&lt; S.length; List&lt;List&lt;Integer&gt;&gt; collection = new ArrayList&lt;List&lt;Integer&gt;&gt;(totalNumber); //结果所有数字的二进制表示 for (int i=0; i&lt;totalNumber; i++) &#123; List&lt;Integer&gt; set = new LinkedList&lt;Integer&gt;(); for (int j=0; j&lt;S.length; j++) &#123; //System.out.println(&quot;i=&quot;+i+&quot;,j=&quot;+j+&quot;,i &amp; 1&lt;&lt;j=&quot;+(i &amp; (1&lt;&lt;j))); //对于每个i都把其二进制中的1添加进来 //因此把1不停的左移，就用&amp;能筛选出所有的 if ((i &amp; (1&lt;&lt;j)) != 0) &#123; set.add(S[j]); &#125; &#125; collection.add(set); &#125; return collection;&#125; 方法二思路递归遍历，有点像dfs subsets = {1 , 2 , 3 }添加顺序为{}{1}{1,2}{1,2,3}{1,3}//path.remove(path.size() - 1),此时i=3,退回i=2,添加3{2}{2,3}{3} 代码12345678910111213141516171819202122public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); res.add(new ArrayList&lt;Integer&gt;()); //添加时保证有序 Arrays.sort(nums); f(nums, 0, new ArrayList&lt;Integer&gt;(), res); return res;&#125;public void f(int[] nums, int index, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res) &#123; for (int i = index; i &lt; nums.length; i++) &#123; path.add(nums[i]); //这里添加一定要new一个，不然后面path删除元素会影响结果集 //res.add(path); res.add(new ArrayList&lt;Integer&gt;(path)); f(nums, i + 1, path, res); path.remove(path.size() - 1); &#125;&#125; 方法三思路循环遍历 在结果集中添加一个空元素 遍历每个数字2.1 ，遍历所有结果集中的结果,将这个数字添加到每个结果中2.2 更新结果集 subsets = {1 , 2 , 3 }添加顺序为{} //add empty{1} // add 1to {}, add 1 for ends{2} //add to {},{1}{1,2} //add 2 for ends{3} // add 3 to {}, {1}, {2}, {1,2}{1,3}{2,3}{1,2,3} //add 3 for ends 代码 错误一 java.util.ConcurrentModificationException12345678910for (Integer i : nums) &#123; // java.util.ConcurrentModificationException List&lt;List&lt;Integer&gt;&gt; tmp = new ArrayList&lt;List&lt;Integer&gt;&gt;(res); for (List&lt;Integer&gt; sub : tmp) &#123; List&lt;Integer&gt; tt = new ArrayList&lt;Integer&gt;(sub); tt.add(i); tmp.add(tt); &#125; res = tmp;&#125; 错误二 添加关联影响123456789for (Integer i : nums) &#123; List&lt;List&lt;Integer&gt;&gt; tmp = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for (List&lt;Integer&gt; sub : res) &#123; //这里sub添加后，res会马上改变 sub.add(i); tmp.add(sub); &#125; res.addAll(tmp);&#125; 正确代码 123456789101112131415161718public List&lt;List&lt;Integer&gt;&gt; subsets1(int[] nums)&#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); res.add(new ArrayList&lt;Integer&gt;()); Arrays.sort(nums); for (Integer i : nums) &#123; //记录本次循环添加的list,一定与res无关，不然ConcurrentModificationException List&lt;List&lt;Integer&gt;&gt; tmp = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for (List&lt;Integer&gt; sub : res) &#123; //对于sub建立副本，不然修改sub，res会改变 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(sub); list.add(i); tmp.add(list); &#125; //同步回res res.addAll(tmp); &#125; return res;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"93. Restore IP Addresses","slug":"93-Restore-IP-Addresses","date":"2016-04-01T13:22:22.000Z","updated":"2016-04-01T13:38:56.000Z","comments":true,"path":"2016/04/01/93-Restore-IP-Addresses/","link":"","permalink":"http://duyao.github.io/2016/04/01/93-Restore-IP-Addresses/","excerpt":"","text":"93. Restore IP Addresses Backtracking - 回溯 1234567891011121314151617181920212223242526272829303132public List&lt;String&gt; restoreIpAddresses(String s) &#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); if(s == null || s.length() &lt; 4)&#123; return list; &#125; for(int i = 1; i &lt; 4;i++)&#123; String s1 = s.substring(0, i); //注意判断是否超出数组长度，且每次循环前判断是否合法，这样能减少后面无用的判断 for(int j = 1; isVaild(s1) &amp;&amp; j &lt; 4 &amp;&amp; i+j &lt; s.length();j++)&#123; String s2 = s.substring(i, i+j); for(int k = 1; isVaild(s2) &amp;&amp; k &lt; 4 &amp;&amp; i+j+k &lt; s.length(); k++)&#123; String s3 = s.substring(i+j, i+j+k); String s4 = s.substring(i+j+k, s.length()); if(isVaild(s3) &amp;&amp; isVaild(s4))&#123; list.add(s1+&quot;.&quot;+s2+&quot;.&quot;+s3+&quot;.&quot;+s4); &#125; &#125; &#125; &#125; return list;&#125;public boolean isVaild(String s)&#123; if(s.length() == 1)&#123; return true; &#125;else if(s.length() == 2 &amp;&amp; s.charAt(0) != &apos;0&apos;)&#123; return true; &#125;else if(s.length() == 3 &amp;&amp; s.charAt(0) != &apos;0&apos; &amp;&amp; Integer.valueOf(s) &lt; 256)&#123; return true; &#125;else&#123; return false; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"15. 3Sum","slug":"15-3Sum","date":"2016-04-01T11:54:26.000Z","updated":"2016-04-30T06:29:56.000Z","comments":true,"path":"2016/04/01/15-3Sum/","link":"","permalink":"http://duyao.github.io/2016/04/01/15-3Sum/","excerpt":"","text":"15. 3SumTwo sum的进阶 思路一利用HashMap存储另外两个数字的和，然后遍历数组类似于Two sum的思路但是3重循环，超时1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; if (nums == null || nums.length &lt; 3) &#123; return new ArrayList&lt;List&lt;Integer&gt;&gt;(); &#125; Arrays.sort(nums); Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;List&lt;Integer&gt;&gt;(); // 3层循环,o(n^3)超时 for (int k = 0; k &lt; nums.length; k++) &#123; HashMap&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;Integer, List&lt;Integer&gt;&gt;(); for (int i = k + 1; i &lt; nums.length; i++) &#123; if (i == k + 1 || nums[i] != nums[i - 1]) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (j == i + 1 || nums[j] != nums[j - 1]) &#123; int tmp = nums[i] + nums[j]; if (!map.containsKey(tmp)) &#123; map.put(tmp, new ArrayList&lt;Integer&gt;()); &#125; List&lt;Integer&gt; list = map.get(tmp); list.add(nums[i]); list.add(nums[j]); &#125; &#125; &#125; &#125; // if (map.containsKey(-nums[k])) &#123; List&lt;Integer&gt; tmp = map.get(-nums[k]); for (int j = 0; j &lt; tmp.size(); j += 2) &#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); int s = Math.min(tmp.get(j), tmp.get(j + 1)); int b = tmp.get(j) == s ? tmp.get(j + 1) : tmp.get(j); if (s &gt; nums[k]) &#123; list.add(nums[k]); list.add(s); list.add(b); &#125; else &#123; list.add(s); if (b &gt; nums[k]) &#123; list.add(nums[k]); list.add(b); &#125; else &#123; list.add(b); list.add(nums[k]); &#125; &#125; res.add(list); &#125; &#125; &#125; return new ArrayList&lt;List&lt;Integer&gt;&gt;(res);&#125; 思路二先排序，从头开始遍历，从剩余的数字中利用两指针找和是其相反数的的两个数字这么做是因为数组有序，时间复杂度o(nnlogN)加入队列判断重复是利用Set&lt;List&lt;Integer&gt;&gt; 123456789101112131415161718192021222324public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; Arrays.sort(nums); Set&lt;List&lt;Integer&gt;&gt; res = new HashSet&lt;List&lt;Integer&gt;&gt;(); for(int i = 0; i &lt; nums.length; i++)&#123; int low = i + 1; int high = nums.length - 1; while(low &lt; high)&#123; if(nums[low] + nums[high] &lt; -nums[i])&#123; low++; &#125;else if(nums[low] + nums[high] &gt; -nums[i])&#123; high--; &#125;else&#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(nums[i]); list.add(nums[low]); list.add(nums[high]); res.add(list); low++; high--; &#125; &#125; &#125; return new ArrayList&lt;List&lt;Integer&gt;&gt;(res);&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"素数筛法及优化","slug":"素数筛法及优化","date":"2016-03-28T13:54:43.000Z","updated":"2016-03-28T14:07:42.000Z","comments":true,"path":"2016/03/28/素数筛法及优化/","link":"","permalink":"http://duyao.github.io/2016/03/28/素数筛法及优化/","excerpt":"","text":"普通素数筛法1234567891011121314151617//bitset 被置1说明是素数public static void count(BitSet set)&#123; //length() -&gt; Returns the &quot;logical size&quot; of this BitSet for(int i = 2; i &lt; set.size(); i++)&#123; //初始化，全部置1 set.set(i); &#125; for(int i = 2; i * i &lt; set.size(); i++)&#123; if(set.get(i))&#123; for(int j = 2 * i; j &lt; set.length(); j += i)&#123; //素数的倍数全部标记为非素数 set.clear(j); &#125; &#125; &#125;&#125; 线性素数筛法上面的筛选方法中，可以看出，有很多重复比如30，会被2,3,5都标记，这样重复很多次下面的方法所有数字只会被标记一次，是线性的 123456789101112131415161718192021222324public static void main(String[] args) &#123; final int N = 100000; boolean[] isNot = new boolean[N]; int[] prime = new int[N]; int cnt = 0; for(int i = 2; i &lt; N; i++)&#123; if(!isNot[i])&#123; prime[cnt++] = i; &#125; //1.每个数字都会经过这循环 //a.如果是素数，就标记素数的素数倍数，即k=p1*p2，而p1,p2都是不相同的素数，一定不会重复筛选 //b.如果是合数，就只晒出该数字和最小素数的乘积，这样筛选才不会重复。 //因为一个合数是若干素数的乘积，因为筛选过程不重复，因此只会被最小素数和另一数字乘积时选住 for(int j = 0; j &lt; cnt &amp;&amp; prime[j] * i &lt; N; j++)&#123; isNot[i * prime[j]] = true; // System.out.println(&quot;i * prime[j] = &quot;+i+&quot;*&quot;+prime[j]+&quot; = &quot;+i * prime[j]); //2.该合数是素数的倍数就退出筛选 if(i%prime[j] == 0)&#123; break; &#125; &#125; &#125;&#125; 关键之处在于2，保证了每个数字筛选一次，因为只会被其最小的素数因子筛选到！这里所有合数都可以表示成若干个素数的乘积","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"1. Two Sum","slug":"1-Two-Sum","date":"2016-03-27T09:16:36.000Z","updated":"2016-03-27T12:37:16.000Z","comments":true,"path":"2016/03/27/1-Two-Sum/","link":"","permalink":"http://duyao.github.io/2016/03/27/1-Two-Sum/","excerpt":"","text":"1. Two Sum 12345678910111213public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; if(map.containsKey(target - nums[i]))&#123; return new int[]&#123;target - nums[i],i&#125;; &#125;else&#123; map.put(nums[i], i); &#125; &#125; return null;&#125; 注意不是有序表，用两个指针不管用，本题目如果硬是凑出了有序表，时间复杂度变为O(nlog(n))","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"230. Kth Smallest Element in a BST","slug":"230-Kth-Smallest-Element-in-a-BST","date":"2016-03-26T14:58:58.000Z","updated":"2016-03-26T15:00:40.000Z","comments":true,"path":"2016/03/26/230-Kth-Smallest-Element-in-a-BST/","link":"","permalink":"http://duyao.github.io/2016/03/26/230-Kth-Smallest-Element-in-a-BST/","excerpt":"","text":"230. Kth Smallest Element in a BST 123456789101112131415161718192021public int kthSmallest(TreeNode root, int k) &#123; int cnt = vis(root.left); if(k == cnt+1)&#123; return root.val; &#125;else if(k &lt; cnt+1)&#123; 从左子树找 return kthSmallest(root.left, k); &#125;else&#123; //从右子树找 return kthSmallest(root.right, k - cnt - 1); &#125; &#125;//计算节点个数public int vis(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; return vis(root.left) + vis(root.right) + 1;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"130. Surrounded Regions","slug":"130-Surrounded-Regions","date":"2016-03-26T11:52:13.000Z","updated":"2017-03-22T12:31:02.000Z","comments":true,"path":"2016/03/26/130-Surrounded-Regions/","link":"","permalink":"http://duyao.github.io/2016/03/26/130-Surrounded-Regions/","excerpt":"","text":"130. Surrounded Regions 思路是图的遍历，类似于岛屿的个数但是边缘的全部不能被该成X因此可以先遍历所有边缘的O，即把本身和与其相连的O全部变为b 然后再顺序遍历，将b变为O，将O变为X 注意bfs遍历时，访问元素可以是入队也可以是出队 入队 如果不设置入队判断，必须是入队访问，即入队是将O变为b因为元素可能会重复入内 出队 出队访问的话，有可能会导致元素重复入队，造成死循环，因此设置是否入队标志 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576static class Node&#123; int x; int y; //记录坐标信息，不需要设置访问值，因为被访问后的值会被改变 Node(int x, int y)&#123; this.x = x; this.y = y; &#125;&#125;//只访问边界的坐标，将边界坐标o置为b，且其相邻的o也遍历置为bpublic void bfsBoundary(char[][] c, int x, int y,boolean[][] in)&#123; int len = c[0].length; int wid = c.length; int[] xx = &#123;0, 1, 0, -1&#125;; int[] yy = &#123;-1, 0, 1, 0&#125;; LinkedList&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); queue.add(new Node(x, y)); c[x][y] = &apos;b&apos;;// in[x][y] =true; while(!queue.isEmpty())&#123; Node cur = queue.poll();// c[cur.x][cur.y] = &apos;b&apos;; for(int i = 0; i &lt; xx.length; i++)&#123; int curX = cur.x + xx[i]; int curY = cur.y + yy[i];// &amp;&amp; !in[curX][curY] if( curX &gt;= 0 &amp;&amp; curX &lt; wid &amp;&amp; curY &gt;= 0 &amp;&amp; curY &lt; len &amp;&amp; c[curX][curY] == &apos;O&apos; )&#123; queue.add(new Node(curX, curY));// in[curX][curY] = true; c[curX][curY] = &apos;b&apos;; &#125; &#125; &#125;&#125;public void solve(char[][] board) &#123; if(board == null || board.length == 0)&#123; return; &#125; boolean[][] in = new boolean[board.length][board[0].length]; int len = board[0].length; int wid = board.length; //访问边缘 for(int i = 0; i &lt;len; i++)&#123; if(board[0][i] == &apos;O&apos;)&#123; bfsBoundary(board, 0, i, in); &#125; if(board[wid-1][i] == &apos;O&apos;)&#123; bfsBoundary(board, wid-1, i, in); &#125; &#125; for(int i = 0; i &lt; wid; i++)&#123; if(board[i][0] == &apos;O&apos;)&#123; bfsBoundary(board, i, 0, in); &#125; if(board[i][len-1] == &apos;O&apos;)&#123; bfsBoundary(board, i, len-1, in); &#125; &#125; //顺序访问 for(int i = 0; i &lt; wid; i++)&#123; for(int j = 0; j &lt; len; j++)&#123; if(board[i][j] == &apos;b&apos;)&#123; board[i][j] = &apos;O&apos;; &#125; else if(board[i][j] == &apos;O&apos;)&#123; board[i][j] = &apos;X&apos;; &#125; &#125; &#125;&#125; https://leetcode.com/problems/number-of-islands/#/description","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"}]},{"title":"Callable and Future","slug":"Callable-and-Future","date":"2016-03-26T07:08:55.000Z","updated":"2016-03-26T07:24:26.000Z","comments":true,"path":"2016/03/26/Callable-and-Future/","link":"","permalink":"http://duyao.github.io/2016/03/26/Callable-and-Future/","excerpt":"","text":"Callable与Runnable相似，只是Runnable无返回值A task that returns a result and may throw an exception. Implementors define a single method with no arguments called call.The Callable interface is similar to Runnable, in that both are designed for classes whose instances are potentially executed by another thread. A Runnable, however, does not return a result and cannot throw a checked exception. Future异步保存结果A Future represents the result of an asynchronous computation.Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation.The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready.Cancellation is performed by the cancel method.Additional methods are provided to determine if the task completed normally or was cancelled.Once a computation has completed, the computation cannot be cancelled. If you would like to use a Future for the sake of cancellability but not provide a usable result, you can declare types of the form Future&lt;?&gt; and return null as a result of the underlying task. 例子实现了在制定文件目录中的所有文件查找关键字的个数 计数任务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class MatchCounter implements Callable&lt;Integer&gt;&#123; private File directory; private String keyWord; private int count; MatchCounter(File directory, String keyWord)&#123; this.directory = directory; this.keyWord = keyWord; &#125; //在文件中搜索关键字 public boolean search(File file)&#123; try &#123; Scanner in = new Scanner(file); boolean found = false; while(!found &amp;&amp; in.hasNextLine())&#123; String line = in.nextLine(); if(line.contains(keyWord))&#123; found = true; &#125; &#125; return found; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); return false; &#125; &#125; @Override public Integer call() throws Exception &#123; count = 0; File[] files = directory.listFiles(); //设置多个线程来访问文件，放在结果集中 List&lt;Future&lt;Integer&gt;&gt; results = new ArrayList&lt;Future&lt;Integer&gt;&gt;(); for (File file : files) &#123; if(file.isDirectory())&#123; //是目录，开启一个计算任务 MatchCounter counter = new MatchCounter(file, keyWord); //可以存放多个Callable FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(counter); //新的任务开启并放在结果集中 results.add(task); Thread t = new Thread(task); t.start(); &#125;else&#123; //是文件，搜索关键字，计数 if(search(file))&#123; count++; &#125; &#125; &#125; //对于结果集中的所有结果，计算所有的次数 for (Future&lt;Integer&gt; future : results) &#123; //如果有些线程没有结果，就阻塞 count += future.get(); &#125; return count; &#125; &#125; Main 12345678910111213141516171819202122public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println(&quot;Enter the directory...&quot;); String directory = in.nextLine(); System.out.println(&quot;Enter the keyword...&quot;); String keyword = in.nextLine(); MatchCounter counter = new MatchCounter(new File(directory), keyword); FutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(counter); Thread t = new Thread(task); t.start(); try &#123; System.out.println(task.get() + &quot; matching files.&quot;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://duyao.github.io/tags/java/"}]},{"title":"ConcurrentHashMap","slug":"ConcurrentHashMap","date":"2016-03-25T05:43:29.000Z","updated":"2016-03-25T06:55:40.000Z","comments":true,"path":"2016/03/25/ConcurrentHashMap/","link":"","permalink":"http://duyao.github.io/2016/03/25/ConcurrentHashMap/","excerpt":"","text":"ConcurrentHashMap是Java 5中支持高并发、 高吞吐的HashMap。它的关键技术是：锁分离技术。 它使用了多个锁来控制对hash表的不同部分进行修改。 实现ConcurrentHashMap包含了两个静态内部类： HashEntry用来封装映射表的键值对 Segment用来充当锁的角色， 是一种可重入锁ReentrantLock 利用了锁分离技术来保护不同的segment ConcurrentHashMap中的Segment就管理若干个的HashTable， 每个HashTable由多个HashEntry组成。 每个Segment持有自己的锁， 只要修改操作发生在不同的Segment上， 就可以并发执行 具体实现每个Segment对象守护整个散列表的若干个桶，每个桶由若干个HashEntry对象连接起来的 ConcurrentHashMap是弱一致的ConcurrentHashMap进行操作时， put操作将一个元素加入到底层数据结构后，get可能在某段时间内还看不到这个元素。ConcurrentHashMap的弱一致性主要是为了提升效率， 是一致性与效率之间的一种权衡。要成为强一致性， 就得到处使用锁， 甚至是全局锁， 这就与Hashtable和同步的HashMap一样了 深度好文探索 ConcurrentHashMap 高并发性的实现机制","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://duyao.github.io/tags/java/"}]},{"title":"Blocking Queue","slug":"Blocking-Queue","date":"2016-03-25T01:33:46.000Z","updated":"2016-03-25T05:44:38.000Z","comments":true,"path":"2016/03/25/Blocking-Queue/","link":"","permalink":"http://duyao.github.io/2016/03/25/Blocking-Queue/","excerpt":"","text":"IntroductionA Queue that additionally supports operations that wait for the queue to become non-empty when retrieving an element, and wait for space to become available in the queue when storing an element. BlockingQueue methods come in four forms, with different ways of handling operations that cannot be satisfied immediately, but may be satisfied at some point in the future: one throws an exception, the second returns a special value (either null or false, depending on the operation), the third blocks the current thread indefinitely until the operation can succeed, and the fourth blocks for only a given maximum time limit before giving up. These methods are summarized in the following table: Throws exception Special value Blocks Times out Insert add(e) offer(e) put(e) offer(e, time, unit) Remove remove() poll() take() poll(time, unit) Examine element() peek() not applicable not applicable A BlockingQueue does not accept null elements. Implementations throw NullPointerException on attempts to add, put or offer a null. A null is used as a sentinel value to indicate failure of poll operations. A BlockingQueue may be capacity bounded. At any given time it may have a remainingCapacity beyond which no additional elements can be put without blocking. A BlockingQueue without any intrinsic capacity constraints always reports a remaining capacity of Integer.MAX_VALUE. BlockingQueue implementations are designed to be used primarily for producer-consumer queues, but additionally support the Collection interface. So, for example, it is possible to remove an arbitrary element from a queue using remove(x). However, such operations are in general not performed very efficiently, and are intended for only occasional use, such as when a queued message is cancelled. BlockingQueue implementations are thread-safe. All queuing methods achieve their effects atomically using internal locks or other forms of concurrency control. However, the bulk Collection operations addAll, containsAll, retainAll and removeAll are not necessarily performed atomically unless specified otherwise in an implementation. So it is possible, for example, for addAll(c) to fail (throwing an exception) after adding only some of the elements in c. A BlockingQueue does not intrinsically support any kind of “close” or “shutdown” operation to indicate that no more items will be added. The needs and usage of such features tend to be implementation-dependent. For example, a common tactic is for producers to insert special end-of-stream or poison objects, that are interpreted accordingly when taken by consumers. Usage example, based on a typical producer-consumer scenario. Note that a BlockingQueue can safely be used with multiple producers and multiple consumers. Implementation ArrayBlockingQueue DelayQueue LinkedBlockingQueue PriorityBlockingQueue SynchronousQueue Example该例子实现了一个在所给目录的所有文件中找关键字的方法其本质是生产者和消费者问题，一个向队列中插入文件，另一个在该队列中取出文件这个队列的实现是利用BlockingQueue做到取出为空时阻塞，添加满时阻塞1234567891011121314151617public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); System.out.println(&quot;Enter the file directory...&quot;); String directory = in.nextLine(); System.out.println(&quot;Enter the keyword...&quot;); String keyword = in.nextLine(); //10个队列 BlockingQueue&lt;File&gt; queue = new ArrayBlockingQueue&lt;File&gt;(10); //1个生产者 FileEnumrationTask task = new FileEnumrationTask(queue, new File(directory)); new Thread(task).start(); //100个消费者 for (int i = 0; i &lt; 100; i++) &#123; new Thread(new SearchTask(queue, keyword)).start(); &#125;&#125; 文件遍历类是一个生产者，向队列中添加所给目录中的所有文件123456789101112131415161718192021222324252627282930313233343536class FileEnumrationTask implements Runnable&#123; public static File DUMMY = new File(&quot;&quot;); private BlockingQueue&lt;File&gt; queue; private File startingDirectory; public FileEnumrationTask(BlockingQueue&lt;File&gt; queue, File startingDirectory) &#123; this.queue = queue; this.startingDirectory = startingDirectory; &#125; public void enumerate(File directory) throws InterruptedException&#123; File[] files = directory.listFiles(); for (File file : files) &#123; if(file.isDirectory())&#123; enumerate(file); &#125;else&#123; queue.put(file); &#125; &#125; &#125; @Override public void run() &#123; try &#123; enumerate(startingDirectory); queue.put(DUMMY); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 单词查找类是消费者，负责都队列中取出文件，然后在该文件中找关键字1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class SearchTask implements Runnable&#123; private BlockingQueue&lt;File&gt; queue; private String keyword; public SearchTask(BlockingQueue&lt;File&gt; queue, String keyword) &#123; this.queue = queue; this.keyword = keyword; &#125; public void search(File file)&#123; try &#123; Scanner in = new Scanner(file); int lineNum = 0; while(in.hasNextLine())&#123; lineNum++; String line = in.nextLine(); if(line.contains(keyword))&#123; System.out.printf(&quot;%s : %d : %s%n&quot;,file.getPath(), lineNum, line); &#125; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; boolean done = false; try &#123; while(!done)&#123; File file = queue.take(); if(file == FileEnumrationTask.DUMMY)&#123; queue.put(file); done = true; &#125;else&#123; search(file); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; Rerfenceshttps://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.htmlhttps://www.ibm.com/developerworks/cn/java/j-tiger06164/","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://duyao.github.io/tags/java/"}]},{"title":"字典树","slug":"字典树","date":"2016-03-24T12:59:19.000Z","updated":"2016-03-28T14:14:28.000Z","comments":true,"path":"2016/03/24/字典树/","link":"","permalink":"http://duyao.github.io/2016/03/24/字典树/","excerpt":"","text":"字典树通常用于查找字符串，比如在搜索框中搜索会自动提示，或者lucene常用操作有 插入和查找, 删除 代码习题 208. Implement Trie (Prefix Tree) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public static class TrieNode &#123; char val; TrieNode[] children; boolean leaf; // Initialize your data structure here. public TrieNode() &#123; this.children = new TrieNode[26]; leaf = false; &#125; public TrieNode(char c) &#123; this.val = c; children = new TrieNode[26]; leaf = false; &#125;&#125;public static class Trie &#123; private TrieNode root; public Trie() &#123; root = new TrieNode(); &#125; // Inserts a word into the trie. public void insert(String word) &#123; TrieNode cur = root; for (int i = 0; i &lt; word.length(); i++) &#123; int index = word.charAt(i) - &apos;a&apos;; TrieNode tmp = cur.children[index]; if (tmp == null) &#123; tmp = new TrieNode(word.charAt(i)); cur.children[index] = tmp; &#125; if (i == word.length() - 1) &#123; tmp.leaf = true; &#125; cur = tmp; &#125; &#125; // Returns if the word is in the trie. public boolean search(String word) &#123; TrieNode cur = root; for (int i = 0; i &lt; word.length(); i++) &#123; int index = word.charAt(i) - &apos;a&apos;; TrieNode tmp = cur.children[index]; if (tmp != null) &#123; if (i == word.length() - 1 &amp;&amp; tmp.leaf) &#123; return true; &#125; cur = tmp; &#125; else &#123; // 无此节点 return false; &#125; &#125; return false; &#125; // Returns if there is any word in the trie // that starts with the given prefix. public boolean startsWith(String prefix) &#123; TrieNode cur = root; for (int i = 0; i &lt; prefix.length(); i++) &#123; int index = prefix.charAt(i) - &apos;a&apos;; TrieNode tmp = cur.children[index]; if (tmp != null) &#123; cur = tmp; &#125; else &#123; // 无此节点 return false; &#125; &#125; //prefix是该字符串也可以 return true; &#125;&#125;// Your Trie object will be instantiated and called as such:// Trie trie = new Trie();// trie.insert(&quot;somestring&quot;);// trie.search(&quot;key&quot;);","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"Comparator and Comparable","slug":"Comparator and Comparable","date":"2016-03-21T04:55:47.000Z","updated":"2017-05-04T02:59:14.000Z","comments":true,"path":"2016/03/21/Comparator and Comparable/","link":"","permalink":"http://duyao.github.io/2016/03/21/Comparator and Comparable/","excerpt":"","text":"比较在集合框架中有两种比较接口： Comparable 接口和 Comparator 接口。Comparable 是通用的接口，用户可以实现它来完成自己特定的比较，在java.lang下Comparator 可以看成一种算法的实现，在需要容器集合实现比较功能的时候，来指定这个比较器，这可以看成一种设计模式，将算法和数据分离，在java.util下。 前者应该比较固定，和一个具体类相绑定，而后者比较灵活，它可以被用于各个需要比较功能的类使用。 一个类实现了 Camparable 接口表明这个类的对象之间是可以相互比较的。如果用数学语言描述的话就是这个类的对象组成的集合中存在一个全序。这样，这个类对象组成的集合就可以使用 Sort 方法排序了。 而 Comparator 的作用有两个，体现了策略模式，就是不改变对象自身，而用一个策略对象（strategy object）来改变它的行为：1 、如果类的设计师没有考虑到 Compare 的问题而没有实现 Comparable 接口，可以通过 Comparator 来实现比较算法进行排序；2 、为了使用不同的排序标准做准备，比如：升序、降序或其他什么序。 Comparator我们如果需要控制某个类的次序，而该类本身不支持排序（即没有实现Comparable接口）；那么可以建立一个该类的比较器来排序，这个比较器只需要实现Comparator接口即可。 通过实现Comparator类来新建一个比较器，然后通过该比较器来对类进行排序。Comparator 接口其实就是一种策略模式的实践 若一个类要实现Comparator接口：它一定要实现compareTo(T o1, T o2)函数，但可以不实现 equals(Object obj) 函数 Comparatable若一个类实现了Comparable接口，就意味着“该类支持排序”。 即然实现Comparable接口的类支持排序，假设现在存在“实现Comparable接口的类的对象的List列表(或数组)”，则该List列表(或数组)可以通过 Collections.sort（或 Arrays.sort）进行排序。 此外，“实现Comparable接口的类的对象”可以用作“有序映射(如TreeMap)”中的键或“有序集合(TreeSet)”中的元素，而不需要指定比较器。 假设我们通过 x.compareTo(y) 来“比较x和y的大小”。若返回“负数”，意味着“x比y小”；返回“零”，意味着“x等于y”；返回“正数”，意味着“x大于y”。 类型 排序方法 BigDecimal,BigInteger,Byte,Double, Float,Integer,Long,Short 按数字大小排序 Character 按 Unicode 值的数字大小排序 String 按字符串中字符 Unicode 值排序 例子 Item.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Item implements Comparable&lt;Item&gt;&#123; private String description; private int partNum; public Item(String des, int num)&#123; this.description = des; this.partNum = num; &#125; public String getDescription()&#123; return this.description; &#125; public int getPartNum()&#123; return this.partNum; &#125; @Override public String toString() &#123; return &quot;[&quot; + description + &quot;,&quot; + partNum + &quot;]&quot;; &#125;// @Override// public int hashCode() &#123;// return Objects.hash(description, partNum);// &#125;// @Override// public boolean equals(Object obj) &#123;// if(this == obj) return true;// if(obj == null) return false;// if(this.getClass() != obj.getClass()) return false;// // Item i = (Item) obj;// return Objects.equals(this.description, i.description) &amp;&amp; this.partNum == i.partNum;// &#125; @Override public int compareTo(Item o) &#123; return Integer.compare(partNum, o.partNum); &#125;&#125; Main 123456789101112131415161718192021222324252627282930313233343536373839404142public static void main(String[] args) &#123; SortedSet&lt;Item&gt; mySet = new TreeSet(); //Item中是按照partNum进行比较的 mySet.add(new Item(&quot;To&quot;, 9234)); mySet.add(new Item(&quot;Wi&quot;, 362)); mySet.add(new Item(&quot;Mo&quot;, 1912)); mySet.add(new Item(&quot;Mo&quot;, 12)); mySet.add(new Item(&quot;Mo&quot;, 342)); System.out.println(mySet); //使用comparator，类Item可以没有实现comparable //新建TreeSet通过传入比较器comparator来完成 SortedSet&lt;Item&gt; setByDes = new TreeSet&lt;Item&gt;(new Comparator&lt;Item&gt;() &#123; @Override public int compare(Item o1, Item o2) &#123; //先按照des排序，对于相等的des则按照partNum排序 String aDes = o1.getDescription(); String bDes = o2.getDescription(); if(aDes.compareTo(bDes) &gt; 0)&#123; return 1; &#125;else if(aDes.compareTo(bDes) &lt; 0)&#123; return -1; &#125;else&#123; //注意前面有符号-，表示逆序，从大到小的顺序 return -Integer.compare(o1.getPartNum(), o2.getPartNum()); &#125; //按照des排序，对于des相同，则只显示最小的partNum// return aDes.compareTo(bDes); &#125; &#125;);// setByDes.addAll(mySet); setByDes.add(new Item(&quot;To&quot;, 9234)); setByDes.add(new Item(&quot;Wi&quot;, 362)); setByDes.add(new Item(&quot;Mo&quot;, 1912)); setByDes.add(new Item(&quot;Mo&quot;, 12)); setByDes.add(new Item(&quot;Mo&quot;, 342)); System.out.println(setByDes);&#125; http://blog.csdn.net/mageshuai/article/details/3849143http://www.cnblogs.com/sunflower627/p/3158042.html","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://duyao.github.io/tags/java/"}]},{"title":"红黑树","slug":"红黑树","date":"2016-03-19T05:01:16.000Z","updated":"2016-03-28T14:14:24.000Z","comments":true,"path":"2016/03/19/红黑树/","link":"","permalink":"http://duyao.github.io/2016/03/19/红黑树/","excerpt":"","text":"红黑树Red-Black Tree(R B-tree) 性质本质是一个有限制的二叉搜索树BST,即每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。 红黑树示例 每个结点不是红色就是黑色 根节点一定是黑色 红色结点的子节点一定全部都是黑色 每个叶子节点(叶结点即指树尾端NIL指针或NULL结点)一定是黑色 对于任意一个节点，其到叶子节点NIL的路径中黑色节点的个数都是相同的(确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树) 一棵含有n个节点的红黑树的高度至多为2log(n+1) 操作树的左旋与右旋 左旋指的是该节点旋转后，变为左孩子，该节点的右孩子变为其父亲 右旋指的是该节点旋转后，变为右孩子，该节点的左孩子变为其父亲 不论左旋还是右旋指的都是该被旋转节点变为左或右孩子 左旋与右旋 1234567891011121314151617181920212223242526LEFT-ROTATE(T, x) y ← right[x] // 前提：这里假设x的右孩子为y。下面开始正式操作 right[x] ← left[y] // 将 “y的左孩子” 设为 “x的右孩子”，即 将β设为x的右孩子 p[left[y]] ← x // 将 “x” 设为 “y的左孩子的父亲”，即 将β的父亲设为x p[y] ← p[x] // 将 “x的父亲” 设为 “y的父亲” if p[x] = nil[T] then root[T] ← y // 情况1：如果 “x的父亲” 是空节点，则将y设为根节点 else if x = left[p[x]] then left[p[x]] ← y // 情况2：如果 x是它父节点的左孩子，则将y设为“x的父节点的左孩子” else right[p[x]] ← y // 情况3：(x是它父节点的右孩子) 将y设为“x的父节点的右孩子” left[y] ← x // 将 “x” 设为 “y的左孩子” p[x] ← y // 将 “x的父节点” 设为 “y” RIGHT-ROTATE(T, y) x ← left[y] // 前提：这里假设y的左孩子为x。下面开始正式操作 left[y] ← right[x] // 将 “x的右孩子” 设为 “y的左孩子”，即 将β设为y的左孩子 p[right[x]] ← y // 将 “y” 设为 “x的右孩子的父亲”，即 将β的父亲设为y p[x] ← p[y] // 将 “y的父亲” 设为 “x的父亲” if p[y] = nil[T] then root[T] ← x // 情况1：如果 “y的父亲” 是空节点，则将x设为根节点 else if y = right[p[y]] then right[p[y]] ← x // 情况2：如果 y是它父节点的右孩子，则将x设为“y的父节点的左孩子” else left[p[y]] ← x // 情况3：(y是它父节点的左孩子) 将x设为“y的父节点的左孩子” right[x] ← y // 将 “y” 设为 “x的右孩子” p[y] ← x // 将 “y的父节点” 设为 “x” 插入节点插入节点一共有有3步→1. [插入]把红黑树当做二叉查找树，插入节点→2. [着色]把插入的节点置为红色 插入节点的父节点为黑色，结束 插入节点的父节点为红色，进入3修复 →3. [修复]根据5种情况进行旋转，使之成为符合要求的红黑树前提是父节点红色 插入情况 删除节点将红黑树内的某一个节点删除。需要执行的操作依次是：首先，将红黑树当作一颗二叉查找树，将该节点从二叉查找树中删除；然后，通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。 详细描述如下：第一步：将红黑树当作一颗二叉查找树，将节点删除。这和”删除常规二叉查找树中删除节点的方法是一样的”。分3种情况：① 被删除节点没有儿子，即为叶节点。那么，直接将该节点删除就OK了。② 被删除节点只有一个儿子。那么，直接删除该节点，并用该节点的唯一子节点顶替它的位置。③ 被删除节点有两个儿子。那么，先找出它的后继节点；然后把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。在这里，后继节点相当于替身，在将后继节点的内容复制给”被删除节点”之后，再将后继节点删除。这样就巧妙的将问题转换为”删除后继节点”的情况了，下面就考虑后继节点。 在”被删除节点”有两个非空子节点的情况下，它的后继节点不可能是双子非空。既然”的后继节点”不可能双子都非空，就意味着”该节点的后继节点”要么没有儿子，要么只有一个儿子。若没有儿子，则按”情况① “进行处理；若只有一个儿子，则按”情况② “进行处理。 第二步：通过”旋转和重新着色”等一系列来修正该树，使之重新成为一棵红黑树。 因为”第一步”中删除节点之后，可能会违背红黑树的特性。所以需要通过”旋转和重新着色”来修正该树，使之重新成为一棵红黑树。 ① 情况说明：x是“红+黑”节点。 处理方法：直接把x设为黑色，结束。此时红黑树性质全部恢复。② 情况说明：x是“黑+黑”节点，且x是根。 处理方法：什么都不做，结束。此时红黑树性质全部恢复。③ 情况说明：x是“黑+黑”节点，且x不是根。 处理方法：这种情况又可以划分为4种子情况。这4种子情况如下： Case 1 x是”黑+黑”节点，x的兄弟节点是红色。(此时x的父节点和x的兄弟节点的子节点都是黑节点)。(01) 将x的兄弟节点设为“黑色”。(02) 将x的父节点设为“红色”。(03) 对x的父节点进行左旋。(04) 左旋后，重新设置x的兄弟节点。 Case 2 x是“黑+黑”节点，x的兄弟节点是黑色，x的兄弟节点的两个孩子都是黑色。(01) 将x的兄弟节点设为“红色”。(02) 设置“x的父节点”为“新的x节点”。 Case 3 x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的。(01) 将x兄弟节点的左孩子设为“黑色”。(02) 将x兄弟节点设为“红色”。(03) 对x的兄弟节点进行右旋。(04) 右旋后，重新设置x的兄弟节点。 Case 4 x是“黑+黑”节点，x的兄弟节点是黑色；x的兄弟节点的右孩子是红色的，x的兄弟节点的左孩子任意颜色。(01) 将x父节点颜色 赋值给 x的兄弟节点。(02) 将x父节点设为“黑色”。(03) 将x兄弟节点的右子节设为“黑色”。(04) 对x的父节点进行左旋。(05) 设置“x”为“根节点”。 参考红黑树插入删除动画演示July红黑树总结深度好文 -&gt; JDK 源代码研究 TreeMap 红黑树算法实现","categories":[],"tags":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"集合和迭代器接口","slug":"集合和迭代器接口","date":"2016-03-14T01:43:21.000Z","updated":"2016-03-21T02:39:00.000Z","comments":true,"path":"2016/03/14/集合和迭代器接口/","link":"","permalink":"http://duyao.github.io/2016/03/14/集合和迭代器接口/","excerpt":"","text":"各种关系浅蓝色是接口深蓝色是类 collection的关系 Collection接口继承于接口Iterator1234567891011121314151617181920public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; int size(); boolean isEmpty(); boolean contains(Object o); Iterator&lt;E&gt; iterator(); Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); boolean add(E e); boolean remove(Object o); boolean containsAll(Collection&lt;?&gt; c); boolean addAll(Collection&lt;? extends E&gt; c); //删除所有与c中相同的元素 boolean removeAll(Collection&lt;?&gt; c); //保留与c中相同的元素，即删除与c中不同的元素 boolean retainAll(Collection&lt;?&gt; c); void clear(); boolean equals(Object o); int hashCode();&#125; Iterator接口1234567public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); void remove();&#125; 访问元素Iterator可以用于访问元素123456Collection&lt;String&gt; c = ...;Iterator&lt;String&gt; it = c.iterator();while(it.hasNext())&#123; String s = it.next(); //do something&#125; 访问元素还可用for each,并且推荐使用for each1234Collection&lt;String&gt; c = ...;for (String string : c) &#123; //do someting with string&#125; Iterator使用方法 next()java迭代器Iterator处于两个元素之间当调用next时候，迭代器就跳过元素，返回刚刚元素的引用 迭代器向前移动 remove()删除一个元素，是删除上一次next返回的元素(当前位置左边元素)remove和next具有相互依赖型，如果没有调用next，使用remove是非法的，会抛出java.lang.IllegalStateException 123456bIterator = b.iterator();bIterator.remove();bIterator.remove();//errorbIterator.next();bIterator.remove();//right AbstractCollection类实现了Collection接口设计上体现了接口与实现的分离，各个类可以实现自己的iterator和size，通用的Collection已经实现1234567public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; &#123; //iterator和size抽象化 public abstract Iterator&lt;E&gt; iterator(); public abstract int size(); //实现Collection中的方法 ...&#125;","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://duyao.github.io/tags/java/"}]},{"title":"330. Patching Array","slug":"330-Patching-Array","date":"2016-03-11T10:11:17.000Z","updated":"2016-03-14T08:55:16.000Z","comments":true,"path":"2016/03/11/330-Patching-Array/","link":"","permalink":"http://duyao.github.io/2016/03/11/330-Patching-Array/","excerpt":"","text":"330. Patching Array 思路贪心设置miss为缺少的数字，sum为当前所有选中数字的的最小和挑选miss的规则 若数组中x &lt;= sum + 1则选中x 若数组没有，就选中sum + 1为miss直到sum &gt; n 思路参考 123456789101112131415161718public int minPatches(int[] nums, int n) &#123; long miss = 0; long sum = 0; int cnt = 0; int i = 0; while (sum &lt; n) &#123; if (i &lt; nums.length &amp;&amp; nums[i] &lt;= sum + 1) &#123; sum += nums[i++]; &#125; else &#123; miss = sum + 1; sum += miss; cnt++; &#125; &#125; return cnt;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"331. Verify Preorder Serialization of a Binary Tree","slug":"331-Verify-Preorder-Serialization-of-a-Binary-Tree","date":"2016-03-09T13:08:31.000Z","updated":"2016-03-14T08:55:12.000Z","comments":true,"path":"2016/03/09/331-Verify-Preorder-Serialization-of-a-Binary-Tree/","link":"","permalink":"http://duyao.github.io/2016/03/09/331-Verify-Preorder-Serialization-of-a-Binary-Tree/","excerpt":"","text":"331. Verify Preorder Serialization of a Binary Tree 思路一砍掉叶子节点两个叶子节点访问后就将该父节点置为叶子节点，这样一个树访问完成后只剩下一个叶子节点因此需要一个栈来存放先序遍历，对于连续栈中两个##，删除##，并且将栈顶替换为#12345678910111213141516171819202122232425public boolean isValidSerialization(String preorder) &#123; if(preorder == null || preorder.length() == 0)&#123; return false; &#125; Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); String[] s = preorder.split(&quot;,&quot;); for (String string : s) &#123; //注意这里是while，因为遇到连续##就要替换 while(string.equals(&quot;#&quot;) &amp;&amp; !stack.isEmpty() &amp;&amp; stack.peek().equals(&quot;#&quot;))&#123; //将#pop stack.pop(); if(stack.empty())&#123; return false; &#125; //将栈顶元素替换为# stack.pop(); &#125; stack.push(string); &#125; if(stack.size() == 1 &amp;&amp; stack.peek().equals(&quot;#&quot;))&#123; return true; &#125; return false;&#125; 对于后序遍历，是遇到数字替换连续## 思路二入度与出度的差对于一个树来说分为叶子节点和非叶节点 非叶子结点:出度2，入度1(不包括根结点) 叶子结点：出度0，入度1 因此diff = 出度 - 入度 = 1，因为根结点入度为0所以对于一个正确的树，一定会有diff = 1且对于任何一个节点，diff都是非负数对于每一个节点进入，diff–，而若是非叶子节点，diff+=2 123456789101112public boolean isValidSerialization(String preorder) &#123; String[] nodes = preorder.split(&quot;,&quot;); int diff = 1; for (String node : nodes) &#123; if (--diff &lt; 0) return false; if (!node.equals(&quot;#&quot;)) diff += 2; &#125; return diff == 0;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"332. Reconstruct Itinerary","slug":"332-Reconstruct-Itinerary","date":"2016-03-07T13:30:07.000Z","updated":"2016-03-14T10:53:14.000Z","comments":true,"path":"2016/03/07/332-Reconstruct-Itinerary/","link":"","permalink":"http://duyao.github.io/2016/03/07/332-Reconstruct-Itinerary/","excerpt":"","text":"332. Reconstruct Itinerary 思路 要先将思维转换到图，每个点都可以看做是图上的一个点 这不是dfs，因为不只是遍历，而是顺序遍历所有路径，即一笔画欧拉路径问题 参考wikipedia Hierholzer’s algorithmEulerian Path and Circuit Fleury’s algorithmDon’t burn your bridgeFleury’s algorithm 理解Hierholzer’s algorithm建立两个栈，一个是tmp暂时暂存元素栈，一个是final最终的结果栈开始循环从图中任一点出发，任意访问相邻得点，该节点放入tmp中当一个节点周围没有相邻节点时，则将该节点从tmp移入到final中，设置当前结点为tmp的栈顶当所有边均被访问，此过程结束最后，将tmp放入final中final的出栈顺序即为路径 还有本题目有个一个重要的数据结构Map&lt;String, PriorityQueue&lt;String&gt;&gt; flightsPriorityQueue&lt;String&gt;可以排序，而map记录每个点的边集 代码递归法123456789101112131415161718192021222324Map&lt;String, PriorityQueue&lt;String&gt;&gt; flights;LinkedList&lt;String&gt; path;public List&lt;String&gt; findItinerary(String[][] tickets) &#123; flights = new HashMap&lt;&gt;(); path = new LinkedList&lt;&gt;(); for (String[] ticket : tickets) &#123; if(!flights.containsKey(ticket[0]))&#123; flights.put(ticket[0], new PriorityQueue&lt;String&gt;()); &#125; flights.get(ticket[0]).add(ticket[1]); &#125; dfs(&quot;JFK&quot;); return path;&#125;public void dfs(String departure) &#123; PriorityQueue&lt;String&gt; arrivals = flights.get(departure); //访问所有的相邻节点 while (arrivals != null &amp;&amp; !arrivals.isEmpty()) dfs(arrivals.poll()); //注意是加到队头！ path.addFirst(departure);&#125; 非递归1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//这里的flights中只包含有邻居的节点Map&lt;String, PriorityQueue&lt;String&gt;&gt; flights;//返回值LinkedList&lt;String&gt; path;public List&lt;String&gt; findItinerary(String[][] tickets) &#123; //使用优先队列来记录相邻接点且保证了字典顺序 flights = new HashMap&lt;String, PriorityQueue&lt;String&gt;&gt;(); path = new LinkedList&lt;String&gt;(); if (tickets == null || tickets.length == 0) &#123; return path; &#125; for(String[] s : tickets)&#123; if(!flights.containsKey(s[0]))&#123; flights.put(s[0], new PriorityQueue&lt;String&gt;()); &#125; flights.get(s[0]).add(s[1]); &#125; //http://www.graph-magics.com/articles/euler.php //设置一个退回栈就是circle，存放没有相邻接点的点 //1.从开始节点遍历，将每个有相邻接点的点加入到结果集stack中 //2.如果当前结点无相邻接点，则将其放入退回栈 //3.然后在结果集中逆序选取有相邻接点的点作为当前结点 //4.继续123，直到遍历过所有的边 //5.最后将结果集并入到退回栈circle中 Stack&lt;String&gt; circle = new Stack&lt;String&gt;(); Stack&lt;String&gt; stack = new Stack&lt;String&gt;(); String cur = &quot;JFK&quot;; for(int i = 0; i &lt; tickets.length; i++)&#123; while(!flights.containsKey(cur) || flights.get(cur).size() == 0)&#123; circle.add(cur); cur = stack.pop(); &#125; stack.add(cur); cur = flights.get(cur).poll(); &#125; //最后一个节点一定是没有邻接点的点，因此要放到退回栈circle中 circle.add(cur); //结果集并入到退回栈中 while(!stack.isEmpty())&#123; circle.add(stack.pop()); &#125; //退回栈的逆序为最终路径 while(!circle.isEmpty())&#123; path.add(circle.pop()); &#125; return path;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"46. Permutations","slug":"46-Permutations","date":"2016-02-18T09:47:31.000Z","updated":"2017-02-24T07:23:50.000Z","comments":true,"path":"2016/02/18/46-Permutations/","link":"","permalink":"http://duyao.github.io/2016/02/18/46-Permutations/","excerpt":"","text":"46. Permutations相似问题78. Subsets题解78 Answer 回溯法backtrack 递归和非递归 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//递归public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;List&lt;Integer&gt;&gt;(); backtrack(nums, 0, lists, new ArrayList&lt;Integer&gt;()); return lists;&#125;public static void backtrack(int[] nums, int i,List&lt;List&lt;Integer&gt;&gt; lists,List&lt;Integer&gt; curList)&#123; //个数满足，就可以添加到答案中 if(curList.size() == nums.length)&#123; lists.add(curList); //返回到上一层递归 return ; &#125; //注意循环条件是j &lt;= curList.size() //这样才能将新的数字添加到所有位置(有等于号)，且一直是对同一list做修改 for(int j = 0; j &lt;= curList.size(); j++)&#123; //获取到最新修改的list List&lt;Integer&gt; newList = new ArrayList&lt;Integer&gt;(curList); newList.add(j, nums[i]); System.out.println(&quot;add &quot;+&quot;nums[i=&quot;+i+&quot;]=&quot;+nums[i]+&quot; at pos j=&quot;+j); System.out.println(&quot;newList : &quot;); for (Integer integer : newList) &#123; System.out.print(integer + &quot; &quot;); &#125; System.out.println(); backtrack(nums, i+1, lists, newList); &#125;&#125;//非递归public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(nums == null || nums.length == 0)&#123; return list; &#125; //先添加第一个元素，并将list加入到结果集中 List&lt;Integer&gt; ll = new ArrayList&lt;Integer&gt;(); ll.add(nums[0]); list.add(ll); //对于所有元素进行添加 //第一个元素已经添加，所以从1开始 for(int i = 1; i &lt; nums.length; i++)&#123; List&lt;List&lt;Integer&gt;&gt; newList = new ArrayList&lt;List&lt;Integer&gt;&gt;(); //枚举所有的位置 //j &lt;= i表示位置始终与元素个数相关 for(int j = 0; j &lt;= i; j++)&#123; //对于所有已经存在的list，尝试添加所有位置 for (List&lt;Integer&gt; tmp : list) &#123; List&lt;Integer&gt; newLL = new ArrayList&lt;Integer&gt;(tmp); newLL.add(j,nums[i]); newList.add(newLL); &#125; &#125; //更新list，使得刚刚做的修改生效 list = newList; &#125; return list;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"}]},{"title":"49. Group Anagrams","slug":"49-Group-Anagrams","date":"2016-02-18T01:09:37.000Z","updated":"2016-02-18T01:15:36.000Z","comments":true,"path":"2016/02/18/49-Group-Anagrams/","link":"","permalink":"http://duyao.github.io/2016/02/18/49-Group-Anagrams/","excerpt":"","text":"49. Group Anagrams 这道题目有两处疑问 字符数组转化为字符串 12String s = String.valueOf(c);//String s = c.toString(); 是否建立新的List&lt;List&lt;String&gt;&gt; 1234567891011121314//对于String[] strs = &#123;&quot;&quot;,&quot;&quot;&#125;;得出的lists的大小是2//why????//List&lt;List&lt;String&gt;&gt; lists = new ArrayList&lt;List&lt;String&gt;&gt;(map.values());//for (String ss : map.keySet()) &#123;// List&lt;String&gt; list = map.get(ss);// Collections.sort(list);// lists.add(list);// &#125;for (String ss : map.keySet()) &#123; Collections.sort(map.get(ss));&#125;return new ArrayList&lt;List&lt;String&gt;&gt;(map.values());//return lists; 1234567891011121314151617181920212223242526272829303132333435363738394041public static List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; if(strs == null || strs.length == 0)&#123; return null; &#125; //key是有序字母组成，list是具有相同字母组成的字符串 HashMap&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;(); for (int i = 0; i &lt; strs.length; i++) &#123; char[] c = strs[i].toCharArray(); Arrays.sort(c); //TODO //toString得到每个都是新建的对象 String s = String.valueOf(c);// String s = c.toString(); //System.out.println(s.hashCode()); if(map.containsKey(s))&#123; map.get(s).add(strs[i]); &#125;else&#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(strs[i]); map.put(s, list); &#125; &#125; //TODO //对于String[] strs = &#123;&quot;&quot;,&quot;&quot;&#125;;得出的lists的大小是2 //why????// List&lt;List&lt;String&gt;&gt; lists = new ArrayList&lt;List&lt;String&gt;&gt;(map.values());// for (String ss : map.keySet()) &#123;// List&lt;String&gt; list = map.get(ss);// Collections.sort(list);// lists.add(list);// &#125; for (String ss : map.keySet()) &#123; Collections.sort(map.get(ss)); &#125; return new ArrayList&lt;List&lt;String&gt;&gt;(map.values());// return lists; &#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"133. Clone Graph","slug":"133-Clone-Graph","date":"2016-02-16T08:31:06.000Z","updated":"2017-03-06T12:10:22.000Z","comments":true,"path":"2016/02/16/133-Clone-Graph/","link":"","permalink":"http://duyao.github.io/2016/02/16/133-Clone-Graph/","excerpt":"","text":"133. Clone Graph 该题目是通过图的遍历复制图 注意的是返回的每个结点必须是新的结点，而不是原来结点的指针 12345678910111213141516171819202122232425262728293031323334353637class UndirectedGraphNode &#123; int label; List&lt;UndirectedGraphNode&gt; neighbors; UndirectedGraphNode(int x) &#123; label = x; neighbors = new ArrayList&lt;UndirectedGraphNode&gt;(); &#125;&#125;;// dfs中是否访问过的标记HashMap&lt;Integer, UndirectedGraphNode&gt; map = new HashMap&lt;Integer, UndirectedGraphNode&gt;();public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123; if (node == null) &#123; return null; &#125; if (map.containsKey(node.label)) &#123; return map.get(node.label); &#125; UndirectedGraphNode clone = new UndirectedGraphNode(node.label); //这里放入的节点一定是clone //因为本题目是clone图，递归返回的值是从map中获取，而获取到的值必须是一个新节点 //map.put(node.label, node); map.put(clone.label, clone); for (UndirectedGraphNode next : node.neighbors) &#123; //这里添加相邻接点必须是新构造的节点，而不是原来的 //clone.neighbors.add(next); //递归的返回值是新的结点 clone.neighbors.add(cloneGraph(next)); &#125; return clone;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"}]},{"title":"62. Unique Paths","slug":"62-Unique-Paths","date":"2016-02-12T02:22:31.000Z","updated":"2016-02-12T02:34:38.000Z","comments":true,"path":"2016/02/12/62-Unique-Paths/","link":"","permalink":"http://duyao.github.io/2016/02/12/62-Unique-Paths/","excerpt":"","text":"62. Unique Paths 思路不是用dfs或者bfs而是dpgrid[i][j]表示到达该位置的方法数目 123456789101112131415public static int uniquePaths(int m, int n) &#123; int grid [][] = new int[m][n]; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i == 0 || j == 0)&#123; grid[i][j] = 1; &#125;else&#123; grid[i][j] = grid[i-1][j] + grid[i][j-1]; &#125; &#125; &#125; return grid[m-1][n-1]; &#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"101. Symmetric Tree","slug":"101-Symmetric-Tree","date":"2016-02-04T03:15:44.000Z","updated":"2016-02-04T03:53:48.000Z","comments":true,"path":"2016/02/04/101-Symmetric-Tree/","link":"","permalink":"http://duyao.github.io/2016/02/04/101-Symmetric-Tree/","excerpt":"","text":"101. Symmetric Tree 递归式recursively1234567891011121314151617181920212223242526public static boolean isSymmetric(TreeNode left, TreeNode right) &#123; if(left == null &amp;&amp; right == null)&#123; //不需要判断子树，一定对称 return true; &#125;else if(left != null &amp;&amp; right != null )&#123; if(left.val != right.val)&#123; //一定不对称，不要需要判断子树 return false; &#125; &#125;else&#123; return false; &#125; //左子树的右和右子树的左对比，这里左右子树都存在 return isSymmetric(right.right, left.left) &amp; isSymmetric(right.left, left.right); &#125;public static boolean isSymmetric(TreeNode root) &#123; if(root == null)&#123; return true; &#125;else&#123; //判断左右子树是否对称 return isSymmetric(root.left, root.right); &#125; &#125; 循环式iteratively123456789101112131415161718192021222324252627282930313233343536373839404142public static boolean isSymmetric(TreeNode left, TreeNode right) &#123; //左右队列分别进行判断 LinkedList&lt;TreeNode&gt; rlist = new LinkedList&lt;TreeNode&gt;(); LinkedList&lt;TreeNode&gt; llist = new LinkedList&lt;TreeNode&gt;(); rlist.offer(right); llist.offer(left); TreeNode lNode, rNode; while (!rlist.isEmpty() &amp;&amp; !llist.isEmpty()) &#123; lNode = llist.poll(); rNode = rlist.poll(); if(lNode == null &amp;&amp; rNode == null)&#123; continue; &#125;else if(lNode != null &amp;&amp; rNode != null)&#123; if(lNode.val != rNode.val)&#123; return false; &#125;else&#123; //注意进入队列的顺序和位置 llist.offer(lNode.left); rlist.offer(rNode.right); llist.offer(lNode.right); rlist.offer(rNode.left); &#125; &#125;else&#123; return false; &#125; &#125; return true;&#125;public static boolean isSymmetric(TreeNode root) &#123; //使用两个队列进行遍历 if(root == null)&#123; return true; &#125;else&#123; return isSymmetric(root.left,root.right); &#125; &#125; 层次遍历树，包括空节点（处理为最大值的节点），判断字符串是否对称 wrong answer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384// 层次遍历public static boolean travel(TreeNode root,int tall) &#123; String s = &quot;&quot;; int height = 0; if (root != null) &#123; LinkedList&lt;TreeNode&gt; list = new LinkedList&lt;TreeNode&gt;(); list.add(root); TreeNode cur = new TreeNode(0); TreeNode last = root; while (!list.isEmpty() &amp;&amp; height != tall) &#123; cur = list.poll(); if (cur.val == Integer.MAX_VALUE) &#123; s += &quot;*&quot;; &#125; else &#123; s += cur.val; //空节点会是层数出错，因此要变化 //空节点设置为值最大的节点 if(cur.left == null)&#123; list.offer(new TreeNode(Integer.MAX_VALUE)); &#125;else&#123; list.offer(cur.left); &#125; if(cur.right == null)&#123; list.offer(new TreeNode(Integer.MAX_VALUE)); &#125;else&#123; list.offer(cur.right); &#125; &#125; if(cur == last)&#123; last = list.getLast(); height++; System.out.println(s+f(s)); if(!f(s))&#123; return false; &#125; s = &quot;&quot;; &#125; &#125; &#125;// System.out.println(&quot;height = &quot;+height); return true;&#125;public static boolean f(String s) &#123; int i = 0; int j = s.length() - 1; // 0,1 2,3 4 5 6, while (i &lt; j) &#123; if (s.charAt(i) != s.charAt(j)) &#123; return false; &#125; i++; j--; &#125; return true;&#125;public static boolean isSymmetric(TreeNode root) &#123; if(root == null)&#123; return true; &#125; return travel(root,getTall(root)); &#125;public static int getTall(TreeNode root)&#123; if(root == null)&#123; return 0; &#125; return Math.max(getTall(root.left), getTall(root.right)) + 1;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"70. Climbing Stairs","slug":"70-Climbing-Stairs","date":"2016-02-02T03:32:34.000Z","updated":"2016-02-02T03:33:48.000Z","comments":true,"path":"2016/02/02/70-Climbing-Stairs/","link":"","permalink":"http://duyao.github.io/2016/02/02/70-Climbing-Stairs/","excerpt":"","text":"70. Climbing Stairs 认出是dp就会做 123456789101112131415161718public static int climbStairs(int n) &#123; if(n == 0)&#123; return 0; &#125;else if(n == 1)&#123; return 1; &#125;else if(n ==2)&#123; return 2; &#125; //dp[i]表示走i共有dp[i]种方法 int[] dp = new int[n+1]; dp[0] = 0; dp[1] = 1; dp[2] = 2; for(int i = 3; i &lt; n+1; i++)&#123; dp[i] = dp[i-1] + dp[i-2]; &#125; return dp[n];&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"206. Reverse Linked List","slug":"206-Reverse-Linked-List","date":"2016-02-02T02:45:30.000Z","updated":"2016-02-02T02:50:48.000Z","comments":true,"path":"2016/02/02/206-Reverse-Linked-List/","link":"","permalink":"http://duyao.github.io/2016/02/02/206-Reverse-Linked-List/","excerpt":"","text":"206. Reverse Linked List 这里主要讨论递归方法 1234567891011121314public static ListNode reverseList(ListNode head) &#123; if(head.next == null || head == null)&#123; return head; &#125;else&#123; ListNode node = reverseList(head.next); //这里反转使用head，而不是node， //node 只是用来返回 //置反 head.next.next = head; //去掉原来的指针 head.next = null; return node; &#125;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"169. Majority Element","slug":"169-Majority-Element","date":"2016-02-01T03:03:31.000Z","updated":"2016-02-01T03:12:22.000Z","comments":true,"path":"2016/02/01/169-Majority-Element/","link":"","permalink":"http://duyao.github.io/2016/02/01/169-Majority-Element/","excerpt":"","text":"169. Majority Element 思路1排序然后找打中间值 思路212345678910111213141516171819public int majorityElement(int[] nums) &#123; //记录次数cnt和当前数值value //数值相同，cnt++,否则cnt-- //当cnt为0,重置value和cnt int value = nums[0]; int cnt = 1; for (int i = 1; i &lt; nums.length; i++) &#123; if(value == nums[i])&#123; cnt++; &#125;else&#123; cnt--; if(cnt == 0)&#123; value = nums[i]; cnt++; &#125; &#125; &#125; return value;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"235.Lowest Common Ancestor of a Binary Search Tree","slug":"235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree","date":"2016-02-01T02:20:42.000Z","updated":"2017-03-09T11:59:18.000Z","comments":true,"path":"2016/02/01/235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/","link":"","permalink":"http://duyao.github.io/2016/02/01/235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/","excerpt":"","text":"235.Lowest Common Ancestor of a Binary Search Tree 思路二上面的方法完全没有用到BST的性质BST(Binary Search Tree)左小右大对于查找BST中两个节点的公共父节点，该结果值一定介于两个节点值之间(包括其本身)因此只要遍历该BST，找到第一个介于两者之间的值就是结果 123456789public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123; return lowestCommonAncestor(root.left, p, q); &#125;else if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123; return lowestCommonAncestor(root.right, p, q); &#125;else&#123; return root; &#125;&#125; 236. Lowest Common Ancestor of a Binary Tree1234567891011public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; //树空或者本身就是公共祖先返回的是根节点 if(root == null || root == p || root == q) return root; //找左右子树的公共祖先 TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); //如果存在，那就一定是 if(left != null &amp;&amp; right != null) return root; //有一边不存在，说明两个节点都在同一边 return left != null ? left : right;&#125;","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"16.1","slug":"16.1","date":"2015-12-13T13:42:43.000Z","updated":"2015-12-14T06:42:14.000Z","comments":true,"path":"2015/12/13/16.1/","link":"","permalink":"http://duyao.github.io/2015/12/13/16.1/","excerpt":"题目有一个机器按自然数序列的方式吐出球(1 号球,2 号球,3 号球,……)，你有一个袋子，袋子最多只能装下K个球，并且除袋子以外，你没有更多的空间。设计一种选择方式，使得当机器吐出第N号球的时候(N&gt;K)，你袋子中的球数是K个，同时可以保证从1号球到N号球中的每一个，被选进袋子的概率都是K/N。 举一个更具体的例子。有一个只能装下10个球的袋子，当吐出100个球时，袋子里有10个球，并且1~100号中的每一个球被选中的概率都是10/100。然后继续吐球，当吐出1000个球时，袋子里有10个球，并且1~1000号中的每一个球被选中的概率都是10/1000。继续吐球，当吐出i个球时，袋子里有10个球，并且1~i号中的每一个球被选中的概率都是10/i，即吐球的同时，已经吐出的球被选中的概率也动态地变化。 应用场景:对于网站的抽奖问题，首先网站不可能统计出所有的用户，因为每个用户上线时间不同，其次对于大量用户抽奖，用户信息量十分庞大，因此对资源消耗非常大，所以采用蓄水池算法。一定时间内抽一次奖，这样把不同时段的用户的信息记录下来，进行抽奖，即k=1，最后统一信息宣布结果，也就是用户一上线就确定了中奖的情况","text":"题目有一个机器按自然数序列的方式吐出球(1 号球,2 号球,3 号球,……)，你有一个袋子，袋子最多只能装下K个球，并且除袋子以外，你没有更多的空间。设计一种选择方式，使得当机器吐出第N号球的时候(N&gt;K)，你袋子中的球数是K个，同时可以保证从1号球到N号球中的每一个，被选进袋子的概率都是K/N。 举一个更具体的例子。有一个只能装下10个球的袋子，当吐出100个球时，袋子里有10个球，并且1~100号中的每一个球被选中的概率都是10/100。然后继续吐球，当吐出1000个球时，袋子里有10个球，并且1~1000号中的每一个球被选中的概率都是10/1000。继续吐球，当吐出i个球时，袋子里有10个球，并且1~i号中的每一个球被选中的概率都是10/i，即吐球的同时，已经吐出的球被选中的概率也动态地变化。 应用场景:对于网站的抽奖问题，首先网站不可能统计出所有的用户，因为每个用户上线时间不同，其次对于大量用户抽奖，用户信息量十分庞大，因此对资源消耗非常大，所以采用蓄水池算法。一定时间内抽一次奖，这样把不同时段的用户的信息记录下来，进行抽奖，即k=1，最后统一信息宣布结果，也就是用户一上线就确定了中奖的情况 分析这个问题是蓄水池问题，主要的难点是理解证明过程解决方案：首先将前k个球全部放入袋子中，然后对于k以后的球，随机选择是否进入袋子中，如果进入则将其余的球袋子中任意一个球拿出，则所有过程中每个就进入袋子的概率都是k/n. 证明过程 代码12345678910111213141516171819202122232425public static int getRandom(int i)&#123; //返回(0,i]的整数，即[1,i] return (int)(Math.random()*i)+1;&#125;public static int[] getNum(int k, int n)&#123; //蓄水池 int[] reservoir = new int[Math.min(k, n)]; //前k个数字直接进入蓄水池 for (int i = 0; i &lt; reservoir.length; i++) &#123; reservoir[i] = i; &#125; for(int i = k+1; i &lt; n ; i++)&#123; //决定i是否进池 //产生[1,i+1],减1后得到[0,i] int cur = getRandom(i+1)-1; if(cur &lt;= k - 1)&#123; //在k之内，就会进入池中，则将池中的任意一个元素拿出 //产生出[1,k],减1后得到[0,k-1] int repalced = getRandom(k)-1; reservoir[repalced] = i; &#125; &#125; return reservoir;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"15.1","slug":"15.1","date":"2015-12-05T12:20:13.000Z","updated":"2015-12-14T08:05:56.000Z","comments":true,"path":"2015/12/05/15.1/","link":"","permalink":"http://duyao.github.io/2015/12/05/15.1/","excerpt":"题目给定一个N*N的矩阵matrix，在这个矩阵中只有0和1两种值，返回边框全是1的最大正方形的边长长度。例如:0111101001010010111101011其中，边框全是1的最大正方形的大小为4*4，所以返回4。","text":"题目给定一个N*N的矩阵matrix，在这个矩阵中只有0和1两种值，返回边框全是1的最大正方形的边长长度。例如:0111101001010010111101011其中，边框全是1的最大正方形的大小为4*4，所以返回4。 思路暴力的方法是对于每个点，判断是否有边长为n,-1,n-2…的正方形图案，因此复杂度为O(n*n)[共有n*n个点]*O(n)[遍历n个边长的正方形图案]*O(n)[判断该正方形图案是正方形],即O(n^4)优化的地方在判断是否是正方形的地方，添加2个二维数组，分别记录当前位置下边和右边1的个数则判断是否是正方形只需判断左上角下和右1的个数、右上角下方1的个数、左下角右方1的个数优化后为O(1)即总的时间复杂度为O(n*n)[共有n*n个点]*O(n)[遍历n个边长的正方形图案]*O(1)[判断该正方形图案是正方形]+O(n*n)[初始化二维数组]=O(n^3) 例如right矩阵，有一行1 1 0 1 1，则right矩阵的值是2 1 2 2 1 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public static void setMap(int[][] m, int[][] down, int[][] right)&#123; for(int i = m.length - 1; i &gt;= 0; i--)&#123; //最后一行 right[i][m[0].length - 1] = m[i][m[0].length - 1] == 1 ? 1 : 0; for(int j = m[0].length - 2; j &gt;= 0; j-- )&#123; //主要看右边的 if(m[i][j+1]== 1)&#123; right[i][j] = right[i][j+1] + m[i][j]; &#125;else&#123; //当前值是0，就只加自己的值 right[i][j] = m[i][j]; &#125; &#125; &#125; for(int i = m[0].length - 1; i &gt;= 0; i--)&#123; down[m.length - 1][i] = m[m[0].length - 1][i] == 1 ? 1 : 0; for(int j = m.length - 2; j &gt;= 0; j-- )&#123; if(m[j+1][i]== 1)&#123; down[j][i] = down[j+1][i] + m[i][j]; &#125;else&#123; down[j][i] = m[j][i]; &#125; &#125; &#125; &#125;public static int getLen(int[][] m)&#123; int[][] down = new int[m.length][m[0].length]; int[][] right = new int[m.length][m[0].length]; setMap(m, down, right); int len = 0; for(int i = 0; i &lt; m.length; i++)&#123; for(int j = 0; j &lt; m[0].length; j++)&#123; //k为生成的正方形边长 int x= Math.min(m.length - i, m[0].length - j); for(int k = x; k &gt; 0; k--)&#123; //左上角下和右1的个数、右上角下方1的个数、左下角右方1的个数 if(m[i][j] == 1 &amp;&amp; right[i][j] &gt;= k &amp;&amp; down[i][j] &gt;= k &amp;&amp; right[i+k-1][j] &gt;= k &amp;&amp; down[i][j+k-1] &gt;= k)&#123; len = Math.max(k, len); &#125; &#125; &#125; &#125; return len;&#125; 题目给定一个整型矩阵matrix，其中的值只有0和1两种，求其中全是1的所有矩形区域中，最大的矩形区域为1的数量。例如:1110其中，最大的矩形区域有 3 个 1，所以返回3。再如:101111111110其中，最大的矩形区域有6个1，所以返回6。 思路 生成height[]每行对应一个用height[]，表示以当前行为底，连续的1的个数然后把这些数字看成一个柱状图，找到最大的矩形面积,不断更新 找最大面积这个找最大面积的过程是依次遍历每个数字，然后分别往左右两边扩，直到遇到比它小的数字就停止，这个间距就是矩形的长，宽就是遍历的该数字。此过程的时间复杂度是O(1)，即遍历一次就能找到。 具体做法是生成一个栈，栈中存放数字的下标。当栈空或者即将入栈的元素比栈顶大，就一直入栈。直到遇到了比栈顶小的元素，此时开始出栈顶，那么出栈元素右边第一个比它小的就是当前元素，左边第一个比他小的就是新的栈顶元素。这样就找到了每个矩形的面积，更新面积。然后继续入栈出栈的过程。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static int getMaxArea(int[][] map)&#123; int[] height = new int[map[0].length]; int res = 0; //更新height for(int i = 0; i &lt; map.length; i++)&#123; for(int j = 0; j &lt; height.length; j++)&#123; //height记录的是连续的1的个数 height[j] = map[i][j] == 0 ? 0 : height[j] + 1; &#125; res = Math.max(res, fArea(height)); &#125; return res;&#125;public static int fArea(int[] a)&#123; //栈中存放数字的下标 Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int maxArea = 0; //实现一次遍历就找面积 for(int i = 0; i &lt; a.length; i++)&#123; //对于栈不空时，当前元素小于等于栈顶时都要出栈， while(!stack.empty() &amp;&amp; a[i] &lt;= a[stack.peek()])&#123; //栈顶出栈，得到矩形的宽a[k] int k = stack.pop(); //左边第一个比a[k]小的值 int left = stack.empty()? -1: stack.peek(); //右边第一个比a[k]小的值，同时注意存在相等的状况 int right = a[k] == a[i] ? i+1 : i; //区间是左开右开 int tmp = (right - left - 1)* a[k]; maxArea = Math.max(tmp, maxArea); &#125; stack.push(i); &#125; //遍历结束后仍然存在元素 while(!stack.empty())&#123; //栈顶出栈，得到矩形的宽a[k] int k = stack.pop(); //栈空时 int right = stack.empty()? a.length: k + 1; int left = stack.empty()? -1: stack.peek(); //区间是左开右开 int tmp = (right - left - 1)* a[k]; maxArea = Math.max(tmp, maxArea); &#125; return maxArea;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"二分查找","slug":"二分查找","date":"2015-12-03T13:26:21.000Z","updated":"2016-05-12T11:30:54.000Z","comments":true,"path":"2015/12/03/二分查找/","link":"","permalink":"http://duyao.github.io/2015/12/03/二分查找/","excerpt":"","text":"查找数字x是否在有序数组中(无重复)key 左闭右闭区间 left&lt;=right 无重复 123456789101112131415161718192021// 查找数字x是否在有序数组中,无重复public static int f1(int[] a, int x) &#123; int left = 0; int right = a.length - 1; int mid = 0; // 区间是[0,n-1] while (left &lt;= right) &#123; mid = (left + right) / 2; if (a[mid] == x) &#123; return mid; &#125; else if (a[mid] &gt; x) &#123; // 在区间[left,mid-1]找 right = mid - 1; &#125; else &#123; // 在区间[mid+1,right]找 left = mid + 1; &#125; &#125; // 找不到 return -1;&#125; 序列的第一个x的位置L(有重复)对于出现左闭右开区间，应会出现r=mid或者l=mid，且循环条件是改为left&lt;rightkey 有重复 左闭右开区间 left &lt; right 出现r=mid或者l=mid 返回left 12345678910111213141516171819202122//序列的第一个x的位置public static int f2(int[] a, int x) &#123; int left = 0; int right = a.length; int mid = 0; // 区间是[0,n) // 分支中出现了l=mid 或者r=mid，循环条件要写成left &lt; right，否则写成left &lt;= right //避免出现left=right-1出现死循环 while (left &lt; right) &#123; mid = (left + right) / 2; if (a[mid] &gt;= x) &#123; // 在区间[left,mid)找 //因为是左闭右开区间，所以right=mid right = mid; &#125; else &#123; // 在区间[mid+1,right)找 left = mid + 1; &#125; &#125; //返回左 return left;&#125; 序列的第一个大于x的位置R(有重复)key 有重复 左闭右开区间 left &lt; right 出现r=mid或者l=mid 返回left a[mid] &gt; x无等号 12345678910111213141516171819202122//第一个大于x的位置Rpublic static int f3(int[] a, int x) &#123; int left = 0; int right = a.length; int mid = 0; // 区间是[0,n) // 分支中出现了l=mid 或者r=mid，循环条件要写成left &lt; right，否则写成left &lt;= right //避免出现left=right-1出现死循环 while (left &lt; right) &#123; mid = (left + right) / 2; //第一个大于x的元素，没有等号 if (a[mid] &gt; x) &#123; // 在区间[left,mid)找 right = mid; &#125; else &#123; // 在区间[mid+1,right)找 left = mid + 1; &#125; &#125; // 找不到 return left;&#125; 练习34. Search for a Range","categories":[],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://duyao.github.io/tags/leetcode/"},{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/tags/algorithm/"}]},{"title":"14.2","slug":"14.2","date":"2015-12-01T12:42:32.000Z","updated":"2015-12-02T07:31:34.000Z","comments":true,"path":"2015/12/01/14.2/","link":"","permalink":"http://duyao.github.io/2015/12/01/14.2/","excerpt":"子数组的最大和及系列问题子数组的最大累加和问题给定一个数组arr，返回子数组的最大累加和。例如，arr=[1,-2,3,5,-2,6,-1]，所有的子数组中，[3,5,-2,6]可以累加出最大的和12，所以返回12。 思路时间复杂度O(n)使用max记录当前和的最大值和sum记录当前的和 sum &lt; 0 -&gt; 舍弃前面的，sum = 当前值 sum &gt;= 0 -&gt; 累加每次更新完sum，要更新max 代码12345678910111213141516171819public static int getMaxSum(int[] a) &#123; //记录当前的和 int sum = 0; //记录最大值 int maxNum = Integer.MIN_VALUE; for (int i = 0; i &lt; a.length; i++) &#123; //如果和小于0，说明加上正数或会变大，但是仍然起副作用 //因此直接丢掉，使得sum为当前值，注意不是0，因为可能所有数字都是负数 if (sum &lt; 0) &#123; sum = a[i]; &#125; else &#123; //和大于0，可以继续累加 sum += a[i]; &#125; //每次算完和，要更新max，这样才能记录下最大值 maxNum = Math.max(maxNum, sum); &#125; return maxNum;&#125;","text":"子数组的最大和及系列问题子数组的最大累加和问题给定一个数组arr，返回子数组的最大累加和。例如，arr=[1,-2,3,5,-2,6,-1]，所有的子数组中，[3,5,-2,6]可以累加出最大的和12，所以返回12。 思路时间复杂度O(n)使用max记录当前和的最大值和sum记录当前的和 sum &lt; 0 -&gt; 舍弃前面的，sum = 当前值 sum &gt;= 0 -&gt; 累加每次更新完sum，要更新max 代码12345678910111213141516171819public static int getMaxSum(int[] a) &#123; //记录当前的和 int sum = 0; //记录最大值 int maxNum = Integer.MIN_VALUE; for (int i = 0; i &lt; a.length; i++) &#123; //如果和小于0，说明加上正数或会变大，但是仍然起副作用 //因此直接丢掉，使得sum为当前值，注意不是0，因为可能所有数字都是负数 if (sum &lt; 0) &#123; sum = a[i]; &#125; else &#123; //和大于0，可以继续累加 sum += a[i]; &#125; //每次算完和，要更新max，这样才能记录下最大值 maxNum = Math.max(maxNum, sum); &#125; return maxNum;&#125; 找到两个不相容子数组的最大和给定一个数组arr，其中有很多的子数组，找到两个不相容子数组使得相加的和最大，并返回和的最大值。比如，数组[1,-1,0,-2,3,5,-2,8,7,-4]，两个不相容子数组分别为[3,5]和[8,7]时累加和最大，所以返回23。再比如，数组[3,-1,0,-2,3,5,-2,8,7,-4]，两个不相容子数组分别为[3]和[3,5,-2,8,7]时累加和最大，所以返回24。 思路借鉴上面的思路，做一些变形设置两个数组 left[i]表示[0,i]上的子数组最大和 right[i]表示[i,N-1]上子数组的最大和 然后设置分割点k分别计算left[k]+right[k+1]最大值该值表示[0,i]和[i+1,N-1]中最大值的和，既保持了不相交，也算出了最大值 代码1234567891011121314151617181920212223242526272829303132333435public static int getUnconnetedSum(int[] a)&#123; int[] left = new int[a.length]; int[] right = new int[a.length]; int sum = 0; int maxNum = Integer.MIN_VALUE; //用求子数组最大和方法初始化left for (int i = 0; i &lt; a.length; i++) &#123; if(sum &lt; 0)&#123; sum = a[i]; &#125;else&#123; sum += a[i]; &#125; maxNum = Math.max(maxNum, sum); left[i] = maxNum; &#125; sum = 0; maxNum = Integer.MIN_VALUE; //用求子数组最大和方法初始化right for(int i = a.length-1; i &gt;= 0; i--)&#123; if(sum &lt; 0)&#123; sum = a[i]; &#125;else&#123; sum += a[i]; &#125; maxNum = Math.max(maxNum, sum); right[i] = maxNum; &#125; int res = Integer.MIN_VALUE; //以i为分界点，查找最大值 for (int i = 0; i &lt; a.length-1; i++) &#123; res = Math.max(res, left[i]+right[i+1]); &#125; return res;&#125; 子矩阵的最大累加和问题给定一个矩阵matrix，其中的值有正、有负、有0，返回子矩阵的最大累加和。 例如，矩阵matrix为：-90 48 78 64 -40 64-81 -7 66其中，最大累加和的子矩阵为： 48 78-40 64-7 66所以返回累加和209。 再例如，matrix为：-1 -1 -1-1 2 2-1 -1 -1其中最大累加和的子矩阵为：2 2所以返回累加和 4。 思路利用最大子数组求和的思想先用tmp[i]求出在该行i列上所有数字的和，是一个列加的和，不停的用上一行列加tmp有了tmp再求最大子数组和，就是求出选那些列能组成最大和为了遍历所有的行，需要设置分割点，即先遍历0123…N,然后123…N,234..N把所有可能都遍历到 代码123456789101112131415161718192021222324public static int getMaxtrixSum(int[][] a) &#123; int maxNum = Integer.MIN_VALUE; //分割点i，遍历所有的行 for(int i = 0; i &lt; a.length; i++)&#123; //存放该行以上所有的和，即tmp[i]表示i列在该行的所有值的和 int[] tmp = new int[a[0].length]; //可遍历第012，12，2行 for(int k = i; k &lt; a.length; k++)&#123; //求最大子数组和的过程 int curSum = 0; for(int j = 0; j &lt; a[0].length; j++)&#123; //先更新tmp，然后求最大 tmp[j] += a[k][j]; if(curSum &lt; 0)&#123; curSum = tmp[j]; &#125;else&#123; curSum += tmp[j]; &#125; maxNum = Math.max(curSum, maxNum); &#125; &#125; &#125; return maxNum;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"14.5","slug":"14.5","date":"2015-11-29T13:48:20.000Z","updated":"2015-12-08T12:32:54.000Z","comments":true,"path":"2015/11/29/14.5/","link":"","permalink":"http://duyao.github.io/2015/11/29/14.5/","excerpt":"子数组累加和系列问题题目给定一个无序数组arr，其中元素可正、可负、可0，再给定一个整数k，求arr所有的子数组中累加和为k的最长子数组长度。 思路如果暴力的算就是遍历所有子数组，求所有和为k的长度，求出最大，时间复杂度是o(n*n)还可以用sum表示所有以i结尾的数组的和，如果sum[i]-k=sum[j]，则说明(j,i]的区间上的和是k那么可以用hashMap记录下所有出现的和的第一次，然后每次进行比较则可以算出时间复杂度是O(n)","text":"子数组累加和系列问题题目给定一个无序数组arr，其中元素可正、可负、可0，再给定一个整数k，求arr所有的子数组中累加和为k的最长子数组长度。 思路如果暴力的算就是遍历所有子数组，求所有和为k的长度，求出最大，时间复杂度是o(n*n)还可以用sum表示所有以i结尾的数组的和，如果sum[i]-k=sum[j]，则说明(j,i]的区间上的和是k那么可以用hashMap记录下所有出现的和的第一次，然后每次进行比较则可以算出时间复杂度是O(n) 代码12345678910111213141516171819202122232425public static int getKLen(int[] arr, int k)&#123; //key表示和的数值，value表示第一次出现该值的位置 //该map只记录第一次出现的情况 HashMap&lt;Integer, Integer&gt; mymap = new HashMap&lt;Integer, Integer&gt;(); //因为和0的记录是所有值都不取，不会被自动加入 //因此这里添加，表示从开头是选 mymap.put(0, -1); int sum = 0; int len = 0; for (int i = 0; i &lt; arr.length; i++) &#123; //以i结尾的和 sum += arr[i]; //只记录第一次出现的和，因为这样才能最长 if(!mymap.containsKey(sum))&#123; mymap.put(sum, i); &#125; //如果有sum[j]+k=sum[i]，说明(j,i]的部分和是k if(mymap.containsKey(sum - k))&#123; int j = mymap.get(sum - k); //以j结尾的和和以i结尾的和，期间的长度是i-j len = Math.max(len, i - j); &#125; &#125; return len;&#125; 题目给定一个数组arr，该数组无序，但每个值均为正数，再给定一个正数k。求arr的所有子数组中所有元素相加和为k的最长子数组长度。例如，arr=[1,2,1,1,1]，k=3。累加和为3的最长子数组为[1,1,1]，所以结果返回3。要求：时间复杂度O(N)，额外空间复杂度O(1)。 思路该题目遇上一题的区别就是正数因此该题目可以用一个区间来找和是k的组合 left区间的左端 right区间的右端 sum该区间的和 len最大的长度 开始left和right都指向0，一边计算sum一边更新len sum &gt; k right右移，继续增加区间的长度 sum &lt; k left右移，减少区间元素，使得和减小 sum == k left右移，等于之后要更新len，为了检测是否有更多和为k的子数组，要继续遍历 代码1234567891011121314151617181920212223242526272829303132public static int getMaxKLen(int[] a,int k)&#123; if(a.length &lt; 0 || k &lt;= 0 || a == null)&#123; return 0; &#125; int left = 0; int right = 0; //这里sum已经设置了，后面要先改区间，再算和 int sum = a[0]; int len = 0; while(left &lt; a.length &amp;&amp; right &lt; a.length) &#123; if(sum &lt; k)&#123; //先改区间，再算和 right ++; if (right == a.length) &#123; break; &#125; sum += a[right]; &#125;else if(sum &gt; k)&#123; //先改区间，再算和 left++; sum -= a[left]; &#125;else&#123; //sum== k len = Math.max(len, right - left + 1); left++; sum -= a[left]; &#125; &#125; return len;&#125; 题目给定一个无序数组arr，其中元素可正、可负、可0，给定一个整数 k。求arr所有的子数组中累加和小于或等于k的最长子数组长度。例如:arr=[3,-2,-4,0,6]，k=-2，相加和小于或等于-2的最长子数组为{3,-2,-4,0}，所以结果返回4 思路回顾上面的题目，用一个数组记录当前位置所有和，然后一边遍历，一边算现在的和，当遍历到i时，用x=当前和-k，找所有和中是否有x值，有就说明该位置到当前位置和是k而本题目是所求的和小于等于k值，对于等式x=当前和-k,这里k&lt;=aa,因此x&gt;=和-aa,而遍历的过程是寻找数组中大于等于和-a[i]的值 对于一个序列，求最长则需要找到第一个大于等于的值因此辅助数组改为记录当前位置和的最大值，是一个递增序列例如[-2,4,2,0,2,1]求第一个大于等于2的位置，那么就是4的位置因此序列改为[-2,4,4,4,4],这样对于递增序列，可以用二分降到O(log(n))整体的复杂度为O(n*log(n)) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static int maxLength(int[] arr, int k) &#123; // 记录当前位置出现的最大和，是一个递增数组 int[] h = new int[arr.length + 1]; int sum = 0; // 加入和是0的记录 h[0] = sum; for (int i = 0; i != arr.length; i++) &#123; sum += arr[i]; h[i + 1] = Math.max(sum, h[i]); &#125; sum = 0; // 结果 int res = 0; // 满足区间的左边界 int pre = 0; // 长度，右边界-左边界+1 int len = 0; for (int i = 0; i != arr.length; i++) &#123; // 当前所有的和 sum += arr[i]; // k+x=sum // 求小于等于k的区间，那么就要找到大于等于x即(sum-k)的值 // 即求出第一个大于x的位置 pre = getIndex(h, sum - k); // 可能找不到 len = pre == -1 ? 0 : i - pre + 1; res = Math.max(res, len); &#125; return res;&#125;// 第一个大于x的位置Rpublic static int getIndex(int[] a, int x) &#123; int left = 0; int right = a.length; int mid = 0; // 有可能出现找不到的情况 int res = -1; // 区间是[0,n) // 分支中出现了l=mid 或者r=mid，循环条件要写成left &lt; right，否则写成left &lt;= right // 避免出现left=right-1出现死循环 while (left &lt; right) &#123; mid = (left + right) / 2; // 第一个大于x的元素，没有等号 if (a[mid] &gt; x) &#123; // 找不到的情况是x比任何数都大，因此如果存在都会进左区间 // 右区间找不到情况下是不进入的 // 用res来记录，如果找到不进入此，不改变值，返回-1 res = mid; // 在区间[left,mid)找 right = mid; &#125; else &#123; // 在区间[mid+1,right)找 left = mid + 1; &#125; &#125; // 找不到 return res;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"14.1","slug":"14.1","date":"2015-11-29T12:38:30.000Z","updated":"2015-12-02T07:31:48.000Z","comments":true,"path":"2015/11/29/14.1/","link":"","permalink":"http://duyao.github.io/2015/11/29/14.1/","excerpt":"最长的可整合子数组的长度先给出可整合数组的定义。如果一个数组在排序之后，每相邻两个数差的绝对值都为1，则该数组为可整合数组。例如，[5,3,4,6,2]排序之后为[2,3,4,5,6]，符合每相邻两个数差的绝对值都为1，所以这个数组为可整合数组。给定一个整型数组arr，请返回其中最大可整合子数组的长度。例如，[5,5,3,2,6,4,3]中最大可整合子数组为[5,3,2,6,4]，所以返回5。 思路注意是子数组，不能全排序如果按照题目中的做，应该每个子数组排序，判断是否可整合，那么时间复杂度是o(n*n*log(n)*n)但是仔细观察，可整合数组有两个规律 无重合数字 最大值 - 最小值 + 1 = 子数组长度 因此只要遍历所有n*n个子数组，找到满足以上规律的结合即可","text":"最长的可整合子数组的长度先给出可整合数组的定义。如果一个数组在排序之后，每相邻两个数差的绝对值都为1，则该数组为可整合数组。例如，[5,3,4,6,2]排序之后为[2,3,4,5,6]，符合每相邻两个数差的绝对值都为1，所以这个数组为可整合数组。给定一个整型数组arr，请返回其中最大可整合子数组的长度。例如，[5,5,3,2,6,4,3]中最大可整合子数组为[5,3,2,6,4]，所以返回5。 思路注意是子数组，不能全排序如果按照题目中的做，应该每个子数组排序，判断是否可整合，那么时间复杂度是o(n*n*log(n)*n)但是仔细观察，可整合数组有两个规律 无重合数字 最大值 - 最小值 + 1 = 子数组长度 因此只要遍历所有n*n个子数组，找到满足以上规律的结合即可 代码123456789101112131415161718192021222324252627public static int getLen(int[] a)&#123; HashSet&lt;Integer&gt; set = new HashSet&lt;Integer&gt;(); int min = 0; int max = 0; int len = 0; for(int i = 0; i &lt; a.length; i++)&#123; //遍历结束以i开头的子数组，要清空 max = Integer.MIN_VALUE; min = Integer.MAX_VALUE; for(int j = i; j &lt; a.length; j++)&#123; //重复，后面的子数组也会重复 if(set.contains(a[j]))&#123; break; &#125; set.add(a[j]); max = Math.max(max, a[j]); min = Math.min(min, a[j]); //最大值 - 最小值 + 1 = 子数组长度 = j-i+1 if(j - i == max - min)&#123; len = Math.max(len, j - i + 1); &#125; &#125; //遍历结束以i开头的子数组，要清空 set.clear(); &#125; return len;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"11.4","slug":"11.4","date":"2015-11-29T02:26:10.000Z","updated":"2015-12-03T05:21:44.000Z","comments":true,"path":"2015/11/29/11.4/","link":"","permalink":"http://duyao.github.io/2015/11/29/11.4/","excerpt":"MaxTree一个数组的MaxTree定义如下：数组必须没有重复元素；MaxTree是一棵二叉树，数组的每一个值对应一个二叉树节点；包括MaxTree树在内并且在其中的每一颗子树上，值最大的节点都是树的头； 给定一个没有重复元素的数组arr，写出生成这个数组的MaxTree的函数，要求如果数组长度为N，时间复杂度O(N)，额外空间复杂度O(N) 思路该树并不是堆，因为不是平衡的，只是有性质任意子树的头结点比任何结点的值都大 leftMap和rightMap本题使用leftMap和rightMap分别记录当前结点左边第一个比它大的结点和当前结点右边第一个比它大的结点这个记录过程是利用栈来实现的，栈中必须满足从堆底到堆顶是从小到大的顺序先从左向右遍历，如果当前结点比堆顶小就直接进入，否则就弹出，直到可以进入为止，弹出的过程就记录比当前结点大的结点然后从右向左遍历，同理 建树建树的过程就是利用leftMap和rightMap遍历所有结点，找到其lNode和rNode 都不空，选择较小的为父，因为较大的可能被选为根节点 有一个空，选择不空的为父 都空，自己就是头","text":"MaxTree一个数组的MaxTree定义如下：数组必须没有重复元素；MaxTree是一棵二叉树，数组的每一个值对应一个二叉树节点；包括MaxTree树在内并且在其中的每一颗子树上，值最大的节点都是树的头； 给定一个没有重复元素的数组arr，写出生成这个数组的MaxTree的函数，要求如果数组长度为N，时间复杂度O(N)，额外空间复杂度O(N) 思路该树并不是堆，因为不是平衡的，只是有性质任意子树的头结点比任何结点的值都大 leftMap和rightMap本题使用leftMap和rightMap分别记录当前结点左边第一个比它大的结点和当前结点右边第一个比它大的结点这个记录过程是利用栈来实现的，栈中必须满足从堆底到堆顶是从小到大的顺序先从左向右遍历，如果当前结点比堆顶小就直接进入，否则就弹出，直到可以进入为止，弹出的过程就记录比当前结点大的结点然后从右向左遍历，同理 建树建树的过程就是利用leftMap和rightMap遍历所有结点，找到其lNode和rNode 都不空，选择较小的为父，因为较大的可能被选为根节点 有一个空，选择不空的为父 都空，自己就是头 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public static class Node &#123; int value; Node left; Node right; public Node(int value) &#123; this.value = value; this.left = null; this.right = null; &#125;&#125;public static Node getMaxTree(int[] a) &#123; if (a == null || a.length == 0) &#123; return null; &#125; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); //右边比第一个比当前结点大 HashMap&lt;Node, Node&gt; rightMap = new HashMap&lt;Node, Node&gt;(); //左边比第一个比当前结点大 HashMap&lt;Node, Node&gt; leftMap = new HashMap&lt;Node, Node&gt;(); //这里必须将所有结点存储到一个数组中，然后以后对node数组取出，修改，才能地址修改 //如果不这样做，后续都对a建立新的结点，那么修改左右子树的每个结点都是新结点，不能保存原来的修改 Node[] arr = new Node[a.length]; for (int i = 0; i &lt; a.length; i++) &#123; arr[i] = new Node(a[i]); &#125; // 初始化leftMap，记录左边第一个大 for (int i = 0; i &lt; arr.length; i++) &#123; // Node cur = new Node(arr[i]); //对数组中的值取出，操作，这样才能保存修改 Node cur = arr[i]; //比当前结点小的pop while (!stack.empty() &amp;&amp; stack.peek().value &lt;= arr[i].value) &#123; popSetMap(stack, leftMap); &#125; // 比当前元素小的全部被pop后，放入 stack.push(cur); &#125; // 栈中可能会有剩余元素 while (!stack.empty()) &#123; popSetMap(stack, leftMap); &#125; // 初始化rightMap for (int i = arr.length - 1; i &gt;= 0; i--) &#123; // Node cur = new Node(arr[i]); Node cur = arr[i]; while (!stack.empty() &amp;&amp; stack.peek().value &lt;= arr[i].value) &#123; popSetMap(stack, rightMap); &#125; stack.push(cur); &#125; while (!stack.empty()) &#123; popSetMap(stack, rightMap); &#125; System.out.println(&quot;rightMap:&quot;); PrintHashMap(rightMap); System.out.println(&quot;leftMap:&quot;); PrintHashMap(leftMap); // 建立树 Node head = null; for (int i = 0; i &lt; arr.length; i++) &#123; // Node node = new Node(arr[i]); //仍然对node数组操作，左右子树的信息才能保存 Node node = arr[i]; Node lNode = rightMap.get(node); Node rNode = leftMap.get(node); //左右都没有比当前大的，说明最大，是根节点 if (lNode == null &amp;&amp; rNode == null) &#123; head = node; &#125; else if (lNode == null &amp;&amp; rNode != null) &#123; if (rNode.left == null) &#123; rNode.left = node; &#125; else &#123; rNode.right = node; &#125; &#125; else if (lNode != null &amp;&amp; rNode == null) &#123; if (lNode.left == null) &#123; lNode.left = node; &#125; else &#123; lNode.right = node; &#125; &#125; else &#123; //左右都有比当前大的，选择较小的当做父亲节点 Node parent = lNode.value &lt; rNode.value ? lNode : rNode; if (parent.left == null) &#123; parent.left = node; &#125; else &#123; parent.right = node; &#125; &#125; &#125; return head;&#125;public static void popSetMap(Stack&lt;Node&gt; stack, HashMap&lt;Node, Node&gt; hashMap) &#123; Node node = stack.pop(); // stack内是按照栈底到栈顶从大到小的顺序，因此栈底小，栈顶大 // 相邻靠上的元素的第一个比他大的一定是他的下一个 if (stack.empty()) &#123; hashMap.put(node, null); &#125; else &#123; hashMap.put(node, stack.peek()); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"13.5","slug":"13.5","date":"2015-11-29T00:14:45.000Z","updated":"2015-11-29T12:32:30.000Z","comments":true,"path":"2015/11/29/13.5/","link":"","permalink":"http://duyao.github.io/2015/11/29/13.5/","excerpt":"设计可以变更的缓存结构设计一种缓存结构，该结构在构造时确定大小，假设大小为 K 功能： set(key,value)：将记录(key,value)插入该结构。 get(key)：返回key对应的value值。 要求: set和get方法的时间复杂度为O(1)。 某个key的set或get操作一旦发生，认为这个 key 的记录成了最经常使用的。 当缓存的大小超过K时，移除最不经常使用的记录，即set或get最久远的。 举例假设缓存结构的实例是cache，大小为3，并依次发生如下行为:1，cache.set(“A”,1)。最经常使用的记录为(“A”,1)。2，cache.set(“B”,2)。最经常使用的记录为(“B”,2)，(“A”,1)变为最不经常的。3，cache.set(“C”,3)。最经常使用的记录为(“C”,2)，(“A”,1)还是最不经常的。4，cache.get(“A”)。最经常使用的记录为(“A”,1)，(“B”,2)变为最不经常的。5，cache.set(“D”,4)。大小超过了 3，所以移除此时最不经常使用的记录(“B”,2)，加入记录(“D”,4)，并且为最经常使用的记录，然后(“C”,2)变为最不经常使用的记录。 思路LRU是最近最少使用页面置换算法(Least Recently Used),也就是首先淘汰最长时间未被使用的页面!LFU是最近最不常用页面置换算法(Least Frequently Used),也就是淘汰一定时期内被访问次数最少的页!比如,第二种方法的时期T为10分钟,如果每分钟进行一次调页,主存块为3,若所需页面走向为2 1 2 1 2 3 4注意,当调页面4时会发生缺页中断 按LRU算法,应换页面1(1页面最久未被使用) 按LFU算法应换页面3(十分钟内,页面3只使用了一次) 区别 LRU关键是看页面最后一次被使用到发生调度的时间长短 LFU关键是看一定时间段内页面被使用的频率 本题是LRU，使用hashMap和双端队列完成 双端队列的功能 队列头旧尾新，加入新节点从尾部加入 把其中任何一个节点移动到尾部，且不影响其他的联系 可以扔掉第一个，即最旧的，第二个就成为头结点 hashMap是完成node与key的相互映射，加速查找 cache的实现 set方法当有节点进来，进行添加或者修改，然后看窗口值是否达到门限，如果没有就添加，冰放入队头，如果达到，就删除队头，放入新节点最后把该节点移动到队尾 get方法从map中得到节点，放入队尾","text":"设计可以变更的缓存结构设计一种缓存结构，该结构在构造时确定大小，假设大小为 K 功能： set(key,value)：将记录(key,value)插入该结构。 get(key)：返回key对应的value值。 要求: set和get方法的时间复杂度为O(1)。 某个key的set或get操作一旦发生，认为这个 key 的记录成了最经常使用的。 当缓存的大小超过K时，移除最不经常使用的记录，即set或get最久远的。 举例假设缓存结构的实例是cache，大小为3，并依次发生如下行为:1，cache.set(“A”,1)。最经常使用的记录为(“A”,1)。2，cache.set(“B”,2)。最经常使用的记录为(“B”,2)，(“A”,1)变为最不经常的。3，cache.set(“C”,3)。最经常使用的记录为(“C”,2)，(“A”,1)还是最不经常的。4，cache.get(“A”)。最经常使用的记录为(“A”,1)，(“B”,2)变为最不经常的。5，cache.set(“D”,4)。大小超过了 3，所以移除此时最不经常使用的记录(“B”,2)，加入记录(“D”,4)，并且为最经常使用的记录，然后(“C”,2)变为最不经常使用的记录。 思路LRU是最近最少使用页面置换算法(Least Recently Used),也就是首先淘汰最长时间未被使用的页面!LFU是最近最不常用页面置换算法(Least Frequently Used),也就是淘汰一定时期内被访问次数最少的页!比如,第二种方法的时期T为10分钟,如果每分钟进行一次调页,主存块为3,若所需页面走向为2 1 2 1 2 3 4注意,当调页面4时会发生缺页中断 按LRU算法,应换页面1(1页面最久未被使用) 按LFU算法应换页面3(十分钟内,页面3只使用了一次) 区别 LRU关键是看页面最后一次被使用到发生调度的时间长短 LFU关键是看一定时间段内页面被使用的频率 本题是LRU，使用hashMap和双端队列完成 双端队列的功能 队列头旧尾新，加入新节点从尾部加入 把其中任何一个节点移动到尾部，且不影响其他的联系 可以扔掉第一个，即最旧的，第二个就成为头结点 hashMap是完成node与key的相互映射，加速查找 cache的实现 set方法当有节点进来，进行添加或者修改，然后看窗口值是否达到门限，如果没有就添加，冰放入队头，如果达到，就删除队头，放入新节点最后把该节点移动到队尾 get方法从map中得到节点，放入队尾 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149// 队列中的结点public static class Node&lt;V&gt; &#123; //双向队列中的节点要有前后指针 private Node&lt;V&gt; prior; private Node&lt;V&gt; next; private V value; public Node(V value) &#123; this.value = value; this.next = null; this.prior = null; &#125;&#125;// 双端队列public static class NodeDoubleLinkedList&lt;V&gt; &#123; //头是最不经常使用的 private Node&lt;V&gt; head; //尾是最经常使用的 private Node&lt;V&gt; tail; public NodeDoubleLinkedList() &#123; head = null; tail = null; &#125; //新节点添加到尾部 public void addToTail(Node&lt;V&gt; newNode) &#123; if (newNode == null) &#123; return; &#125; //队列没有节点 if (head == null) &#123; head = newNode; tail = newNode; head.next = null; head.prior = null; tail.prior = null; tail.next = null; &#125; else &#123; //有节点 newNode.prior = tail; tail.next = newNode; tail = newNode; tail.next = null; &#125; &#125; //当窗口不够，就需要将头节点去掉 public Node&lt;V&gt; removeHead() &#123; //没有头结点 if(head == null)&#123; return null; &#125; //获取到头结点 Node&lt;V&gt; res = head; //只有一个节点 if (head == tail) &#123; head = null; tail = null; &#125; else &#123; head.next.prior = null; head = head.next; &#125; //返回的节点要清理干净，只有值，指针全部清空 res.next = null; res.prior = null; return res; &#125; //对于刚刚进行操作的节点要移动到队尾 public void moveToTail(Node&lt;V&gt; curNode) &#123; //移动头结点 if (head == curNode) &#123; curNode = this.removeHead(); addToTail(curNode); &#125;else if(curNode != tail)&#123; //如果本身在队尾不用操作 if (head != tail) &#123; // 删除节点 curNode.prior.next = curNode.next; curNode.next.prior = curNode.prior; // 移到尾部 addToTail(curNode); &#125; &#125; &#125;&#125;public static class MyCache&lt;K, V&gt; &#123; //2个hashMap对应key和value，加速查找 private HashMap&lt;K, Node&lt;V&gt;&gt; keyNodeMap; private HashMap&lt;Node&lt;V&gt;, K&gt; nodeKeyMap; //双向队列 private NodeDoubleLinkedList&lt;V&gt; nDLList; //窗口大小 private int windowSize; //初始化窗口大小 public MyCache(int capacity) &#123; this.windowSize = capacity; this.keyNodeMap = new HashMap&lt;K, Node&lt;V&gt;&gt;(); this.nodeKeyMap = new HashMap&lt;Node&lt;V&gt;, K&gt;(); this.nDLList = new NodeDoubleLinkedList&lt;V&gt;(); &#125; //根据key得到value public V get(K k) &#123; if (keyNodeMap.containsKey(k)) &#123; Node&lt;V&gt; cur = keyNodeMap.get(k); //最新操作的节点移到队头 nDLList.moveToTail(cur); return cur.value; &#125; else &#123; return null; &#125; &#125; public void set(K k,V value)&#123; if(keyNodeMap.containsKey(k))&#123; //更新节点 Node&lt;V&gt; cur = keyNodeMap.get(k); cur.value = value; //操作过的节点移到队头 nDLList.moveToTail(cur); &#125;else&#123; //如果此时窗口达到最大值，则把最久没有用的即头结点去掉 if(keyNodeMap.size() == windowSize)&#123; removeMostUnusedCache(); &#125; //新增节点 Node&lt;V&gt; newNode= new Node&lt;V&gt;(value); keyNodeMap.put(k, newNode); nodeKeyMap.put(newNode, k); //移到队尾 nDLList.addToTail(newNode); &#125; &#125; public void removeMostUnusedCache() &#123; //删除头结点 Node&lt;V&gt; rNode = nDLList.removeHead(); K rKey = nodeKeyMap.get(rNode); //hashMap中删除相关内容 nodeKeyMap.remove(rNode); keyNodeMap.remove(rKey); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"13.4","slug":"13.4","date":"2015-11-29T00:04:29.000Z","updated":"2015-11-29T07:15:06.000Z","comments":true,"path":"2015/11/29/13.4/","link":"","permalink":"http://duyao.github.io/2015/11/29/13.4/","excerpt":"","text":"一种怪异的节点删除方式链表节点值类型为int型，给定一个链表中的节点node，但不给定整个链表的头节点，如何在链表中删除node？请实现这个函数,并分析这么会出现哪些问题。要求时间复杂度为O(1)。 解决方法将后一个结点的值付给前面的节点，然后将后面的节点删除 出现三个问题 如果给出的是最后一个结点，无法删除 有的结点无拷贝函数 结点具有依赖性，无法拷贝依赖性","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"12.4","slug":"12.4","date":"2015-11-28T13:42:06.000Z","updated":"2015-11-28T15:15:14.000Z","comments":true,"path":"2015/11/28/12.4/","link":"","permalink":"http://duyao.github.io/2015/11/28/12.4/","excerpt":"一种消息接收并打印的结构设计消息流吐出 2,一种结构接收而不打印 2,因为 1 还没出现。消息流吐出 1,一种结构接收 1,并且打印:1,2。消息流吐出 4,一种结构接收而不打印 4,因为 3 还没出现。消息流吐出 5,一种结构接收而不打印 5,因为 3 还没出现。消息流吐出 7,一种结构接收而不打印 7,因为 3 还没出现。消息流吐出 3,一种结构接收 3,并且打印:3,4,5。消息流吐出 9,一种结构接收而不打印 9,因为 6 还没出现。消息流吐出 8,一种结构接收而不打印 8,因为 6 还没出现。消息流吐出 6,一种结构接收 6,并且打印:6,7,8,9。已知一个消息流会不断地吐出整数1~N，但不一定按照顺序吐出。如果上次打印的数为i，那么当i+1出现时,请打印i+1及其之后接收过的并且连续的所有数,直到1~N全部接收并打印完，请设计这种接收并打印的结构。 应用udp和滑动窗口 思路把每一个吐出的消息都看成单独的一个集合，每当进入新的集合n时候就进行合并。与上面n-1合并，与下面的n+1合并合并的过程就是查找是否有该值，因此使用hashMap分别存放未打印的可能成为头和尾的结点然后根据即将打印的值，判断本次是否可以打印","text":"一种消息接收并打印的结构设计消息流吐出 2,一种结构接收而不打印 2,因为 1 还没出现。消息流吐出 1,一种结构接收 1,并且打印:1,2。消息流吐出 4,一种结构接收而不打印 4,因为 3 还没出现。消息流吐出 5,一种结构接收而不打印 5,因为 3 还没出现。消息流吐出 7,一种结构接收而不打印 7,因为 3 还没出现。消息流吐出 3,一种结构接收 3,并且打印:3,4,5。消息流吐出 9,一种结构接收而不打印 9,因为 6 还没出现。消息流吐出 8,一种结构接收而不打印 8,因为 6 还没出现。消息流吐出 6,一种结构接收 6,并且打印:6,7,8,9。已知一个消息流会不断地吐出整数1~N，但不一定按照顺序吐出。如果上次打印的数为i，那么当i+1出现时,请打印i+1及其之后接收过的并且连续的所有数,直到1~N全部接收并打印完，请设计这种接收并打印的结构。 应用udp和滑动窗口 思路把每一个吐出的消息都看成单独的一个集合，每当进入新的集合n时候就进行合并。与上面n-1合并，与下面的n+1合并合并的过程就是查找是否有该值，因此使用hashMap分别存放未打印的可能成为头和尾的结点然后根据即将打印的值，判断本次是否可以打印 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//节点信息public static class Node&#123; int value; Node next; public Node(int value)&#123; this.value = value; &#125;&#125;public static class MessageBox&#123; HashMap&lt;Integer, Node&gt; headMap; HashMap&lt;Integer, Node&gt; tailMap; //即将打印的数字 int printNum; public MessageBox()&#123; //表示未打印集合中的头结点 headMap = new HashMap&lt;Integer, Node&gt;(); //表示未打印集合中的尾结点 tailMap = new HashMap&lt;Integer, Node&gt;(); printNum = 1; &#125; public void receive(int value) &#123; if(value &lt; 1)&#123; return; &#125; //把node看做单独的节点 Node node = new Node(value); headMap.put(value, node); tailMap.put(value, node); //由于value-1是头，因此hand中应该包含，而tail中不应该包含 //因此tail去掉value-1,head去掉value if(tailMap.containsKey(value-1))&#123; tailMap.get(value-1).next = node; headMap.remove(value); tailMap.remove(value-1); &#125; //value+1是尾，tail中应该包含，而head中不应该有 //因此head去掉value+1，tail去掉value if(headMap.containsKey(value+1))&#123; node.next = headMap.get(value+1); tailMap.remove(value); headMap.remove(value+1); &#125; //打印，看头结点是否有即将打印的数字 if(headMap.containsKey(printNum))&#123; printNode(); &#125; &#125; public void printNode()&#123; Node node = headMap.get(printNum); //因为已经打印，所以head中要去掉 headMap.remove(printNum--); while (node != null) &#123; System.out.print(node.value + &quot; &quot;); node = node.next; printNum++; &#125; System.out.println(); //打印完成后去掉尾结点 tailMap.remove(printNum); printNum++; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"13.2","slug":"13.2","date":"2015-11-28T06:33:44.000Z","updated":"2015-11-29T02:14:50.000Z","comments":true,"path":"2015/11/28/13.2/","link":"","permalink":"http://duyao.github.io/2015/11/28/13.2/","excerpt":"最大值减去最小值小于或等于num的子数组数量给定数组arr和整数num，返回有多少个子数组满足如下情况:max(arr[i..j]) - min(arr[i..j]) &lt;= nummax(arr[i..j])表示子数组arr[i..j]中的最大值，min(arr[i..j])表示子数组arr[i..j]中的最小值。如果数组长度为 N，请实现时间复杂度为 O(N)的解法。 思路有两个规律 如果max(arr[i..j]) - min(arr[i..j]) &lt;= num，那么ij往里缩，仍然满足要求因为范围缩小后，最大值只能比当前最大值小，而最小值只能比当前大，那么差值会变小，故仍满组要求 如果max(arr[i..j]) - min(arr[i..j]) &gt; num，不满足要求，那么ij往外扩大，仍不满足要求因为范围扩大，最大值可能比当前还大，最小值可能比当前值还小，那么差值会变大，仍不满足要求 利用双端队列，利用双端队列动态记录子数组的大小值 qmax和qmin是双端队列，记录大小值的序号，且满足数组的顺序是有序的由于过程中ij一直只增不减，且到末尾就停止，相当于2n次遍历，而更新qmax和qmin时，所有的数字都是进出各一次队列，相当2n次遍历故一共4n次遍历，时间复杂度是o(n)","text":"最大值减去最小值小于或等于num的子数组数量给定数组arr和整数num，返回有多少个子数组满足如下情况:max(arr[i..j]) - min(arr[i..j]) &lt;= nummax(arr[i..j])表示子数组arr[i..j]中的最大值，min(arr[i..j])表示子数组arr[i..j]中的最小值。如果数组长度为 N，请实现时间复杂度为 O(N)的解法。 思路有两个规律 如果max(arr[i..j]) - min(arr[i..j]) &lt;= num，那么ij往里缩，仍然满足要求因为范围缩小后，最大值只能比当前最大值小，而最小值只能比当前大，那么差值会变小，故仍满组要求 如果max(arr[i..j]) - min(arr[i..j]) &gt; num，不满足要求，那么ij往外扩大，仍不满足要求因为范围扩大，最大值可能比当前还大，最小值可能比当前值还小，那么差值会变大，仍不满足要求 利用双端队列，利用双端队列动态记录子数组的大小值 qmax和qmin是双端队列，记录大小值的序号，且满足数组的顺序是有序的由于过程中ij一直只增不减，且到末尾就停止，相当于2n次遍历，而更新qmax和qmin时，所有的数字都是进出各一次队列，相当2n次遍历故一共4n次遍历，时间复杂度是o(n) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344public static int getNum(int[] arr, int num)&#123; if(arr == null || arr.length == 0)&#123; return 0; &#125; LinkedList&lt;Integer&gt; qmax = new LinkedList&lt;Integer&gt;(); LinkedList&lt;Integer&gt; qmin = new LinkedList&lt;Integer&gt;(); int i = 0; int j = 0; int res = 0; while(i &lt; arr.length)&#123; while(j &lt; arr.length)&#123; //更新qmax,满足依次递减 while(!qmax.isEmpty() &amp;&amp; arr[j] &gt;= arr[qmax.getLast()])&#123; qmax.removeLast(); &#125; qmax.add(j); //更新qmin,满足依次递增 while(!qmin.isEmpty() &amp;&amp; arr[j] &lt;= arr[qmin.getLast()])&#123; qmin.removeLast(); &#125; qmin.add(j); //判断是否不符条件，如果不符，后面的都不会符合 if(arr[qmax.getFirst()] - arr[qmin.getFirst()] &lt;= num)&#123; //这里不能更新res，因为当i增加的时候j一直都是在最后，不会进入到此循环内，不能正确的计数 //res ++; &#125;else&#123; break; &#125; j++; &#125; //更新窗口，因为i会变化，所以要将原来的pop if(qmax.getFirst() &lt;= i)&#123; qmax.removeFirst(); &#125; if(qmin.getFirst() &lt;= i)&#123; qmin.removeFirst(); &#125; //这里表示[i,i+1],[i,i+2],...,[i,j-1][i,j]都是符合条件的 //一共是j-i组 res += j-i; i++; &#125; return res;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"13.1","slug":"13.1","date":"2015-11-28T05:05:09.000Z","updated":"2015-11-28T15:15:30.000Z","comments":true,"path":"2015/11/28/13.1/","link":"","permalink":"http://duyao.github.io/2015/11/28/13.1/","excerpt":"生成窗口最大值数组有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边，窗口每次向右边滑一个位置。例如，数组为[4,3,5,4,3,3,6,7]，窗口大小为3时： [4 3 5] 4 3 3 6 7 窗口中最大值为54 [3 5 4] 3 3 6 7 窗口中最大值为54 3 [5 4 3] 3 6 7 窗口中最大值为54 3 5 [4 3 3] 6 7 窗口中最大值为44 3 5 4 [3 3 6] 7 窗口中最大值为64 3 5 4 3 [3 6 7] 窗口中最大值为7 如果数组长度为n，窗口大小为w，则一共产生n-w+1个窗口的最大值。请实现一个函数，给定一个数组arr，窗口大小w。返回一个长度为n-w+1的数组res,res[i]表示每一种窗口状态下的最大值。以本题为例，结果应该返回[5,5,5,4,6,7]。 思路普通解法就是对于每个大小为w窗口都遍历，找到最大值，一共遍历n-w+1次，时间复杂度为O(w*n)O(n)解法就是利用双端队列双端队列中存放的是数组中的下标，表示的当前窗口中从大到小的最大值的下标只需要遍历一次数组，对个数组中的每个值，如果比队列中末尾值小就放入队列，否则就把队列中的最后一个值pop，直到可以放入为止。然后更新结果res，队列中的第一个值是当前的最大值，但是要注意是否在窗口范围内，如果不在，就pop，选择在窗口范围内的最大值","text":"生成窗口最大值数组有一个整型数组arr和一个大小为w的窗口从数组的最左边滑到最右边，窗口每次向右边滑一个位置。例如，数组为[4,3,5,4,3,3,6,7]，窗口大小为3时： [4 3 5] 4 3 3 6 7 窗口中最大值为54 [3 5 4] 3 3 6 7 窗口中最大值为54 3 [5 4 3] 3 6 7 窗口中最大值为54 3 5 [4 3 3] 6 7 窗口中最大值为44 3 5 4 [3 3 6] 7 窗口中最大值为64 3 5 4 3 [3 6 7] 窗口中最大值为7 如果数组长度为n，窗口大小为w，则一共产生n-w+1个窗口的最大值。请实现一个函数，给定一个数组arr，窗口大小w。返回一个长度为n-w+1的数组res,res[i]表示每一种窗口状态下的最大值。以本题为例，结果应该返回[5,5,5,4,6,7]。 思路普通解法就是对于每个大小为w窗口都遍历，找到最大值，一共遍历n-w+1次，时间复杂度为O(w*n)O(n)解法就是利用双端队列双端队列中存放的是数组中的下标，表示的当前窗口中从大到小的最大值的下标只需要遍历一次数组，对个数组中的每个值，如果比队列中末尾值小就放入队列，否则就把队列中的最后一个值pop，直到可以放入为止。然后更新结果res，队列中的第一个值是当前的最大值，但是要注意是否在窗口范围内，如果不在，就pop，选择在窗口范围内的最大值 代码123456789101112131415161718192021222324252627282930public static int[] getMaxWindow(int[] arr, int w) &#123; if (arr == null || w &lt; 1 || arr.length &lt; w) &#123; return null; &#125; int[] res = new int[arr.length - w + 1]; //存放数组中数字的序号，且序号表示的数字顺序必须是从大到小 LinkedList&lt;Integer&gt; qMax = new LinkedList&lt;Integer&gt;(); //res的位置 int index = 0; for(int i = 0; i &lt; arr.length; i++)&#123; //添加元素 //更新qmax的数据，对于满足顺序，即小于最后一个元素的直接放入，否则一直剔除最后一个，可能会使双端队列变空，直到满足要求 while(!qMax.isEmpty() &amp;&amp; arr[qMax.getLast()] &lt;= arr[i])&#123; qMax.removeLast(); &#125; qMax.add(i); //更新res if(i &gt;= w - 1)&#123; //由于qmax是按照从小到大的顺序排列，因此最大值一定是第一个，但是可能出现一个数不在当前窗口的范围之中 //检查qmax的数字是否有效，即在窗口之内 while(qMax.getFirst() &lt; index || qMax.getFirst() &gt; index + w)&#123; qMax.removeFirst(); &#125; res[index++] = arr[qMax.getFirst()]; &#125; &#125; return res; &#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"12.3","slug":"12.3","date":"2015-11-27T13:32:59.000Z","updated":"2015-11-27T14:42:58.000Z","comments":true,"path":"2015/11/27/12.3/","link":"","permalink":"http://duyao.github.io/2015/11/27/12.3/","excerpt":"设计 RandomPool结构设计一种结构,在该结构中有如下三个功能: insert(key):将某个key加入到该结构,做到不重复加入。 delete(key):将原本在结构中的某个key移除。 getRandom():等概率随机返回结构中的任何一个key。要求：Insert、delete 和 getRandom 方法的时间复杂度都是 O(1)。 思路getRandom()要随机就要知道这个结构中的元素个数，且保证都存在而删除会导致某个元素消失，这样的话元素不连续，getRandom()会出错因此本题的考点是删除但是使得元素连续解决方案是删除时将该删除元素与最后一个元素换位置，删除最后一个元素，这个就会连续而用O(1)找到元素的方法是hashMap","text":"设计 RandomPool结构设计一种结构,在该结构中有如下三个功能: insert(key):将某个key加入到该结构,做到不重复加入。 delete(key):将原本在结构中的某个key移除。 getRandom():等概率随机返回结构中的任何一个key。要求：Insert、delete 和 getRandom 方法的时间复杂度都是 O(1)。 思路getRandom()要随机就要知道这个结构中的元素个数，且保证都存在而删除会导致某个元素消失，这样的话元素不连续，getRandom()会出错因此本题的考点是删除但是使得元素连续解决方案是删除时将该删除元素与最后一个元素换位置，删除最后一个元素，这个就会连续而用O(1)找到元素的方法是hashMap 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static class Pool&lt;K&gt;&#123; //为了迅速找到intger，即size private HashMap&lt;K, Integer&gt; keyIndexMap; //为了迅速找到key private HashMap&lt;Integer, K&gt; indexKeyMap; int size; public Pool() &#123; keyIndexMap = new HashMap&lt;K, Integer&gt;(); indexKeyMap = new HashMap&lt;Integer, K&gt;(); size = 0; &#125; public void insert(K key)&#123; if(!this.keyIndexMap.containsKey(key))&#123; //两个map都要维护 this.keyIndexMap.put(key, this.size); this.indexKeyMap.put(this.size, key); //添加个数增加 this.size++; &#125; &#125; public void delete(K key) &#123; if(this.keyIndexMap.containsKey(key))&#123; //得到删除的index int delIndex = keyIndexMap.get(key); //将个数减少 int lastIndex = --size; //得到最后的index K lastK = indexKeyMap.get(lastIndex); //交换位置，并且删除最后一个 this.keyIndexMap.remove(key); this.keyIndexMap.put(lastK, delIndex); this.indexKeyMap.remove(lastIndex); this.indexKeyMap.put(lastIndex, lastK); &#125; &#125; public K getRandom() &#123; if (this.size == 0) &#123; return null; &#125; int rand = (int) (Math.random() * this.size); return this.indexKeyMap.get(rand); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"12.2","slug":"12.2","date":"2015-11-27T12:45:33.000Z","updated":"2015-11-28T15:15:52.000Z","comments":true,"path":"2015/11/27/12.2/","link":"","permalink":"http://duyao.github.io/2015/11/27/12.2/","excerpt":"设计有setAll功能的哈希表哈希表常见的三个操作是 put、get 和 containsKey,而且这三个操作的时间复杂度为 O(1)。现在想加一个 setAll 功能,就是把所有记录的 value 都设成统一的值。请设计并实现 这种有 setAll 功能的哈希表,并且 put、get、containsKey 和 setAll 四个操作的时间复杂度 都为 O(1)。 思路setAll是把所有数据设置为同一个值,但是时间复杂度是 O(1) 普通做法遍历hashMap然后把值都修改成同一个值这样的时间复杂度一定不是O(1) O(1)做法因此提出时间戳的概念，就是setAll变为单独一个部分，加上一个时间戳，普通数据也加上一个时间戳取数据的时候要判断是从setAll取还是从普通数据取，这个取决于对应的时间戳 在普通的hashMap中value就是一个普通的值，而这里把普通数据value设置为一个带有时间戳的value，即一个新的数据结构，包含时间戳和value每次对于添加value都要更新时间戳","text":"设计有setAll功能的哈希表哈希表常见的三个操作是 put、get 和 containsKey,而且这三个操作的时间复杂度为 O(1)。现在想加一个 setAll 功能,就是把所有记录的 value 都设成统一的值。请设计并实现 这种有 setAll 功能的哈希表,并且 put、get、containsKey 和 setAll 四个操作的时间复杂度 都为 O(1)。 思路setAll是把所有数据设置为同一个值,但是时间复杂度是 O(1) 普通做法遍历hashMap然后把值都修改成同一个值这样的时间复杂度一定不是O(1) O(1)做法因此提出时间戳的概念，就是setAll变为单独一个部分，加上一个时间戳，普通数据也加上一个时间戳取数据的时候要判断是从setAll取还是从普通数据取，这个取决于对应的时间戳 在普通的hashMap中value就是一个普通的值，而这里把普通数据value设置为一个带有时间戳的value，即一个新的数据结构，包含时间戳和value每次对于添加value都要更新时间戳 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//value值是带有时间戳的public static class MyValue&lt;V&gt;&#123; private V value; private long time; public MyValue(V value, long time)&#123; this.time = time; this.value = value; &#125; public V getValue()&#123; return this.value; &#125; public long getTime()&#123; return this.time; &#125;&#125;public static class MyHashMap&lt;K, V&gt;&#123; //hashMap的value是带有时间戳的value private HashMap&lt;K, MyValue&lt;V&gt;&gt; baseMap; private long time; //setAll变为单独的区域 private MyValue&lt;V&gt; setAll; //初始化 public MyHashMap()&#123; this.baseMap = new HashMap&lt;K, MyValue&lt;V&gt;&gt;(); this.time = 0; this.setAll = new MyValue&lt;V&gt;(null, -1); &#125; //普通的containsKey public boolean containsKey(K key)&#123; return this.baseMap.containsKey(key); &#125; //添加时要添加时间戳 public void put(K key, V value) &#123; this.baseMap.put(key, new MyValue&lt;V&gt;(value, this.time++)); &#125; //将setAll单独设置成为一个区域，而不是改变所有的值 public void setAll(V value)&#123; this.setAll = new MyValue&lt;V&gt;(value, time++); &#125; //取值时，要根据时间戳来判断取出setAll还是myValue public V get(K key)&#123; if(this.containsKey(key))&#123; if(this.baseMap.get(key).time &gt; this.setAll.time)&#123; return this.baseMap.get(key).getValue(); &#125;else&#123; return this.setAll.getValue(); &#125; &#125;else&#123; return null; &#125; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"11.3","slug":"11.3","date":"2015-11-27T05:55:45.000Z","updated":"2015-11-27T12:59:54.000Z","comments":true,"path":"2015/11/27/11.3/","link":"","permalink":"http://duyao.github.io/2015/11/27/11.3/","excerpt":"二叉树的序列化和反序列化二叉树被记录成文件的过程，叫做二叉树的序列化，通过文件内容重建原来二叉树的过程叫做二叉树的反序列化。给定一棵二叉树的头节点head，并已知二叉树节点值的类型为32位整型。请设计一种二叉树序列化和反序列化的方案并用代码实现。 应用：判断两颗二叉树中是否有子树完全相同，先序列化为文件，然后kmp 思路将每个树的节点的值放在字符串中，用一个分隔符分开来，不然会引起歧义，然后将空节点也用特殊符号代替本题用!代表分隔符，用#表示空结点思路就是先序遍历和层次遍历，注意处理过程稍有不同","text":"二叉树的序列化和反序列化二叉树被记录成文件的过程，叫做二叉树的序列化，通过文件内容重建原来二叉树的过程叫做二叉树的反序列化。给定一棵二叉树的头节点head，并已知二叉树节点值的类型为32位整型。请设计一种二叉树序列化和反序列化的方案并用代码实现。 应用：判断两颗二叉树中是否有子树完全相同，先序列化为文件，然后kmp 思路将每个树的节点的值放在字符串中，用一个分隔符分开来，不然会引起歧义，然后将空节点也用特殊符号代替本题用!代表分隔符，用#表示空结点思路就是先序遍历和层次遍历，注意处理过程稍有不同 先序序列化及反序列化12345678910111213141516171819202122232425262728293031323334353637383940// 先序序列化//类似于树的先序遍历public static String serialByPre(Node head) &#123; if (head == null) &#123; return &quot;#!&quot;; &#125; //处理根节点，然后左右节点 String res = head.value + &quot;!&quot;; res += serialByPre(head.left); res += serialByPre(head.right); return res;&#125;// 先序反序列化public static Node reconByPreString(String preStr) &#123; //分割字符串 String[] values = preStr.split(&quot;!&quot;); //将字符添加到队列中 Queue&lt;String&gt; preQueue = new LinkedList&lt;String&gt;(); for (int i = 0; i &lt; values.length; i++) &#123; preQueue.add(values[i]); &#125; //还原树 return reconPreOrder(preQueue);&#125;//还原树的过程类似于树的先序遍历public static Node reconPreOrder(Queue&lt;String&gt; queue) &#123; //得到队头结点 String string = queue.poll(); if(string.equals(&quot;#&quot;))&#123; return null; &#125; //处理根节点 Node head = new Node(Integer.valueOf(string)); //处理左右节点 head.left = reconPreOrder(queue); head.right = reconPreOrder(queue); return head;&#125; 层次序列化及反序列化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 层次序列化public static String serialByLevel(Node head) &#123; if (head == null) &#123; return &quot;#!&quot;; &#125; Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); // 头结点入队处理，而不出队时处理 // 因为这里对于空节点也要处理 String res = Integer.valueOf(head.value) + &quot;!&quot;; queue.add(head); while (!queue.isEmpty()) &#123; Node node = queue.poll(); // 入队时处理左右节点，因为有空节点 if (node.left != null) &#123; res += Integer.valueOf(node.left.value) + &quot;!&quot;; queue.add(node.left); &#125; else &#123; // 空结点也要处理 res += &quot;#!&quot;; &#125; if (node.right != null) &#123; res += Integer.valueOf(node.right.value) + &quot;!&quot;; queue.add(node.right); &#125; else &#123; res += &quot;#!&quot;; &#125; &#125; return res;&#125;public static Node reconByLevelString(String levelStr) &#123; String[] strings = levelStr.split(&quot;!&quot;); //与层次遍历相似 Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;(); int index = 0; //处理头结点并入队 Node head = generateNodeByString(strings[index++]); //不空才入队 if(head != null)&#123; queue.add(head); &#125; while(!queue.isEmpty())&#123; //出队头 Node node = queue.poll(); //处理左结点，并入队 node.left = generateNodeByString(strings[index++]); if(node.left != null)&#123; queue.add(node.left); &#125; //处理右结点，并入队 node.right = generateNodeByString(strings[index++]); if(node.right != null)&#123; queue.add(node.right); &#125; &#125; return head;&#125;// 根据value返回nodepublic static Node generateNodeByString(String val) &#123; if (val.equals(&quot;#&quot;)) &#123; return null; &#125; return new Node(Integer.valueOf(val));&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"链表的相关问题","slug":"链表的相关问题","date":"2015-11-26T14:01:58.000Z","updated":"2017-04-20T07:38:16.000Z","comments":true,"path":"2015/11/26/链表的相关问题/","link":"","permalink":"http://duyao.github.io/2015/11/26/链表的相关问题/","excerpt":"两个单链表相交的一系列问题单链表可能有环,也可能无环。给定两个单链表的头节点 head1 和 head2, 这两个链表可能相交,也可能不相交。请实现一个函数,如果两个链表相交,请返回相交 的第一个节点;如果不相交,返回 null 即可。要求:如果链表1的长度为N，链表2的长度为M，时间复杂度请达到O(N+M)，额外空间复杂度请达到O(1)。 思路本题目可以拆分为2大问题 是否有环 是否相交 然后又可以拆分为多个子问题 判断单链表是否有环，如果有找出入环点 两个无环链表是否相交 两个有环链表是否相交 一个有环链表和一个无环链表是否相交","text":"两个单链表相交的一系列问题单链表可能有环,也可能无环。给定两个单链表的头节点 head1 和 head2, 这两个链表可能相交,也可能不相交。请实现一个函数,如果两个链表相交,请返回相交 的第一个节点;如果不相交,返回 null 即可。要求:如果链表1的长度为N，链表2的长度为M，时间复杂度请达到O(N+M)，额外空间复杂度请达到O(1)。 思路本题目可以拆分为2大问题 是否有环 是否相交 然后又可以拆分为多个子问题 判断单链表是否有环，如果有找出入环点 两个无环链表是否相交 两个有环链表是否相交 一个有环链表和一个无环链表是否相交 判断单链表是否有环，如果有找出入环点 快指针一次走两步，慢指针一次走一步，直到快慢指针相遇 新指针从链表头开始走，慢指针从刚刚位置继续走 新指针和慢指针相遇的地方就是入环点 1234567891011121314151617181920212223242526272829// 判断链表是否有环 public static Node getLoopNode(Node head) &#123; if(head == null || head.next ==null || head.next.next ==null)&#123; return null; &#125; Node nq = head; Node ns = head.next.next; //循环使得快慢指针相遇 while (ns != nq) &#123; if(ns == null || nq == null)&#123; break; &#125; ns = ns.next; nq = nq.next.next; &#125; Node node = head; //新指针和慢指针遍历，直到相遇 while (ns != node) &#123; if(ns == null || node == null)&#123; return null; &#125; node = node.next; ns = ns.next; &#125; return node; &#125; 两个无环链表是否相交 如果两个没有环的链表相交于某一节点，那么在这个节点之后的所有节点都是两个链表共有的 因此这两个链表的最后一个节点一定是公共的所以先遍历两个链表，判断末尾节点是否是同一个，同时设置一个计数，表示两个链表长度的差值然后让长的链表先从头走过这个差值，然后长短一起走，直到发现第一个公共节点 这个长度差值还可以体现在求链表倒数第k个结点。即有2个指针指向链表，一个先走k步，然后两者一起走，直到有一个为空为止。这样非空的指针指向的就是倒数k的节点因为两者一个都相差k步，所有快的走完全程，慢的就停在了倒数k步上 12345678910111213141516171819202122232425262728293031323334353637// 无环的时候找公共的节点public static Node noLoop(Node head1, Node head2) &#123; // n是记录长链表比短链表长多少，然后让长链表走过这一段，之后一起走，找到公共节点 int n = 0; // head1走完全程 Node n1 = head1; while (n1.next != null) &#123; n++; n1 = n1.next; &#125; // head2走完全程 Node n2 = head2; while (n2.next != null) &#123; n--; n2 = n2.next; &#125; // 最后一个节点不相同，则一定没有公共节点 if (n1 != n2) &#123; return null; &#125; // 把n1设置为长度更长的链表 n1 = n &gt; 0 ? head1 : head2; n2 = n1 == head1 ? head2 : head1; // n1把多出来的部分走过 n = Math.abs(n); while (n != 0) &#123; n--; n1 = n1.next; &#125; // n1==n2时就是公共节点 while (n1 != n2) &#123; n1 = n1.next; n2 = n2.next; &#125; return n1;&#125; 两个有环链表是否相交 两个入环点相同说明相交点在环内，只需要判断一链表上俩指针相遇的那个节点，在不在另一条链表上 两个入环点不同说明相交点不在环内，则类似于两个无环链表的遍历，只是遍历到入环点就停止 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) &#123; if (loop1 == loop2) &#123; // 入环点相同，相交点在环外 // 方法类似无环链表求公共点 // 先求长度差，然后长的走过长度差，之后一起走，直到相遇 int n = 0; Node n1 = head1; //遍历到入环点停止，而不是为空 while (n1.next != loop1) &#123; n++; n1 = n1.next; &#125; Node n2 = head2; //遍历到入环点停止，而不是为空 while (n2.next != loop2) &#123; n--; n2 = n2.next; &#125; n1 = n &gt; 0 ? head1 : head2; n2 = n1 == head1 ? head2 : head1; n = Math.abs(n); //长的走过多余的部分 while (n != 0) &#123; n--; n1 = n1.next; &#125; //一起走，直到相遇 while (n1 != n2) &#123; n1 = n1.next; n2 = n2.next; &#125; return n1; &#125; else &#123; // 入环点不同，只要遍历一个环，检查另一个入环点是否在其中即可 Node node = loop1; do &#123; // loop2是否在loop1中 if (node == loop2) &#123; return node; &#125; node = node.next; &#125; while (node != loop1); // 不在其中，则不相交 return null; &#125;&#125; 一个有环链表和一个无环链表是否相交一个有环链表和一个无环链表不可能相交 代码1234567891011121314151617public static Node getIntersectNode(Node head1, Node head2) &#123; if (head1 == null || head2 == null) &#123; return null; &#125; Node loop1 = getLoopNode(head1); Node loop2 = getLoopNode(head2); // 12都没有环 if (loop1 == null &amp;&amp; loop2 == null) &#123; return noLoop(head1, head2); &#125; // 12都有环 if (loop1 != null &amp;&amp; loop2 != null) &#123; return bothLoop(head1, loop1, head2, loop2); &#125; // 一个有环一个无环，不可能相交！ return null;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"11.2","slug":"11.2","date":"2015-11-26T07:15:04.000Z","updated":"2015-11-27T12:59:54.000Z","comments":true,"path":"2015/11/26/11.2/","link":"","permalink":"http://duyao.github.io/2015/11/26/11.2/","excerpt":"判断一个链表是否为回文结构给定一个链表的头节点head，请判断该链表是不是回文结构。例如：1-&gt;2-&gt;1，返回true。1-&gt;2-&gt;2-&gt;1，返回true。15-&gt;6-&gt;15，返回true。1-&gt;2-&gt;3，返回false。 思路 &amp; 代码123456789//链表结构public static class Node &#123; public int value; public Node next; public Node(int data) &#123; this.value = data; &#125;&#125;","text":"判断一个链表是否为回文结构给定一个链表的头节点head，请判断该链表是不是回文结构。例如：1-&gt;2-&gt;1，返回true。1-&gt;2-&gt;2-&gt;1，返回true。15-&gt;6-&gt;15，返回true。1-&gt;2-&gt;3，返回false。 思路 &amp; 代码123456789//链表结构public static class Node &#123; public int value; public Node next; public Node(int data) &#123; this.value = data; &#125;&#125; 空间复杂度O(n/2)使用2个指针，一个快一个慢，快的一次走2步，慢的一次走一步，直到空为止此时慢指针停在中间位置，然后将慢指针后面的内容入栈因为栈是逆序的，所以相当于将后半部分的链表逆序然后从栈顶与链表头开始比较是否相同当元素个数为奇数时，如1,2,3,2,1，入栈的值为3,2,1当元素个数为偶数时，如1,2,3,4,2,1，入栈的值为4,2,1 1234567891011121314151617181920212223242526272829303132333435public static boolean isPalindrome1(Node head) &#123; if(head == null || head.next == null)&#123; //链表为空或者只有一个元素 return true; &#125; //慢指针 Node ns = head; //快指针 Node nq = head; //这里判断的条件不是nq.next.next //因为可能nq到了末尾，而nq.next为空，nq.next.next是不存在的 //也可能是nq为被赋值为空 while(nq != null &amp;&amp; nq.next != null)&#123; //快指针一次走2步，慢指针一次走一步 ns = ns.next; nq = nq.next.next; &#125; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); //慢指针的后半段入栈 while(ns != null)&#123; stack.push(ns); ns = ns.next; &#125; //栈中内容与链表头开始比较 while(!stack.empty())&#123; if(head.value != stack.pop().value)&#123; //元素不符合 return false; &#125; head = head.next; &#125; return true;&#125; 空间复杂度O(1)该方法改变了链接的结构，之后要进行还原这个方法与前一种部分类似，也是在快慢指针一起走直到为空。之后就有所区别了，即将慢指针后半部分的值全部反向指 原链表为1,2,3,2,1，修改后为1-&gt;2-&gt;3&lt;-2&lt;-1 原链表为1,2,3,4,2,1，修改后为1-&gt;2-&gt;3-&gt;4&lt;-2&lt;-1 然后从两端分别遍历，查看是否是回文注意的是节点为空的情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273//只用空间复杂度O(1)public static boolean isPalindrome2(Node head) &#123; boolean res = true; if(head == null || head.next == null)&#123; //链表为空或者只有一个元素 return true; &#125; //慢指针 Node ns = head; //快指针 Node nq = head; while(nq != null &amp;&amp; nq.next != null)&#123; ns = ns.next; nq = nq.next.next; &#125; //将ns后面的链表反转 Node prior = ns; Node cur = ns.next; //两个节点单独判断 if(cur == null)&#123; //说明此链表中只有2个元素,直接返回不需要修复 return head.value == ns.value ? true: false; &#125; //只有两个节点的时候，无nextNode Node nextNode = cur.next; //将中间的节点的后继设为空 ns.next = null; while(cur != null) &#123; //反向指 cur.next = prior; prior = cur; cur = nextNode; //判空,因为cur为空，nextNode不存在 if(cur == null)&#123; break; &#125; nextNode = nextNode.next; &#125; //结束后prior就是头结点 //head和prior不能破坏因为还要修复链表 ns = head; cur = prior; //判断是否是回文 while(ns != null &amp;&amp; cur != null)&#123; if(ns.value != cur.value)&#123; res = false; &#125; ns = ns.next; cur = cur.next; &#125; //修复链表 cur = prior.next; //nextNode可能为空，当只有3个元素的时候，所以下面重置nextNode会判断 nextNode = cur.next; prior.next = null; while(cur != null)&#123; cur.next = prior; prior = cur; cur = nextNode; //判空,因为cur为空，nextNode不存在 if(cur == null)&#123; break; &#125; nextNode = nextNode.next; &#125; return res; &#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"11.1","slug":"11.1","date":"2015-11-26T04:52:22.000Z","updated":"2015-11-27T12:59:54.000Z","comments":true,"path":"2015/11/26/11.1/","link":"","permalink":"http://duyao.github.io/2015/11/26/11.1/","excerpt":"如何仅用递归函数和栈操作逆序一个栈一个栈依次压入1,2,3,4,5那么从栈顶到栈底分别为5,4,3,2,1。将这个栈转置后，从栈顶到栈底为1,2,3,4,5，也就是实现栈中元素的逆序，但是只能用递归函数来实现，而不能用另外的数据结构。 思路如果仍然允许使用其他栈，那么每次要取得栈底元素，然后投入到栈中int getAndRemoveLastElement(Stack&lt;Integer&gt; stack)是取得栈底，并且保持栈的状态result栈顶，依次为5,4,3,2,1，然后栈空返回1last是得到的栈底元素，即刚刚的返回的1，最后又返回last为1可见递归过程中last一直都是1依次压入result，2,3,4,5，这个过程就还原了栈","text":"如何仅用递归函数和栈操作逆序一个栈一个栈依次压入1,2,3,4,5那么从栈顶到栈底分别为5,4,3,2,1。将这个栈转置后，从栈顶到栈底为1,2,3,4,5，也就是实现栈中元素的逆序，但是只能用递归函数来实现，而不能用另外的数据结构。 思路如果仍然允许使用其他栈，那么每次要取得栈底元素，然后投入到栈中int getAndRemoveLastElement(Stack&lt;Integer&gt; stack)是取得栈底，并且保持栈的状态result栈顶，依次为5,4,3,2,1，然后栈空返回1last是得到的栈底元素，即刚刚的返回的1，最后又返回last为1可见递归过程中last一直都是1依次压入result，2,3,4,5，这个过程就还原了栈 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//反转栈public static void reverse(Stack&lt;Integer&gt; stack) &#123; if (stack.isEmpty()) &#123; //栈空返回 return; &#125; //取出栈底元素 //依次为1，2，3，4，5 int i = getAndRemoveLastElement(stack); //递归调用，使得栈空 reverse(stack); //压入栈底元素i //因此5，4，3，2，1被压入 stack.push(i);&#125;//取得栈底元素，并且其余元素与原始状态相同public static int getAndRemoveLastElement(Stack&lt;Integer&gt; stack) &#123; //result取得栈顶 int result = stack.pop(); if (stack.isEmpty()) &#123; //栈空返回栈顶，那么最后应该返回1 return result; &#125; else &#123; //得到栈空的返回值1 int last = getAndRemoveLastElement(stack); //此时栈是空的，压入上一次的res //依次为2，3，4，5 stack.push(result); //返回last即1 //由此可见每次返回的都是last1 return last; &#125;&#125;public static void main(String[] args) &#123; Stack&lt;Integer&gt; test = new Stack&lt;Integer&gt;(); test.push(1); test.push(2); test.push(3); test.push(4); test.push(5); reverse(test); while (!test.isEmpty()) &#123; System.out.println(test.pop()); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"10.2","slug":"10.2","date":"2015-11-25T05:11:16.000Z","updated":"2015-11-27T12:59:54.000Z","comments":true,"path":"2015/11/25/10.2/","link":"","permalink":"http://duyao.github.io/2015/11/25/10.2/","excerpt":"排成一条线的纸牌博弈问题给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。例如:arr=[1,2,100,4]。开始时玩家A只能拿走1或4。如果玩家A拿走1，则排列变为[2,100,4]，接下来玩家B可以拿走2或4，然后继续轮到玩家A。如果开始时玩家A拿走4，则排列变为[1,2,100]，接下来玩家B可以拿走1或100，然后继续轮到玩家A。玩家A作为绝顶聪明的人不会先拿4，因为拿了4之后玩家B将拿走100。所以玩家A会先拿1，让排列变为[2,100,4]，接下来玩家B不管怎么选，100都会被玩家A拿走。玩家A会获胜，分数为101。所以返回101。arr=[1,100,2]。开始时玩家A不管拿1还是2，玩家B作为绝顶聪明的人，都会把100拿走。玩家B会获胜，分数为100。所以返回100。","text":"排成一条线的纸牌博弈问题给定一个整型数组arr，代表数值不同的纸牌排成一条线。玩家A和玩家B依次拿走每张纸牌，规定玩家A先拿，玩家B后拿，但是每个玩家每次只能拿走最左或最右的纸牌，玩家A和玩家B都绝顶聪明。请返回最后获胜者的分数。例如:arr=[1,2,100,4]。开始时玩家A只能拿走1或4。如果玩家A拿走1，则排列变为[2,100,4]，接下来玩家B可以拿走2或4，然后继续轮到玩家A。如果开始时玩家A拿走4，则排列变为[1,2,100]，接下来玩家B可以拿走1或100，然后继续轮到玩家A。玩家A作为绝顶聪明的人不会先拿4，因为拿了4之后玩家B将拿走100。所以玩家A会先拿1，让排列变为[2,100,4]，接下来玩家B不管怎么选，100都会被玩家A拿走。玩家A会获胜，分数为101。所以返回101。arr=[1,100,2]。开始时玩家A不管拿1还是2，玩家B作为绝顶聪明的人，都会把100拿走。玩家B会获胜，分数为100。所以返回100。 思路及代码暴力递归设置2个递归函数，一个是先拿f，一个是后拿s结果是看f先拿整体区域和s后拿整体区域的最大值 1234567891011121314151617181920212223242526272829303132// 先拿时，[i,j]段获得钱数public static int f(int[] arr, int i, int j) &#123; //对于i=j，即只有一个元素，作为先拿者，一定会拿走 if (i == j) &#123; return arr[i]; &#125; // 面对[i,j]，先拿着只能取两端的值，然后后拿剩余的值 // 因此先拿arr[i]后拿剩余i+1的部分s(arr, i + 1, j) // 先拿着一定会选取最大的拿走 return Math.max(arr[i] + s(arr, i + 1, j), arr[j] + s(arr, i, j - 1));&#125;// 后拿时，[i,j]段获得钱数public static int s(int[] arr, int i, int j) &#123; //对于i=j，即只有一个元素，作为后拿者，一定拿不到，所以返回0 if (i == j) &#123; return 0; &#125; //面对[i,j]，后拿着只能先拿除了两端以外的值，是先拿，因此是f(arr, i + 1, j) //但是在本次，拿不到两端值，因为先拿者已经拿走，故无arr[i]+f(arr, i + 1, j) //也没有arr[i+1]+f(arr, i + 1, j)，因为面对的区间是[i,j]要么拿边界，要么不拿 //由于先拿的人选择是最大的，而总和是一定的，因此，后者只能是最小min return Math.min(f(arr, i + 1, j), f(arr, i, j - 1));&#125;public static int win1(int[] arr) &#123; if (arr == null || arr.length == 0) &#123; return 0; &#125; //先拿或者后拿的最大值 return Math.max(f(arr, 0, arr.length - 1), s(arr, 0, arr.length - 1));&#125; 优化递归f和s记录每个区间上的值 f[i][j]表示先拿[i,j]区间上，能获得的最大值 s[i][j]表示后拿[i,j]区间上，能获得的最大值 123456789101112131415161718192021public static int win2(int[] arr) &#123; if (arr == null || arr.length == 0) &#123; return 0; &#125; //f[i][j] 表示先拿的[i,j]的位置可以获得的最大钱数 int[][] f = new int[arr.length][arr.length]; int[][] s = new int[arr.length][arr.length]; for (int j = 0; j &lt; arr.length; j++) &#123; //初始化，先拿者面对arr[j]一定会全部拿走，而后拿者只能拿走0 f[j][j] = arr[j]; s[j][j] = 0; //i=j-1而j必须以0开始，但不会报错，因为i &gt;= 0 for(int i = j-1; i &gt;= 0; i--)&#123; f[i][j] = Math.max(arr[i] + s[i+1][j], arr[j] + s[i][j-1]); s[i][j] = Math.min(f[i+1][j], f[i][j-1]); &#125; &#125; return Math.max(f[0][arr.length-1], s[0][arr.length-1]);&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"10.1","slug":"10.1","date":"2015-11-25T02:21:32.000Z","updated":"2015-11-27T12:59:06.000Z","comments":true,"path":"2015/11/25/10.1/","link":"","permalink":"http://duyao.github.io/2015/11/25/10.1/","excerpt":"表达式得到期望结果的组成种数给定一个只由0(假)、1(真)、&amp;(逻辑与)、|(逻辑或)和^(异或)五种字符组成的字符串express，再给定一个布尔值desired。返回express能有多少种组合方式，可以达到desired的结果。express=“1^0|0|1”，desired=false。只有1^((0|0)|1)和1^(0|(0|1))的组合可以得到false。返回2。express=“1”，desired=false。没有组合可以得到false。返回0。","text":"表达式得到期望结果的组成种数给定一个只由0(假)、1(真)、&amp;(逻辑与)、|(逻辑或)和^(异或)五种字符组成的字符串express，再给定一个布尔值desired。返回express能有多少种组合方式，可以达到desired的结果。express=“1^0|0|1”，desired=false。只有1^((0|0)|1)和1^(0|(0|1))的组合可以得到false。返回2。express=“1”，desired=false。没有组合可以得到false。返回0。 思路 &amp; 代码暴力递归先对表达式必须进行判断，必须满足一下几点 长度必须为偶数 奇数位上是0或者1 偶数位上是^|&amp; 然后对于每一个运算符作为分界点，分别计算左右两边的方法数使得满足disired，然后相乘得到方法数，再把所有方法数相加即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//判断字符串是否合法public static boolean isValid(char[] exp) &#123; //长度为偶数 if ((exp.length &amp; 1) == 0) &#123; return false; &#125; //奇数位是0或1 for (int i = 0; i &lt; exp.length; i = i + 2) &#123; if ((exp[i] != &apos;1&apos;) &amp;&amp; (exp[i] != &apos;0&apos;)) &#123; return false; &#125; &#125; //偶数为是&amp;,|,^ for (int i = 1; i &lt; exp.length; i = i + 2) &#123; if ((exp[i] != &apos;&amp;&apos;) &amp;&amp; (exp[i] != &apos;|&apos;) &amp;&amp; (exp[i] != &apos;^&apos;)) &#123; return false; &#125; &#125; return true;&#125;public static int num1(String express, boolean desired) &#123; if (express == null || express.equals(&quot;&quot;)) &#123; return 0; &#125; char[] exp = express.toCharArray(); if (!isValid(exp)) &#123; return 0; &#125; return p(exp, desired, 0, exp.length - 1);&#125;//判断l到r上的表达式有多少种满足desired的方法public static int p(char[] exp, boolean desired, int l, int r) &#123; if (l == r) &#123; if (exp[l] == &apos;1&apos;) &#123; return desired ? 1 : 0; &#125; else &#123; return desired ? 0 : 1; &#125; &#125; int res = 0; if (desired) &#123; //以位运算符分割表达式，分别计算表达的值 //总的可能数为左边可能数乘以右边可能数 for (int i = l + 1; i &lt; r; i += 2) &#123; //以该运算符为分界点 switch (exp[i]) &#123; case &apos;&amp;&apos;: //desired为1，运算符是&amp;,左右必须都是true res += p(exp, true, l, i - 1) * p(exp, true, i + 1, r); break; case &apos;|&apos;: //desired为1，运算符是|,左1右0,左0右1，左1右1 res += p(exp, true, l, i - 1) * p(exp, false, i + 1, r); res += p(exp, false, l, i - 1) * p(exp, true, i + 1, r); res += p(exp, true, l, i - 1) * p(exp, true, i + 1, r); break; case &apos;^&apos;: //desired为1，运算符是^,左1右0,左0右1 res += p(exp, true, l, i - 1) * p(exp, false, i + 1, r); res += p(exp, false, l, i - 1) * p(exp, true, i + 1, r); break; &#125; &#125; &#125; else &#123; for (int i = l + 1; i &lt; r; i += 2) &#123; switch (exp[i]) &#123; case &apos;&amp;&apos;: res += p(exp, false, l, i - 1) * p(exp, true, i + 1, r); res += p(exp, true, l, i - 1) * p(exp, false, i + 1, r); res += p(exp, false, l, i - 1) * p(exp, false, i + 1, r); break; case &apos;|&apos;: res += p(exp, false, l, i - 1) * p(exp, false, i + 1, r); break; case &apos;^&apos;: res += p(exp, true, l, i - 1) * p(exp, true, i + 1, r); res += p(exp, false, l, i - 1) * p(exp, false, i + 1, r); break; &#125; &#125; &#125; return res;&#125; 优化递归使用数组记录算过的值由于p(char[] exp, boolean desired, int l, int r)递归中有3个变量，应该使用三维表进行记录但是使用2张二维表就可以，因为boolean desired只有真假两种取值仍然是以位运算符号作为分割，计算所有的方法数，并记录 t[i][j]表示第i到j([i,j])的exp中结果为true的结果数 f[i][j]表示第i到j([i,j])的exp中结果为false的结果数12345678910111213141516171819202122232425262728293031323334353637383940414243444546//优化递归，记录所计算的值//p(char[] exp, boolean desired, int l, int r)递归中有3个变量，但是使用2张二维表就可以//一个表记录结果是true，另一个记录结果是falsepublic static int num2(String express, boolean desired) &#123; if (express == null || express.equals(&quot;&quot;)) &#123; return 0; &#125; char[] exp = express.toCharArray(); if (!isValid(exp)) &#123; return 0; &#125; //t[i][j]表示第i到j的exp中结果为true的结果数 int[][] t = new int[exp.length][exp.length]; //f[i][j]表示第i到j的exp中结果为false的结果数 int[][] f = new int[exp.length][exp.length]; t[0][0] = exp[0] == &apos;0&apos; ? 0 : 1; f[0][0] = exp[0] == &apos;1&apos; ? 0 : 1; //以i为尾，j为头，算t[i][j]与f[i][j] //依次向两边扩散，计算 for (int i = 2; i &lt; exp.length; i += 2) &#123; //t[i][i]表示第i个位置为true的结果数 //因此只要看是t[i][i]的值，值1返回1，值0返回0 t[i][i] = exp[i] == &apos;0&apos; ? 0 : 1; f[i][i] = exp[i] == &apos;1&apos; ? 0 : 1; for (int j = i - 2; j &gt;= 0; j -= 2) &#123; //以k+1为分界，判断前面和后后的组成数目 for (int k = j; k &lt; i; k += 2) &#123; if (exp[k + 1] == &apos;&amp;&apos;) &#123; //k+1是&amp;，结果是true的可能是前1后1 t[j][i] += t[j][k] * t[k + 2][i]; //k+1是&amp;，结果是false的可能是前1后0，前0后1，前0后0 //这里做了合并，先算前1后0和前0后0的结果，再加上前0后1 f[j][i] += (f[j][k] + t[j][k]) * f[k + 2][i] + f[j][k] * t[k + 2][i]; &#125; else if (exp[k + 1] == &apos;|&apos;) &#123; t[j][i] += (f[j][k] + t[j][k]) * t[k + 2][i] + t[j][k] * f[k + 2][i]; f[j][i] += f[j][k] * f[k + 2][i]; &#125; else &#123; t[j][i] += f[j][k] * t[k + 2][i] + t[j][k] * f[k + 2][i]; f[j][i] += f[j][k] * f[k + 2][i] + t[j][k] * t[k + 2][i]; &#125; &#125; &#125; &#125; return desired ? t[0][t.length - 1] : f[0][f.length - 1];&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"9.4","slug":"9.4","date":"2015-11-20T02:47:58.000Z","updated":"2015-11-24T12:50:50.000Z","comments":true,"path":"2015/11/20/9.4/","link":"","permalink":"http://duyao.github.io/2015/11/20/9.4/","excerpt":"字符串的交错组成给定三个字符串str1、str2和aim。如果aim包含且仅包含来自str1和str2的所有字符，而且在aim中属于str1的字符之间保持原来在str1中的顺序，属于str2的字符之间保持原来在str2中的顺序，那么称aim是str1和str2的交错组成。实现一个函数，判断aim是否是str1和str2交错组成。str1=“AB”，str2=“12”。那么“AB12”、“A1B2”、“A12B”、“1A2B”和“1AB2”等等都是str1和str2交错组成。","text":"字符串的交错组成给定三个字符串str1、str2和aim。如果aim包含且仅包含来自str1和str2的所有字符，而且在aim中属于str1的字符之间保持原来在str1中的顺序，属于str2的字符之间保持原来在str2中的顺序，那么称aim是str1和str2的交错组成。实现一个函数，判断aim是否是str1和str2交错组成。str1=“AB”，str2=“12”。那么“AB12”、“A1B2”、“A12B”、“1A2B”和“1AB2”等等都是str1和str2交错组成。 思路 &amp;&amp; 代码经典动态规划如果str1的长度为M， str2的长度为N，经典动态规划的方法可以达到时间复杂度O(M*N)，额外空间复杂度O(M*N)。 首先aim如果是str1和str2的交错组成， aim的长度一定是M+N，否则直接返回false。然后生成大小为(M+1)*(N+1)布尔类型的矩阵dp。dp[i][j]的值代表aim[0..i+j-1]能否被str1[0..i-1]和str2[0..j-1]交错组成。 计算dp矩阵的时候，是从左到右再从上到下的计算的， dp[M][N]就是dp矩阵中最右下角的值，就表示aim整体能否被str1整体和str2整体交错组成，也就是最终结果。具体说明dp矩阵每个位置的值是如何计算。 1， dp[0][0]=true。 aim为空串时，当然可以被str1为空串和str2为空串交错组成。2，矩阵dp第一列即dp[0..M-1][0]。 dp[i][0]表示aim[0..i-1]能否只被str1[0..i-1]交错组成。如果aim[0..i-1]等于str1[0..i-1]，则令dp[i][0]=true，否则令dp[i][0]=false。3，矩阵dp第一行即dp[0][0..N-1]。 dp[0][j]表示aim[0..j-1]能否只被str2[0..j-1]交错组成。如果aim[0..j-1]等于str1[0..j-1]，则令dp[i][0]=true，否则令dp[i][0]=false。4，对于其他位置(i,j)， dp[i][j]的值由下面的情况决定。1） dp[i-1][j]代表aim[0..i+j-2]能否被str1[0..i-2]和str2[0..j-1]交错组成，如果可以，那么如果再有str1[i-1]等于aim[i+j-1]，说明str1[i-1]可以作为交错组成aim[0..i+j-1]的最后一个字符。令dp[i][j]=true。2） dp[i][j-1]代表aim[0..i+j-2]能否被str1[0..i-1]和str2[0..j-2]交错组成，如果可以，那么如果再有str2[j-1]等于aim[i+j-1]，说明str1[j-1]可以作为交错组成aim[0..i+j-1]的最后一个字符。令dp[i][j]=true。3）如果情况1）和情况2）都不满足，令dp[i][j]=false。具体过程请参看如下代码中的isCross1方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344public static boolean isCross1(String str1, String str2, String aim) &#123; if (str1 == null || str2 == null || aim == null) &#123; return false; &#125; char[] char1 = str1.toCharArray(); char[] char2 = str2.toCharArray(); char[] caim = aim.toCharArray(); if (char1.length + char2.length != caim.length) &#123; return false; &#125; // 多增加一行和一列，为空值，方便计算 int row = char1.length + 1; int col = char2.length + 1; boolean[][] dp = new boolean[row][col]; dp[0][0] = true; for (int i = 1; i &lt; row; i++) &#123; // str1[0,i-1]交错aim[0,i-1] if(char1[i-1] != caim[i-1])&#123; //遇到不等就退出循环，初始化时是false break; &#125; dp[i][0] = true; &#125; for (int i = 1; i &lt; col; i++) &#123; // str2[0,i-1]交错aim[0,i-1] if(char2[i-1] != caim[i-1])&#123; break; &#125; dp[0][i] = true; &#125; for (int i = 1; i &lt; row; i++) &#123; for (int j = 1; j &lt; col; j++) &#123; if (caim[i + j - 1] == char1[i - 1] &amp;&amp; dp[i - 1][j] || caim[i + j - 1] == char2[j - 1] &amp;&amp; dp[i][j - 1]) &#123; dp[i][j] = true; &#125; &#125; &#125; return dp[row - 1][col - 1];&#125; 经典动态规划方法结合空间压缩的方法。如果结合空间压缩的技巧可以把额外空间复杂度减至O(min{M,N})。实际进行空间压缩的时候，比较str1和str2哪个长度较小，长度较小的那个作为列对应的字符串，然后生成和较短字符串长度一样的一维数组dp，滚动更新即可。具体请参看如下代码中的isCross2方法。12345678910111213141516171819202122232425262728293031323334353637383940//压缩空间，只用一行表示一个数组，然后滚动更新public static boolean isCross2(String str1, String str2, String aim) &#123; if (str1 == null || str2 == null || aim == null) &#123; return false; &#125; char[] ch1 = str1.toCharArray(); char[] ch2 = str2.toCharArray(); char[] chaim = aim.toCharArray(); if (chaim.length != ch1.length + ch2.length) &#123; return false; &#125; //选出长短，长的在外循环，短的在循环内，因为使得不断更新短的数值 char[] longs = ch1.length &gt;= ch2.length ? ch1 : ch2; char[] shorts = ch1.length &lt; ch2.length ? ch1 : ch2; boolean[] dp = new boolean[shorts.length + 1]; dp[0] = true; //初始化该行 for (int i = 1; i &lt;= shorts.length; i++) &#123; if (shorts[i - 1] != chaim[i - 1]) &#123; break; &#125; dp[i] = true; &#125; //滚动更新的过程 for (int i = 1; i &lt;= longs.length; i++) &#123; //更新该行的第一列 dp[0] = dp[0] &amp;&amp; longs[i - 1] == chaim[i - 1]; for (int j = 1; j &lt;= shorts.length; j++) &#123; //此时只更新到j-1，而j还没有更新，表示的是上一行的j值，即要更新位置的上面 //j-1已经更新，表示的是要更新位置的左边 if ((longs[i - 1] == chaim[i + j - 1] &amp;&amp; dp[j]) || (shorts[j - 1] == chaim[i + j - 1] &amp;&amp; dp[j - 1])) &#123; dp[j] = true; &#125; else &#123; dp[j] = false; &#125; &#125; &#125; return dp[shorts.length];&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"9.3","slug":"9.3","date":"2015-11-19T09:13:25.000Z","updated":"2015-12-08T12:36:48.000Z","comments":true,"path":"2015/11/19/9.3/","link":"","permalink":"http://duyao.github.io/2015/11/19/9.3/","excerpt":"最小编辑代价给定两个字符串str1和str2，再给定三个整数ic、dc和rc分别代表插入、删除和替换一个字符的代价，返回将str1编辑成str2的最小代价。str1=“abc”，str2=“adc”，ic=5，dc=3，rc=2。从“abc”编辑成“adc”，把’b’替换成’d’是代价最小的。所以返回2。str1=“abc”，str2=“adc”，ic=5，dc=3，rc=100。从“abc”编辑成“abd”，先删除’b’然后插入’d’是代价最小的。所以返回8。str1=“abc”，str2=“abc”，ic=5，dc=3，rc=2。不用编辑了，本来就是一样的字符串。所以返回0。","text":"最小编辑代价给定两个字符串str1和str2，再给定三个整数ic、dc和rc分别代表插入、删除和替换一个字符的代价，返回将str1编辑成str2的最小代价。str1=“abc”，str2=“adc”，ic=5，dc=3，rc=2。从“abc”编辑成“adc”，把’b’替换成’d’是代价最小的。所以返回2。str1=“abc”，str2=“adc”，ic=5，dc=3，rc=100。从“abc”编辑成“abd”，先删除’b’然后插入’d’是代价最小的。所以返回8。str1=“abc”，str2=“abc”，ic=5，dc=3，rc=2。不用编辑了，本来就是一样的字符串。所以返回0。 思路该题目是3个字符串进行比较dp[i][j]代表str1[0..i-1]编辑成str2[0..j-1]的最小代价下面具体说明dp矩阵每个位置的值是如何计算的：1， dp[0][0]=0，表示str1空的子串编辑成str2空的子串的代价为0。2，矩阵dp第一列即dp[0..M-1][0]。 dp[i][0]表示str1[0..i-1]编辑成空串的最小代价，毫无疑问是把str1[0..i-1]所有字符删掉的代价，所以dp[i][0]=dci。3，矩阵dp第一行即dp[0][0..N-1]。 dp[0][j]表示空串编辑成str2[0..j-1]最小代价，毫无疑问是在空串里插入str2[0..j-1]所有字符的代价，所以dp[0][j]=ic\\j。4，其他位置按照从左到右再从上到下来计算， dp[i][j]的值只可能来自以下四种情况。1） str1[0..i-1]可以先编辑成str1[0..i-2]，也就是删除字符str1[i-1]，然后再由str1[0..i-2]编辑成str2[0..j-1]， dp[i-1][j]表示str1[0..i-2]编辑成str2[0..j-1]的最小代价， 那么dp[i][j]可能等于dc+dp[i-1][j]。2） str1[0..i-1]可以先编辑成str2[0..j-2]，然后str2[0..j-2]再插入字符str2[j-1]编辑成str2[0..j-1]， dp[i][j-1]表示str1[0..i-1]编辑成str2[0..j-2]的最小代价， 那么dp[i][j]可能等于dp[i][j-1]+ic。3）如果str1[i-1]!=str2[j-1]。先把str1[0..i-1]中str1[0..i-2]的部分可以先变成str2[0..j-2]，然后把字符str1[i-1]替换成str2[j-1]，这样str1[0..i-1]就编辑成str2[0..j-1]了。dp[i-1][j-1]表示str1[0..i-2]编辑成str2[0..i-2]的最小代价，那么dp[i][j]可能等于dp[i-1][j-1]+rc。4）如果str1[i-1]==str2[j-1]。先把str1[0..i-1]中str1[0..i-2]的部分可以先变成str2[0..j-2]，因为此时字符str1[i-1]等于str2[j-1]，所以str1[0..i-1]已经编辑成str2[0..j-1]了。dp[i-1][j-1]表示str1[0..i-2]编辑成str2[0..i-2]的最小代价，那么dp[i][j]可能等于dp[i-1][j-1]。5，以上四种可能的值中，选最小值作为dp[i][j]的值。 dp最右下角的值就是最终结果。具体过程请参看如下代码中的minCost1方法。 代码123456789101112131415161718192021222324252627282930313233343536373839public static int minCost(String str1, String str2, int ic, int dc, int rc) &#123; if (str1 == null || str2 == null) &#123; return 0; &#125; char[] chs1 = str1.toCharArray(); char[] chs2 = str2.toCharArray(); //多设置一行一列的空值，方便计算 int row = chs1.length + 1; int col = chs2.length + 1; //dp[0][0]是0，因为空变成空不需要代价 int[][] dp = new int[row][col]; for(int i = 1; i &lt; col; i++)&#123; //把空改为str2的代价是添加 dp[0][i] = ic*i; &#125; for(int j = 1; j &lt; row; j++)&#123; dp[j][0] = dc*j; &#125; for(int i = 1; i &lt; row; i++)&#123; for(int j= 1; j &lt; col; j++)&#123; //在3中取值找最小 //判断 if(chs1[i-1] == chs2[j-1])&#123; //最后一个相同，不用代价 dp[i][j] = dp[i-1][j-1]; &#125;else&#123; //不同就修改最后一个 dp[i][j] = dp[i-1][j-1]+rc; &#125; //先0,i-1变为0,j-2然后加上j-1 dp[i][j]=Math.min(dp[i][j], dp[i][j-1]+ic); //先0,i-1删除i-1得到0,i-2变为0,j-1 dp[i][j]=Math.min(dp[i][j], dp[i-1][j]+dc); &#125; &#125; return dp[row-1][col-1]; &#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"9.2","slug":"9.2","date":"2015-11-19T06:23:58.000Z","updated":"2015-11-19T09:12:42.000Z","comments":true,"path":"2015/11/19/9.2/","link":"","permalink":"http://duyao.github.io/2015/11/19/9.2/","excerpt":"最长公共子序列问题给定两个字符串str1和str2，返回两个字符串的最长公共子序列。str1=“1A2C3D4B56”，str2=“B1D23CA45B6A”。“123456”或者“12C4B6”都是最长公共子序列，返回哪一个都行。","text":"最长公共子序列问题给定两个字符串str1和str2，返回两个字符串的最长公共子序列。str1=“1A2C3D4B56”，str2=“B1D23CA45B6A”。“123456”或者“12C4B6”都是最长公共子序列，返回哪一个都行。 思路dp[i][j]的含义是str1[0..i]与str2[0..j]的最长公共子序列的长度。从左到右，再从上到下计算矩阵dp先计算第一行和第一列，再计算中间 str1[i] == str2[j]，dp[i][j] = dp[i-1][j-1]+1 str1[i] != str2[j]，dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); 算出dp后，要根据dp找到公共子序列1，从矩阵的右下角开始，有三种移动方式，向上、向左、 向左上。假设移动的过程中， i表示此时的⾏数， j表示此时的列数，同时⽤⼀个变量res来表示最长公共子序列。2，如果dp[i][j]⼤于dp[i-1][j]和dp[i][j-1]，说明之前在计算dp[i][j]的时候，⼀定是选择了决策dp[i-1][j-1]+1，可以确定str1[i]等于str2[j]，并且这个字符⼀定属于最长公共子序列，把这个字符放进res， 然后向左上方移动。3，如果dp[i][j]等于dp[i-1][j]，说明之前在计算dp[i][j]的时候， dp[i-1][j-1]+1这个决策不是必须选择的决策，向上方移动即可。4，如果dp[i][j]等于dp[i][j-1]，与步骤3同理，向左方移动。5，如果dp[i][j]同时等于dp[i-1][j]和dp[i][j-1]，向上还是向下⽆所谓，选择其中⼀个即可，反正不会错过必须选择的字符。 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public static int[][] getdp(char[] str1, char[] str2) &#123; int[][] dp = new int[str1.length][str2.length]; //初始化第一行 for(int i = 0; i &lt; str1.length; i++)&#123; if(str1[i]==str2[0])&#123; dp[i][0] = 1; for(int j = i+1; j &lt; str1.length; j++)&#123; dp[j][0] = 1; &#125; break; &#125;else&#123; dp[i][0] = 0; &#125; &#125; //初始化第一列 for(int i = 1; i &lt; str2.length; i++)&#123; if(str1[0]==str2[i])&#123; dp[0][i] = 1; for(int j = i+1; j &lt; str2.length; j++)&#123; dp[0][j] = 1; &#125; break; &#125;else&#123; dp[0][i] = 0; &#125; &#125; for(int i = 1; i &lt; str1.length; i++)&#123; for(int j = 1;j &lt; str2.length; j++)&#123; dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]); if(str1[i] == str2[j])&#123; dp[i][j] = dp[i-1][j-1]+1; &#125; &#125; &#125; return dp; &#125;public static char[] getAns(String str1, String str2)&#123; int m = str1.length()-1; int n = str2.length()-1; char[] char1 = str1.toCharArray(); char[] char2 = str2.toCharArray(); int[][] dp = getdp(char1, char2); int len = dp[m][n]; char[] str = new char[len]; while(len &gt; 0)&#123; //m&gt;0 和n&gt;0放在最前面，因为有可能过界导致后面 dp[m][n] == dp[m][n-1]的判断不能进行 if(n&gt;0 &amp;&amp; dp[m][n] == dp[m][n-1])&#123; n--; &#125;else if(m&gt;0 &amp;&amp; dp[m][n] == dp[m-1][n])&#123; m--; &#125;else&#123; //dp[m][n] == dp[m-1][n-1]+1应该是一个判断分支，但是不能写出该判断条件 //因为有可能到了第一行，m=0,无法计算m-1 str[--len] = char1[m]; m--; n--; &#125; &#125; return str; &#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"jQuery实现Ajax应用","slug":"jQuery实现Ajax应用","date":"2015-11-18T03:06:09.000Z","updated":"2015-11-18T04:42:20.000Z","comments":true,"path":"2015/11/18/jQuery实现Ajax应用/","link":"","permalink":"http://duyao.github.io/2015/11/18/jQuery实现Ajax应用/","excerpt":"jQuery实现Ajax应用","text":"jQuery实现Ajax应用 使用load()方法异步请求数据使用load()方法通过Ajax请求加载服务器中的数据，并把返回的数据放置到指定的元素中调用格式为load(url,[data],[callback]) 参数url为加载服务器地址 可选项data参数为请求时发送的数据 callback参数为数据请求成功后，执行的回调函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;使用load()方法异步请求数据&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; #divtest &#123; width: 282px; &#125; #divtest .title &#123; padding: 8px; background-color:Blue; color:#fff; height: 23px; line-height: 23px; font-size: 15px; font-weight: bold; &#125; ul &#123; float: left; width: 280px; padding: 5px 0px; margin: 0px; font-size: 14px; list-style-type: none; &#125; img &#123; margin: 8px; &#125; ul li &#123; float: left; width: 280px; height: 23px; line-height: 23px; padding: 3px 8px; &#125; .fl &#123; float: left; &#125; .fr &#123; float: right; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;divtest&quot;&gt; &lt;div class=&quot;title&quot;&gt; &lt;span class=&quot;fl&quot;&gt;我最爱吃的水果&lt;/span&gt; &lt;span class=&quot;fr&quot;&gt; &lt;input id=&quot;btnShow&quot; type=&quot;button&quot; value=&quot;加载&quot; /&gt; &lt;/span&gt; &lt;/div&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;#btnShow&quot;).bind(&quot;click&quot;, function () &#123; var $this = $(this); $(&quot;ul&quot;).html(&quot;loading&quot;); $(&quot;ul&quot;).load(&quot;http://imooc.com/data/fruit_part.html&quot;,function() &#123; $this.attr(&quot;disabled&quot;, &quot;true&quot;); &#125;); &#125;) &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用getJSON()方法异步加载JSON格式数据使用getJSON()方法可以通过Ajax异步请求的方式，获取服务器中的数组，并对获取的数据进行解析，显示在页面中调用格式为jQuery.getJSON(url,[data],[callback])或$.getJSON(url,[data],[callback])其中，url参数为请求加载json格式文件的服务器地址，可选项data参数为请求时发送的数据，callback参数为数据请求成功后，执行的回调函数。123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;使用getJSON()方法异步加载JSON格式数据&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;divtest&quot;&gt; &lt;div class=&quot;title&quot;&gt; &lt;span class=&quot;fl&quot;&gt;我最喜欢的一项运动&lt;/span&gt; &lt;span class=&quot;fr&quot;&gt; &lt;input id=&quot;btnShow&quot; type=&quot;button&quot; value=&quot;加载&quot; /&gt; &lt;/span&gt; &lt;/div&gt; &lt;ul&gt;&lt;/ul&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;#btnShow&quot;).bind(&quot;click&quot;, function () &#123; var $this = $(this); $.getJSON(&quot;http://www.imooc.com/data/sport.json&quot;,function(data)&#123; $this.attr(&quot;disabled&quot;, &quot;true&quot;); $.each(data, function (index, sport) &#123; //if(index==3) $(&quot;ul&quot;).append(&quot;&lt;li&gt;&quot; + sport[&quot;name&quot;] + &quot;&lt;/li&gt;&quot;); &#125;); &#125;); &#125;) &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://duyao.github.io/tags/jQuery/"}]},{"title":"jQuery动画特效","slug":"jQuery动画特效","date":"2015-11-18T01:17:16.000Z","updated":"2015-11-18T03:07:04.000Z","comments":true,"path":"2015/11/18/jQuery动画特效/","link":"","permalink":"http://duyao.github.io/2015/11/18/jQuery动画特效/","excerpt":"jQuery动画特效","text":"jQuery动画特效 调用show()和hide()方法显示和隐藏元素show()和hide()方法用于显示或隐藏页面中的元素12$(selector).hide(speed,[callback])$(selector).show(speed,[callback]) 参数speed设置隐藏或显示时的速度值，可为“slow”、“fast”或毫秒数值，可选项参数callback为隐藏或显示动作执行完成后调用的函数名。12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;show()和hide()方法动画方式显示和隐藏元素&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;show()和hide()方法动画方式显示和隐藏元素&lt;/h3&gt; &lt;div&gt; &lt;h4&gt;我喜欢吃的水果&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;甘桔&lt;/li&gt; &lt;li&gt;梨&lt;/li&gt; &lt;/ul&gt; &lt;input id=&quot;hidval&quot; type=&quot;hidden&quot; value=&quot;0&quot;/&gt; &lt;input id=&quot;button&quot; type=&quot;button&quot; value=&quot;show&quot;/&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;h4&quot;).bind(&quot;click&quot;, function () &#123; if ($(&quot;#hidval&quot;).val() == 0) &#123; //设置时间及函数 $(&quot;ul&quot;).show(3000,function()&#123; $(&quot;#hidval&quot;).val(1); //无参数 $(&quot;#button&quot;).hide(); &#125;) &#125; else &#123; $(&quot;ul&quot;).hide(3000,function()&#123; $(&quot;#hidval&quot;).val(0); $(&quot;#button&quot;).show(); &#125;) &#125; &#125;) &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 调用toggle()方法实现动画切换效果实现元素的显示与隐藏需要使用hide()与show()，那么有没有更简便的方法来实现同样的动画效果呢？调用toggle()方法就可以很容易做到 如果元素处于显示状态，调用该方法则隐藏该元素 如果元素处于隐藏状态，调用该方法则显示该元素它的调用格式是：$(selector).toggle(speed,[callback])其中speed参数为动画效果时的速度值，可以为数字，单位为毫秒，也可是“fast”、“slow”字符，可选项参数callback为方法执行成功后回调的函数名称。12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;toggle()方法的动画切换效果&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;toggle()方法的动画切换效果&lt;/h3&gt; &lt;div&gt; &lt;h4&gt; &lt;span class=&quot;fl&quot;&gt;我喜欢吃的水果&lt;/span&gt; &lt;span class=&quot;fr&quot; id=&quot;spnTip&quot;&gt;显示&lt;/span&gt; &lt;/h4&gt; &lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;甘桔&lt;/li&gt; &lt;li&gt;梨&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; var $spn = $(&quot;#spnTip&quot;); $(&quot;h4&quot;).bind(&quot;click&quot;, function () &#123; $(&quot;ul&quot;).toggle(&quot;slow&quot;,function()&#123; $spn.html() == &quot;隐藏&quot; ? $spn.html(&quot;显示&quot;) : $spn.html(&quot;隐藏&quot;); &#125;) &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用slideUp()和slideDown()方法的滑动效果可以使用slideUp()和slideDown()方法在页面中滑动元素 slideUp()用于向上滑动元素 slideDown()用于向下滑动元素调用方法分别为：$(selector).slideUp(speed,[callback])和$(selector).slideDown(speed,[callback])其中speed参数为滑动时的速度，单位是毫秒，可选项参数callback为滑动成功后执行的回调函数名。要注意的是：slideDown()仅适用于被隐藏的元素；slideup()则相反。123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;使用slideUp()和slideDown()方法的滑动效果&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;使用slideUp()和slideDown()方法的滑动效果&lt;/h3&gt; &lt;div&gt; &lt;h4&gt;我喜欢吃的水果&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;甘桔&lt;/li&gt; &lt;li&gt;梨&lt;/li&gt; &lt;/ul&gt; &lt;input id=&quot;hidval&quot; type=&quot;hidden&quot; value=&quot;0&quot;/&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;h4&quot;).bind(&quot;click&quot;, function () &#123; if ($(&quot;#hidval&quot;).val() == 0) &#123; $(&quot;ul&quot;).slideDown(&quot;slow&quot;,function() &#123; $(&quot;#hidval&quot;).val(1); &#125;) &#125; else &#123; $(&quot;ul&quot;).slideUp(&quot;slow&quot;,function()&#123; $(&quot;#hidval&quot;).val(0); &#125;) &#125; &#125;) &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用slideToggle()方法实现图片“变脸”效果使用slideToggle()方法可以切换slideUp()和slideDown()即调用该方法时，如果元素已向上滑动，则元素自动向下滑动，反之，则元素自动向上滑动格式为$(selector).slideToggle(speed,[callback])其中speed参数为动画效果时的速度值，可以为数字，单位为毫秒，也可是“fast”、“slow”字符，可选项参数callback为方法执行成功后回调的函数名称。1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;使用slideToggle()方法切换滑动效果&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;使用slideToggle()方法切换滑动效果&lt;/h3&gt; &lt;div&gt; &lt;h4&gt; &lt;span class=&quot;fl&quot;&gt;我喜欢吃的水果&lt;/span&gt; &lt;span class=&quot;fr&quot; id=&quot;spnTip&quot;&gt;向下滑&lt;/span&gt;&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;甘桔&lt;/li&gt; &lt;li&gt;梨&lt;/li&gt; &lt;/ul&gt; &lt;input id=&quot;hidval&quot; type=&quot;hidden&quot; value=&quot;0&quot;/&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; var $spn = $(&quot;#spnTip&quot;); $(&quot;h4&quot;).bind(&quot;click&quot;, function () &#123; $(&quot;ul&quot;).slideToggle(&quot;slow&quot;,function() &#123; $spn.html() == &quot;向下滑&quot; ? $spn.html(&quot;向上滑&quot;) : $spn.html(&quot;向下滑&quot;); &#125;) &#125;) &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用fadeIn()与fadeOut()方法实现淡入淡出效果fadeIn()和fadeOut()方法可以实现元素的淡入淡出效果，前者淡入隐藏的元素，后者可以淡出可见的元素它们的调用格式分别为$(selector).fadeIn(speed,[callback])和$(selector).fadeOut(speed,[callback])其中参数speed为淡入淡出的速度，callback参数为完成后执行的回调函数名。12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;使用fadeIn()与fadeOut()方法实现元素淡入淡出的效果&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;使用fadeIn()与fadeOut()方法实现元素淡入淡出的效果&lt;/h3&gt; &lt;div&gt; &lt;h4&gt;我喜欢吃的水果&lt;/h4&gt; &lt;ul&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;甘桔&lt;/li&gt; &lt;li&gt;梨&lt;/li&gt; &lt;/ul&gt; &lt;input id=&quot;hidval&quot; type=&quot;hidden&quot; value=&quot;0&quot;/&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;h4&quot;).bind(&quot;click&quot;, function () &#123; if ($(&quot;#hidval&quot;).val() == 0) &#123; $(&quot;ul&quot;).fadeIn(&quot;slow&quot;,function() &#123; $(&quot;#hidval&quot;).val(1); &#125;) &#125; else &#123; $(&quot;ul&quot;).fadeOut(3000,function() &#123; $(&quot;#hidval&quot;).val(0); &#125;) &#125; &#125;) &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用fadeTo()方法设置淡入淡出效果的不透明度调用fadeTo()方法，可以将所选择元素的不透明度以淡入淡出的效果调整为指定的值该方法的调用格式为$(selector).fadeTo(speed,opacity,[callback])其中speed参数为效果的速度，opacity参数为指定的不透明值，它的取值范围是0.0~1.0，可选项参数callback为效果完成后，回调的函数名。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;使用fadeTo()方法设置淡入淡出效果的不透明度&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; span &#123; width: 70px; height: 70px; float: left; border: solid 1px #ccc; margin: 0px 8px; &#125; .red &#123; background-color: Red; &#125; .orange &#123; background-color:Orange; &#125; .blue &#123; background-color: Blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;使用fadeTo()方法设置淡入淡出效果的不透明度&lt;/h3&gt; &lt;span class=&quot;red&quot;&gt;&lt;/span&gt;&lt;span class=&quot;orange&quot;&gt;&lt;/span&gt;&lt;span class=&quot;blue&quot;&gt;&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;span&quot;).each(function (index) &#123; switch (index) &#123; case 0: $(this).fadeTo(3000,0.3); break; case 1: $(this).fadeTo(3000,0.6); break; case 2: $(this).fadeTo(3000,0.9); break; &#125; &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 调用animate()方法制作简单的动画效果调用animate()方法可以创建自定义动画效果调用格式为$(selector).animate({params},speed,[callback])其中，params参数为制作动画效果的CSS属性名与值，speed参数为动画的效果的速度，单位为毫秒，可选项callback参数为动画完成时执行的回调函数名。 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;制作简单的动画效果&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; span &#123; float: left; border: solid 1px #ccc; margin: 0px 8px; background-color: Blue; color:White; vertical-align:middle &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;制作简单的动画效果&lt;/h3&gt; &lt;span&gt;&lt;/span&gt; &lt;div id=&quot;tip&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;span&quot;).animate(&#123; width: &quot;80px&quot;, height: &quot;80px&quot; &#125;, 3000, function () &#123; $(&quot;#tip&quot;).html(&quot;执行完成!&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 调用animate()方法制作移动位置的动画调用animate()方法不仅可以制作简单渐渐变大的动画效果，而且还能制作移动位置的动画在移动位置之前，必须将被移元素的“position”属性值设为“absolute”或“relative”，否则，该元素移动不了。123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;制作移动位置的动画&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; span &#123; position:absolute; width:80px; height:80px; border: solid 1px #ccc; margin: 0px 8px; background-color: Red; color:White; vertical-align:middle &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;制作移动位置的动画&lt;/h3&gt; &lt;span&gt;&lt;/span&gt; &lt;div id=&quot;tip&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;span&quot;).animate(&#123; left: &quot;+=100px&quot; &#125;, 3000, function () &#123; $(&quot;span&quot;).animate(&#123; height: &apos;+=30px&apos;, width: &apos;+=30px&apos; &#125;, 3000, function () &#123; $(&quot;#tip&quot;).html(&quot;执行完成!&quot;); &#125;); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 调用stop()方法停止当前所有动画效果stop()方法的功能是在动画完成之前，停止当前正在执行的动画效果，这些效果包括滑动、淡入淡出和自定义的动画，调用格式为$(selector).stop([clearQueue],[goToEnd])其中，两个可选项参数clearQueue和goToEnd都是布尔类型值，前者表示是否停止正在执行的动画，后者表示是否完成正在执行的动画，默认为false。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;调用stop()方法停止当前所有动画效果&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; div &#123; margin: 10px 0px; &#125; span &#123; position:absolute; width:80px; height:80px; border: solid 1px #ccc; margin: 0px 8px; background-color: Red; color:White; vertical-align:middle &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;调用stop()方法停止当前所有动画效果&lt;/h3&gt; &lt;span&gt;&lt;/span&gt; &lt;input id=&quot;btnStop&quot; type=&quot;button&quot; value=&quot;停止&quot; /&gt; &lt;div id=&quot;tip&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;span&quot;).animate(&#123; left: &quot;+=100px&quot; &#125;, 3000, function () &#123; $(this).animate(&#123; height: &apos;+=60px&apos;, width: &apos;+=60px&apos; &#125;, 3000, function () &#123; $(&quot;#tip&quot;).html(&quot;执行完成!&quot;); &#125;); &#125;); $(&quot;#btnStop&quot;).bind(&quot;click&quot;, function () &#123; $(&quot;span&quot;).stop(); $(&quot;#tip&quot;).html(&quot;执行停止!&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 调用delay()方法延时执行动画效果delay()方法的功能是设置一个延时值来推迟动画效果的执行调用格式为$(selector).delay(duration)其中参数duration为延时值，它的单位是毫秒，当超过延时值时，动画继续执行。```&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; 调用delay()方法延时执行动画效果 div { margin: 10px 0px; } span { position:absolute; width:80px; height:80px; border: solid 1px #ccc; margin: 0px 8px; background-color: Red; color:White; vertical-align:middle } 调用delay()方法延时执行动画效果 $(function () { $(“span”).animate({ left: “+=100px” }, 3000, function () { $(this).animate({ height: ‘+=60px’, width: ‘+=60px’ }, 3000, function () { $(“#tip”).html(“执行完成!”); }); }); $(“#btnStop”).bind(“click”, function () { $(“span”).delay(5000); $(“#tip”).html(“正在延时!”); }); });","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://duyao.github.io/tags/jQuery/"}]},{"title":"9.1","slug":"9.1","date":"2015-11-17T05:03:46.000Z","updated":"2015-11-17T11:27:22.000Z","comments":true,"path":"2015/11/17/9.1/","link":"","permalink":"http://duyao.github.io/2015/11/17/9.1/","excerpt":"最长递增子序列longest increasing subsequence给定数组arr，返回arr的最长递增子序列。arr=[2,1,5,3,6,4,8,9,7]，返回的最长递增子序列为[1,3,4,8,9]。如果arr长度为N，请实现时间复杂度为O(NlogN)的方法。*子序列不一定连续，子串和子数组一定连续","text":"最长递增子序列longest increasing subsequence给定数组arr，返回arr的最长递增子序列。arr=[2,1,5,3,6,4,8,9,7]，返回的最长递增子序列为[1,3,4,8,9]。如果arr长度为N，请实现时间复杂度为O(NlogN)的方法。*子序列不一定连续，子串和子数组一定连续 思路 &amp; 代码时间复杂度为O(N^2)产生dp数组的过程(长度就是arr的长度) dp[i]=Max{dp[j]+1(0&lt;=j&lt;i， arr[j]&lt;arr[i])} dp[i]表示以i结尾的数组的最长子序列的长度 dp[0] = 1 找到大于当前值i的位置j，dp[i] = dp[j]+1 找不到大于当前值i的位置j，dp[i] = 1 找到LIS,找到dp的情况下 dp中的最大值就是子序列的长度 dp中最大值对应的arr就是子序列中的一个 倒叙找到出比前面值arr[i]小的并且dp[i]=dp[j]+1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public static int[] getdp1(int[] arr) &#123; // dp[i]表示以i结尾的最长的子序列长度 int[] dp = new int[arr.length]; dp[0] = 1; for (int i = 1; i &lt; dp.length; i++) &#123; if (arr[i] &gt; arr[i - 1]) &#123; dp[i] = dp[i - 1] + 1; &#125; else &#123; for (int j = i - 1; j &gt;= 0; j--) &#123; if (arr[j] &lt;= arr[i]) &#123; dp[i] = dp[j] + 1; break; &#125; &#125; if (dp[i] == 0) &#123; dp[i] = 1; &#125; &#125; &#125; return dp;&#125;public static int[] generateLIS(int[] arr, int[] dp) &#123; // dp中的最大值 int index = 0; // LIS的长度 int len = 1; for (int i = 1; i &lt; dp.length; i++) &#123; if (dp[index] &lt; dp[i]) &#123; index = i; len++; &#125; &#125; int[] res = new int[len]; res[--len] = arr[index]; for (int i = index - 1; i &gt;= 0; i--) &#123; if (arr[i] &lt; arr[index] &amp;&amp; dp[i] + 1 == dp[index]) &#123; res[--len] = arr[i]; index = i; &#125; &#125; return res;&#125;public static int[] lis1(int[] arr) &#123; if (arr == null || arr.length == 0) &#123; return null; &#125; int[] dp = getdp1(arr); return generateLIS(arr, dp);&#125; 时间复杂度O(N*logN)从上面的计算dp过程可以看出，重复访问以前计算的dp值，会降低效率因此添加一个ends数组，二分计算ends[i]表示当前计算状态下，长度为i+1的LIS的最后结尾字符的最小值，计算ends的过程是与计算dp的过程同步的，right是ends中的有效范围的右边界，表示[0,right]范围内是有效的ends，其余是[ends+1,arr.length]是无效的 时间复杂度O(N*logN)生成dp数组的过程是利用二分查找来进行的优化。 生成一个长度为N的数组ends，初始时ends[0]=arr[0]，其他位置上的值为0。 生成整型变量right，初始时right=0。 在从左到右遍历arr数组的过程中，求解dp[i]的过程需要使用ends数组和right变量遍历的过程中， ends[0..right]为有效区， ends[right+1..N-1]为无效区。对于有效区上的位置b，如果有ends[b]==c，则表示遍历到目前为止，在所有长度为b+1的递增序列中，最小的结尾数是c。无效区的位置则没有意义。 例如arr=[2,1,5,3,6,4,8,9,7]，初始时dp[0]=1， ends[0]=2， right=0。ends[0..0]为有效区，ends[0]==2的含义是，在遍历过arr[0]之后，所有长度为1的递增序列中(此时只有[2])，最小的结尾数是2。之后的遍历继续用这个例子来说明求解过程。 1，遍历到arr[1]==1。 ends有效区=ends[0..0]=[2]，在有效区中找到最左边的大于等于arr[1]的数。发现是ends[0]，表示以arr[1]结尾的最长递增序列只有arr[1]，所以令dp[1]=1。然后令ends[0]=1，因为遍历到目前为止，在所有长度为1的递增序列中，最小的结尾数是1而不再是2了。 2，遍历到arr[2]==5。 ends有效区=ends[0..0]=[1]，在有效区中找到最左边的大于等于arr[2]的数。发现没有这样的数，表示以arr[2]结尾的最长递增序列长度=ends有效区长度+1，所以令dp[2]=2。ends整个有效区都没有例arr[2]更大的数，说明发现了例ends有效区长度更长的递增序列，于是把有效区扩大， ends有效区=ends[0..1]=[1,5]。 3，遍历到arr[3]==3。 ends有效区=ends[0..1]=[1,5]，在有效区中用二分法找到最左边的大于等于arr[3]的数。发现是ends[1]，表示以arr[3]结尾的最长递增序列长度为2，所以令dp[3]=2。然后令ends[1]=3，因为遍历到目前为止，在所有长度为2的递增序列中，最小的结尾数是3而不再是5了。 4，遍历到arr[4]==6。 ends有效区=ends[0..1]=[1,3]，在有效区中用二分法找到最左边的大于等于arr[4]的数。发现没有这样的数，表示以arr[4]结尾的最长递增序列长度=ends有效区长度+1，所以令dp[4]=3。 ends整个有效区都没有例arr[4]更大的数，说明发现了例ends有效区长度更长的递增序列，于是把有效区扩大， ends有效区=ends[0..2]=[1,3,6]。 5，遍历到arr[5]==4。 ends有效区=ends[0..2]=[1,3,6]，在有效区中用二分法找到最左边的大于等于arr[5]的数。发现是ends[2]，表示以arr[5]结尾的最长递增序列长度为3，所以令dp[5]=3。然后令ends[2]=4，表示在所有长度为3的递增序列中，最小的结尾数变为4。 6，遍历到arr[6]==8。 ends有效区=ends[0..2]=[1,3,4]，在有效区中用二分法找到最左边的大于等于arr[6]的数。发现没有这样的数，表示以arr[6]结尾的最长递增序列长度=ends有效区长度+1，所以令dp[6]=4。 ends整个有效区都没有例arr[6]更大的数，说明发现了例ends有效区长度更长的递增序列，于是把有效区扩大， ends有效区=ends[0..3]=[1,3,4,8]。 7，遍历到arr[7]==9。 ends有效区=ends[0..3]=[1,3,4,8]，在有效区中用二分法找到最左边的大于等于arr[7]的数。发现没有这样的数，表示以arr[7]结尾的最长递增序列长度=ends有效区长度+1，所以令dp[7]=5。 ends整个有效区都没有例arr[7]更大的数，于是把有效区扩大， ends有效区=ends[0..5]=[1,3,4,8,9]。 8，遍历到arr[8]==7。 ends有效区=ends[0..5]=[1,3,4,8,9]，在有效区中用二分法找到最左边的大于等于arr[8]的数。发现是ends[3]，表示以arr[8]结尾的最长递增序列长度为4，所以令dp[8]=4。然后令ends[3]=7，表示在所有长度为4的递增序列中，最小的结尾数变为7。 具体过程请参看如下代码中的getdp2方法。123456789101112131415161718192021222324252627282930public static int[] getdp2(int[] arr) &#123; int[] dp = new int[arr.length]; int[] ends = new int[arr.length]; ends[0] = arr[0]; dp[0] = 1; int right = 0; // 二分中的左中右 int l = 0; int r = 0; int m = 0; for (int i = 1; i &lt; arr.length; i++) &#123; l = 0; r = right; // 二分找到arr[i]应该在该数列的位置 while (l &lt;= r) &#123; m = (l + r) / 2; if (arr[i] &gt; ends[m]) &#123; l = m + 1; &#125; else &#123; r = m - 1; &#125; &#125; // 如果arr[i]比ends[right]还大，那么其位置l是right+1 // 更新right，即ends的有效区域 right = Math.max(right, l); ends[l] = arr[i]; dp[i] = l + 1; &#125; return dp;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"8.2","slug":"8.2","date":"2015-11-16T11:14:30.000Z","updated":"2015-11-17T08:53:02.000Z","comments":true,"path":"2015/11/16/8.2/","link":"","permalink":"http://duyao.github.io/2015/11/16/8.2/","excerpt":"题目换钱的方法数 给定数组arr，arr中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim代表要找的钱数，求换钱有多少种方法。 arr=[5,10,25,1]，aim=0。组成0元的方法有1种，就是所有面值的货币都不用。所以返回1。arr=[5,10,25,1]，aim=15。组成15元的方法有6种，分别为3张5元，1张10元+1张5元，1张10元+5张1元，10张1元+1张5元，2张5元+5张1元，15张1元。所以返回6。arr=[3,5]，aim=2。任何方法都无法组成2元。所以返回0。","text":"题目换钱的方法数 给定数组arr，arr中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim代表要找的钱数，求换钱有多少种方法。 arr=[5,10,25,1]，aim=0。组成0元的方法有1种，就是所有面值的货币都不用。所以返回1。arr=[5,10,25,1]，aim=15。组成15元的方法有6种，分别为3张5元，1张10元+1张5元，1张10元+5张1元，10张1元+1张5元，2张5元+5张1元，15张1元。所以返回6。arr=[3,5]，aim=2。任何方法都无法组成2元。所以返回0。 思路 &amp; 代码暴力的递归如果arr=[5,10,25,1]， aim=1000，分析过程如下 用0张5元的货币，让[10,25,1]去组成剩下的1000，最终方法数记为res1。 用1张5元的货币，让[10,25,1]去组成剩下的995，最终方法数记为res2。 用2张5元的货币，让[10,25,1]去组成剩下的990，最终方法数记为res3。 … 用200张5元的货币，让[10,25,1]去组成剩下的0，最终方法数记为res201。 那么res1+res2+…+res201的值就是总共的方法数。根据如上的分析过程定义递归函数process1(arr,index,aim)，它的含义是如果用arr[index..N-1]这些面值的钱去组成aim的话，返回总共的方法数。具体实现如下代码中的coins1方法。12345678910111213141516171819202122232425public int coins1(int[] arr, int aim) &#123; if (arr == null || arr.length == 0 || aim &lt; 0) &#123; return 0; &#125; return f1(arr, 0, aim);&#125;// 暴力递归，无优化public static int f1(int[] a, int index, int aim) &#123; // 方法数 int res = 0; if (index == a.length) &#123; // index已经到了数组的边界，且目标钱数已经减为0，说明这个方法是有效的 if (aim == 0) &#123; res = 1; &#125; &#125; else &#123; for (int i = 0; a[index] * i &lt;= aim; i++) &#123; // 注意后面是index+1 // 因此每次是先index增加，然后index的个数i增加，增加之后要将aim减少 res += f1(a, index + 1, aim - a[index] * i); &#125; &#125; return res;&#125; 记忆搜索的方法接下来介绍基于暴力递归的初步优化的方法，也就是记忆搜索的方法。暴力递归之所以暴力是因为存在大量的重复计算。 当已经使用0张5元+1张10元的情况下，后续应该求[25,1]组成剩下的990的方法总数。 当已经使用2张5元+0张10元的情况下，后续还是求[25,1]组成剩下的990的方法总数。 两个情况下都需要求process1(arr,2,990)。 类似这样的重复计算在暴力递归的过程中大量发生，所以暴力递归方法的时间复杂度非常高并且和arr中钱的面值有关，最差情况下为O(aim^N)。记忆化搜索的优化方式。 process1(arr,index,aim)中arr是始终不变的，变化的只有index和aim，所以可以用p(index,aim)表示一个递归过程。重复计算之所以大量发生，是因为每一个递归过程的结果都没记下来，所以下次还要重复的去求。所以可以事先准备好一个map，每计算完一个递归过程，都将结果记录到map中。 当下次进入同样的递归过程之前，先在map中查询是否这个递归过程已经计算过， 如果已经计算过把值拿出来直接用就可以了 如果没计算过再进入递归过程。 具体请参看如下代码中的coins2方法，它和coins1方法的区别就是准备好全局变量map，记录已经计算过的递归过程的结果，防止下次重复计算。因为本题的递归过程可由两个变量表示，所以map是一张二维表。map[i][j]表示递归过程p(i,j)的返回值。 map[i][j]==0表示递归过程p(i,j)从来没有计算过。 map[i][j]==-1表示递归过程p(i,j)计算过但返回值是0。 map[i][j]的值既不等于0也不等于-1，记为a，则表示递归过程p(i,j)的返回值为a。 记忆化搜索方法的时间复杂度为什么也是O(N*(aim^2))12345678910111213141516171819202122232425262728293031323334353637//使用map，减少重复计算public int coins2(int[] arr, int aim) &#123; if (arr == null || arr.length == 0 || aim &lt; 0) &#123; return 0; &#125; //map是存储该方法是否计算过，值为-1表示计算过，且为用此方法返回值为0，map值为0，表示没有计算， int[][] map = new int[arr.length + 1][aim + 1]; return f2(arr, 0, aim, map);&#125;public static int f2(int[] a, int index, int aim, int[][] map)&#123; int res = 0; if(index == a.length)&#123; if(aim == 0)&#123; return 1; &#125; &#125;else&#123; for (int i = 0; a[index] * i &lt;= aim; i++) &#123; //因为下面要算这个，所以先看看map中是否存储 int tmp = map[index+1][aim - a[index] * i]; if(tmp != 0)&#123; //tmp！=0表示计算过 if(tmp != -1)&#123; //tmp=-1表示返回值为0，所以不用加， //tmp！=-1有返回值，且不为0 res += tmp; &#125; &#125;else&#123; //该值map中还没有算过，因此要计算一下 res += f2(a, index + 1, aim - a[index] * i,map); &#125; // 每次算完一个循环，更新map,更新的此过程的map，即map[index][aim] map[index][aim] = res == 0 ? -1 : res; &#125; &#125; return res;&#125; 动态规划方法组成行数为N，列数为aim+1的矩阵dp，dp[i][j]的含义是在使用arr[0..i]货币的情况下，组成钱数j有多少种方法。 dp[i][j]的值求法如下：1，对于矩阵dp第一列的值dp[..][0]，表示组成钱数为0的方法数，很明显是1种，也就是不使用任何货币。所以dp第一列的值统一设置为1。2，对于矩阵dp第一行的值dp[0][..]，表示只能使用arr[0]这一种货币的情况下，组成钱的方法数，例如arr[0]==5时，能组成的钱数只有0， 5， 10， 15…。所以令dp[0][karr[0]]=1(0&lt;=karr[0]&lt;=aim， k为非负整数)。3，除了第一行和第一列的其他位置，记为位置(i,j)。 dp[i][j]的值是以下几个值的累加。0）完全不用arr[i]货币，只使用arr[0..i-1]货币时，方法数为dp[i-1][j]。1）用1张arr[i]货币，剩下的钱用arr[0..i-1]货币组成时，方法数为dp[i-1][j-arr[i]]。2）用2张arr[i]货币，剩下的钱用arr[0..i-1]货币组成时，方法数为dp[i-1][j-2*arr[i]]。… k）用k张arr[i]货币，剩下的钱用arr[0..i-1]货币组成时，方法数为dp[i-1][j-karr[i]]。j-karr[i]&gt;=0， k为非负整数。4，最终dp[N-1][aim]的值就是最终结果。具体过程请参看如下代码中的coins3方法。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public static int coins3(int[] arr, int aim) &#123; if (arr == null || arr.length == 0 || aim &lt; 0) &#123; return 0; &#125; //dp[i][j]表示使用arr[0..i]货币的情况下，组成钱数j有多少种方法 int[][] dp = new int[arr.length][aim + 1]; //初始化 for (int i = 0; i &lt; arr.length; i++) &#123; //使用arr[0..i]货币的情况下，组成钱数0有1种 dp[i][0] = 1; &#125; for (int j = 1; arr[0] * j &lt;= aim; j++) &#123; ////使用arr[0]货币的情况下，只能组成arr[0]的倍数的钱数 dp[0][arr[0] * j] = 1; &#125; int num = 0; //dp[i][j]使用dp[i-1][j]即不使用arr[i]的货币，组成j的方法数 //当使用arr[i]的货币的时候 //那么使用1张arr[i]，有dp[i-1][j-arr[i]] //那么使用2张arr[i]，有dp[i-1][j-arr[i]*2] //...因此当使用k张arr[i]的货币，方法数为dp[i-1][j-arr[i]*k] for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = 1; j &lt;= aim; j++) &#123; num = 0; for (int k = 0; j - arr[i] * k &gt;= 0; k++) &#123; num += dp[i - 1][j - arr[i] * k]; &#125; //更新dp dp[i][j] = num; &#125; &#125; return dp[arr.length - 1][aim];&#125;``` 在最差情况下对于位置(i,j)来说，求解dp[i][j]的计算过程需要枚举dp[i-1][0..j]上的所有值，dp一共有N*aim个位置，所以总体的时间复杂度为O(N*(aim^2))。解释之前记忆化搜索方法的时间复杂度为什么也是O(N*(aim^2))，因为在本质上记忆化搜索方法等价于动态规划方法。记忆化搜索的方法说白了就是不关心到达某一个递归过程的路径，只是单纯的对计算过的递归过程进行记录，避免重复的递归过程动态规划的方法则是规定好每一个递归过程的计算顺序，依次进行计算，后计算的过程严格依赖前者计算过的过程。两者都是空间换时间的方法，也都有枚举的过程，区别就在于动态规划规定计算顺序而记忆搜索不用规定。所以记忆化搜索方法的时间复杂度也是O(N*(aim^2))。两者各有优缺点，如果对暴力递归过程简单地优化成记忆搜索的方法，递归函数依然在使用，这在过程上的开销较大。动态规划方法严格规定了计算顺序，可以将递归计算变成顺序计算，这是动态规划方法很大的优势。其实记忆搜索的方法也有优势，本题就很好的体现了。例如arr=[20000,10000,1000]， aim=2000000000。如果是动态规划的计算方法，要严格计算3*2000000000个位置。对于记忆搜索来说，因为面值最小的钱为1000，所以百位为(1~9)或⼗位为(1~9)或各位为(1~9)的钱数是不可能出现的，当然也就不必要计算。通过本例可以知道，记忆化搜索是对必须要计算的递归过程才去计算并记录的。### 优化dp时间复杂度为O(N*aim)的动态规划方法。我们来看上一个动态规划方法中，求dp[i][j]值的时候的步骤3，这也是最关键的枚举过程：3，除了第一行和第一列的其他位置，记为位置(i,j)。 dp[i][j]的值是以下几个值的累加。0）完全不用arr[i]货币，只使用arr[0..i-1]货币时，方法数为dp[i-1][j]。1）用1张arr[i]货币，剩下的钱用arr[0..i-1]货币组成时，方法数为dp[i-1][j-arr[i]]。2）用2张arr[i]货币，剩下的钱用arr[0..i-1]货币组成时，方法数为dp[i-1][j-2*arr[i]]。...k）用k张arr[i]货币，剩下的钱用arr[0..i-1]货币组成时，方法数为dp[i-1][j-k*arr[i]]。j-k*arr[i]&gt;=0， k为非负整数。步骤3中，情况0）的方法数为dp[i-1][j]，情况1）一直到情况k）的方法数累加值其实就是dp[i][j-arr[i]]的值。![推导过程](http://7xilc8.com1.z0.glb.clouddn.com/7.2_dp.png &quot;推导过程&quot;)所以步骤3可以化简为dp[i][j]=dp[i-1][j]+dp[i][j-arr[i]]。一下省去了枚举的过程，时间复杂度也减为O(N*aim)，具体请参看如下代码中的coins4方法。 //优化dppublic static int coins4(int[] arr, int aim) { if (arr == null || arr.length == 0 || aim &lt; 0) { return 0; } // dp[i][j]表示使用arr[0..i]货币的情况下，组成钱数j有多少种方法 int[][] dp = new int[arr.length][aim + 1]; // 初始化 for (int i = 0; i &lt; arr.length; i++) { // 使用arr[0..i]货币的情况下，组成钱数0有1种 dp[i][0] = 1; } for (int j = 1; arr[0] j &lt;= aim; j++) { // 使用arr[0]货币的情况下，只能组成arr[0]的倍数的钱数 dp[0][arr[0] j] = 1; } //计算其余的dp for (int i = 1; i &lt; arr.length; i++) { for (int j = 1; j &lt;= aim; j++) { //dp[i][j] = dp[i-1][j] + dp[i-1][j-arr[i]] //先要判断j-arr[i]是否越界 dp[i][j] = dp[i-1][j]; if(j-arr[i] &gt;= 0){ dp[i][j] += dp[i-1][j-arr[i]]; } } } return dp[arr.length - 1][aim];}```","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"8.1","slug":"8.1","date":"2015-11-16T09:35:50.000Z","updated":"2015-11-17T05:03:56.000Z","comments":true,"path":"2015/11/16/8.1/","link":"","permalink":"http://duyao.github.io/2015/11/16/8.1/","excerpt":"题目给定整数N，返回斐波那契数列的第N项。123456789public int f1(int n) &#123; if (n &lt; 1) &#123; return 0; &#125; if (n == 1 || n == 2) &#123; return 1; &#125; return f1(n - 1) + f1(n - 2);&#125; 上面的时间复杂度是O(2^N)要求：时间复杂度O(logN)的解法","text":"题目给定整数N，返回斐波那契数列的第N项。123456789public int f1(int n) &#123; if (n &lt; 1) &#123; return 0; &#125; if (n == 1 || n == 2) &#123; return 1; &#125; return f1(n - 1) + f1(n - 2);&#125; 上面的时间复杂度是O(2^N)要求：时间复杂度O(logN)的解法 思路由递推公式f(n),f(n-1))=(f(n-1),f(n-2)可以化作当含有f(n-3)时，行列式是3阶的可以代入求出行列式于是有 …依次带入得到因此该题目的关键是求行列式的幂运算集合的幂运算和普通数字的目运算相同，都可以是用二分法假设有整数是10，如何最快的求解10的75次方。 75的2进制形式为1001011。 10的75次方=(10^64) (10^8) (10^2) * (10^1)。在这个过程中，我们先求出10^1，然后根据10^1求出10^2，再根据10^2求出10^4， …，最后根据10^32求出10^64次方，即75的⼆进制形式总共有多少位，我们就使用了几次次乘法。 在步骤2的过程中，把应该累乘的值乘起来即可。 10^64、 10^8、 10^2、 10^1应该累乘起来，因为64、 8、 2、 1对应到75的2进制中，相应的位上是1。而10^32、 10^16、 10^4不应该累乘，因为32、 16、 4对应到75的2进制中，相应的位上是0。1234567891011121314151617//整数的幂运算public static int power(int x, int n)&#123; if (n == 0) return 1; int result = 1; while (n != 0) &#123; //n%2 != 0 if ((n &amp; 1) != 0) result *= x; x *= x; //n/=2 n &gt;&gt;= 1; &#125; return result;&#125; 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 计算矩阵的幂运算public static int[][] matrixPower(int[][] m, int p) &#123; int[][] res = new int[m.length][m[0].length]; // 初始化结果矩阵为单位阵，即对角线是1，其余位置是0，相当于整数中的1 //相当于设置res=1 for (int i = 0; i &lt; m.length; i++) &#123; res[i][i] = 1; &#125; int[][] tmp = m; while (p != 0) &#123; if (p % 2 != 0) &#123; res = muliMatrix(res, tmp); &#125; tmp = muliMatrix(tmp, tmp); p /= 2; &#125; return res;&#125;// 矩阵相乘的运算public static int[][] muliMatrix(int[][] m1, int[][] m2) &#123; int[][] res = new int[m1.length][m2[0].length]; for (int i = 0; i &lt; m1.length; i++) &#123; for (int j = 0; j &lt; m2[0].length; j++) &#123; for (int k = 0; k &lt; m2.length; k++) &#123; res[i][j] += m1[i][k] * m2[k][j]; &#125; &#125; &#125; return res;&#125;public static int f(int n) &#123; if(n &lt; 1)&#123; return 0; &#125;else if(n == 1 || n == 2)&#123; return 1; &#125;else&#123; int[][] a = &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;; int[][] res = matrixPower(a, n-2); return res[0][0] + res[1][0]; &#125;&#125; 题目假设农场中成熟的母牛每年只会生1头小母牛，并且永远不会死。第一年农场有1只成熟的母牛，从第二年开始，母牛将开始生小母牛。每只小母牛3年之后成熟又可以开始生小母牛。给定整数N，求出N年后牛的数量。 N=6。第1年1头成熟母牛记为a。第2年a生了新的小母牛记为b，总牛数为2。第3年a生了新的小母牛记为c，总牛数为3。第4年a生了新的小母牛记为d，总牛数为4。第5年b成熟了，a和b分别生了新的小母牛，总牛数为6。第6年c也成熟了，a、b和c分别生了新的小母牛，总牛数为9。返回9。 思路递推公式为C(n)=C(n-1)+C(n-3)，C(1)=1， C(2)=2， C(3)=3， C(4)=4， C(5)=6因此可以化为3阶带入求解的到 代码1234567891011public int c(int n) &#123; if (n &lt; 1) &#123; return 0; &#125; if (n == 1 || n == 2 || n == 3) &#123; return n; &#125; int[][] base = &#123; &#123; 1, 1, 0 &#125;, &#123; 0, 0, 1 &#125;, &#123; 1, 0, 0 &#125; &#125;; int[][] res = matrixPower(base, n - 3); return 3 * res[0][0] + 2 * res[1][0] + res[2][0];&#125; 结论如果递归式严格符合F(n)=aF(n-1)+bF(n-2)+…+kF(n-i)，那么它就是i阶的递推式，必然有与ii的状态矩阵有关的矩阵乘法的表达。一律可以用加速矩阵乘法的动态规划将时间复杂度降为O(logN)。","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"jQuery事件与应用","slug":"jQuery事件与应用","date":"2015-11-15T08:38:48.000Z","updated":"2015-11-17T00:37:32.000Z","comments":true,"path":"2015/11/15/jQuery事件与应用/","link":"","permalink":"http://duyao.github.io/2015/11/15/jQuery事件与应用/","excerpt":"jQuery事件与应用","text":"jQuery事件与应用 页面加载时触发ready()事件ready()事件类似于onLoad()事件 ready()只要页面的DOM结构加载后便触发,ready()可以写多个，按顺序执行 onLoad()必须在页面全部元素加载成功才触发下列写法是相等的：$(document).ready(function(){})等价于$(function(){}); 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;ready()事件&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;页面载入时触发ready()事件&lt;/h3&gt; &lt;div id=&quot;tip&quot;&gt;&lt;/div&gt; &lt;input id=&quot;btntest&quot; type=&quot;button&quot; value=&quot;点下我&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(document).ready(function() &#123; $(&quot;#btntest&quot;).bind(&quot;click&quot;, function () &#123; $(&quot;#tip&quot;).html(&quot;我被点击了！&quot;); &#125;); &#125;); $(function()&#123; $(&quot;#btntest&quot;).bind(&quot;click&quot;, function () &#123; $(&quot;#tip&quot;).html(&quot;我被点击了！&quot;); &#125;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用bind()方法绑定元素的事件bind()方法绑定元素的事件非常方便，绑定前，需要知道被绑定的元素名，绑定的事件名称，事件中执行的函数内容就可以它的绑定格式如下：1$(selector).bind(event,[data] function) 参数event为事件名称，多个事件名称用空格隔开，function为事件执行的函数。123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;bind()方法绑定事件&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;bind()方法绑多个事件&lt;/h3&gt; &lt;input id=&quot;btntest&quot; type=&quot;button&quot; value=&quot;点击或移出就不可用了&quot; /&gt; &lt;script type=&quot;text/javascript&quot;&gt; //使用bind()方法绑定单击(click)和鼠标移出(mouseout)这两个事件，触发这两个事件中，按钮将变为不可用。 $(function () &#123; $(&quot;#btntest&quot;).bind(&quot;click mouseout&quot;, function()&#123; $(this).attr(&quot;disabled&quot;, &quot;true&quot;); &#125;) &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用hover()方法切换事件hover()方法的功能是当鼠标移到所选元素上时，执行方法中的第一个函数，鼠标移出时，执行方法中的第二个函数实现事件的切实效果，调用格式$(selector).hover(over，out);over参数为移到所选元素上触发的函数，out参数为移出元素时触发的函数。12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;hover()方法切换事件&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;hover()方法切换事件&lt;/h3&gt; &lt;div&gt;别走！你就是土豪&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;div&quot;).hover( function () &#123; $(this).addClass(&quot;orange&quot;); &#125;, function () &#123; $(this).removeClass(&quot;orange&quot;) &#125;) &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用toggle()方法绑定多个函数toggle()方法可以在元素的click事件中绑定两个或两个以上的函数，同时，它还可以实现元素的隐藏与显示的切换绑定多个函数的调用格式$(selector).toggle(fun1(),fun2(),funN(),...)其中，fun1，fun2就是多个函数的名称12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;toggle()方法绑定多个函数&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.8.2/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;toggle()方法绑定多个函数&lt;/h3&gt; &lt;input id=&quot;btntest&quot; type=&quot;button&quot; value=&quot;点一下我&quot; /&gt; &lt;div&gt;我是动态显示的&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;#btntest&quot;).bind(&quot;click&quot;, function () &#123; $(&quot;div&quot;).toggle( //没有下面这段，实现的是显示和消失的功能 //下面的这段，实现按钮显示123 /* function()&#123; $(this).html(&quot;1&quot;); &#125;, function()&#123; $(this).html(&quot;2&quot;); &#125;, function()&#123; $(this).html(&quot;3&quot;); &#125;*/ ); &#125;) &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用one()方法绑定元素的一次性事件one()方法可以绑定元素任何有效的事件，但这种方法绑定的事件只会触发一次它的调用格式$(selector).one(event,[data],fun)参数event为事件名称，data为触发事件时携带的数据，fun为触发该事件时执行的函数。 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;one()方法执行一次绑定事件&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;one()方法执行一次绑定事件&lt;/h3&gt; &lt;div&gt;请点击我一下&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; var intI = 0; //相应一次 $(&quot;div&quot;).one(&quot;click&quot;, function () &#123; intI++; $(this).html(intI + &quot;px&quot;); &#125;) //响应多次，每次都会++ // $(&quot;div&quot;).bind(&quot;click&quot;, function () &#123; // intI++; // $(this).html(intI + &quot;px&quot;); // &#125;) &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 调用trigger()方法手动触发指定的事件trigger()方法可以直接手动触发元素指定的事件，这些事件可以是元素自带事件，也可以是自定义的事件，总之，该事件必须能执行调用格式为$(selector).trigger(event)其中event参数为需要手动触发的事件名称。 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;trigger()手动触发事件&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;trigger()手动触发事件&lt;/h3&gt; &lt;div&gt;土豪，咱们交个朋友吧&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;div&quot;).bind(&quot;change-color&quot;, function () &#123; $(this).addClass(&quot;color&quot;); $(this).html(&quot;hello&quot;); &#125;); //触发change-color事件 $(&quot;div&quot;).trigger (&quot;change-color&quot;); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 文本框的focus和blur事件 focus事件在元素获取焦点时触发，如点击文本框时，触发该事件 blur事件则在元素丢失焦点时触发，如点击除文本框的任何元素，都会触发该事件。123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;表单中文本框的focus和blur事件&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;表单中文本框的focus和blur事件&lt;/h3&gt; &lt;input id=&quot;txtest&quot; type=&quot;text&quot; value=&quot;&quot; /&gt; &lt;div&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;input&quot;) .bind(&quot;focus&quot;, function () &#123; $(&quot;div&quot;).html(&quot;请输入您的姓名！&quot;); &#125;) $(&quot;input&quot;).bind(&quot;blur&quot;, function () &#123; if ($(this).val().length == 0) $(&quot;div&quot;).html(&quot;你的名称不能为空！&quot;); &#125;) &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 下拉列表框的change事件当一个元素的值发生变化时，将会触发change事件，例如在选择下拉列表框中的选项时，就会触change事件。1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;下拉列表的change事件&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;下拉列表的change事件&lt;/h3&gt; &lt;select id=&quot;seltest&quot;&gt; &lt;option value=&quot;葡萄&quot;&gt;葡萄&lt;/option&gt; &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt; &lt;option value=&quot;荔枝&quot;&gt;荔枝&lt;/option&gt; &lt;option value=&quot;香焦&quot;&gt;香焦&lt;/option&gt; &lt;/select&gt; &lt;div&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;#seltest&quot;).bind(&quot;change&quot;, function () &#123; if ($(this).val() == &quot;苹果&quot;) $(&quot;div&quot;).html($(this).val()+&quot;apple&quot;); else $(&quot;div&quot;).html(&quot;select&quot;+$(this).val()); &#125;) &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://duyao.github.io/tags/jQuery/"}]},{"title":"jQuery操作DOM元素","slug":"jQuery操作DOM元素","date":"2015-11-15T02:02:26.000Z","updated":"2015-11-15T07:54:58.000Z","comments":true,"path":"2015/11/15/jQuery操作DOM元素/","link":"","permalink":"http://duyao.github.io/2015/11/15/jQuery操作DOM元素/","excerpt":"jQuery操作DOM元素","text":"jQuery操作DOM元素 使用attr()方法控制元素的属性attr()方法的作用是设置或者返回元素的属性 attr(属性名)格式是获取元素属性名的值 attr(属性名，属性值)格式则是设置元素属性名的值。1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;操作元素属性&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;attr()方法设置元素属性&lt;/h3&gt; &lt;a href=&quot;http://127.0.0.1&quot; id=&quot;a1&quot;&gt;点我就变&lt;/a&gt; &lt;div&gt;我改变后的地址是：&lt;span id=&quot;tip&quot;&gt;&lt;/span&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;#a1&quot;).attr(&quot;href&quot; , &quot;www.imooc.com&quot;); var $url = $(&quot;#a1&quot;).attr(&quot;href&quot;); $(&quot;#tip&quot;).html($url); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 操作元素的内容使用html()和text()方法操作元素的内容，当两个方法的参数为空时，表示获取该元素的内容，而如果方法中包含参数，则表示将参数值设置为元素内容。 html()获取的html代码，如果该内容是斜体加粗等格式，都会获取到 text()获取文本内容，不会获取到内容的格式等1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;操作元素内容&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;html()和text()方法设置元素内容&lt;/h3&gt; &lt;div id=&quot;html&quot;&gt;&lt;/div&gt; &lt;div id=&quot;text&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var $content = &quot;&lt;b&gt;唉，我又变胖了！&lt;/b&gt;&quot;; $(&quot;#html&quot;).html($content); $(&quot;#text&quot;).text($content); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 操作元素的样式通过addClass()和css()方法可以方便地操作元素中的样式 addClass()括号中的参数为增加元素的样式名称，增加多个样式名称时，要用空格隔开 css()直接将样式的属性内容写在括号中。1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;操作元素样式&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;css()方法设置元素样式&lt;/h3&gt; &lt;div id=&quot;content&quot;&gt;我穿了一件红色外衣&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;#content&quot;).css(&#123;&quot;background-color&quot;:&quot;red&quot;,&quot;color&quot;:&quot;white&quot;&#125;); &lt;/script&gt; &lt;style type=&quot;text/css&quot;&gt; div &#123; padding: 8px; width: 180px; &#125; .back&#123; background-color:blue; &#125; .word&#123; color:white; &#125; &lt;/style&gt; &lt;h3&gt;addClass()方法设置元素样式&lt;/h3&gt; &lt;div id=&quot;cont&quot;&gt;我穿一件蓝色外衣&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //名字与css中相同 $(&quot;#cont&quot;).addClass(&quot;back word&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 移除属性和样式使用removeAttr(name)和removeClass(class)分别可以实现移除元素的属性和样式的功能， removeAttr(name)方法中参数表示移除属性名 removeClass(class)方法中参数则表示移除的样式名 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;移除元素样式&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;removeClass()方法移除元素样式&lt;/h3&gt; &lt;div id=&quot;content&quot; class=&quot;blue white&quot;&gt;我脱下了一件蓝色外衣&lt;/div&gt; &lt;style type=&quot;text/css&quot;&gt; div &#123; padding: 8px; width: 180px; &#125; .blue &#123; background-color: Blue; &#125; .white &#123; color: White; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;#content&quot;).removeClass(&quot;blue white&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用append()方法向元素内追加内容append(content)方法的功能是向指定的元素中追加内容，被追加的content参数，可以是字符、HTML元素标记，还可以是一个返回字符串内容的函数。12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;append()方法追加内容&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;append()方法追加内容&lt;/h3&gt; &lt;script type=&quot;text/javascript&quot;&gt; function rethtml() &#123; var $html = &quot;&lt;div id=&apos;test&apos; title=&apos;hi&apos;&gt;我是调用函数创建的&lt;/div&gt;&quot; return $html; &#125; var $myhtml = &quot;&lt;div id=&apos;test&apos; title=&apos;hi&apos;&gt;我是调用函数创建的&lt;/div&gt;&quot; $(&quot;body&quot;).append(rethtml()); $(&quot;body&quot;).append($myhtml); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用appendTo()方法向被选元素内插入内容appendTo()方法也可以向指定的元素内插入内容，它的使用格式是：1$(content).appendTo(selector) 参数content表示需要插入的内容，参数selector表示被选的元素，即把content内容插入selector元素内，默认是在尾部123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;appendTo()方法插入内容&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;appendTo()方法插入内容&lt;/h3&gt; &lt;div&gt; &lt;span class=&quot;green&quot;&gt;小乌龟&lt;/span&gt; &lt;/div&gt; &lt;span class=&apos;red&apos;&gt;小青蛙&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; var $html = &quot;&lt;span class=&apos;red&apos;&gt;小青蛙&lt;/span&gt;&quot;; //content是$html,第一个$是调用格式 $($html).appendTo(&quot;div&quot;); //将class加入到div中 $(&quot;.red&quot;).appendTo(&quot;div&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用before()和after()在元素前后插入内容使用before()和after()方法可以在元素的前后插入内容，它们分别表示在整个元素的前面和后面插入指定的元素或内容，调用格式分别为：1$(selector).before(content)和$(selector).after(content) 其中参数content表示插入的内容，该内容可以是元素或HTML字符串。12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;在元素前后插入内容&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;after()方法在元素之后插入内容&lt;/h3&gt; &lt;span class=&quot;green&quot;&gt;我们交个朋友吧！&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; var $html = &quot;&lt;span class=&apos;red&apos;&gt;兄弟。&lt;/span&gt;&quot; $(&quot;.green&quot;).after($html); $(&quot;.green&quot;).before($html); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用clone()方法复制元素调用clone()方法可以生成一个被选元素的副本，即复制了一个被选元素，包含它的节点、文本和属性，它的调用格式为：1$(selector).clone() 其中参数selector可以是一个元素或HTML内容。1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;使用clone()方法复制元素&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;使用clone()方法复制元素&lt;/h3&gt; &lt;span class=&quot;red&quot; title=&quot;hi&quot;&gt;我是美猴王&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;body&quot;).append($(&quot;.red&quot;).clone()); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 替换内容replaceWith()和replaceAll()方法都可以用于替换元素或元素中的内容，但它们调用时，内容和被替换元素所在的位置不同，分别为如下所示： $(selector).replaceWith(content) $(content).replaceAll(selector)参数selector为被替换的元素，content为替换的内容。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;使用替换元素和内容&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;使用replaceAll()方法替换元素内容&lt;/h3&gt; &lt;span class=&quot;green&quot; title=&quot;hi&quot;&gt;我是屌丝&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; var $html = &quot;&lt;span class=&apos;red&apos; title=&apos;hi&apos;&gt;我是土豪&lt;/span&gt;&quot;; $($html).replaceAll(&quot;.green&quot;); $(&quot;.green&quot;).replaceWith($html); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用wrap()和wrapInner()方法包裹元素和内容wrap()和wrapInner()方法都可以进行元素的包裹 wrap()用于包裹元素本身 wrapInner()用于包裹元素中的内容调用格式分别为：12$(selector).wrap(wrapper)$(selector).wrapInner(wrapper) 参数selector为被包裹的元素，wrapper参数为包裹元素的格式。 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;包裹元素和内容&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;使用wrapInner()方法包裹元素&lt;/h3&gt; &lt;span class=&quot;red&quot; title=&apos;hi&apos;&gt;我的身体有点歪&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;.red&quot;).wrapInner(&quot;&lt;i&gt;&lt;/i&gt;&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用each()方法遍历元素使用each()方法可以遍历指定的元素集合，在遍历时，通过回调函数返回遍历元素的序列号，它的调用格式为：1$(selector).each(function(index)) 参数function为遍历时的回调函数，index为遍历元素的序列号，它从0开始。123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;使用each()方法遍历元素&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;使用each()方法遍历元素&lt;/h3&gt; &lt;span class=&quot;green&quot;&gt;香蕉&lt;/span&gt; &lt;span class=&quot;green&quot;&gt;桃子&lt;/span&gt; &lt;span class=&quot;green&quot;&gt;葡萄&lt;/span&gt; &lt;span class=&quot;green&quot;&gt;荔枝&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;span&quot;).each(function (index) &#123; if (index == 1) &#123; $(this).attr(&quot;class&quot;, &quot;red&quot;); &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用remove()和empty()方法删除元素 empty() will remove all the contents of the selection. remove() will remove the selection and its contents.12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;删除元素&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;使用empty()方法删除元素&lt;/h3&gt; &lt;span class=&quot;green&quot;&gt;香蕉&lt;/span&gt; &lt;span class=&quot;green&quot;&gt;桃子&lt;/span&gt; &lt;span class=&quot;red&quot;&gt;葡萄&lt;/span&gt; &lt;span class=&quot;green&quot;&gt;葡萄&lt;/span&gt; &lt;span class=&quot;red&quot;&gt;荔枝&lt;/span&gt; &lt;span class=&quot;green&quot;&gt;荔枝&lt;/span&gt; &lt;script type=&quot;text/javascript&quot;&gt; //删除.red所在的元素,包括span $(&quot;.red&quot;).remove(); //只是删除了内容，span还在 $(&quot;.green&quot;).empty(); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; style.css1234567891011span&#123; color: White; padding: 8px; margin: 5px; float: left;&#125;.green&#123; background-color: Green;&#125;","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://duyao.github.io/tags/jQuery/"}]},{"title":"jQuery表单选择器","slug":"jQuery表单选择器","date":"2015-11-14T09:03:02.000Z","updated":"2015-11-18T03:07:28.000Z","comments":true,"path":"2015/11/14/jQuery表单选择器/","link":"","permalink":"http://duyao.github.io/2015/11/14/jQuery表单选择器/","excerpt":"jQuery表单选择器","text":"jQuery表单选择器 ##:input表单选择器:input表单选择器可以实现，它的功能是返回全部的表单元素不仅包括所有标记的表单元素，而且还包括、 和 标记的表单元素，因此，它选择的表单元素是最广的。注意:前面有个空格1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitiona//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;title&gt;:input表单选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;修改全部表单元素的背景色&lt;/h3&gt; &lt;form id=&quot;frmTest&quot; action=&quot;#&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;Input Button&quot; /&gt;&lt;br /&gt; &lt;select&gt; &lt;option&gt;Option&lt;/option&gt; &lt;/select&gt;&lt;br /&gt; &lt;textarea rows=&quot;3&quot; cols=&quot;8&quot;&gt;&lt;/textarea&gt;&lt;br /&gt; &lt;button&gt; Button&lt;/button&gt;&lt;br /&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;#frmTest :input&quot;).addClass(&quot;bg_blue&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;## :text表单文本选择器` :text`表单选择器只获取单行的文本输入框元素，对于`&lt;textarea&gt;`区域文本、按钮等元素无效。 &lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN” “http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; :text表单选择器 &lt;body&gt; &lt;h3&gt;修改多个单行输入框元素的背景色&lt;/h3&gt; &lt;form id=&quot;frmTest&quot; action=&quot;#&quot;&gt; &lt;input type=&quot;text&quot; id=&quot;Text1&quot; value=&quot;我是小纸条&quot;/&gt;&lt;br /&gt; &lt;textarea rows=&quot;3&quot; cols=&quot;8&quot;&gt;&lt;/textarea&gt;&lt;br /&gt; &lt;input type=&quot;text&quot; id=&quot;Text2&quot; value=&quot;我也是小纸条&quot;/&gt;&lt;br /&gt; &lt;button&gt; Button&lt;/button&gt;&lt;br /&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;#frmTest :text&quot;).addClass(&quot;bg_blue&quot;); &lt;/script&gt; &lt;/body&gt; ```","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://duyao.github.io/tags/jQuery/"}]},{"title":"jQuery练习","slug":"jQuery练习","date":"2015-11-14T08:09:28.000Z","updated":"2015-11-18T03:03:20.000Z","comments":true,"path":"2015/11/14/jQuery练习/","link":"","permalink":"http://duyao.github.io/2015/11/14/jQuery练习/","excerpt":"","text":"p1题目在页面中,添加一个&lt;ul&gt;元素,里面放置多个(至少7个以上)的`&lt;li&gt;元素,此外,再添加一个&lt;a&gt;元素. 初始时:&lt;ul&gt;元素中仅显示5个&lt;li&gt;元素,其中包含还包括最后一个&lt;li&gt;元素,元素中的显示”更多”字符. 当点击”更多”链接时,自身内容变为”简化”,同时,&lt;ul&gt;元素中显示全部的&lt;li&gt;元素. 当点击”简化”链接时,自身内容变为”更多”,同时,&lt;ul&gt;元素中仅显示包含最后一个&lt;li&gt;元素在内的5个元素. 代码123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;title&gt;挑战题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li class=&quot;1&quot; style=&quot;display:none&quot;&gt;5&lt;/li&gt; &lt;li class=&quot;1&quot; style=&quot;display:none&quot;&gt;6&lt;/li&gt; &lt;li &gt;7&lt;/li&gt; &lt;a id=&quot;aa&quot; href=&quot;#&quot; onclick=&quot;fun()&quot;&gt;更多&lt;/a&gt; &lt;/ul&gt; &lt;script type=&quot;text/javascript&quot;&gt; function fun()&#123; var $str=$(&quot;#aa&quot;).html(); if($str==&quot;更多&quot;)&#123; $(&quot;#aa&quot;).html(&quot;简化&quot;); $(&quot;li:hidden&quot;).css(&apos;display&apos;,&apos;block&apos;); &#125; else if($str==&quot;简化&quot;)&#123; $(&quot;#aa&quot;).html(&quot;更多&quot;); //$(&quot;.1&quot;).css(&apos;display&apos;,&apos;none&apos;); $(&quot;li[class*=&apos;1&apos;]&quot;).css(&apos;display&apos;,&apos;none&apos;); &#125; &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; p2题目在页面中，创建两个按钮。点击第一个“左移”按钮后，将页面中的元素在当前的位置上，以动画的效果向左移动50个像素；点击第二个“右移”按钮后，页面中的元素在当前的位置上，以动画的效果向右移动50个像素。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;title&gt;jQuery动画特效&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; div &#123; position:absolute; width:80px; height:80px; border: solid 1px #ccc; margin: 0px 8px; background-color: Red; color:White; vertical-align:middle &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; id=&quot;b1&quot; value=&quot;左移&quot;&gt; &lt;input type=&quot;button&quot; id=&quot;b2&quot; value=&quot;右移&quot;&gt; &lt;div&gt;I&apos;m div&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function () &#123; $(&quot;#b1&quot;).bind(&quot;click&quot;,function () &#123; $(&quot;div&quot;).animate(&#123; left: &quot;-=50px&quot; &#125;, &quot;fast&quot;) &#125;) $(&quot;#b2&quot;).bind(&quot;click&quot;,function () &#123; $(&quot;div&quot;).animate(&#123; left: &quot;+=50px&quot; &#125;,3000) &#125;) &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://duyao.github.io/tags/jQuery/"}]},{"title":"jQuery过滤性选择器","slug":"jQuery过滤性选择器","date":"2015-11-14T02:40:51.000Z","updated":"2015-11-16T01:18:28.000Z","comments":true,"path":"2015/11/14/jQuery过滤性选择器/","link":"","permalink":"http://duyao.github.io/2015/11/14/jQuery过滤性选择器/","excerpt":"jQuery过滤性选择器书写时以:号开头,通常用于查找集合元素中的某一位置的单个元素","text":"jQuery过滤性选择器书写时以:号开头,通常用于查找集合元素中的某一位置的单个元素 :first过滤选择器:first获得相同标签的第1个元素:last获得相同标签的第1个元素 1234567891011121314151617181920212223&lt;html&gt; &lt;head&gt; &lt;title&gt;:first过滤选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;改变最后一行&quot;苹果&quot;背景颜色：&lt;/div&gt; &lt;ol&gt; &lt;li&gt;葡萄&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;橘子&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;/ol&gt; &lt;script type=&quot;text/javascript&quot;&gt; //最后一个li变色 $(&quot;li:last&quot;).css(&quot;background-color&quot;, &quot;red&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; :eq(index)过滤性选择器:eq(index)可以选择任意的标签元素index是索引号，从0开始 12345678910111213141516171819202122&lt;html&gt; &lt;head&gt; &lt;title&gt;:eq(index)过滤选择器&lt;/title&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;改变中间行&quot;葡萄&quot;背景颜色：&lt;/div&gt; &lt;ol&gt; &lt;li&gt;橘子&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;葡萄&lt;/li&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt; &lt;/ol&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;li:eq(2)&quot;).css(&quot;background-color&quot;, &quot;#60F&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; :contains(text)过滤选择器:contains(text)按照文本内容查找元素，包含指定字符串text的的全部内容1234567891011121314151617181920212223&lt;html&gt; &lt;head&gt; &lt;title&gt;:contains(text)过滤选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;改变包含&quot;jQuery&quot;字符内容的背景色：&lt;/div&gt; &lt;ol&gt; &lt;li&gt;强大的&quot;jQuery&quot;&lt;/li&gt; &lt;li&gt;&quot;javascript&quot;也很实用&lt;/li&gt; &lt;li&gt;&quot;jQuery&quot;前端必学&lt;/li&gt; &lt;li&gt;&quot;java&quot;是一种开发语言&lt;/li&gt; &lt;li&gt;前端利器——&quot;jQuery&quot;语言&lt;/li&gt; &lt;/ol&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;li:contains(&apos;jQuery&apos;)&quot;).css(&quot;background&quot;, &quot;green&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 注意$(&quot;li:contains(&#39;jQuery&#39;)&quot;)中&#39;jQuery&#39;带单引号，是因为jQuery是不是变量，不能用双引号 :has(selector)过滤选择器:has(selector)通过元素名称来选择元素,不是文本！ 12345678910111213141516171819202122&lt;html&gt; &lt;head&gt; &lt;title&gt;:has(selector)过滤选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;改变包含&quot;label&quot;元素的背景色：&lt;/div&gt; &lt;ol&gt; &lt;li&gt;&lt;p&gt;我是P先生&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;L妹纸就是我&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;我也是P先生&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;label&gt;我也是L妹纸哦&lt;/label&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;P先生就是我哦&lt;/p&gt;&lt;/li&gt; &lt;/ol&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;li:has(&apos;label&apos;)&quot;).css(&quot;background-color&quot;, &quot;blue&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; :hidden过滤选择器:hidden过滤选择器的功能是获取全部不可见的元素，这些不可见的元素中包括type属性值为hidden的元素。123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;:hidden过滤选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;显示隐藏元素的内容&lt;/h3&gt; &lt;input id=&quot;hidstr&quot; type=&quot;hidden&quot; value=&quot;我已隐藏起来&quot;/&gt; &lt;div&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var $strHTML = $(&quot;input:hidden&quot;).val(); $(&quot;div&quot;).html($strHTML); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; :visible过滤选择器与:hidden过滤选择器相反，:visible过滤选择器获取的是全部可见的元素，也就是说，只要不将元素的display属性值设置为“none”，那么，都可以通过该选择器获取。1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;:visible过滤选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;修改可见“水果”的背景色&lt;/h3&gt; &lt;ul&gt; &lt;li style=&quot;display:none&quot;&gt;橘子&lt;/li&gt; &lt;li style=&quot;display:block&quot;&gt;香蕉&lt;/li&gt; &lt;li style=&quot;display:&quot;&gt;葡萄&lt;/li&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li style=&quot;display:none&quot;&gt;西瓜&lt;/li&gt; &lt;/ul&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;li:visible&quot;).css(&quot;background-color&quot;,&quot;blue&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; [attribute=value]属性选择器[attribute=value]属性选择器的功能是获取与属性名和属性值完全相同的全部元素，其中[]是专用于属性选择器的括号符，参数attribute表示属性名称，value参数表示属性值。1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;[attribute=value]属性选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;改变&quot;title&quot;属性值为&quot;蔬菜&quot;的背景色&lt;/h3&gt; &lt;ul&gt; &lt;li title=&quot;蔬菜&quot;&gt;茄子&lt;/li&gt; &lt;li title=&quot;水果&quot;&gt;香蕉&lt;/li&gt; &lt;li title=&quot;蔬菜&quot;&gt;芹菜&lt;/li&gt; &lt;li title=&quot;水果&quot;&gt;苹果&lt;/li&gt; &lt;li title=&quot;水果&quot;&gt;西瓜&lt;/li&gt; &lt;/ul&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;li[title=&apos;蔬菜&apos;]&quot;).css(&quot;background-color&quot;, &quot;green&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; [attribute*=value]属性选择器[attribute*=value]可以获取属性值中包含指定内容的全部元素1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;[attribute*=value]属性选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; role=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;改变&quot;title&quot;属性值包含&quot;果&quot;的背景色&lt;/h3&gt; &lt;ul&gt; &lt;li title=&quot;蔬菜&quot;&gt;茄子&lt;/li&gt; &lt;li title=&quot;水果&quot;&gt;香蕉&lt;/li&gt; &lt;li title=&quot;蔬菜&quot;&gt;芹菜&lt;/li&gt; &lt;li title=&quot;人参果&quot;&gt;小西红柿&lt;/li&gt; &lt;li title=&quot;水果&quot;&gt;西瓜&lt;/li&gt; &lt;/ul&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;li[title*=&apos;果&apos;]&quot;).css(&quot;background-color&quot;, &quot;green&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; :first-child子元素过滤选择器:first过滤选择器可以获取指定父元素中的首个子元素，但该选择器返回的只有一个元素，并不是一个集合，而使用:first-child子元素过滤选择器则可以获取每个父元素中返回的首个子元素，它是一个集合，常用多个集合数据的选择处理。注意:与first-child无空格123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;:first-child子元素过滤选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;改变每个&quot;蔬菜水果&quot;中第一行的背景色&lt;/h3&gt; &lt;ol&gt; &lt;li&gt;芹菜&lt;/li&gt; &lt;li&gt;茄子&lt;/li&gt; &lt;li&gt;萝卜&lt;/li&gt; &lt;li&gt;大白菜&lt;/li&gt; &lt;li&gt;西红柿&lt;/li&gt; &lt;/ol&gt; &lt;ol&gt; &lt;li&gt;橘子&lt;/li&gt; &lt;li&gt;香蕉&lt;/li&gt; &lt;li&gt;葡萄&lt;/li&gt; &lt;li&gt;苹果&lt;/li&gt; &lt;li&gt;西瓜&lt;/li&gt; &lt;/ol&gt; &lt;script type=&quot;text/javascript&quot;&gt; //li中的第一个 $(&quot;li:first-child&quot;).css(&quot;background-color&quot;, &quot;green&quot;); //li中最后一个 $(&quot;li:last-child&quot;).css(&quot;background-color&quot;, &quot;green&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://duyao.github.io/tags/jQuery/"}]},{"title":"jQuery基础选择器","slug":"jQuery基础选择器","date":"2015-11-13T12:59:22.000Z","updated":"2015-11-16T01:01:10.000Z","comments":true,"path":"2015/11/13/jQuery基础选择器/","link":"","permalink":"http://duyao.github.io/2015/11/13/jQuery基础选择器/","excerpt":"jQuery基础选择器","text":"jQuery基础选择器 id选择器-#id$(#id)根据id查找元素1234567891011121314&lt;html&gt; &lt;head&gt; &lt;title&gt;#id选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;divtest&quot;&gt;div的内容&lt;/div&gt; &lt;div id=&quot;default&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //default显示div的内容 $(&quot;#default&quot;).html($(&quot;#divtest&quot;).html()); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; element选择器$(&quot;element&quot;)根据元素名查找元素相当于从铅笔盒里找铅笔12345678910111213&lt;html&gt; &lt;head&gt; &lt;title&gt;element选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;button id=&quot;btntest&quot;&gt;点我&lt;/button&gt; &lt;script type=&quot;text/javascript&quot;&gt; //button变灰 $(&quot;button&quot;).attr(&quot;disabled&quot;,&quot;true&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; .class 选择器$(&quot;.class&quot;)根据元素的类别属性朝找元素相当于从铅笔盒中找红色铅笔1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;title&gt;.class选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;red&quot;&gt;立正，向我这边看齐&lt;/div&gt; &lt;div class=&quot;green&quot;&gt;我先歇歇脚&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //先取得红色的字 var $redHTML = $(&quot;.red&quot;).html(); //让绿色和红色相同 $(&quot;.green&quot;).html($redHTML); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; * 选择器$(&quot;*&quot;)获取页面全部元素相当于取走全部铅笔慎用，反应缓慢123456789101112131415161718&lt;html&gt; &lt;head&gt; &lt;title&gt;*选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;#&quot;&gt; &lt;input id=&quot;Button1&quot; type=&quot;button&quot; value=&quot;button&quot; /&gt; &lt;input id=&quot;Text1&quot; type=&quot;text&quot; /&gt; &lt;input id=&quot;Radio1&quot; type=&quot;radio&quot; /&gt; &lt;input id=&quot;Checkbox1&quot; type=&quot;checkbox&quot; /&gt; &lt;/form&gt; &lt;script type=&quot;text/javascript&quot;&gt; //使form表单中所有元素都不可用 $(&quot;form *&quot;).attr(&quot;disabled&quot;, &quot;true&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; sele1,sele2,seleN选择器$(&quot;sele1,sele2,seleN&quot;)选择多个选择器可以是$(&quot;#id&quot;),$(&quot;.class&quot;).$(&quot;selector&quot;)等相当于从铅笔盒中选择任意多个铅笔1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;title&gt;sele1,sele2,seleN选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;red&quot;&gt;选我吧！我是red&lt;/div&gt; &lt;div class=&quot;green&quot;&gt;选我吧！我是green&lt;/div&gt; &lt;div class=&quot;blue&quot;&gt;选我吧！我是blue&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //红绿变 $(&quot;.red,.green&quot;).html(&quot;hi,我们的样子很美哦!&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ance desc选择器$(&quot;ance desc&quot;)通过层次选择器将多个元素选中ance是父元素，desc是子元素，中间用空格分开不管是孙子辈还是孩子辈，只要有就选择 123456789101112131415161718192021&lt;html&gt; &lt;head&gt; &lt;title&gt;ance desc选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;码农家族 &lt;p&gt; &lt;label&gt;&lt;/label&gt; &lt;/p&gt; &lt;label&gt;&lt;/label&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; //只要是div下面的lable都会改变 $(&quot;div label&quot;).css(&quot;background-color&quot;,&quot;blue&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; parent &gt; child选择器$(&quot;parent &gt; child&quot;)选择孩子辈的子集元素，只有孩子辈，不包括孙子等123456789101112131415161718192021222324&lt;html&gt; &lt;head&gt; &lt;title&gt;parent &gt; child选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 码农家族 &lt;p&gt; &lt;label&gt;&lt;/label&gt; &lt;/p&gt; &lt;label&gt;&lt;/label&gt; &lt;label&gt;&lt;/label&gt; &lt;/div&gt; &lt;label&gt;&lt;/label&gt; &lt;script type=&quot;text/javascript&quot;&gt; //只有div的孩子label才改变 $(&quot;div &gt; label&quot;).css(&quot;border&quot;, &quot;solid 5px red&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; prev + next选择器$(&quot;prev + next&quot;)选择与prev邻近的下一个元素，且只有一个12345678910111213141516171819202122&lt;html&gt; &lt;head&gt; &lt;title&gt;prev + next选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 码农家族 &lt;label&gt;&lt;/label&gt; &lt;p&gt;&lt;/p&gt; &lt;label&gt;&lt;/label&gt; &lt;label&gt;&lt;/label&gt; &lt;/div&gt; &lt;label&gt;&lt;/label&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(&quot;p + label&quot;).css(&quot;background-color&quot;,&quot;red&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; prev ~ siblings选择器$(&quot;prev ~ sibling&quot;)获取当前元素的多个相邻元素，但是只是后面的，不包括前面和本身123456789101112131415161718192021222324&lt;html&gt; &lt;head&gt; &lt;title&gt;prev ~ siblings选择器&lt;/title&gt; &lt;script src=&quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;style.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 码农家族 &lt;label&gt;&lt;/label&gt; &lt;p&gt;&lt;/p&gt; &lt;label&gt;&lt;/label&gt; &lt;label&gt;&lt;/label&gt; &lt;/div&gt; &lt;label&gt;&lt;/label&gt; &lt;script type=&quot;text/javascript&quot;&gt; //获取当前元素的后面的所有label $(&quot;p ~ label&quot;).css(&quot;border&quot;, &quot;solid 1px red&quot;); $(&quot;p ~ label&quot;).html(&quot;我们都是p先生的粉丝&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://duyao.github.io/tags/jQuery/"}]},{"title":"O/R Mapping","slug":"hibernate","date":"2015-11-12T14:22:45.000Z","updated":"2015-11-13T06:39:02.000Z","comments":true,"path":"2015/11/12/hibernate/","link":"","permalink":"http://duyao.github.io/2015/11/12/hibernate/","excerpt":"Collections Mappings:If an entity or class has collection of values for a particular variable, then we can map those values using any one of the collection interfaces available in java. Hibernate can persist instances of java.util.Map, java.util.Set, java.util.SortedMap, java.util.SortedSet, java.util.List, and any array of persistent entities or values. Collection type Mapping and Description java.util.Set This is mapped with a element and initialized with java.util.HashSet java.util.SortedSet This is mapped with a element and initialized with java.util.TreeSet. The sort attribute can be set to either a comparator or natural ordering. java.util.List This is mapped with a element and initialized with java.util.ArrayList java.util.Collection This is mapped with a or element and initialized with java.util.ArrayList java.util.Map This is mapped with a element and initialized with java.util.HashMap java.util.SortedMap This is mapped with a element and initialized with java.util.TreeMap. The sort attribute can be set to either a comparator or natural ordering.","text":"Collections Mappings:If an entity or class has collection of values for a particular variable, then we can map those values using any one of the collection interfaces available in java. Hibernate can persist instances of java.util.Map, java.util.Set, java.util.SortedMap, java.util.SortedSet, java.util.List, and any array of persistent entities or values. Collection type Mapping and Description java.util.Set This is mapped with a element and initialized with java.util.HashSet java.util.SortedSet This is mapped with a element and initialized with java.util.TreeSet. The sort attribute can be set to either a comparator or natural ordering. java.util.List This is mapped with a element and initialized with java.util.ArrayList java.util.Collection This is mapped with a or element and initialized with java.util.ArrayList java.util.Map This is mapped with a element and initialized with java.util.HashMap java.util.SortedMap This is mapped with a element and initialized with java.util.TreeMap. The sort attribute can be set to either a comparator or natural ordering. Set Mapping","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"hibernate","slug":"hibernate","permalink":"http://duyao.github.io/tags/hibernate/"}]},{"title":"6.3","slug":"6.3","date":"2015-11-10T13:54:57.000Z","updated":"2015-11-12T02:33:50.000Z","comments":true,"path":"2015/11/10/6.3/","link":"","permalink":"http://duyao.github.io/2015/11/10/6.3/","excerpt":"计算数组的小和题目数组小和的定义如下：例如数组s=[1,3,5,2,4,6]，在s[0]的左边小于等于s[0]的数的和为0，在s[1]的左边小于等于s[1]的数的和为1，在s[2]的左边小于等于s[2]的数的和为1+3=4，在s[3]的左边小于等于s[3]的数的和为1，在s[4]的左边小于等于s[4]的数的和为1+3+2=6，在s[5]的左边小于等于s[5]的数的和为1+3+5+2+4=15,所以s的小和=0+1+4+1+6+15=27。给定一个数组s，实现函数返回s的小和。","text":"计算数组的小和题目数组小和的定义如下：例如数组s=[1,3,5,2,4,6]，在s[0]的左边小于等于s[0]的数的和为0，在s[1]的左边小于等于s[1]的数的和为1，在s[2]的左边小于等于s[2]的数的和为1+3=4，在s[3]的左边小于等于s[3]的数的和为1，在s[4]的左边小于等于s[4]的数的和为1+3+2=6，在s[5]的左边小于等于s[5]的数的和为1+3+5+2+4=15,所以s的小和=0+1+4+1+6+15=27。给定一个数组s，实现函数返回s的小和。 思路归并排序merge sort和归并相同，先分组，然后合并合并的时候先算小和，再排序算小和的规则 左边小于等于右边的，可以算小和=当前数字*右边比该数字大的个数，然后在排序 左边大与右边，只排序 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public static int getSmallSum(int[] a)&#123; if(a.length == 1 || a == null || a.length == 0)&#123; return 0; &#125; int ans = merge(a, 0, a.length-1); return ans;&#125;public static int merge(int[] a, int low, int high)&#123; if(low == high)&#123; return 0; &#125; int mid = (low + high)/2; int start1 = low, end1 = mid; int start2 = mid+1, end2 = high; //和归并排序相同，就是算小和不仅排序还要算和 return merge(a, start1, end1) + merge(a, start2, end2) + sum(a, low, high); //由于要算小和，每次相加，因此不能像归并排序那样，把后面的排序也写进来，必须分开写，才能算和// int k = 0;// int[] reg = new int[high-low+1];// int tmpSum = 0;// //归并排序中，下面的步骤是排序，这里是算小和加排序// while(start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)&#123;// //左边小于等于右边，算小和且排序// if(a[start1] &lt;= a[start2])&#123;// tmpSum += a[start1]*(end2-start2+1);// reg[k++] = a[start1++];// &#125;else&#123;// //只排序，不算和// reg[k++] = a[start2++];// &#125;// // &#125;// while(start1 &lt;= end1)&#123;// reg[k++] = a[start1++];// &#125;// while(start2 &lt;= end2)&#123;// reg[k++] = a[start2++];// &#125;// for(int i = low, j = 0; i &lt;= high &amp;&amp; j&lt;=k; i++,j++)&#123;// a[i] = reg[j];// &#125;// return tmpSum;&#125;public static int sum(int[] a, int low, int high)&#123; int mid = (low + high)/2; int start1 = low, end1 = mid; int start2 = mid+1, end2 = high; //k是reg数组的位置 int k = 0; //reg存放排好序的新数组 int[] reg = new int[high-low+1]; //tmpSum小和 int tmpSum = 0; //归并排序中，下面的步骤是排序，这里是算小和加排序 while(start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)&#123; //左边小于等于右边，算小和且排序 if(a[start1] &lt;= a[start2])&#123; //注意这里是小的数字乘以比其大的数字的个数 tmpSum += a[start1]*(end2-start2+1); //排序 reg[k++] = a[start1++]; &#125;else&#123; //只排序，不算和 reg[k++] = a[start2++]; &#125; &#125; //剩余的排序 while(start1 &lt;= end1)&#123; reg[k++] = a[start1++]; &#125; while(start2 &lt;= end2)&#123; reg[k++] = a[start2++]; &#125; for(int i = low, j = 0; i &lt;= high &amp;&amp; j&lt;=k; i++,j++)&#123; //把排好序的数组赋值给a a[i] = reg[j]; &#125; return tmpSum;&#125;public static void main(String[] args) &#123; //int[] a = &#123;1,3,5,2,4,6&#125;; int[] a = &#123;1,2,3,4,5,6&#125;; int ans = getSmallSum(a); System.out.println(ans);&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"6.2","slug":"6.2","date":"2015-11-10T12:13:08.000Z","updated":"2015-11-12T02:33:46.000Z","comments":true,"path":"2015/11/10/6.2/","link":"","permalink":"http://duyao.github.io/2015/11/10/6.2/","excerpt":"数组排序之后相邻数的最大差值题目给定一个整型数组arr，返回如果排序之后，相邻两数的最大差值。arr=[9,3,1,10]。如果排序，结果为[1,3,9,10]，9和3的差为最大差值，故返回6。arr=[5,5,5,5]。返回0。如果arr的长度为N，请做到时间复杂度为O(N)。 思路如果用排序做，最好的是O(n*log(n))利用桶排的思想比如有10个数，最小是10，最大是110，那么就化为11个区间，最后一个区间是最后一个数其余区间就是[10,20),[20,30),[30,40)…[90,100),[100,110)然后把这10个数字放到11个区间里去，那么必然有一个区间是空的而最大差值是一个非空区间最大值与另一个非空区间最小值得差，(两者中间可能有空区间)因为同一区间内的差值最大是就是间隔 因此需要先找到最大值和最小值，然后划分区间，把数字放到区间中去，找最大差值","text":"数组排序之后相邻数的最大差值题目给定一个整型数组arr，返回如果排序之后，相邻两数的最大差值。arr=[9,3,1,10]。如果排序，结果为[1,3,9,10]，9和3的差为最大差值，故返回6。arr=[5,5,5,5]。返回0。如果arr的长度为N，请做到时间复杂度为O(N)。 思路如果用排序做，最好的是O(n*log(n))利用桶排的思想比如有10个数，最小是10，最大是110，那么就化为11个区间，最后一个区间是最后一个数其余区间就是[10,20),[20,30),[30,40)…[90,100),[100,110)然后把这10个数字放到11个区间里去，那么必然有一个区间是空的而最大差值是一个非空区间最大值与另一个非空区间最小值得差，(两者中间可能有空区间)因为同一区间内的差值最大是就是间隔 因此需要先找到最大值和最小值，然后划分区间，把数字放到区间中去，找最大差值 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public int maxGap(int[] a) &#123; if (a.length == 0 || a == null) &#123; return 0; &#125; // 求出最大最小值 int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; for (int i = 0; i &lt; a.length; i++) &#123; min = Math.min(a[i], min); max = Math.max(a[i], max); &#125; if (max == min) &#123; // 最大值与最小值相等，说明所有数字都相等，差值为0 return 0; &#125; // 记录每个桶的最大值和最小值，及该桶是否有值 int[] minb = new int[a.length + 1]; int[] maxb = new int[a.length + 1]; boolean[] is = new boolean[a.length + 1]; int len = a.length; for (int i = 0; i &lt; len; i++) &#123; // 找到该数应该放在哪个桶里 int bid = bucket(a[i], min, max, len); if (is[bid]) &#123; minb[bid] = Math.min(a[i], minb[bid]); maxb[bid] = Math.max(a[i], maxb[bid]); &#125; else &#123; minb[bid] = a[i]; maxb[bid] = a[i]; is[bid] = true; &#125; &#125; int i = 0; //计算结果时候的前区间的最大值 int num = 0; //最大差值，即后最小减前最大 int res = 0; //找到第一个不空的区间 while (i &lt; len) &#123; if (is[i]) &#123; num = maxb[i]; i++; break; &#125; &#125; //找到后面不空的区间 for (; i &lt;= len; i++) &#123; if (is[i]) &#123; res = Math.max(res, minb[i] - num); //每次重置前区间的最大值 num = maxb[i]; &#125; &#125; return res;&#125;//找到数字i在哪个哪个区间中！//((i - min) * len / (max - min))//用long是为了防止溢出public int bucket(long i, long min, long max, long len) &#123; return (int) ((i - min) * len / (max - min));&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"6.1","slug":"6.1","date":"2015-11-10T10:36:32.000Z","updated":"2015-11-12T03:00:26.000Z","comments":true,"path":"2015/11/10/6.1/","link":"","permalink":"http://duyao.github.io/2015/11/10/6.1/","excerpt":"找出数组中未出现的正整数题目给定一个无序数组，找出数组中未出现的正整数arr=[-1,2,3,4]返回1arr=[1,2,3,4]返回5","text":"找出数组中未出现的正整数题目给定一个无序数组，找出数组中未出现的正整数arr=[-1,2,3,4]返回1arr=[1,2,3,4]返回5 思路用hash也可以做出来，但是空间复杂度很大，该解是最优解，时间复杂度O(N)空间复杂度O(1) 设置2个变量l和rl表示遍历到l位置时，已经收集到[1,l]的正整数，也表示左边界，初始值为0r表示遍历该数组期望收集到[1,r]上面的数，也表示右边界，初始值为数组长度 遍历数组主要靠l和r来设置两端，直到他们相遇遍历过程中，最好的情况是数组是1-r的集合，arr[i]的数字是i-1是最好的对于每一个位置都期望得到是[l+1,r]中间的数字，因为对于l位置已经收集到了[1,l]的数组对于不是期望区间的数组，r的期望区间会减小对于arr[i]的数字不是i-1，但arr[i]是期望区间的，交换值为arr[i]-1的位置，这个意思是，只要不是期望数字，就一直交换，知道找到期望数字为止比如最好的情况下，arr[2]=3,但是此时arr[2]=6,本来6应该出现在arr[5]的位置上的，因此就把arr中2和5位置的数字交换，再判断是不是3，知道找到3为止3种情况 arr[i] &lt;= l || arr[i] &gt; r得到了期望区间之外的数字，最右边界损失把右边界 arr[i] 在[l+1,r]，但是不是i-1，交换a[i]-1与i的位置的值， arr[i]收到重复值的时候，必然导致r的期望区间减小 代码123456789101112131415161718192021222324252627public int missNum(int[] arr) &#123; int l = 0; int r = arr.length; while (l &lt; r) &#123; if (arr[l] == l + 1) &#123; // 最好的时候，这一步要卸载最前面，否则会出现a[0]=1,匹配到arr[l] == arr[arr[l] - 1]导致错误 l++; &#125; else if (arr[l] &gt; r || arr[l] &lt;= l || arr[l] == arr[arr[l] - 1]) &#123; // 出边界或者得到重复值 swap(arr, l, --r); &#125; else if (arr[l] != arr[arr[l] - 1]) &#123; // 得到期望期间的值，但不是期望值 l+1，因此交换，知道得到期望值 l+1为止 swap(arr, l, arr[l] - 1); &#125; &#125; return l + 1; &#125;public void swap(int[] arr, int a, int b) &#123; int tmp = arr[a]; arr[a] = arr[b]; arr[b] = tmp; return;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"Myeclipsee快捷键","slug":"Myeclipsee快捷键","date":"2015-11-06T06:59:54.000Z","updated":"2015-11-07T13:30:26.000Z","comments":true,"path":"2015/11/06/Myeclipsee快捷键/","link":"","permalink":"http://duyao.github.io/2015/11/06/Myeclipsee快捷键/","excerpt":"","text":"Myeclipsee快捷键 按键 功能 ctrl+d 删除本行 ctrl+1 快速修复 shift+enter 在本行的任意位置添加新的下一行 ctrl+f11 快速运行 alt+↑/↓键 快速移动本行代码 ctrl+alt+↑/↓键 快速复制本行代码 ctrl+m 缩小/放大当前工作区 Alt+Shift+j 在函数前面添加函数说明 Ctrl+Shift+O 添加import Ctrl+O 显示大纲 Ctrl+e 显示已经打开的所有编辑器 Ctrl+Shift+X 把当前选中的文本全部变为小写 Ctrl+Shift+Y 把当前选中的文本全部变为小写 Ctrl+k 寻找下一个选中的名字","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"快捷键","slug":"快捷键","permalink":"http://duyao.github.io/tags/快捷键/"}]},{"title":"5.2","slug":"5.2","date":"2015-11-05T14:17:34.000Z","updated":"2015-11-06T05:16:18.000Z","comments":true,"path":"2015/11/05/5.2/","link":"","permalink":"http://duyao.github.io/2015/11/05/5.2/","excerpt":"BFPRT algorithm - Median of mediansO(n) running timea selection algorithm based on the quickselect algorithm having worst-case linear time complexity for selecting the kth largest element题目给定一个无序的整型数组arr，找到其中最小的k个数。 如果数组arr的长度为N，排序之后自然可以得到最小的k个数，此时时间复杂度为排序的时间复杂度即O(NlogN)本题要求读者实现时间复杂度O(NlogK)和O(N)的方法","text":"BFPRT algorithm - Median of mediansO(n) running timea selection algorithm based on the quickselect algorithm having worst-case linear time complexity for selecting the kth largest element题目给定一个无序的整型数组arr，找到其中最小的k个数。 如果数组arr的长度为N，排序之后自然可以得到最小的k个数，此时时间复杂度为排序的时间复杂度即O(NlogN)本题要求读者实现时间复杂度O(NlogK)和O(N)的方法 思路快排也能做，但是由于是随机的选择k，因此只能O(N*logN) BFPRT时间复杂度O(N)其精髓是选择pivot，不是任意的选,而是选择中位数中的中位数-Median of medians 步骤： 5个数分一组，分为n/5一组 组内插入排序，选择所有的上中位数，单独组成一个数组arrm[] 求所有中位数的中位数，即arrm[]的中位数，使用递归调用，求出次中位数pivot 然后快排使用pivot来划分区域，看k是否是中间区域 堆排序时间复杂度O(N*logK)不需要所有的都排序，因此比快排好，更加适合从一堆选前k个大的 步骤: 建k长度的堆 然后对于数组里的剩余数字，每次替换堆顶，对于大于当前堆顶的数字，不用替换，因为他不可能是前k大的数字 每次替换后调整结构，保证堆的定义 代码BFPRT123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128//得到0-k大的数组public int[] getMinKNumsByBFPRT(int[] arr, int k) &#123; if (k &lt; 1 || k &gt; arr.length) &#123; return arr; &#125; int minKth = getMinKthByBFPRT(arr, k); int[] res = new int[k]; int index = 0; for (int i = 0; i != arr.length; i++) &#123; if (arr[i] &lt; minKth) &#123; res[index++] = arr[i]; &#125; &#125; for (; index != res.length; index++) &#123; res[index] = minKth; &#125; return res;&#125;//得到第k个大的数字public int getMinKthByBFPRT(int[] arr, int K) &#123; int[] copyArr = copyArray(arr); return select(copyArr, 0, copyArr.length - 1, K - 1);&#125;public int[] copyArray(int[] arr) &#123; int[] res = new int[arr.length]; for (int i = 0; i != res.length; i++) &#123; res[i] = arr[i]; &#125; return res;&#125;//返回值是int，选择i位置的数字，返回结果public int select(int[] arr, int begin, int end, int i) &#123; if (begin == end) &#123; return arr[begin]; &#125; //选择中位数的中位数 int pivot = medianOfMedians(arr, begin, end); //找到与pivot相等的数组下标 int[] pivotRange = partition(arr, begin, end, pivot); if (i &gt;= pivotRange[0] &amp;&amp; i &lt;= pivotRange[1]) &#123; return arr[i]; &#125; else if (i &lt; pivotRange[0]) &#123; //如果没命中就去找比pivot小的中位数 //pivotRange[0]是与pivot值相等的左边位置 return select(arr, begin, pivotRange[0] - 1, i); &#125; else &#123; //pivotRange[1]是与pivot值相等的右边位置 return select(arr, pivotRange[1] + 1, end, i); &#125;&#125;//找中位数的中位数public int medianOfMedians(int[] arr, int begin, int end) &#123; int num = end - begin + 1; //不是5的倍数，就要多一组 int offset = num % 5 == 0 ? 0 : 1; int[] mArr = new int[num / 5 + offset]; for (int i = 0; i &lt; mArr.length; i++) &#123; int beginI = begin + i * 5; int endI = beginI + 4; //mArr是中位数的集合 mArr[i] = getMedian(arr, beginI, Math.min(end, endI)); &#125; //选择中位数组中的中位数 return select(mArr, 0, mArr.length - 1, mArr.length / 2);&#125;/** * @param pivotValue 选择的中间位置 * partition的目的是利用快排将arr进行分区 * 左边比pivotValue小，右边比pivotValue大，中间是与pivotValue相等的 * @return 返回值是int数组，返回的是与pivotValue相等的数组下标 */public int[] partition(int[] arr, int begin, int end, int pivotValue) &#123; int small = begin - 1; int cur = begin; int big = end + 1; //快排原理，将arr分区， //左边是比pivotValue小的,右边比pivotValue大，中间的和pivotValue等 while (cur != big) &#123; if (arr[cur] &lt; pivotValue) &#123; swap(arr, ++small, cur++); &#125; else if (arr[cur] &gt; pivotValue) &#123; swap(arr, cur, --big); &#125; else &#123; cur++; &#125; &#125; //得到与pivotValue相等的位置的坐标范围 int[] range = new int[2]; //最左边 range[0] = small + 1; //最右边 range[1] = big - 1; return range;&#125;//得到中间位置的数字public int getMedian(int[] arr, int begin, int end) &#123; insertionSort(arr, begin, end); int sum = end + begin; int mid = (sum / 2) + (sum % 2); return arr[mid];&#125;//插入排序public void insertionSort(int[] arr, int begin, int end) &#123; for (int i = begin + 1; i != end + 1; i++) &#123; for (int j = i; j != begin; j--) &#123; if (arr[j - 1] &gt; arr[j]) &#123; swap(arr, j - 1, j); &#125; else &#123; break; &#125; &#125; &#125;&#125;public void swap(int[] arr, int index1, int index2) &#123; int tmp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = tmp;&#125; Heap1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public int[] getMinKNumsByHeap(int[] arr, int k) &#123; if (k &lt; 1 || k &gt; arr.length) &#123; return arr; &#125; //建堆，长度为k，因为只需要找出前k大的数字 int[] kHeap = new int[k]; for (int i = 0; i != k; i++) &#123; //向堆中插入数字 heapInsert(kHeap, arr[i], i); &#125; //找出前k大的数字 for (int i = k; i != arr.length; i++) &#123; //kHeap[0]是当前第k大的数字 //因为只需要找前k大的数字，因此比堆顶大的数字不需要考虑，因为他至少是k+1大的数字了 if (arr[i] &lt; kHeap[0]) &#123; //将当前堆顶换掉，换位目前第k大的数字 kHeap[0] = arr[i]; //调整堆，因为换了堆顶，要满足堆的定义 heapify(kHeap, 0, k); &#125; &#125; return kHeap; &#125; public void heapInsert(int[] arr, int value, int index) &#123; arr[index] = value; //保证是堆，即每个树父亲比孩子大 while (index != 0) &#123; int parent = (index - 1) / 2; //父亲小，作调整，在循环里，保证交换后都可以符合堆的定义 if (arr[parent] &lt; arr[index]) &#123; swap(arr, parent, index); index = parent; &#125; else &#123; break; &#125; &#125; &#125; public void heapify(int[] arr, int index, int heapSize) &#123; //找到左右孩子 int left = index * 2 + 1; int right = index * 2 + 2; //假设堆顶最大 int largest = index; //发现比堆顶大的就交换，循环里保证堆的定义 while (left &lt; heapSize) &#123; //2个if找到父亲，左右孩子中最大的值，然后交换 if (arr[left] &gt; arr[index]) &#123; largest = left; &#125; if (right &lt; heapSize &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right; &#125; //交换 if (largest != index) &#123; swap(arr, largest, index); &#125; else &#123; break; &#125; //使当前位置指向交换过的位置，继续检查 index = largest; left = index * 2 + 1; right = index * 2 + 2; &#125; &#125; public void swap(int[] arr, int index1, int index2) &#123; int tmp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = tmp; &#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"5.1","slug":"5.1","date":"2015-11-05T05:55:51.000Z","updated":"2015-11-06T04:55:14.000Z","comments":true,"path":"2015/11/05/5.1/","link":"","permalink":"http://duyao.github.io/2015/11/05/5.1/","excerpt":"KMP algorithm - A string matching algorithm 题目给定两个字符串str和match，长度分别为N和M。实现一个算法，如果字符串str中含有字串match，则返回match在str中的开始位置，不含有则返回-1。 str=“acbc”，match=“bc”。返回2。str=“acbc”，match=“bcc”。返回-1。 如果match的长度大于str长度(M&gt;N)，str必然不会含有match，可直接返回-1。但如果N&gt;=M，要求算法复杂度O(N)。","text":"KMP algorithm - A string matching algorithm 题目给定两个字符串str和match，长度分别为N和M。实现一个算法，如果字符串str中含有字串match，则返回match在str中的开始位置，不含有则返回-1。 str=“acbc”，match=“bc”。返回2。str=“acbc”，match=“bcc”。返回-1。 如果match的长度大于str长度(M&gt;N)，str必然不会含有match，可直接返回-1。但如果N&gt;=M，要求算法复杂度O(N)。 思路kmp算法的核心是next数组,长度是要查找的字符串长度，表示的是： next[i]: The length of the longest proper prefix in the (sub)pattern that matches a proper suffix in the same (sub)pattern. next[i]是当前位置i以前的字符串 proper prefixes : All the characters in a string, with one or more cut off the end. “S”, “Sn”, “Sna”, and “Snap” are all the proper prefixes of “Snape”.proper suffixes : All the characters in a string, with one or more cut off the beginning. “agrid”, “grid”, “rid”, “id”, and “d” are all proper suffixes of “Hagrid”. proper prefixes和proper suffixes都不包含自己本身 如何计算next,O(m)cn跳的位置 pos要计算的每个位置 next[0] = -1 next[1] = 0 str[pos-1] == str[cn]-&gt; next[pos] = cn; str[pos-1] != str[cn] &amp;&amp; cn!=0 -&gt; cn = next[cn] str[pos-1] != str[cn] &amp;&amp; cn == 0 -&gt; next[pos] = 0 如何利用 next If a partial match of length partial_match_length is found and next[partial_match_length] &gt; 1,we may skip ahead partial_match_length - next[partial_match_length - 1] characters. More:KMP algoritmKMP animation 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public int KMP(String string, String match)&#123; char[] cstring = string.toCharArray(); char[] cmatch = match.toCharArray(); //生成next int [] next = initNext(cmatch); int i = 0, j = 0; while(i&lt;string.length() &amp;&amp; j&lt;match.length())&#123; if(cstring[i] == cmatch[j])&#123; i++; j++; &#125;else if(next[j] == -1)&#123; i++; &#125;else&#123; //下次从next[j]位置比较，就是跳过了j-next[j]个位置，此时i不变的 j = next[j]; &#125; &#125; if(j == cmatch.length)&#123; //j遍历完整的match串,说明完全匹配 return i-j; &#125;else&#123; //没有遍历完整，无匹配 return -1; &#125; &#125;public int[] initNext(char[] cmatch)&#123; if(cmatch.length == 1)&#123; return new int[]&#123;-1&#125;; &#125; //next与match等长 int[] next = new int[cmatch.length]; next[0] = -1; next[1] = 0; int pos = 2, cn = 0; while(pos &lt; next.length)&#123; //next记录的是当前位置以前的状况，即不包括当前位置 if(cmatch[pos-1] == cmatch[cn])&#123; next[pos++] = ++cn; &#125;else &#123; if(cn != 0)&#123; //pos没有自增，因为还要继续，直到cn=0为止 cn = next[cn]; &#125;else&#123; next[pos++] = 0; &#125; &#125; &#125; return next;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"4.1","slug":"4.1","date":"2015-11-04T14:17:21.000Z","updated":"2015-11-05T06:25:18.000Z","comments":true,"path":"2015/11/04/4.1/","link":"","permalink":"http://duyao.github.io/2015/11/04/4.1/","excerpt":"Manacher algorithm - Longest Palindromic SubstringO(N) time and O(N) space 题目给定一个字符串str，返回str中的最长回文子串的长度。str=“123”。其中的最长回文子串“1”或者“2”或者“3”，所以返回1。str=“abc1234321ab”。其中的最长回文子串“1234321”，所以返回7。","text":"Manacher algorithm - Longest Palindromic SubstringO(N) time and O(N) space 题目给定一个字符串str，返回str中的最长回文子串的长度。str=“123”。其中的最长回文子串“1”或者“2”或者“3”，所以返回1。str=“abc1234321ab”。其中的最长回文子串“1234321”，所以返回7。 思路 解决字符串奇偶问题，在源字符串每个字符添加一个字符，包括首尾，这个字符是任意的 12s: a b c 1 2 3 4 3 2 1 a bt:#a#b#c#1#2#3#4#3#2#1#a#b# 设定p[]表示的是以该字符为中心的最大回文半径 123s:a b c 1 2 3 4 3 2 1 a bt:#a#b#c#1#2#3#4#3#2#1#a#b#p:0101010101010701010101010 从p可以看出最大回文长度为7,因多了字符，所以不用除2 求p[]的过程 设置index和rindex:以index位置为中心r:以index位置为中心，最大的回文半径所在的坐标位置这两个值是随时更新的 三种情况： 当i的对称点p[i_mirro]在回文半径r-index内部时，p[i]=p[i_mirro] 当i的对称点p[i_mirro]在回文半径r-index位置上，p[i]=p[i_mirro],然后再继续遍历找p[i] 当i的对称点p[i_mirro]在回文半径r-index外部时，直接遍历找p[i] see more: Longest Palindromic Substring 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//对字符串添加public char [] changeToManacher(String s)&#123; char [] c = s.toCharArray(); char [] res = new char[c.length * 2 + 1]; for(int i = 0;i &lt;res.length; i++)&#123; if(i % 2 == 0)&#123; res[i] = '#'; &#125;else&#123; res[i] = c[i/2]; &#125; &#125; return res;&#125;public String Manacher(String s)&#123; char [] t = changeToManacher(s); int [] p = new int[t.length]; int index = 0, r = 0; //第一个和最后一个的p都是0 for (int i = 1; i &lt; t.length -1 ; i++)&#123; int i_mirro = 2*index - i;//i的关于index的对称点 = index + i - index if(r &lt; i)&#123; //当i在r之外,关于自己对称是p是0 p[i] = 0; &#125;else&#123; //i在r内部，或在r的位置 //在r的位置时，p为0 p[i] = Math.min(p[i_mirro], r-i); &#125; //对于在外部或者在r位置的状况，只能遍历两侧是否为回文 while(i + p[i] +1 &lt; t.length - 1 &amp;&amp; i - p[i] -1 &gt; -1)&#123; if(t[i + p[i] +1] == t[i - p[i] -1])&#123; p[i]++; &#125;else&#123; break; &#125; &#125; //更新index和r //r是最长回文半径所在位置的坐标 if(i + p[i] &gt; r)&#123; r = i + p[i]; index = i; &#125; &#125; //找到最长的回文长度 int maxP = 0; int center = 0; for (int i = 1; i &lt; t.length - 1; i++)&#123; if(p[i] &gt; maxP)&#123; maxP = p[i]; center = i; &#125; &#125; return s.substring((center - maxP)/2, maxP); &#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"shoppingSite_pom","slug":"shoppingSite-pom","date":"2015-11-02T08:46:31.000Z","updated":"2015-11-02T08:49:12.000Z","comments":true,"path":"2015/11/02/shoppingSite-pom/","link":"","permalink":"http://duyao.github.io/2015/11/02/shoppingSite-pom/","excerpt":"shoppingSite中的pom.xml该项目主要是struts2, spring, mybatis 框架整合搭环境时除了很多问题，特地把pom.xml记录下来","text":"shoppingSite中的pom.xml该项目主要是struts2, spring, mybatis 框架整合搭环境时除了很多问题，特地把pom.xml记录下来 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.dy&lt;/groupId&gt; &lt;artifactId&gt;ShoppingSite&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;ShoppingSite&lt;/name&gt; &lt;description /&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet.jsp.jstl&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.37&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- &lt;dependency&gt; &lt;groupId&gt;org.springframework.ws&lt;/groupId&gt; &lt;artifactId&gt;spring-ws-core&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; --&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;4.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;4.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;4.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- struts --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.14&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ognl&lt;/groupId&gt; &lt;artifactId&gt;ognl&lt;/artifactId&gt; &lt;version&gt;3.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm&lt;/artifactId&gt; &lt;version&gt;3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm-commons&lt;/artifactId&gt; &lt;version&gt;3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;asm&lt;/groupId&gt; &lt;artifactId&gt;asm-tree&lt;/artifactId&gt; &lt;version&gt;3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.22&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.11.0.GA&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Exception starting filter struts2 Unable to load configuration. - [unknown location] at org.apache.struts2.dispatcher.Dispatcher.init --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-spring-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.24.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-core&lt;/artifactId&gt; &lt;version&gt;2.3.24&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts.xwork&lt;/groupId&gt; &lt;artifactId&gt;xwork-core&lt;/artifactId&gt; &lt;version&gt;2.3.24&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;4.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-instrument&lt;/artifactId&gt; &lt;version&gt;4.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.2.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.7&lt;/source&gt; &lt;target&gt;1.7&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;failOnMissingWebXml&gt;false&lt;/failOnMissingWebXml&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt;","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"project","slug":"project","permalink":"http://duyao.github.io/tags/project/"}]},{"title":"3.5","slug":"3.5","date":"2015-11-01T02:58:09.000Z","updated":"2015-11-01T02:58:34.000Z","comments":true,"path":"2015/11/01/3.5/","link":"","permalink":"http://duyao.github.io/2015/11/01/3.5/","excerpt":"","text":"","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"3.4","slug":"3.4","date":"2015-11-01T01:41:38.000Z","updated":"2015-11-01T02:49:56.000Z","comments":true,"path":"2015/11/01/3.4/","link":"","permalink":"http://duyao.github.io/2015/11/01/3.4/","excerpt":"","text":"题目设X[0: n-1]和Y[0: n-1]为两个数组，每个数组中含有n个己排好序的数。试设计一个〇(logn)时间的分治算法，找出X和y的2n个数的中位数，并证明算法的时间复杂性为〇(logn) 思路本题目已说明时间复杂度为〇(logn)，因此不是简单地遍历，因此选中二分来解题。 当数组中数字个数为偶数时数字代表位置，而不是大小 X: 1,2,3,4 Y:11,22,33,44 将X,Y合并时，新数组共有8个数字，也就是中位数是第4个数字 分情况讨论: 2 == 22中位数一定是2或者22 2 &gt; 22中位数可能是1,2,33,44因为22最好的情况是比1,11大，不可能是中位数同理11不可能是中位数而3已经比1,2,11,22这4个数大，不可能是中位数同理4也不能因此得到二分区间[1,2]和[33,44] 2 &lt; 22中位数可能是11,22,3,4因此得到二分区间[11,22]和[3,4] 当数组中数字个数为奇数时数字代表位置，而不是大小 X: 1,2,3,4,5 Y:11,22,33,44,55 将X,Y合并时，新数组共有10个数字，也就是中位数是第5个数字 分情况讨论: 3 == 33中位数一定是3或者33 3 &lt; 33中位数可能是11,22,3,4,5因为33已经比1,2,3,11,22这5个数大了，一定不是中位数同理44,55不是中位数而2最好的情况是大于1,11,22，最多可能是第4个数，也不能是中位数同理1不是中位数因此得到二分区间[11,22]和[3,4,5]但是这样的区间个数不相等，无法递归因此该区间为[11,22,33]和[3,4,5]尽管33不可能是中位数，但是为了递归只能算进去 3 &gt; 33中位数可能是1,2,33,44,55因此得到二分区间[1,2,33]和[33,44,55] 代码12345678910111213141516171819202122232425262728293031323334/** * @param a 数组a * @param as 数组a第一个数的下标 * @param ae 数组a最后一个数的下标 * @param b 数组b * @param bs 数组b第一个数的下标 * @param be 数组b最后一个数的下标 * @return 合并后中位数 */public int find (int []a, int as, int ae, int []b, int bs, int be)&#123; int len = ae - as + 1; int amid = as + len/2; int bmid = bs + len/2; if(len == 1)&#123; return Math.min(a[amid], b[bmid]); &#125; //奇偶标志位 int flag = 0; if(len%2 == 0)&#123; amid -= 1; bmid -= 1; flag = 1; &#125; if(a[amid] &gt; b[bmid])&#123; return find(a, as, amid, b, bmid + flag, be); &#125;else if(a[amid] &lt; b[bmid])&#123; return find(a, amid + flag, ae, b, bs, bmid); &#125;else&#123; return a[amid]; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"shoppingSite","slug":"shoppingSite","date":"2015-10-31T06:26:14.000Z","updated":"2015-11-09T14:34:06.000Z","comments":true,"path":"2015/10/31/shoppingSite/","link":"","permalink":"http://duyao.github.io/2015/10/31/shoppingSite/","excerpt":"shoppingSite本文只要记录在开发工程中遇到的问题以及解决方法以及待改进 技术 struts2 spring mybatis 做项目时候，先将各种包，接口等做好然后依次配置xml,先从mybatis，spring，struts2","text":"shoppingSite本文只要记录在开发工程中遇到的问题以及解决方法以及待改进 技术 struts2 spring mybatis 做项目时候，先将各种包，接口等做好然后依次配置xml,先从mybatis，spring，struts2 一些还能改进的地方 待改进 商品修改时，如果修改了类别，那么新类别数目+1，旧类别数目-1，删除也是 购物车添加商品后，显示慢一步 商品显示分页 当前位置的显示，一直是手机 清空购物车 未完成 我的账户，订单 管理员查询管理订单 评价功能 配置spring的xml文件中的bean应该全部配置实例的？！！1234567891011&lt;bean id=\"userMapper\" class=\"org.mybatis.spring.mapper.MapperFactoryBean\"&gt; &lt;!--接口--&gt; &lt;property name=\"mapperInterface\" value=\"com.dy.shoppingSite.dao.UserDao\" /&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" /&gt;&lt;/bean&gt;&lt;!--实例--&gt;&lt;bean id=\"userService\" class=\"com.dy.shoppingSite.service.impl.UserServiceImpl\"&gt; &lt;property name=\"userDao\" ref=\"userMapper\"&gt;&lt;/property&gt;&lt;/bean&gt; spring 与 struts2 联合使用加入struts2-spring-plugin Exception starting filter struts2 Unable to load configuration.[unknown location] at org.apache.struts2.dispatcher.Dispatcher.init 报错原因是没有struts2-spring-plugin 得到id随机数串使用UUID.randomUUID()1234public static String getID()&#123; UUID uuid = UUID.randomUUID(); return uuid.toString().replace(\"-\", \"\");&#125; ajax和jquery需要服务器端返回一个无参数的函数使用ajax和jquery来实现，需要服务器端返回一个无参数的函数,参数传递使用response123456789101112public void isExist() &#123; boolean b = userService.isExist(user.getName()); try &#123; PrintWriter writer = ServletActionContext.getResponse().getWriter(); writer.print(b); writer.flush(); writer.close(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125; 分页操作 建立pageBean的实体类，使用泛型 1234567891011121314public class PageBean&lt;T&gt; &#123; //数据 private List&lt;T&gt; data; //设置每页显示多少条，固定的 private int pageSize; //当前页的记录的标号，mysql中的参数 private int pageNo; //总页数 private int totalPage; //当前页数 private int page; //总的条数，即一共多少条记录 private int totalNum;&#125; 在dao层进行查询得到data的值，比如List&lt;Goods&gt; 在service层实现pageBean的封装,比如totalPage 在action中传入所需要的参数,比如page 实现搜索条件保存和翻页的结合在项目中搜索栏中会有各种搜索条件，搜索完成后，需要分页浏览，但是进入下一页时，要保证搜索条件仍然显示出来这是需要用form表单将他们放在一起，并用jquery控制分页及整体form提交 jquery检查到page发生变化，就向后台提交 page是向后台传送的属性123456&lt;script type=&quot;text/javascript&quot;&gt; function goPage(p)&#123; $(&quot;#page&quot;).val(p); $(&quot;#form1&quot;).submit(); &#125;&lt;/script&gt; 使用form把搜索条件和页码一起控制 12345678910111213141516&lt;!-- //为了解决 将搜索内容和page都传到后台--&gt;&lt;form action=&quot;goods_listGoodsByPage&quot; method=&quot;post&quot; id=&quot;form1&quot;&apos;&gt; &lt;!-- 因此添加hidden属性将page和goods一起传到后台,在jquery中goPage实现的 --&gt; &lt;!-- name是传到后台的属性名，id是jquery中使用的属性名 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;page&quot; id=&quot;page&quot; /&gt; &lt;select class=&quot;auto&quot; name=&quot;goods.categoryId&quot; id=&quot;category&quot;&gt; &lt;option value=&quot;&quot;&gt;选择分类&lt;/option&gt; &lt;c:forEach items=&quot;$&#123;categories&#125;&quot; var=&quot;category&quot;&gt; &lt;option value=&quot;$&#123;category.id&#125;&quot;&gt;$&#123;category.name&#125;&lt;/option&gt; &lt;/c:forEach&gt; &lt;/select&gt; 商品名： &lt;input class=&quot;small&quot; name=&quot;goods.name&quot; id=&quot;name&quot; type=&quot;text&quot; value=&quot;&quot;&gt; &lt;button class=&quot;btn&quot; type=&quot;submit&quot;&gt; &lt;span class=&quot;sel&quot;&gt;筛 选&lt;/span&gt; &lt;/button&gt;&lt;/form&gt; 分页实现 1234567&lt;div class=&apos;pages_bar&apos;&gt; &lt;a href=&apos;javascript:goPage(1)&apos; id=&quot;first&quot;&gt;首页&lt;/a&gt; &lt;c:forEach begin=&quot;1&quot; end=&quot;$&#123;pageBean.totalPage&#125;&quot; var=&quot;p&quot;&gt; &lt;a href=&quot;javascript:goPage(&apos;$&#123;p&#125;&apos;)&quot;&gt;$&#123;p&#125;&lt;/a&gt; &lt;/c:forEach&gt; &lt;a href=&apos;javascript:goPage($&#123;pageBean.totalPage&#125;)&apos; id=&quot;last&quot;&gt;尾页&lt;/a&gt;&lt;span&gt;当前第$&#123;pageBean.page&#125;页/共$&#123;pageBean.totalPage&#125;页&lt;/span&gt;&lt;/div&gt; 先得到旧数据，再更新在实际中，比如要更新商品，要先得到旧数据，然后对旧数据进行修改，输入到数据库中这样做的原因是，修改界面不一定所有的属性都要修改，所以直接拿新数据进行修改可能会产生空值12345678910public void updateGoods(Goods goods) &#123; // TODO Auto-generated method stub //这里更新要先将beforeGoods拿来，然后把新的goods中属性付给beforeGoods //因为goods中不一定所有属性都进行更新，会产生空值，导致出错 Goods beforeGoods = goodsDao.getGoodsById(goods.getId()); beforeGoods.setCategory(goods.getCategory()); beforeGoods.setCategoryId(goods.getCategoryId()); goodsDao.updateGoods(beforeGoods);&#125; mybatis相关传入多个同类型的参数，使用#{序号}取出1234&lt;select id=\"getUserByNameAndPwd\" resultType=\"User\"&gt;&lt;!-- 传入多个参数可以使用map，通过名字来取出，对于同一类型的多个传入参数，可以使用列号来取出 --&gt; select * from shop_user where name = #&#123;0&#125; and password = #&#123;1&#125;&lt;/select&gt; jdbcType = VARCHAR可以传入空值，且不报错1234567&lt;!-- #&#123;avatar,jdbcType = VARCHAR&#125;当传入值为空的时候，使用varchar可以传入空值 --&gt;&lt;insert id=\"addUser\" parameterType=\"User\"&gt; insert into shop_user values(#&#123;id&#125;, #&#123;name&#125;, #&#123;password&#125;, #&#123;phoneNum&#125;, #&#123;money&#125;, #&#123;avatar,jdbcType = VARCHAR&#125;, #&#123;regTime&#125;, #&#123;role&#125; )&lt;/insert&gt; 得到多个相同类型的数据123456&lt;!-- While this approach is simple, it will not perform well for large data sets or lists. This problem is known as the \"N+1 Selects Problem\". In a nutshell, the N+1 selects problem is caused. We can Nest Results for Association --&gt;&lt;select id=\"getAddress\" parameterType=\"string\" resultType=\"Address\"&gt; select * from shop_address where userid = #&#123;0&#125;&lt;/select&gt; java可以直接用list取得1234public List&lt;Address&gt; getAddress(String userid) &#123; // TODO Auto-generated method stub return addressDao.getAddress(userid);&#125; column不一定是数据库中的名字，property是在java中get，set方法的那些属性association查询一个属性，该属性和另一张表关联，从而查出另一站标的所有属性1234567891011&lt;!--property是在java中get，set方法的那些属性 --&gt;&lt;resultMap type=&quot;Goods&quot; id=&quot;GoodsResultMap&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;result column=&quot;goodsNo&quot; property=&quot;goodsNo&quot; /&gt; &lt;association property=&quot;category&quot; javaType=&quot;Category&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot; /&gt; &lt;!-- 因为goods中也有name属性，因此查询出来的结果会重复。 故把category中的name重新命名为cname，这样就不会重复。 由此可以看出column属性不一定是数据库中的列名， 而是查询后显示的列名 --&gt; &lt;result column=&quot;cname&quot; property=&quot;name&quot; /&gt; &lt;/association&gt;&lt;/resultMap&gt; parameterType不是hashmap等时，不需要加所属，反之必加&amp;hashmap注意判空&amp;bind实现模糊查询parameterType是Goods，是普通的java类型，因此不要goods.name,mybatis直接会用Goods中的get/set方法123456789101112131415&lt;select id=&quot;getGoodses&quot; resultMap=&quot;GoodsResultMap&quot; parameterType=&quot;Goods&quot;&gt; &lt;!-- 这里给c.name使用别名cname，因为g中也name列，会重复 --&gt; select g.*, c.name cname from shop_goods g, shop_category c where g.categoryId = c.id &lt;!-- parameterType单一的情况下，就是只有goods或者只有string，(不是hashmap或者list等)， 查询时不需要加所属名字的，比如goods.name --&gt; &lt;if test=&quot;categoryId != null and categoryId!= &apos;&apos; &quot;&gt; and g.categoryId = #&#123;categoryId&#125; &lt;/if&gt; &lt;if test=&quot;name != null and name != &apos;&apos; &quot;&gt; &lt;!-- 模糊查询，1.要用bind 将查询的东西与页面的显示联系起来 --&gt; &lt;bind name=&quot;name&quot; value=&quot;&apos;%&apos; + name + &apos;%&apos;&quot; /&gt; &lt;!-- 模糊查询，2.like关键字模糊查询 --&gt; and g.name like #&#123;name&#125; &lt;/if&gt;&lt;/select&gt; parameterType是hashmap，含有多种不同类型的值，一定要加上key值，才能取出，比如goods.categoryId,mybatis直接会用hashmap中的get/set得到key值，然后在用key中的get/set方法得到属性值 hashmap中放多种key时，注意判断key是否为空，否则报错source is null for getProperty(null, &quot;categoryId&quot;) bind实现模糊查询:模糊查询 12345678910111213141516171819202122&lt;select id=&quot;listGoodsByPage&quot; parameterType=&quot;hashmap&quot; resultMap=&quot;GoodsResultMap&quot;&gt; select g.*, c.name cname from shop_goods g, shop_category c where g.categoryId = c.id &lt;!-- 一定要判断goods是否为空，否则会报错 source is null for getProperty(null, &quot;categoryId&quot;) --&gt; &lt;if test=&quot;goods != null&quot;&gt; &lt;!-- parameterType为hashmap的情况下，查询时一定要加key的名字，比如goods.name --&gt; &lt;if test=&quot;goods.categoryId != null and goods.categoryId!= &apos;&apos; &quot;&gt; and g.categoryId = #&#123;goods.categoryId&#125; &lt;/if&gt; &lt;!-- 这里要指出key值，因为hashmap中放了多个值，比如goods.name --&gt; &lt;if test=&quot;goods.name != null and goods.name != &apos;&apos; &quot;&gt; &lt;!-- 模糊查询，1.要用bind 将查询的东西与页面的显示联系起来 --&gt; &lt;bind name=&quot;goods.name&quot; value=&quot;&apos;%&apos; + goods.name + &apos;%&apos;&quot; /&gt; &lt;!-- 模糊查询，2.like关键字模糊查询 --&gt; and g.name like #&#123;goods.name&#125; &lt;/if&gt; &lt;/if&gt; ORDER BY id LIMIT #&#123;pageNo&#125;, #&#123;pageSize&#125;&lt;/select&gt; struts2 相关struts2 文件上传struts upload 123456789101112131415161718192021222324252627282930313233343536373839404142// 上传头像// struts2对于文件上传已经规定好了属性// setX(File file),setXFileName(String fileName),setXContentType(String contentType)private File avatar;private String avatarFileName;// 上传用户头像public String uploadAvatar() &#123; String userId = ((User) ActionContext.getContext().getSession() .get(\"user\")).getId(); // 得到文件存放的绝对地址 String path = ServletActionContext.getServletContext().getRealPath( \"/userAvatars\"); System.out.println(path); if (avatar != null) &#123; // 得到才上传文件的后缀名 String suffix = avatarFileName.substring(avatarFileName .lastIndexOf(\".\")); System.out.println(userId + suffix); // 得到新的文件，与上传文件相同，文件名是id+后缀名 File saveFile = new File(new File(path), userId + suffix); try &#123; if (!saveFile.getParentFile().exists()) &#123; saveFile.getParentFile().mkdir(); &#125; // 把上传文件拷贝到服务器端/avatar FileUtils.copyFile(avatar, saveFile); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; // 存放到数据库中 userService.upadteAvatar(userId, \"userAvatars/\" + userId + suffix); // 更新session ((User) ActionContext.getContext().getSession().get(\"user\")) .setAvatar(\"userAvatars/\" + userId + suffix); return \"usercenter\"; &#125; return path;&#125; struts得到界面的值jsp中有captcha，要去后台验证是否正确12&lt;td&gt;&lt;input style=&quot;width:85px&quot; type=&apos;text&apos; class=&apos;normal&apos; name=&apos;captcha&apos; /&gt;&lt;label&gt;填写下图所示字符&lt;/label&gt;&lt;/td&gt; 在action中可以直接定义该属性，要保持名字一致，并且使用set/get方法12345678private String captcha;public String getCaptcha() &#123; return captcha;&#125;public void setCaptcha(String captcha) &#123; this.captcha = captcha;&#125; strut2 验证码注意将BufferedImage转化为ByteArrayInputStream，才能在前端显示出来RandomAction.java后台验证123456789101112131415161718192021222324252627public class RandomAction &#123; private ByteArrayInputStream image; public String execute()&#123; RandomUtils randomUtils = RandomUtils.Instance(); //验证码的图片 image = randomUtils.getImage(); //把验证码放入session中 ActionContext.getContext().getSession().put(&quot;vcode&quot;, randomUtils.getString()); System.out.println(&quot;vcode&quot;+randomUtils.getString()); System.out.println(&quot;session&quot;+ActionContext.getContext().getSession().get(&quot;vcode&quot;) .toString()); return &quot;success&quot;; &#125; public ByteArrayInputStream getImage() &#123; return image; &#125; public void setImage(ByteArrayInputStream image) &#123; this.image = image; &#125; &#125; RandomUtils.java产生验证码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class RandomUtils &#123; // public static final char[] CHARS = &#123; &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, // &apos;9&apos;, &apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;, &apos;H&apos;, &apos;J&apos;, &apos;K&apos;, &apos;L&apos;, &apos;M&apos;, // &apos;N&apos;, &apos;P&apos;, &apos;Q&apos;, &apos;R&apos;, &apos;S&apos;, &apos;T&apos;, &apos;U&apos;, &apos;V&apos;, &apos;W&apos;, &apos;X&apos;, &apos;Y&apos;, &apos;Z&apos; &#125;; public static final char[] CHARS = &#123; &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &#125;; private ByteArrayInputStream image;// 图像 private String str;// 验证码 private RandomUtils() &#123; init();// 初始化属性 &#125; public static RandomUtils Instance() &#123; return new RandomUtils(); &#125; /* * 取得验证码图片 */ public ByteArrayInputStream getImage() &#123; return this.image; &#125; /* * 取得图片的验证码 */ public String getString() &#123; return this.str; &#125; private void init() &#123; // 在内存中创建图象 int width = 85, height = 20; BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); // 获取图形上下文 Graphics g = image.getGraphics(); // 生成随机类 Random random = new Random(); // 设定背景色 g.setColor(getRandColor(200, 250)); g.fillRect(0, 0, width, height); // 设定字体 g.setFont(new Font(&quot;Times New Roman&quot;, Font.PLAIN, 18)); // 随机产生155条干扰线，使图象中的认证码不易被其它程序探测到 g.setColor(getRandColor(160, 200)); for (int i = 0; i &lt; 155; i++) &#123; int x = random.nextInt(width); int y = random.nextInt(height); int xl = random.nextInt(12); int yl = random.nextInt(12); g.drawLine(x, y, x + xl, y + yl); &#125; // 取随机产生的认证码(6位数字) StringBuffer sRand = new StringBuffer(); for (int i = 0; i &lt; 6; i++) &#123; String rand = String.valueOf(CHARS[random.nextInt(CHARS.length)]); sRand.append(rand); // 将认证码显示到图象中 g.setColor(new Color(20 + random.nextInt(110), 20 + random .nextInt(110), 20 + random.nextInt(110))); // 调用函数出来的颜色相同，可能是因为种子太接近，所以只能直接生成 g.drawString(rand, 13 * i + 6, 16); &#125; // 赋值验证码 this.str = sRand.toString(); // 图象生效 g.dispose(); ByteArrayInputStream input = null; ByteArrayOutputStream output = new ByteArrayOutputStream(); try &#123; ImageOutputStream imageOut = ImageIO .createImageOutputStream(output); ImageIO.write(image, &quot;JPEG&quot;, imageOut); imageOut.close(); input = new ByteArrayInputStream(output.toByteArray()); &#125; catch (Exception e) &#123; System.out.println(&quot;验证码图片产生出现错误：&quot; + e.toString()); &#125; this.image = input;/* 赋值图像 */ &#125; /* * 给定范围获得随机颜色 */ private Color getRandColor(int fc, int bc) &#123; Random random = new Random(); if (fc &gt; 255) fc = 255; if (bc &gt; 255) bc = 255; int r = fc + random.nextInt(bc - fc); int g = fc + random.nextInt(bc - fc); int b = fc + random.nextInt(bc - fc); return new Color(r, g, b); &#125;&#125; 前端显示12345&lt;tr&gt; &lt;th valign=&quot;middle&quot;&gt;验证码：&lt;/th&gt; &lt;td&gt;&lt;input style=&quot;width:85px&quot; type=&apos;text&apos; class=&apos;normal&apos; name=&apos;captcha&apos; /&gt; &lt;label&gt;填写下图所示字符&lt;/label&gt;&lt;/td&gt;&lt;/tr&gt; 跳转redirectAction直接跳转到action中1234&lt;action name=&quot;address_*&quot; class=&quot;addressAction&quot; method=&quot;&#123;1&#125;&quot;&gt; &lt;result name=&quot;oprsuc&quot; type=&quot;redirectAction&quot;&gt;address_list&lt;/result&gt; &lt;result name=&quot;list&quot;&gt;/usercenter/address_list.jsp&lt;/result&gt;&lt;/action&gt; spring相关spring事务一般在service层可以操作多个dao，因此要设置事务service层，每个dao是一个对数据库的操作，下面这种2个dao一起添加的操作一定是事务123456public void addGoods(Goods goods) &#123; goods.setId(MyUntil.getID()); goodsDao.addGoods(goods); //这是类别的更新，与商品添加一起完成 categoryDao.updateGoodsNum(goods.getCategoryId(), 1);&#125; 添加c3p0，并在spring的xml文件中配置不用添加任何其余代码就完成了事务的配置，基于AOP12345678910111213141516171819202122232425&lt;!-- 添加事务的dataSource --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql://localhost:3306/shoppingsite&quot;&gt;&lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;mysql&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- REQUIRED表示不是事务就建立事务 --&gt; &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;!--SUPPORTS不是事务就不建立 --&gt; &lt;tx:method name=&quot;get*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot; /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt;&lt;!-- 包名一定要写清楚，对应好 com.dy.shoppingSite.*.*(..)这个就不能对应，因为shoppingSite.*是包，也就没有方法--&gt; &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;execution(* com.dy.shoppingSite.service.impl.*.*(..))&quot; /&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pointcut&quot; /&gt;&lt;/aop:config&gt; jspc:forEach中的varStatus&amp;el表达式计算比较等要放在括号内 c:forEach中的varStatusvarStatus有很多属性，index是序号，从0开始，也有first等more:varStatus el表达式计算比较等要放在括号内比如${string1 eq string 2}而不是${string1} eq ${string 2}1234567891011&lt;c:set var=&quot;totalMoney&quot; value=&quot;0&quot;&gt;&lt;/c:set&gt; &lt;c:forEach items=&quot;$&#123;orderDetails&#125;&quot; var=&quot;orderDetail&quot; varStatus=&quot;s&quot;&gt; &lt;tr&gt;&lt;td&gt; &lt;!-- //传递orderDetail要使用index，直接传是不成功的 --&gt; &lt;!-- 下标用s.index表示，http://www.opencms-wiki.org/wiki/C:forEach --&gt; &lt;input type=&quot;hidden&quot; name=&quot;orderDetails[$&#123;s.index &#125;].goods.id&quot; value=&quot;$&#123;orderDetail.goods.id&#125;&quot;/&gt; &lt;input type=&quot;hidden&quot; name=&quot;orderDetails[$&#123;s.index &#125;].nums&quot; value=&quot;$&#123;orderDetail.nums&#125;&quot; /&gt; &lt;b class=&quot;red2&quot;&gt;$&#123;orderDetail.nums*orderDetail.goods.price2&#125;&lt;/b&gt; &lt;/td&gt;&lt;/tr&gt; &lt;c:set var=&quot;totalMoney&quot; value=&quot;$&#123;totalMoney+orderDetail.nums*orderDetail.goods.price2&#125;&quot;/&gt;&lt;/c:forEach&gt;","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"project","slug":"project","permalink":"http://duyao.github.io/tags/project/"}]},{"title":"git心得","slug":"git心得","date":"2015-10-29T15:26:41.000Z","updated":"2015-10-30T13:38:42.000Z","comments":true,"path":"2015/10/29/git心得/","link":"","permalink":"http://duyao.github.io/2015/10/29/git心得/","excerpt":"使用git的心得","text":"使用git的心得 建库不增加contribution啊！！所以应该弄个不同文件夹每天更新contribution中每个小格子代表每一天 blog更新也不算在git-Contributions！ git 文件夹是灰色的，而且是空的因为文件中还是包含了.git，还是一个repository 本地建库，同步到远程 在本地准备好文件，确定文件家中不包含包含了.git 在远程建库，得到URL，本地git init git remote add origin [https URL] git add --all .添加所有 git commit -m &quot;message&quot;提交到缓存 git push -u origin master提交到远程，第一次添加需要加-u","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"git","slug":"git","permalink":"http://duyao.github.io/tags/git/"}]},{"title":"springMVC掉坑","slug":"springMVC掉坑","date":"2015-10-29T12:12:43.000Z","updated":"2015-10-30T12:46:08.000Z","comments":true,"path":"2015/10/29/springMVC掉坑/","link":"","permalink":"http://duyao.github.io/2015/10/29/springMVC掉坑/","excerpt":"本文记录使用springmvc时候的困惑，及解决的方法","text":"本文记录使用springmvc时候的困惑，及解决的方法 坑：web.xml文件的version开始建立项目时候新建mavenProject，此时默认的Dynamic Web Module是2.3，但是在2.4版本以下默认关闭el表达式，而且项目一般都没有src/main/java等source folder,jsp文件有错因此jsp文件中${}内容全不出现 解决建立web project可以选择Dynamic Web Module然后添加maven，上面的问题都不会出现的 坑：对应的servlet.xml不是个都叫HelloWeb-servelt.xml!!!!不是个都叫HelloWeb-servelt.xml!!!!不是个都叫HelloWeb-servelt.xml!!!!仔细看文档啊啊啊啊！！！ The web.xml file will be kept WebContent/WEB-INF directory of your web application. OK, upon initialization of [servlet-name] DispatcherServlet, the framework will try to load the application context from a file named [servlet-name]-servlet.xml located in the application’s WebContent/WEB-INF directory. servlet-name就是包名 生成项目的url是谁？建立时候时，是根据maven中的Artifact id确定项目的url因此在配置web.xml时，注意servlet名字要与Artifact id相同，且配置的[servlet]-servlet.xml要与其对应也就是上面的问题","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"springMVC","slug":"springMVC","permalink":"http://duyao.github.io/tags/springMVC/"}]},{"title":"3.3","slug":"3.3","date":"2015-10-28T14:29:32.000Z","updated":"2015-10-29T13:07:40.000Z","comments":true,"path":"2015/10/28/3.3/","link":"","permalink":"http://duyao.github.io/2015/10/28/3.3/","excerpt":"#统计完全二叉树的节点数题目给定一棵完全二叉树的头节点head，返回这棵树的节点个数。如果完全二叉树的节点数为N，请实现时间复杂度低于O(N)的解法。","text":"#统计完全二叉树的节点数题目给定一棵完全二叉树的头节点head，返回这棵树的节点个数。如果完全二叉树的节点数为N，请实现时间复杂度低于O(N)的解法。","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"3.2","slug":"3.2","date":"2015-10-28T13:38:23.000Z","updated":"2015-10-29T01:14:44.000Z","comments":true,"path":"2015/10/28/3.2/","link":"","permalink":"http://duyao.github.io/2015/10/28/3.2/","excerpt":"数组中子数组的最大累乘积题目给定一个double类型的数组arr，其中的元素可正可负可0，返回子数组累乘的最大乘积。例如arr=[-2.5，4，0，3，0.5，8，-1]，子数组[3，0.5，8]累乘可以获得最大的乘积12，所以返回12。思路子序列-&gt;前面一串决定当前位置子数组/子串(必须连续)-&gt;以当前位置结尾决定相邻后面的状态 因此，本题目必须是以当前位置结尾的位置决定后面的位置 因此本题目有3中决策 max[i]*a[i+1],比如{1,2,3,4} min[i]*a[i+1],比如{-5,2,-5} a[i+1],比如{0,0,100}值得注意的是此题目求的是最大值，但是必须记录最小值，因为乘法运算2个最小值相乘可能是最大值","text":"数组中子数组的最大累乘积题目给定一个double类型的数组arr，其中的元素可正可负可0，返回子数组累乘的最大乘积。例如arr=[-2.5，4，0，3，0.5，8，-1]，子数组[3，0.5，8]累乘可以获得最大的乘积12，所以返回12。思路子序列-&gt;前面一串决定当前位置子数组/子串(必须连续)-&gt;以当前位置结尾决定相邻后面的状态 因此，本题目必须是以当前位置结尾的位置决定后面的位置 因此本题目有3中决策 max[i]*a[i+1],比如{1,2,3,4} min[i]*a[i+1],比如{-5,2,-5} a[i+1],比如{0,0,100}值得注意的是此题目求的是最大值，但是必须记录最小值，因为乘法运算2个最小值相乘可能是最大值 代码12","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"3.1","slug":"3.1","date":"2015-10-28T00:02:41.000Z","updated":"2015-10-29T01:18:34.000Z","comments":true,"path":"2015/10/28/3.1/","link":"","permalink":"http://duyao.github.io/2015/10/28/3.1/","excerpt":"#局部最小 定义局部最小的概念。arr长度为1时，arr[0]是局部最小。arr的长度为N(N&gt;1)时，如果arr[0]&lt;arr[1]，那么arr[0]是局部最小；如果arr[N-1]&lt;arr[N-2]，那么arr[N-1]是局部最小；如果0&lt;i&lt;N-1，既有arr[i]&lt;arr[i-1]又有arr[i]&lt;arr[i+1]，那么arr[i]是局部最小。给定无序数组arr，已知arr中任意两个相邻的数都不相等，写一个函数，只需返回arr中任意一个局部最小出现的位置即可。","text":"#局部最小 定义局部最小的概念。arr长度为1时，arr[0]是局部最小。arr的长度为N(N&gt;1)时，如果arr[0]&lt;arr[1]，那么arr[0]是局部最小；如果arr[N-1]&lt;arr[N-2]，那么arr[N-1]是局部最小；如果0&lt;i&lt;N-1，既有arr[i]&lt;arr[i-1]又有arr[i]&lt;arr[i+1]，那么arr[i]是局部最小。给定无序数组arr，已知arr中任意两个相邻的数都不相等，写一个函数，只需返回arr中任意一个局部最小出现的位置即可。 思路 比较图 如图所示，当不满足arr[0]和arr[n-1]是局部最小时，必有arr[0]&gt;arr[1]和arr[N-2]&lt;arr[N-1]因此其中必有局部最小 对于任意位置k，0&lt;k&lt;N-1 若arr[k] &gt; arr[k+1],结合arr[N-2]&lt;arr[N-1]则在k+1到n-2位置必有局部最小 若arr[k-1] &lt; arr[k],结合则arr[0]&gt;arr[1]在1到k-1位置必有局部最小 因此便可以用二分解出 代码123456789101112131415161718192021222324public int find(int []a)&#123; if(a[0] &lt; a[1] || a.length == 1)&#123; return 0; &#125;else if(a[a.length-2] &gt; a[a.length-1])&#123; return a.length-1; &#125;else&#123; int mid = 0; int left = 1; int right = a.length-2; while(left &lt; right)&#123; mid = (left + right)/2; if(a[mid-1] &lt; a[mid])&#123; right = mid-1; &#125;else if(a[mid] &gt; a[mid+1])&#123; left = mid+1; &#125;else&#123; //m-1&gt;=m&lt;=m+1,显然m是局部最小 return mid; &#125; &#125; //return left是什么鬼？！ return mid; &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"2.5","slug":"2.5","date":"2015-10-27T14:16:42.000Z","updated":"2015-10-29T01:14:26.000Z","comments":true,"path":"2015/10/27/2.5/","link":"","permalink":"http://duyao.github.io/2015/10/27/2.5/","excerpt":"现在有一种新的二叉树节点类型如下：123456789public class Node &#123; public int value; public Node left; public Node right; public Node parent; public Node(int data) &#123; this.value = data; &#125;&#125; 该结构比普通二叉树节点结构多了一条指向父节点的parent指针。假设有一棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确的指向自己的父节点，头节点的parent指向null。只给一个在二叉树中的某个节点node，请实现返回node的后继节点的函数。在二叉树的中序遍历的序列中，node的下一个节点叫做node的后继节点。例如，下图的二叉树：1234567 __________6__________ / \\ ___3___ ___9___ / \\ / \\1__ 4__ __8 10 \\ \\ / 2 5 7 中序遍历的结果为：1，2，3，4，5，6，7，8，9，10所以节点1的后继为节点2，节点2的后继为节点3，…，节点10的后继为null","text":"现在有一种新的二叉树节点类型如下：123456789public class Node &#123; public int value; public Node left; public Node right; public Node parent; public Node(int data) &#123; this.value = data; &#125;&#125; 该结构比普通二叉树节点结构多了一条指向父节点的parent指针。假设有一棵Node类型的节点组成的二叉树，树中每个节点的parent指针都正确的指向自己的父节点，头节点的parent指向null。只给一个在二叉树中的某个节点node，请实现返回node的后继节点的函数。在二叉树的中序遍历的序列中，node的下一个节点叫做node的后继节点。例如，下图的二叉树：1234567 __________6__________ / \\ ___3___ ___9___ / \\ / \\1__ 4__ __8 10 \\ \\ / 2 5 7 中序遍历的结果为：1，2，3，4，5，6，7，8，9，10所以节点1的后继为节点2，节点2的后继为节点3，…，节点10的后继为null 思路代码1234567891011121314151617181920212223242526272829303132333435363738394041public int find(Node node)&#123; //叶子节点 if(node.left == null &amp;&amp; node.right == null )&#123; //找parent到parent的右孩子不是自己或者不存在 return parent(node); &#125;else&#123; //非叶子结点 if(node.left !=null)&#123; //右孩子存在，返回右孩子的最左 return left(node.right); &#125;else&#123; //右孩子 不存在，返回parent return node.parent.value; &#125; &#125; &#125; public int left(Node node)&#123; //找左孩子 while(node.left != null)&#123; left(node.left); &#125; return node.value; &#125; public int parent(Node node)&#123; if(node.parent != null)&#123; if(node.parent.right == null)&#123; return node.parent.value; &#125;else&#123; while(node.parent.right == node)&#123; parent(node.parent); &#125; return node.parent.value; &#125; &#125;else&#123; return -1; &#125; &#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"2.4","slug":"2.4","date":"2015-10-27T11:52:41.000Z","updated":"2015-10-27T14:06:08.000Z","comments":true,"path":"2015/10/27/2.4/","link":"","permalink":"http://duyao.github.io/2015/10/27/2.4/","excerpt":"最大的leftMax与rightMax之差的绝对值给定一个长度为N(N&gt;1)的整型数组arr，可以划分成左右两个部分，左部分arr[0..K]，右部分arr[K+1..N-1]，K可以取值的范围是[1,N-2]。求这么多划分方案中，左部分中的最大值减去右部分最大值的绝对值，最大是多少？例如[2,7,3,1,1]，当左部分为[2,7]，右部分为[3,1,1]时，左部分中的最大值减去右部分最大值的绝对值为4。当左部分为[2,7,3]，右部分为[1,1]时，左部分中的最大值减去右部分最大值的绝对值为6。还有很多划分方案，但最终返回6。","text":"最大的leftMax与rightMax之差的绝对值给定一个长度为N(N&gt;1)的整型数组arr，可以划分成左右两个部分，左部分arr[0..K]，右部分arr[K+1..N-1]，K可以取值的范围是[1,N-2]。求这么多划分方案中，左部分中的最大值减去右部分最大值的绝对值，最大是多少？例如[2,7,3,1,1]，当左部分为[2,7]，右部分为[3,1,1]时，左部分中的最大值减去右部分最大值的绝对值为4。当左部分为[2,7,3]，右部分为[1,1]时，左部分中的最大值减去右部分最大值的绝对值为6。还有很多划分方案，但最终返回6。 思路一时间复杂度O(N)，额外空间复杂度O(N)。从左往右遍历数组，计算left[]表示，以当前位置结尾左边最大值从右往左遍历数组，计算right[]表示，以当前位置结尾右边最大值然后遍历这两个数组，求差值绝对值得最大值 代码123456789101112131415161718192021222324252627282930public int ans1(int []a)&#123; int leftNum = Integer.MIN_VALUE; int rightNum = Integer.MIN_VALUE; int [] left = new int[a.length]; int [] right = new int[a.length]; //找左边的最大值 for(int i = 0; i &lt; a.length; i++)&#123; if(a[i] &gt; leftNum )&#123; left[i] = a[i]; leftNum = a[i]; &#125;else&#123; left[i] = leftNum; &#125; &#125; //找右边的最大值 for(int i = a.length-1; i &gt; -1; i--)&#123; if(a[i] &gt; rightNum)&#123; rightNum = a[i]; right[i] = a[i]; &#125;else&#123; right[i] = rightNum; &#125; &#125; //对左右的最大值进行比较 int maxRes = Integer.MIN_VALUE; for(int i=0; i &lt; a.length-2; i++)&#123; maxRes = Math.max(maxRes, Math.abs(left[i] - right[i+1])); &#125; return maxRes;&#125; 思路二最优解，时间复杂度O(N)，额外空间复杂度O(1)。找出该数组的最大值，那么其中一组的最大值一定是该值，且另一组最大值应该尽量小，比如这个最大值是左侧的最大值，那么右侧选右侧的最后一个元素，才能保证差值绝对值最大 代码123456789101112public int ans2(int []a)&#123; //找到数组中的最大值 int maxNum = Integer.MIN_VALUE; for(int i=0; i &lt; a.length; i++)&#123; if(a[i] &gt; maxNum)&#123; maxNum = a[i]; &#125; &#125; //一个最大值是该数组的最大值，另一个是该组的边界的最小值 return maxNum - Math.min(a[0], a[a.length - 1]);&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"2.3","slug":"2.3","date":"2015-10-26T09:29:42.000Z","updated":"2015-10-27T12:09:22.000Z","comments":true,"path":"2015/10/26/2.3/","link":"","permalink":"http://duyao.github.io/2015/10/26/2.3/","excerpt":"题目给定一个无序数组arr，求出需要排序的最短子数组长度。例如：arr = [1，5，3，4，2，6，7]返回4，因为只有[5，3，4，2]需要排序。","text":"题目给定一个无序数组arr，求出需要排序的最短子数组长度。例如：arr = [1，5，3，4，2，6，7]返回4，因为只有[5，3，4，2]需要排序。 思路TIPS对于出现子数组,子串等连续的长度，应该想到的是以当前位置结尾的串…本题对应的是以当前位置结尾的最大最小值 可以排序，然后比较，但是这种方法最多O(log(n))下面的方面可以达到O(n) 先从前往后遍历，设第一个数为最大值，然后与当前a[i]比较，设置最大移动的坐标， 如果a[i]大，更新最大值 如果a[i]小，则最大移动坐标为i，因为在一个已经排好序的数组中，最大之后面不会出现比他小的数字 同理设置最小值和最小移动的坐标坐标之差则是需要排序的子数组长度 代码123456789101112131415161718192021222324252627282930313233public int Find(int []a)&#123; if(a.length == 1)&#123; return 0; &#125; //当前需要移动的位置 int maxIndex = 0; //当前最大值 int max = a[0]; //从前面遍历，找到最大值和需要移动的位置 for(int i = 1 ; i &lt; a.length; i++)&#123; //如果当前值小于最大值，说明要移动，因为最大值的后面不应该出现比他大的 if(max &gt; a[i])&#123; maxIndex = i; &#125;else&#123; //出现比当前最大值大的，更新最大值 max = a[i]; &#125; &#125; //当前需要移动的位置 int minIndex = a.length - 1; //当前最小值 int min = a[a.length-1]; for(int i = a.length-2 ; i &gt;= 0; i--)&#123; if( min &lt; a[i])&#123; minIndex = i; &#125;else&#123; min = a[i]; &#125; &#125; return maxIndex - minIndex + 1;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"2.2","slug":"2.2","date":"2015-10-25T14:09:49.000Z","updated":"2015-10-27T12:08:12.000Z","comments":true,"path":"2015/10/25/2.2/","link":"","permalink":"http://duyao.github.io/2015/10/25/2.2/","excerpt":"从5随机到7随机及其扩展基本题目题目给定一个等概率随机产生1~5的随机函数rand1To5如下：public int rand1To5() {return (int) (Math.random() * 5) + 1;}除此之外不能使用任何额外的随机机制，请用rand1To5实现等概率随机产生1~7的随机函数rand1To7。","text":"从5随机到7随机及其扩展基本题目题目给定一个等概率随机产生1~5的随机函数rand1To5如下：public int rand1To5() {return (int) (Math.random() * 5) + 1;}除此之外不能使用任何额外的随机机制，请用rand1To5实现等概率随机产生1~7的随机函数rand1To7。 思路插空和筛选 插空5 * (rand1To5-1) -&gt; 等概率随机产生1~20 5 (rand1To5-1) + (rand1To5-1) -&gt; 等概率随机产生0~24 ,5 (rand1To5-1)和 rand1To5-1是两个独立的函数 ( 5 * (rand1To5-1) + (rand1To5-1) )% 7 不等随机产生 0~6，产生3,2,1,0的概率更高，因为0~20等概率产生0~6，21~24又产生了0~3 这里乘以5的原因是，rand1To5产生5个数 筛选由于0~3多产生了，因此不等概率，需要筛选过程就是产生了大于20的数字，重新产生，这样，产生的每个数字都是0~20 代码123456789101112131415161718192021#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int rand1To5() &#123; //rand()%5，random0-4 //rand()%5 + 1，random1-5 return rand()%5 + 1;&#125;int rand1To7()&#123; int num; do&#123; num = 5*(rand1To5()-1)+rand1To5()-1; &#125;while(num&gt;20);//´óÓÚ20É¸Ñ¡ return num%7+1;&#125;int main()&#123; for(int i=0;i&lt;200;i++)&#123; int k =rand1To7(); printf(\"%d\\n\",k); &#125; return 0;&#125; 补充题目给定一个以p概率产生0，以1-p概率产生1的随机函数rand01p如下：public int rand01p() {// you can change p as you likedouble p = 0.83;return Math.random() &lt; p ? 0 : 1;} 除此之外不能使用任何额外的随机机制，请用rand01p实现等概率随机产生1~6的随机函数rand1To6。 思路由于产生0和1概率不等，但是产生(0,1)和(1,0)组合的概率相等，可以把这个看做是0和1然后题目就变成了用0-1产生1-6，仍然是插空和筛选 代码12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int rand01p() &#123; // you can change p as you like double p = 0.83; return rand()%2 &lt; p ? 0 : 1;&#125;int rand01()&#123; //rand 0,1 while(1)&#123; int a=rand01p(); int b=rand01p(); if(a==1 &amp;&amp; b==0)&#123; return 1; &#125;else if(a==0 &amp;&amp; b==1 )&#123; return 0; &#125; &#125; &#125;int rand0To3()&#123; return rand01()*2+rand01();&#125;int rand1To6()&#123; int a; do&#123; a = 4*rand0To3() + rand0To3(); &#125;while(a&gt;11); return a%6+1;&#125;int main()&#123; //int a = rand1ToN(10); for(int i=0;i&lt;10;i++)&#123; int ans = rand1To6(); printf(\"%d\\n\",ans); &#125; &#125; 这里是先产生0-3，再产生1-6但是按照进制的方法不知道这样子是否可以rand01()*2 *2 + rand01()*2 + rand01() —&gt; 产生0-7，然后再进行筛选 123456789101112//用01产生1-n的任何数，没看懂int rand1ToN(int n)&#123; int ans = 0; do&#123; for(int i=0;n;n &gt;&gt;= 1,i++)&#123; if(rand01() == 1)&#123; ans = (1&lt;&lt;i); &#125; &#125; &#125;while(ans &gt;= n); return ans +1;&#125; 进阶题目题目给定一个等概率随机产生1~M的随机函数rand1ToM如下：public int rand1ToM(int m) {return (int) (Math.random() * m) + 1;}除此之外不能使用任何额外的随机机制。有两个输入参数分别为m和n，请用rand1ToM(m)实现等概率随机产生1~n的随机函数rand1ToN。 思路把随机产生先化成0~m-1，然后看做是m进制的数字，看n最多能占几位，然后筛选比如，从5产生7，由于1位5进制只能表示0-4，而2位5进制能表示0-24 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public int rand1ToM(int m) &#123; return (int) (Math.random() * m) + 1;&#125;public int rand1ToN(int n, int m) &#123; int[] nMSys = getMSysNum(n - 1, m); int[] randNum = getRanMSysNumLessN(nMSys, m); return getNumFromMSysNum(randNum, m) + 1;&#125;// 把value转成m进制的数public int[] getMSysNum(int value, int m) &#123; int[] res = new int[32]; int index = res.length - 1; while (value != 0) &#123; res[index--] = value % m; value = value / m; &#125; return res;&#125;// 等概率随机产生一个0~nMsys范围上的数，只不过是m进制表达的。//没看懂！！public int[] getRanMSysNumLessN(int[] nMSys, int m) &#123; //创造一个新数，和n-1的位数相等 int[] res = new int[nMSys.length]; //下面应该是构造新数的过程 int start = 0; while (nMSys[start] == 0) &#123; start++; &#125; int index = start; //应该最后创造的数不能比n-1大的标志 boolean lastEqual = true; while (index != nMSys.length) &#123; res[index] = rand1ToM(m) - 1; if (lastEqual) &#123; if (res[index] &gt; nMSys[index]) &#123; index = start; lastEqual = true; continue; &#125; else &#123; lastEqual = res[index] == nMSys[index]; &#125; &#125; index++; &#125; return res;&#125;// 把m进制的数转成10进制public int getNumFromMSysNum(int[] mSysNum, int m) &#123; int res = 0; for (int i = 0; i != mSysNum.length; i++) &#123; res = res * m + mSysNum[i]; &#125; return res;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"1.2","slug":"1.2","date":"2015-10-25T11:02:41.000Z","updated":"2015-10-27T12:03:22.000Z","comments":true,"path":"2015/10/25/1.2/","link":"","permalink":"http://duyao.github.io/2015/10/25/1.2/","excerpt":"题目： 给定一个字符串str和str的最长回文子序列strLPS，返回字符串str在任意位置添加最少字符后，整体都是回文串的其中一种结果。例如：str = “B1G2TY34I3OPX2S1”;strLPS = “123I321”;返回：B1GS2TYXPO34I43OPXYT2SG1B注意：也可以返回B1SG2XPOTY34I43YTOPX2GS1B，总之返回一种满足条件的结果即可。","text":"题目： 给定一个字符串str和str的最长回文子序列strLPS，返回字符串str在任意位置添加最少字符后，整体都是回文串的其中一种结果。例如：str = “B1G2TY34I3OPX2S1”;strLPS = “123I321”;返回：B1GS2TYXPO34I43OPXYT2SG1B注意：也可以返回B1SG2XPOTY34I43YTOPX2GS1B，总之返回一种满足条件的结果即可。 思路这是一个剥洋葱的过程，字符串m个字符，子串n个字符，则新串工为2*(m-n)+n=2m-n在str左右同时找strLPS的每个字母，找到相同的记录下来，添加不同的值比如左1左边是B右1右边是空，故新字符串左右添加B，即B1…1B比如左2左边是GS右1右边是空,故新字符串左右添加GS,即B1GS2…2SG1B 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;string.h&gt;char str[10000];char lps[10000];int main()&#123; freopen(\"in.txt\",\"r\",stdin); while(scanf(\"%s %s\",str,lps)!=EOF)&#123; int len=2*strlen(str)-strlen(lps); char res[len]; int i=0,j=0,k=strlen(str)-1,cnt=0; while(j&lt;=k)&#123; while(str[j]!=lps[i])&#123; res[cnt++]=str[j]; j++; &#125; while(str[k]!=lps[i])&#123; res[cnt++]=str[k]; k--; &#125; res[cnt++]=lps[i++]; j++;k--; &#125; cnt--; for(int i=cnt;i&lt;len;i++)&#123; res[i]=res[--cnt]; &#125; printf(\"%s\\n\",res); &#125;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"1.1","slug":"1.1","date":"2015-10-25T07:52:49.000Z","updated":"2015-10-27T12:15:18.000Z","comments":true,"path":"2015/10/25/1.1/","link":"","permalink":"http://duyao.github.io/2015/10/25/1.1/","excerpt":"实现“之”字形打印矩阵输入一个矩阵，按照从之字形打印出每一个数字，例如，如果输入如下矩阵：1 2 3 45 6 7 89 10 11 1213 14 15 16则依次打印出数字1 5 2 3 6 9 13 10 7 4 8 11 14 15 12 16","text":"实现“之”字形打印矩阵输入一个矩阵，按照从之字形打印出每一个数字，例如，如果输入如下矩阵：1 2 3 45 6 7 89 10 11 1213 14 15 16则依次打印出数字1 5 2 3 6 9 13 10 7 4 8 11 14 15 12 16 思路可以将问题化简为按照斜线打印，然后每次打印方向遇上一次相反先给出斜线的上下顶点，打印斜线，然后移动再打印 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;stdio.h&gt;int m,n;int a[1010][1010];void zigzag(int ux,int uy,int dx,int dy,int flag)&#123; if(flag)&#123; //flag=1从下到上 for(int i=dx,j=dy;i&gt;=ux,j&lt;=uy;i--,j++)&#123; printf(\"%d \",a[i][j]); &#125; &#125;else&#123; //flag=0从上向下 for(int i=ux,j=uy;i&lt;=dx,j&gt;=dy;i++,j--)&#123; printf(\"%d \",a[i][j]); &#125; &#125; &#125;int main()&#123; freopen(\"in.txt\",\"r\",stdin); while(scanf(\"%d %d\",&amp;m,&amp;n)!=EOF)&#123; for (int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; scanf(\"%d\",&amp;a[i][j]); &#125; &#125; if(m==1)&#123; for(int i=0;i&lt;n;i++)&#123; printf(\"%d \",a[0][i]); &#125; &#125; else if(n==1)&#123; for(int i=0;i&lt;m;i++)&#123; printf(\"%d \",a[i][0]); &#125; &#125;else&#123; //给出定点坐标和方向 int flag=0; int ux=0,uy=0,dx=0,dy=0; //指出上下定点的坐标 while(ux&lt;m&amp;&amp;dy&lt;n)&#123; zigzag(ux,uy,dx,dy,flag); //flag是用来告诉方向的 flag=!flag; //上点右移，uy+，下点下移，dx+ //对于非正方形，要同时移动ux及dy uy++;dx++; if(uy&gt;=n)&#123; uy=n-1; ux++; &#125; if(dx&gt;=m)&#123; dx=m-1; dy++; &#125; &#125; &#125; printf(\"\\n\"); &#125; return 0;&#125; 顺时针打印 题目描述：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下矩阵：1 2 3 45 6 7 89 10 11 1213 14 15 16则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 输入：输入可能包含多个测试样例，对于每个测试案例，输入的第一行包括两个整数m和n(1&lt;=m,n&lt;=1000)：表示矩阵的维数为m行n列。接下来的m行，每行包括n个整数，表示矩阵的元素，其中每个元素a的取值范围为(1&lt;=a&lt;=10000)。 输出：对应每个测试案例，输出一行，按照从外向里以顺时针的顺序依次打印出每一个数字，每个数字后面都有一个空格。 样例输入：4 41 2 3 45 6 7 89 10 11 1213 14 15 16 样例输出：1 2 3 4 8 12 16 15 14 13 9 5 6 7 11 10 顺时针打印矩阵 思路可以看做是按圈打印，先打印最外圈的数字，然后打印内圈，打印的顺序都是顺时针。首先给出左上和右下的坐标，然后按照顺时针打印。打印完一圈后，左上和右下往里移动。直到两者相遇。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;int m,n;int a[1010][1010];int main()&#123; while(scanf(\"%d %d\",&amp;m,&amp;n)!=EOF)&#123; for (int i=0;i&lt;m;i++)&#123; for(int j=0;j&lt;n;j++)&#123; scanf(\"%d\",&amp;a[i][j]); &#125; &#125; //只有一行 if (m == 1)&#123; for(int i=0;i&lt;n;i++)&#123; printf(\"%d \",a[0][i]); &#125; printf(\"\\n\"); continue; &#125; //只有一列 if( n==1)&#123; for(int i=0;i&lt;m;i++)&#123; printf(\"%d \",a[i][0]); &#125; printf(\"\\n\"); continue; &#125; int ux=0,uy=0,dx=m-1,dy=n-1; while(ux&lt;=dx &amp;&amp; uy&lt;=dy )&#123; for(int j=uy;j&lt;dy;j++)&#123; printf(\"%d \",a[ux][j]); &#125; for(int i = ux;i&lt;dx; i++)&#123; printf(\"%d \",a[i][dy] ) ; &#125; for (int j=dy;j&gt;uy;j--)&#123; printf(\"%d \",a[dx][j]); &#125; for(int i=dx;i&gt;ux;i--)&#123; printf(\"%d \",a[i][uy]); &#125; ux++,uy++,dx--,dy--; &#125; printf(\"\\n\"); &#125; return 0;&#125;","categories":[{"name":"algorithm","slug":"algorithm","permalink":"http://duyao.github.io/categories/algorithm/"}],"tags":[{"name":"niuke","slug":"niuke","permalink":"http://duyao.github.io/tags/niuke/"}]},{"title":"Programmatic Transaction","slug":"Programmatic Transaction","date":"2015-10-24T13:02:27.000Z","updated":"2015-10-24T13:17:54.000Z","comments":true,"path":"2015/10/24/Programmatic Transaction/","link":"","permalink":"http://duyao.github.io/2015/10/24/Programmatic Transaction/","excerpt":"IntroductionProgrammatic transaction management approach allows you to manage the transaction with the help of programming in your source code. That gives you extreme flexibility, but it is difficult to maintain. SEE MORE: Programmatic Transaction","text":"IntroductionProgrammatic transaction management approach allows you to manage the transaction with the help of programming in your source code. That gives you extreme flexibility, but it is difficult to maintain. SEE MORE: Programmatic Transaction Declarative transaction VS Programmatic TransactionDeclarative transaction management is preferable over programmatic transaction management though it is less flexible than programmatic transaction management, which allows you to control transactions through your code. But as a kind of crosscutting concern, declarative transaction management can be modularized with the AOP approach. Spring supports declarative transaction management through the Spring AOP framework. StepsLet us use PlatformTransactionManager directly to implement programmatic approach to implement transactions. Have a instance of TransactionDefinition with the appropriate transaction attributes.For this example we will simply create an instance of DefaultTransactionDefinition to use the default transaction attributes. Once the TransactionDefinition is created, start transaction by calling getTransaction() method, which returns an instance of TransactionStatus. The TransactionStatus objects helps in tracking the current status of the transaction and finally,if everything goes fine, use commit() method of PlatformTransactionManager to commit the transaction,otherwise use rollback() to rollback the complete operation. CodeStudentJDBCTemplate_programmatic.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class StudentJDBCTemplate_programmatic implements StudentDAO &#123; private DataSource dataSource; private JdbcTemplate jdbcTemplateObject; private PlatformTransactionManager transactionManager; @Override public void setDataSource(DataSource ds) &#123; // TODO Auto-generated method stub this.dataSource = ds; this.jdbcTemplateObject = new JdbcTemplate(ds); &#125; public void setTransactionManager( PlatformTransactionManager platformTransactionManager) &#123; this.transactionManager = platformTransactionManager; &#125; @Override public void create(String name, Integer age, Integer marks, Integer year) &#123; // TODO Auto-generated method stub TransactionDefinition transactionDefinition = new DefaultTransactionDefinition(); //status can commit or rollback TransactionStatus status = this.transactionManager .getTransaction(transactionDefinition); try &#123; String SQL1 = \"insert into Student (name, age) values (?, ?)\"; jdbcTemplateObject.update(SQL1, name, age); // Get the latest student id to be used in Marks table String SQL2 = \"select max(id) from Student\"; int sid = jdbcTemplateObject.queryForObject(SQL2, Integer.class); String SQL3 = \"insert into Marks(sid, marks, year) \" + \"values (?, ?, ?)\"; jdbcTemplateObject.update(SQL3, sid, marks, year); System.out.println(\"Created Name = \" + name + \", Age = \" + age); //success transactionManager.commit(status); &#125; catch (DataAccessException e) &#123; // TODO: handle exception System.out.println(\"Error in creating record, rolling back\"); //fail transactionManager.rollback(status); throw e; &#125; &#125; @Override public List&lt;StudentMarks&gt; listStudents() &#123; String SQL = \"select * from Student, Marks where Student.id=Marks.sid\"; List&lt;StudentMarks&gt; studentMarks = jdbcTemplateObject.query(SQL, new StudentMarksMapper()); return studentMarks; &#125;&#125; applicationContext_programmatic.xml 123456789101112131415161718192021&lt;!-- don't forget the DataSource --&gt;&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/stu\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"mysql\" /&gt;&lt;/bean&gt;&lt;!-- similarly, don't forget the PlatformTransactionManager --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- this is the service object that we want to make transactional --&gt;&lt;bean id=\"studentJDBCTemplate\" class=\"com.dy.stu.StudentJDBCTemplate_programmatic\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;property name=\"transactionManager\" ref=\"transactionManager\"&gt;&lt;/property&gt;&lt;/bean&gt;","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://duyao.github.io/tags/spring/"}]},{"title":"Declarative Transaction","slug":"Declaration Transaction","date":"2015-10-24T06:48:02.000Z","updated":"2015-10-24T13:12:54.000Z","comments":true,"path":"2015/10/24/Declaration Transaction/","link":"","permalink":"http://duyao.github.io/2015/10/24/Declaration Transaction/","excerpt":"IntroductionDeclarative transaction management approach allows you to manage the transaction with the help of configuration instead of hard coding in your source code. This means that you can separate transaction management from the business code. You only use annotations or XML based configuration to manage the transactions. The bean configuration will specify the methods to be transactional. SEE MORE:Declarative Transaction","text":"IntroductionDeclarative transaction management approach allows you to manage the transaction with the help of configuration instead of hard coding in your source code. This means that you can separate transaction management from the business code. You only use annotations or XML based configuration to manage the transactions. The bean configuration will specify the methods to be transactional. SEE MORE:Declarative Transaction Declarative transaction VS Programmatic TransactionDeclarative transaction management is preferable over programmatic transaction management though it is less flexible than programmatic transaction management, which allows you to control transactions through your code. But as a kind of crosscutting concern, declarative transaction management can be modularized with the AOP approach. Spring supports declarative transaction management through the Spring AOP framework. StepsHere are the steps associated with declarative transaction: We use &lt;tx:advice /&gt; tag, which creates a transaction-handling advice and same time we define a pointcut that matches all methods we wish to make transactional and reference the transactional advice. If a method name has been included in the transactional configuration then created advice will begin the transaction before calling the method. Target method will be executed in a try / catch block. If the method finishes normally, the AOP advice commits the transaction successfully otherwise it performs a rollback. CodesStudentJDBCTemplate.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class StudentJDBCTemplate implements StudentDAO &#123; private JdbcTemplate jdbcTemplateObject; @Override public void setDataSource(DataSource ds) &#123; // TODO Auto-generated method stub this.jdbcTemplateObject = new JdbcTemplate(ds); &#125; @Override public void create(String name, Integer age, Integer marks, Integer year) &#123; try &#123; String SQL1 = \"insert into Student (name, age) values (?, ?)\"; jdbcTemplateObject.update(SQL1, name, age); // Get the latest student id to be used in Marks table String SQL2 = \"select max(id) from Student\"; int sid = jdbcTemplateObject.queryForObject(SQL2, Integer.class); String SQL3 = \"insert into Marks(sid, marks, year) \" + \"values (?, ?, ?)\"; jdbcTemplateObject.update(SQL3, sid, marks, year); System.out.println(\"Created Name = \" + name + \", Age = \" + age); // to simulate the exception. throw new RuntimeException(\"simulate Error condition\"); &#125; catch (DataAccessException e) &#123; System.out.println(\"Error in creating record, rolling back\"); throw e; &#125; &#125; @Override public List&lt;StudentMarks&gt; listStudents() &#123; //pay attention to the query sentence String SQL = \"select * from Student, Marks where Student.id=Marks.sid\"; List&lt;StudentMarks&gt; studentMarks = jdbcTemplateObject.query(SQL, new StudentMarksMapper()); return studentMarks; &#125;&#125; bean.xml 12345678910111213141516171819202122232425262728293031323334353637&lt;!-- don't forget the DataSource --&gt;&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/stu\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"mysql\" /&gt;&lt;/bean&gt;&lt;!-- similarly, don't forget the PlatformTransactionManager --&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- this is the service object that we want to make transactional --&gt;&lt;bean id=\"studentJDBCTemplate\" class=\"com.dy.stu.StudentJDBCTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt; &lt;!-- the transactional advice (what 'happens'; see the &lt;aop:advisor/&gt; bean below) --&gt;&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;!-- methods use the default transaction settings (see below) --&gt; &lt;tx:method name=\"create\" /&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt; &lt;aop:pointcut id=\"createOperation\" expression=\"execution(* com.dy.stu.StudentJDBCTemplate.create(..))\" /&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"createOperation\" /&gt;&lt;/aop:config&gt;","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://duyao.github.io/tags/spring/"}]},{"title":"Isolation","slug":"Isolation","date":"2015-10-24T01:38:22.000Z","updated":"2015-10-24T11:14:36.000Z","comments":true,"path":"2015/10/24/Isolation/","link":"","permalink":"http://duyao.github.io/2015/10/24/Isolation/","excerpt":"IsolationIntroductionIsolation is typically defined at database level as a property that defines how/when the changes made by one operation become visible to other. Isolation is one of the ACID (Atomicity, Consistency, Isolation, Durability) properties. Atomicity: A transaction should be treated as a single unit of operation which means either the entire sequence of operations is successful or unsuccessful. Consistency: This represents the consistency of the referential integrity of the database, unique primary keys in tables etc. Isolation: There may be many transactions processing with the same data set at the same time, each transaction should be isolated from others to prevent data corruption. Durability: Once a transaction has completed, the results of this transaction have to be made permanent and cannot be erased from the database due to system failure. Two-phase locking is the most common transaction concurrency control method in DBMSs, used to provide both serializability and recoverability for correctness.","text":"IsolationIntroductionIsolation is typically defined at database level as a property that defines how/when the changes made by one operation become visible to other. Isolation is one of the ACID (Atomicity, Consistency, Isolation, Durability) properties. Atomicity: A transaction should be treated as a single unit of operation which means either the entire sequence of operations is successful or unsuccessful. Consistency: This represents the consistency of the referential integrity of the database, unique primary keys in tables etc. Isolation: There may be many transactions processing with the same data set at the same time, each transaction should be isolated from others to prevent data corruption. Durability: Once a transaction has completed, the results of this transaction have to be made permanent and cannot be erased from the database due to system failure. Two-phase locking is the most common transaction concurrency control method in DBMSs, used to provide both serializability and recoverability for correctness. Isolation levelThe programmer must carefully analyze database access code to ensure that any relaxation of isolation does not cause software bugs that are difficult to find. Conversely, if higher isolation levels are used, the possibility of deadlock is increased, which also requires careful analysis and programming techniques to avoid. Serializable This is the highest isolation level. [x] read locks [x] write locks [x] range-locks Repeatable reads [x] read locks [x] write locks [ ] range-locks Read committed [ ] read locks [X] write locks [ ] range-locks Putting it in simpler words, read committed is an isolation level that guarantees that any data read is committed at the moment it is read. It simply restricts the reader from seeing any intermediate, uncommitted, ‘dirty’ read. It makes no promise whatsoever that if the transaction reissues the read, it will find the same data; data is free to change after it is read. Read uncommitted This is the lowest isolation level. [ ] read locks [ ] write locks [ ] range-locks Read phenomena Dirty readsearlier updates will always appear in a result set before later updates. Non-repeatable reads In this example, Transaction 2 commits successfully, which means that its changes to the row with id 1 should become visible. However, Transaction 1 has already seen a different value for age in that row. At the SERIALIZABLE and REPEATABLE READ isolation levels, the DBMS must return the old value for the second SELECT. At READ COMMITTED and READ UNCOMMITTED, the DBMS may return the updated value; this is a non-repeatable read. Phantom readsThis can occur when range locks are not acquired on performing a SELECT … WHERE operation. Note that Transaction 1 executed the same query twice. If the highest level of isolation were maintained, the same set of rows should be returned both times, and indeed that is what is mandated to occur in a database operating at the SQL SERIALIZABLE isolation level. However, at the lesser isolation levels, a different set of rows may be returned the second time. Summary Isolation level Dirty reads Non-repeatable reads Phantoms Read Uncommitted may occur may occur may occur Read committed - may occur may occur Repeatable Read - - may occur Serializable - - - In lock-based concurrency control, isolation level determines the duration that locks are held. “C” - Denotes that locks are held until the transaction commits. “S” - Denotes that the locks are held only during the currently executing statement. Note that if locks are released after a statement, the underlying data could be changed by another transaction before the current transaction commits, thus creating a violation. Isolation level Write Operation Read Operation Range Operation (…where…) Read Uncommitted S S S Read Committed C S S Repeatable Read C C S Serializable C C C","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"database","slug":"database","permalink":"http://duyao.github.io/tags/database/"}]},{"title":"git_md_snippet","slug":"git-md-snippet","date":"2015-10-23T14:53:25.000Z","updated":"2015-10-23T14:55:40.000Z","comments":true,"path":"2015/10/23/git-md-snippet/","link":"","permalink":"http://duyao.github.io/2015/10/23/git-md-snippet/","excerpt":"","text":"MarkdownLink(mdlink).sublime-snippet 12345678&lt;snippet&gt; &lt;content&gt;&lt;![CDATA[[$&#123;1:Display_Text&#125;]($&#123;2:http://example.com/&#125; $&#123;3:&quot;$2&quot;&#125;)]]&gt;&lt;/content&gt; &lt;tabTrigger&gt;mdlink&lt;/tabTrigger&gt; &lt;scope&gt;text.html.markdown.multimarkdown, text.html.markdown&lt;/scope&gt; &lt;description&gt;Insert Link&lt;/description&gt;&lt;/snippet&gt; MarkdownImage(mdimg).sublime-snippet 12345678&lt;snippet&gt; &lt;content&gt;&lt;![CDATA[![$&#123;1:Some_Text&#125;]($&#123;2:url_to_image&#125; $&#123;3:&quot;$1&quot;&#125;)]]&gt;&lt;/content&gt; &lt;tabTrigger&gt;mdimg&lt;/tabTrigger&gt; &lt;scope&gt;text.html.markdown.multimarkdown, text.html.markdown&lt;/scope&gt; &lt;description&gt;Insert Image&lt;/description&gt;&lt;/snippet&gt; MarkdownAnchor(mdarch).sublime-snippet 123456789&lt;snippet&gt; &lt;content&gt;&lt;![CDATA[[$&#123;1:Display_Text&#125;][$&#123;2:id&#125;]$5[$2]:$&#123;3:http://example.com/&#125; $&#123;4:&quot;$3&quot;&#125;]]&gt;&lt;/content&gt; &lt;tabTrigger&gt;mdacr&lt;/tabTrigger&gt; &lt;scope&gt;text.html.markdown.multimarkdown, text.html.markdown&lt;/scope&gt; &lt;description&gt;Link Anchor&lt;/description&gt;&lt;/snippet&gt; MarkdownFootnote(mdfn).sublime-snippet 123456789&lt;snippet&gt; &lt;content&gt;&lt;![CDATA[[^$&#123;1:Footnote&#125;]$3[^$1]:$&#123;2:Footnote_Text&#125;]]&gt;&lt;/content&gt; &lt;tabTrigger&gt;mdfn&lt;/tabTrigger&gt; &lt;scope&gt;text.html.markdown.multimarkdown, text.html.markdown&lt;/scope&gt; &lt;description&gt;Insert Footnote&lt;/description&gt;&lt;/snippet&gt;","categories":[{"name":"tools","slug":"tools","permalink":"http://duyao.github.io/categories/tools/"}],"tags":[{"name":"git","slug":"git","permalink":"http://duyao.github.io/tags/git/"}]},{"title":"spring_jdbc","slug":"spring-jdbc","date":"2015-10-23T12:11:55.000Z","updated":"2017-05-13T14:20:32.000Z","comments":true,"path":"2015/10/23/spring-jdbc/","link":"","permalink":"http://duyao.github.io/2015/10/23/spring-jdbc/","excerpt":"JdbcTemplate the central framework class that manages all the database communication and exception handling. Instances of the JdbcTemplate class are threadsafe once configured. So you can configure a single instance of a JdbcTemplate and then safely inject this shared reference into multiple DAOs. A common practice when using the JdbcTemplate class is to configure a DataSource in your Spring configuration file, and then dependency-inject that shared DataSource bean into your DAO classes, and the JdbcTemplate is created in the setter for the DataSource. reference: jdbc_spring","text":"JdbcTemplate the central framework class that manages all the database communication and exception handling. Instances of the JdbcTemplate class are threadsafe once configured. So you can configure a single instance of a JdbcTemplate and then safely inject this shared reference into multiple DAOs. A common practice when using the JdbcTemplate class is to configure a DataSource in your Spring configuration file, and then dependency-inject that shared DataSource bean into your DAO classes, and the JdbcTemplate is created in the setter for the DataSource. reference: jdbc_spring StudentJDBCTemplate.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class StudentJDBCTemplate implements StudentDao &#123; //configure a DataSource private DataSource dataSource; private JdbcTemplate jdbcTemplateObject; @Override public void setDataSource(DataSource ds) &#123; // TODO Auto-generated method stub this.dataSource = ds; this.jdbcTemplateObject = new JdbcTemplate(ds); &#125; @Override public void create(String name, Integer age) &#123; String SQL = \"insert into Student (name, age) values (?, ?)\"; jdbcTemplateObject.update(SQL, name, age); System.out.println(\"Created Record Name = \" + name + \" Age = \" + age); return; &#125; @Override public Student getStudent(Integer id) &#123; // TODO Auto-generated method stub String SQL = \"select id,name,age from student where id = ? \"; //.queryForObject(String sql, Object[] args, RowMapper&lt;Student&gt; rowMapper) //Query given SQL to create a prepared statement from SQL and a list of arguments to bind to the query, mapping a single result row to a Java object via a RowMapper Student student = jdbcTemplateObject.queryForObject(SQL, new Object[]&#123;id&#125;, new StudentMapper()); return student; &#125; @Override public List&lt;Student&gt; listStudents() &#123; String SQL = \"select * from student\"; List&lt;Student&gt; list = jdbcTemplateObject.query(SQL, new StudentMapper()); return list; &#125; @Override public void delete(Integer id) &#123; // TODO Auto-generated method stub String SQL = \"delete from Student where id = ?\"; jdbcTemplateObject.update(SQL, id); System.out.println(\"Deleted Record with ID = \" + id); return; &#125; @Override public void update(Integer id, Integer age) &#123; // TODO Auto-generated method stub String SQL = \"update Student set age = ? where id = ?\"; jdbcTemplateObject.update(SQL, age, id); System.out.println(\"Updated Record with ID = \" + id); return; &#125; public DataSource getDataSource() &#123; return dataSource; &#125;&#125; bean.xml 1234567891011&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/stu\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"mysql\"/&gt;&lt;/bean&gt;&lt;!--single instance--&gt;&lt;bean id=\"studentJDBCTemplate\" class=\"com.dy.stu.StudentJDBCTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt;&lt;/bean&gt; The SimpleJdbcCall class can be used to call a stored procedure with IN and OUT parameters. see :stored procedure","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://duyao.github.io/tags/spring/"}]},{"title":"Details in AOP","slug":"Details-in-AOP","date":"2015-10-19T14:46:51.000Z","updated":"2015-10-19T14:56:32.000Z","comments":true,"path":"2015/10/19/Details-in-AOP/","link":"","permalink":"http://duyao.github.io/2015/10/19/Details-in-AOP/","excerpt":"execution expression of pointcutSpring AOP users are likely to use the execution pointcut designator the most often. The format of an execution expression is: execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)All parts except the returning type pattern (ret-type-pattern in the snippet above), name pattern, and parameters pattern are optional. The returning type pattern determines what the return type of the method must be in order for a join point to be matched. Most frequently you will use * as the returning type pattern, which matches any return type. A fully-qualified type name will match only when the method returns the given type. The name pattern matches the method name. You can use the * wildcard as all or part of a name pattern. The parameters pattern is slightly more complex: () matches a method that takes no parameters (..) matches any number of parameters (zero or more) (*) matches a method taking one parameter of any type, (*,String) matches a method taking two parameters, the first can be of any type, the second must be a String.","text":"execution expression of pointcutSpring AOP users are likely to use the execution pointcut designator the most often. The format of an execution expression is: execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)All parts except the returning type pattern (ret-type-pattern in the snippet above), name pattern, and parameters pattern are optional. The returning type pattern determines what the return type of the method must be in order for a join point to be matched. Most frequently you will use * as the returning type pattern, which matches any return type. A fully-qualified type name will match only when the method returns the given type. The name pattern matches the method name. You can use the * wildcard as all or part of a name pattern. The parameters pattern is slightly more complex: () matches a method that takes no parameters (..) matches any number of parameters (zero or more) (*) matches a method taking one parameter of any type, (*,String) matches a method taking two parameters, the first can be of any type, the second must be a String. Some examples of common pointcut expressions are given below. the execution of any public method:execution(public * *(..)) the execution of any method with a name beginning with “set”:execution(* set*(..)) the execution of any method defined by the AccountService interface:execution(* com.xyz.service.AccountService.*(..)) the execution of any method defined in the service package:execution(* com.xyz.service.*.*(..)) the execution of any method defined in the service package or a sub-package:execution(* com.xyz.service..*.*(..)) @Around of adviceAround advice is declared using the @Around annotation. The first parameter of the advice method must be of type ProceedingJoinPoint.Within the body of the advice, calling proceed() on the ProceedingJoinPoint causes the underlying method to execute.The proceed method may also be called passing in an Object[] - the values in the array will be used as the arguments to the method execution when it proceeds. XML Schema basedbean.xml 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd\"&gt;&lt;context:component-scan base-package=\"com.dy\"&gt;&lt;/context:component-scan&gt;&lt;aop:aspectj-autoproxy/&gt;&lt;aop:config &gt; &lt;aop:aspect id=\"myLogAspect\" ref=\"logAspect\"&gt; &lt;aop:pointcut id=\"logPointCut\" expression=\"execution(* com.dy.springIOC.dao.*.add*(..)) ||execution(* com.dy.springIOC.dao.*.delete*(..)) ||execution(* com.dy.springIOC.dao.*.load*(..))\" /&gt; &lt;aop:before method=\"logStart\" pointcut-ref=\"logPointCut\"/&gt; &lt;aop:after method=\"logEnd\" pointcut-ref=\"logPointCut\"/&gt; &lt;aop:around method=\"aroundLog\" pointcut-ref=\"logPointCut\"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; &lt;/beans&gt; LogAspect.java 1234567891011121314151617181920212223@Component(\"logAspect\")@Aspect//声明这是一个切面public class LogAspect &#123; public void logStart()&#123; Logger.info(\"开始记录日志\"); &#125; public void logEnd()&#123; Logger.info(\"结束日志\"); &#125; public Object aroundLog(ProceedingJoinPoint joinPoint) throws Throwable&#123; System.out.println(\"around before\"); Object out = joinPoint.proceed(); System.out.println(\"around after\"); return out; &#125;&#125; @AspectJ basedbean.xml 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd\"&gt;&lt;context:component-scan base-package=\"com.dy\"&gt;&lt;/context:component-scan&gt;&lt;aop:aspectj-autoproxy/&gt; &lt;/beans&gt; LogAspect.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Component(\"logAspect\")@Aspect//声明这是一个切面public class LogAspect &#123; //声明@Pointcut后，后面的advice都可以使用，不用重复写 //@Pointcut返回值为void，且函数为空 @Pointcut(\"execution(* com.dy.springIOC.dao.*.add*(..))\" +\"||execution(* com.dy.springIOC.dao.*.delete*(..))\" +\"||execution(* com.dy.springIOC.dao.*.load*(..))\") public void selectAll()&#123;&#125;//signature @Before(\"selectAll()\")// @Before(\"execution(* com.dy.springIOC.dao.*.add*(..))\"// +\"||execution(* com.dy.springIOC.dao.*.delete*(..))\"// +\"||execution(* com.dy.springIOC.dao.*.load*(..))\") public void logStart()&#123; Logger.info(\"开始记录日志\"); &#125; // @After(\"execution(* com.dy.springIOC.dao.*.add*(..))\"// +\"||execution(* com.dy.springIOC.dao.*.delete*(..))\"// +\"||execution(* com.dy.springIOC.dao.*.load*(..))\") @After(\"selectAll()\") public void logEnd()&#123; Logger.info(\"结束日志\"); &#125; /** * 传入参数必须是ProceedingJoinPoint，返回值必须是Object * 执行proceed方法得到返回的对象 * @throws Throwable */ @Around(\"selectAll()\")// public void aroundLog()&#123;// Logger.info(\"around Log\");// &#125; public Object aroundLog(ProceedingJoinPoint joinPoint) throws Throwable&#123; System.out.println(\"around before\"); Object out = joinPoint.proceed(); System.out.println(\"around after\"); return out; &#125;","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://duyao.github.io/tags/spring/"}]},{"title":"words in study","slug":"words-in-study","date":"2015-10-18T14:22:04.000Z","updated":"2015-11-16T03:13:26.000Z","comments":true,"path":"2015/10/18/words-in-study/","link":"","permalink":"http://duyao.github.io/2015/10/18/words-in-study/","excerpt":"","text":"word explaination attibute syntax 语法 n. synonym 近义词 n. eliminate 排除 v. wildcard 通配符 n. boilerplate 文本，示范 n. concurrency 并发 n. comprise 包括 v. constrain 约束 v. nested 嵌套的 adj. simulate 模仿，假装 v. retrieve 检索 v.","categories":[{"name":"words","slug":"words","permalink":"http://duyao.github.io/categories/words/"}],"tags":[{"name":"words","slug":"words","permalink":"http://duyao.github.io/tags/words/"}]},{"title":"AOP_Instruction","slug":"AOP-Instruction","date":"2015-10-18T13:34:45.000Z","updated":"2015-10-19T14:53:40.000Z","comments":true,"path":"2015/10/18/AOP-Instruction/","link":"","permalink":"http://duyao.github.io/2015/10/18/AOP-Instruction/","excerpt":"","text":"cross-cutting concernsSystem services such as logging, transaction management, and security often find their way into components whose core responsibilities is something else.These system services are commonly referred to as cross-cutting concerns because they tend to cut across multiple components in a system. AOPUsing AOP, system-wide concerns blanket the components they impact. This leaves the application components to focus on their specific business functionality That’s `boilerplate code—the code that you oftenhave to write over and over again to accomplish common and otherwise simple tasks. Terms of AOP Terms Description Aspect A module which has a set of APIs providing cross-cutting requirements. For example, a logging module would be called AOP aspect for logging. An application can have any number of aspects depending on the requirement. Join point This represents a point in your application where you can plug-in AOP aspect. You can also say, it is the actual place in the application where an action will be taken using Spring AOP framework. Advice This is the actual action to be taken either before or after the method execution. This is actual piece of code that is invoked during program execution by Spring AOP framework. Pointcut This is a set of one or more joinpoints where an advice should be executed. You can specify pointcuts using expressions or patterns as we will see in our AOP examples. Types of AdviceSpring aspects can work with five kinds of advice mentioned below: Advice Description before Run advice before the a method execution. after Run advice after the a method execution regardless of its outcome. after-returning Run advice after the a method execution only if method completes successfully. after-throwing Run advice after the a method execution only if method exits by throwing an exception. around Run advice before and after the advised method is invoked.","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://duyao.github.io/tags/spring/"}]},{"title":"maven依赖","slug":"maven依赖","date":"2015-10-16T03:01:57.000Z","updated":"2015-10-16T03:06:46.000Z","comments":true,"path":"2015/10/16/maven依赖/","link":"","permalink":"http://duyao.github.io/2015/10/16/maven依赖/","excerpt":"pom.xml12345678910111213141516&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.imooc.hi&lt;/groupId&gt; &lt;artifactId&gt;hi&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 来源于dependency scpoe 依赖范围即scope标签内容There are 6 scopes available:","text":"pom.xml12345678910111213141516&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.imooc.hi&lt;/groupId&gt; &lt;artifactId&gt;hi&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 来源于dependency scpoe 依赖范围即scope标签内容There are 6 scopes available: compileThis is the default scope, used if none is specified. Compile dependencies are available in all classpaths of a project. Furthermore, those dependencies are propagated(传播) to dependent projects. providedThis is much like compile, but indicates you expect the JDK or a container to provide the dependency at runtime. For example, when building a web application for the Java Enterprise Edition, you would set the dependency on the Servlet API and related Java EE APIs to scope provided because the web container provides those classes. This scope is only available on the compilation and test classpath, and is not transitive. runtimeThis scope indicates that the dependency is not required for compilation, but is for execution. It is in the runtime and test classpaths, but not the compile classpath. JDBC is such kind. testThis scope indicates that the dependency is not required for normal use of the application, and is only available for the test compilation and execution phases.systemThis scope is similar to provided except that you have to provide the JAR which contains it explicitly. The artifact is always available and is not looked up in a repository. import (only available in Maven 2.0.9 or later)This scope is only used on a dependency of type pom in the section. It indicates that the specified POM should be replaced with the dependencies in that POM’s section. Since they are replaced, dependencies with a scope of import do not actually participate in limiting the transitivity of a dependency. 依赖传递 Excluded dependencies 排除依赖If project X depends on project Y, and project Y depends on project Z, the owner of project X can explicitly exclude project Z as a dependency, using the “exclusion” element.12345678910111213141516&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.Y&lt;/groupId&gt; &lt;artifactId&gt;Y&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;com.Z&lt;/groupId&gt; &lt;artifactId&gt;Z&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 依赖冲突 Dependency mediation “nearest definition”means that the version used will be the closest one to your project in the tree of dependencies, eg. if dependencies for A, B, and C are defined as A -&gt; B -&gt; C -&gt; D 2.0 and A -&gt; E -&gt; D 1.0, then D 1.0 will be used when building A because the path from A to D through E is shorter. You could explicitly add a dependency to D 2.0 in A to force the use of D 2.0 the first declaration winsNote that if two dependency versions are at the same depth in the dependency tree, until Maven 2.0.8 it was not defined which one would win, but since Maven 2.0.9 it’s the order in the declaration that counts: the first declaration wins. 聚合 Project Aggregation与继承 Project Inheritanceaggregation and inheritance ###聚合要点 Change the parent POMs packaging to the value pom . Specify in the parent POM the directories of its modules (children POMs) ###继承要点 Elements in the POM that are merged are the following: dependencies developers and contributors plugin lists (including reports) plugin executions with matching ids plugin configuration resources","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"maven","slug":"maven","permalink":"http://duyao.github.io/tags/maven/"}]},{"title":"jsp原理","slug":"jsp原理","date":"2015-10-16T01:48:39.000Z","updated":"2015-10-16T03:12:48.000Z","comments":true,"path":"2015/10/16/jsp原理/","link":"","permalink":"http://duyao.github.io/2015/10/16/jsp原理/","excerpt":"jsp(java server page): * 运行在服务器端 * 基础是servlet，因此也是动态网页 * 是一种综合技术=html+css+javasricp+java片段+jsp标签 * jsp无需配置，修改后无需重新发布 * 访问方法：http://ip:8080/web应用名/jsp路径(路径从webRoot开始) 原理web服务器是如何调用并执行jsp页面的例如文件为myjsp.java第一次访问jsp文件，服务器会将文件翻译为servlet文件myjsp_jsp.java并编译为.class文件，在文件tomcat根目录的..\\work\\Catalina中可以找到，即D:\\Program Files\\apche\\apache-tomcat-6.0.43\\work\\Catalina\\localhost\\web应用名\\org\\apache\\jsp，然后加载到服务器内存中去，如果是第二次访问，就会直接访问内存中的实例，因此jsp也是单例的，因此第一访问jsp网站速度比较慢，以后访问速度比较快。如果某个jsp被修改了，就相当于第一次访问jsp。(web服务器有一张表记录每个jsp是否是第一次访问)注意：jsp出错后会报出翻译后servlet中的位置在该xxx_jsp.java文件中，有几分主要函数如下，其实就是servlet中的需要实现的函数init,destory,service","text":"jsp(java server page): * 运行在服务器端 * 基础是servlet，因此也是动态网页 * 是一种综合技术=html+css+javasricp+java片段+jsp标签 * jsp无需配置，修改后无需重新发布 * 访问方法：http://ip:8080/web应用名/jsp路径(路径从webRoot开始) 原理web服务器是如何调用并执行jsp页面的例如文件为myjsp.java第一次访问jsp文件，服务器会将文件翻译为servlet文件myjsp_jsp.java并编译为.class文件，在文件tomcat根目录的..\\work\\Catalina中可以找到，即D:\\Program Files\\apche\\apache-tomcat-6.0.43\\work\\Catalina\\localhost\\web应用名\\org\\apache\\jsp，然后加载到服务器内存中去，如果是第二次访问，就会直接访问内存中的实例，因此jsp也是单例的，因此第一访问jsp网站速度比较慢，以后访问速度比较快。如果某个jsp被修改了，就相当于第一次访问jsp。(web服务器有一张表记录每个jsp是否是第一次访问)注意：jsp出错后会报出翻译后servlet中的位置在该xxx_jsp.java文件中，有几分主要函数如下，其实就是servlet中的需要实现的函数init,destory,service 123456789101112//myjsp_jsp.javapublic final class jsp1_jsp &#123; public void _jspInit() &#123; ... &#125; public void _jspDestroy() &#123; &#125; public void _jspService(HttpServletRequest request, HttpServletResponse response) throws java.io.IOException, ServletException &#123; ... &#125; jsp的html标签的排版空间,java代码段是如何发送到客户端的12345678910111213141516171819202122232425262728//myjsp_jsp.java的_jspService函数public void _jspService(HttpServletRequest request, HttpServletResponse response) throws java.io.IOException, ServletException &#123; PageContext pageContext = null; HttpSession session = null; ServletContext application = null; ServletConfig config = null; JspWriter out = null; Object page = this; //这里out已经设置为内部流(JspWriter out = null)，因此可以在jsp中直接使用 //html的标签直接使用out输出 out.write(\"&lt;html&gt;\\r\\n\"); out.write(\" &lt;head&gt;\\r\\n\"); out.write(\" &lt;/head&gt;\\r\\n\"); out.write(\" &lt;body&gt;\\r\\n\"); out.write(\" &lt;h1&gt;hello,world!&lt;/h1&gt;\\r\\n\"); out.write(\"&lt;/html&gt;\"); //对于内嵌的java代码则定义为内部变量,放在_jspService函数中 /*jsp中的源代码 &lt;% int i=1; out.print(\"i=\"i); %&gt; */ int i=1; out.print(\"i=\"i); web服务器调用jsp时会哪些java对象一共提供了9个，在生成的xxx_jsp.java文件中_jspService函数中可以找到 out向客户端输出字节流媒体 out.print(); request接受客户端的http请求，相当于servlet中的HttpServletRequest 12345request.getParameter(String);request.getParameterValues(String);request.getAttribute(String);request.getAttributeNames();request.getCookies(); response封装jsp产生的回应，相当于servlet的HttpServletResponse 12response.addCookie(Cookie);response.sendRedirect(String); session用于保存用户信息，跟踪用户行为，相当于servlet的HttpSession 12session.getAttribute(String);session.setAttribute(String,Object); application多个用户共享，保存信息，相当于servlet的ServletContext 12application.getAttribute(String);application.setAttribute(String,Object); pageContext只在本页面生效的域对象，可以setAttribute等 exception代表运行时的一个异常 page代表jsp这个实例，相当于this config得到web.xml的配置信息，相当于servlet的ServletConfig jsp的4个作用域 名称 作用域 application 在所有应用程序中有效 session 在当前会话中有效 request 在当前请求中有效 page 在当前页面有效 jsp语法指令元素概念：用于从jsp发送一个信息到容器，比如设置全局变量，文字编码，引入宝 page指令&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;ISO-8859-1&quot;%&gt; language=”java” 放入的语言 import=”java.util.*” 引入了哪些包 pageEncoding=”utf-8” 以什么方式翻译为servlet contentType=”text/html; charset=utf-8” 以什么方式显示网页 isErrorPage=”/err” include指令&lt;%@include file=&quot;index.jsp&quot; %&gt;该指令用于引入一个文件，jsp引擎通常会把这2个页面翻译成一个jsp页面，也成为静态引入，以webRoot为根目录被引入的jsp页面只保留page指令，标签&lt;html&gt;,&lt;body&gt;均要省略 taglib指令 脚本元素 scrplet&lt;% java代码 %&gt; 表达式相当于_jspService的变量&lt;%=java表达式%&gt;例如&lt;%=rs.getInt(1)%&gt; declaration声明相当于xxx——jsp.java的成员变量和成员函数&lt;%! java代码 %&gt;,&lt;%! java函数代码 %&gt;与表达式声明的区别是，表示声明是局部变量，declaration是全局变量而函数定义只能用在declaration中定义，不能再表达式式中定义1234&lt;%! int i=900; //全局变量 %&gt;&lt;% int i=90; //局部变量 out.print(\"i=\"+i); %&gt; 在对相应的xx_jsp.java文件中声明的位置完全不同，declaration变量时该servlet的成员变量12345678910111213//jsp1_jsp.javapublic final class jsp1_jsp &#123; int i=900;//全局变量 public void _jspInit() &#123; ... &#125; public void _jspDestroy() &#123; &#125; public void _jspService(HttpServletRequest request, HttpServletResponse response)throws java.io.IOException, ServletException &#123; int i=90;//局部变量 out.print(\"i=\"+i); ... &#125; 动作元素 &lt;jsp:forward &gt;&lt;jsp:forward page=&quot;index.jsp&quot;&gt;&lt;/jsp:forward&gt;这里起到跳转作用，通常开发时，将各种jsp文件不直接放在WebRoot中，因为这样利用&lt;a&gt;标签可以将网站源代码下载下来，而且得到路径后可以直接访问，很不安全，因此要把jsp文件放在/WebRoot/WEB-INF文件夹中，这样即使得到路径也不能直接访问和下载源码。而访问网站的方法是WebRoot放一个xxx.jsp通过&lt;jsp:forward page=&quot;/WEB-INF/xxx.jsp&quot;&gt;&lt;/jsp:forward&gt;转向/WebRoot/WEB-INF文件夹要访问的jsp文件 &lt;jsp:include &gt;&lt;jsp:include page=&quot;&quot;&gt;&lt;/jsp:include&gt;这里也是引入文件，注意与`&lt;%@include&gt;区分，但是这里的引入是动态引入，即jsp引擎会将这2个servlet分别编译形成2个java文件，因此不必省略标签&lt;html&gt;,&lt;body&gt; jsp注释2种方式&lt;-- 注释 --&gt;和&lt;%-- 注释 --%&gt;没有%的可以在源码中显示，而有%的在源码中不能显示建议使用&lt;%-- 注释 --%&gt;","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://duyao.github.io/tags/jsp/"}]},{"title":"Mybatis 接口式编程","slug":"Mybatis 接口式编程","date":"2015-10-15T15:32:10.000Z","updated":"2015-10-23T14:29:42.000Z","comments":true,"path":"2015/10/15/Mybatis 接口式编程/","link":"","permalink":"http://duyao.github.io/2015/10/15/Mybatis 接口式编程/","excerpt":"##引言首先分析MessageDao中获取sqlSession的过程12345//Command是namespace//queryCommandList是一种select方法的id//command是传入的Command类型的参数//list是该方法返回值list = sqlSession.selectList(\"Command.queryCommandList\",command); 由于以上信息都在Command.xml文件中，且都是手动填入，可能会出错。因此引入接口式编程，即把该方法写成接口形式，这样调用时会校验，减少出错。","text":"##引言首先分析MessageDao中获取sqlSession的过程12345//Command是namespace//queryCommandList是一种select方法的id//command是传入的Command类型的参数//list是该方法返回值list = sqlSession.selectList(\"Command.queryCommandList\",command); 由于以上信息都在Command.xml文件中，且都是手动填入，可能会出错。因此引入接口式编程，即把该方法写成接口形式，这样调用时会校验，减少出错。 实现-动态代理jdkProxy","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://duyao.github.io/tags/Mybatis/"}]},{"title":"Mybatis 常见问题","slug":"Mybatis 常见问题","date":"2015-10-15T12:34:22.000Z","updated":"2015-10-16T03:13:04.000Z","comments":true,"path":"2015/10/15/Mybatis 常见问题/","link":"","permalink":"http://duyao.github.io/2015/10/15/Mybatis 常见问题/","excerpt":"Mybatis 常见问题resultMap与resultType两者都是用来实现数据库与java代码的映射。 resultMap必须写指明映射关系，且要select等语句要用其id reslutType无需指明关系，映射方式是看语句的列名与java代码列名相同，且忽略大小写,内容是java的文件名123&lt;select id=\"queryMessageList\" parameterType=\"com.imooc.bean.Message\" resultType=\"com.imooc.bean.Message\"&gt; select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE&lt;/select&gt;","text":"Mybatis 常见问题resultMap与resultType两者都是用来实现数据库与java代码的映射。 resultMap必须写指明映射关系，且要select等语句要用其id reslutType无需指明关系，映射方式是看语句的列名与java代码列名相同，且忽略大小写,内容是java的文件名123&lt;select id=\"queryMessageList\" parameterType=\"com.imooc.bean.Message\" resultType=\"com.imooc.bean.Message\"&gt; select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE&lt;/select&gt; parameterMap与parameterType两者都是指定参数内容parameterMap已经废弃parameterType是指明参数类型，如果是string和java常用类型，直接写名字即可，比如int,double,string，如果是自定义和其他类型，需要写出报名，比如com.imooc.bean.Message,java.util.List 1234567&lt;delete id=\"deleteBatch\" parameterType=\"java.util.List\" &gt; delete from message where ID in ( &lt;foreach collection=\"list \" item=\"item\" separator=\",\"&gt; #&#123;item&#125; &lt;/foreach&gt; )&lt;/delete&gt; #{}与${}两者都是传入参数的#{}是带有预编译过程的，而${}没有，传进来什么就是什么12select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where ID = #&#123;id&#125;select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where ID = $&#123;id&#125; 编译后变为12select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where ID = &apos;?&apos;select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE where ID = xxx 可以看出#{}可以有预编译，防止sql注入等，而${}原样带入但是在order by语句中经常使用${}1select ID,COMMAND,DESCRIPTION,CONTENT from MESSAGE order by $&#123;id&#125; 获取自增主键的值当主键自增，添加数据需要获取主键的值时可使用时useGeneratedKeys=&quot;true&quot;表示逐渐自增和keyColumn=&quot;id&quot;表示获取id的值123&lt;insert id=&quot;insert&quot; parameterType=&quot;UserAlias&quot; useGeneratedKeys=&quot;true&quot; keyColumn=&quot;id&quot;&gt;INSERT INTO user( id,username,) VALUES ( #&#123;id&#125;,#&#123;username&#125;)&lt;/insert&gt; 中文乱码 数据库文件 Mybatis的configuration.xml文件 1&lt;property name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/wechat?useUnicode=yes&amp;characterEncoding=UTF-8\"/&gt; jsp文件 1&lt;%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"utf-8\"%&gt; servlet文件 123// 设置编码request.setCharacterEncoding(\"utf-8\");response.setContentType(\"text/html;charset=utf-8\"); Myeclipse文件编码","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://duyao.github.io/tags/Mybatis/"}]},{"title":"Mybatis 标签","slug":"Mybatis 标签","date":"2015-10-14T12:49:25.000Z","updated":"2017-05-13T14:20:58.000Z","comments":true,"path":"2015/10/14/Mybatis 标签/","link":"","permalink":"http://duyao.github.io/2015/10/14/Mybatis 标签/","excerpt":"Mybatis 标签where 标签用于处理select语句and等问题12345678&lt;select id=\"version\" parameterType=\"long\" resultType=\"int\"&gt; SELECT column1, column2, columnN FROM table_name; &lt;where&gt; &lt;if test=\"condition\"&gt; column1=#&#123;value1&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; set标签用于处理update逗号，逗号等问题，与where类似12345678&lt;update id=\"update\" parameterType=\"UserAlias\"&gt; UPDATE table_name &lt;set&gt; &lt;if test=\"condition\"&gt; column1 = #&#123;value1&#125;, column2 = #&#123;value2&#125; &lt;/if&gt; &lt;/set&gt;&lt;/update&gt; ##sql标签sql标签与select等标签同级，相当于常量定义12345&lt;sql id=\"select_content\"&gt;column1, column2, columnN&lt;/sql&gt;&lt;select id=\"version\" parameterType=\"long\" resultType=\"int\"&gt; SELECT &lt;include refid=\"select_content\"&gt;&lt;/include&gt; FROM table_name;&lt;/select&gt;","text":"Mybatis 标签where 标签用于处理select语句and等问题12345678&lt;select id=\"version\" parameterType=\"long\" resultType=\"int\"&gt; SELECT column1, column2, columnN FROM table_name; &lt;where&gt; &lt;if test=\"condition\"&gt; column1=#&#123;value1&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; set标签用于处理update逗号，逗号等问题，与where类似12345678&lt;update id=\"update\" parameterType=\"UserAlias\"&gt; UPDATE table_name &lt;set&gt; &lt;if test=\"condition\"&gt; column1 = #&#123;value1&#125;, column2 = #&#123;value2&#125; &lt;/if&gt; &lt;/set&gt;&lt;/update&gt; ##sql标签sql标签与select等标签同级，相当于常量定义12345&lt;sql id=\"select_content\"&gt;column1, column2, columnN&lt;/sql&gt;&lt;select id=\"version\" parameterType=\"long\" resultType=\"int\"&gt; SELECT &lt;include refid=\"select_content\"&gt;&lt;/include&gt; FROM table_name;&lt;/select&gt; ##trim标签灵活的代替set或者where12&lt;trim prefix=\"set\" suffixOverrides=\",\"&gt;&lt;/trim&gt;&lt;trim prefix=\"where\" prefixOverrides=\"and\"&gt;&lt;/trim&gt; ##choose标签可以当做if…else，也可以视为switch123456&lt;choose&gt; &lt;when test=\"\"&gt;&lt;/when&gt; &lt;when test=\"\"&gt;&lt;/when&gt; &lt;when test=\"\"&gt;&lt;/when&gt; &lt;otherwise&gt;&lt;/otherwise&gt; &lt;/choose&gt; ##collection与association标签collection用来展示联合查询时子表内容的association用来展示联合查询主表内容的123&lt;collection property=\"javaBean的主表名\" resultMap=\"Namespace.ResultMap的id\"/&gt;&lt;association property=\"javaBean的子表名\" resultMap=\"Namespace.ResultMap的id&gt;&lt;/association&gt; ##标签总结","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://duyao.github.io/tags/Mybatis/"}]},{"title":"Mybatis简介","slug":"Mybatis简介","date":"2015-10-10T01:45:41.000Z","updated":"2015-10-24T13:28:32.000Z","comments":true,"path":"2015/10/10/Mybatis简介/","link":"","permalink":"http://duyao.github.io/2015/10/10/Mybatis简介/","excerpt":"Mybatis主要是使用配置文件来完成操作 config.xml这里可以配置数据库的基本信息 SqlSession 作用 向sql语句传入参数 执行sql语句 获取sql语句的结果 事物的控制 如何获得SqlSession 通过配置文件获取数据库相关信息 通过信息构建SqlSessonFactory 通过SqlSessionFactory打开数据库会话","text":"Mybatis主要是使用配置文件来完成操作 config.xml这里可以配置数据库的基本信息 SqlSession 作用 向sql语句传入参数 执行sql语句 获取sql语句的结果 事物的控制 如何获得SqlSession 通过配置文件获取数据库相关信息 通过信息构建SqlSessonFactory 通过SqlSessionFactory打开数据库会话 查询的配置文件，用来对应，一个JavaBean对应一个配置文件，对应数据库中的一张表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//namespace相当于包名，是一个作用域，可以保证id不重复&lt;mapper namespace=\"User\"&gt;//resultMap的type是查询时候的类型javaBean，id随意，与下面的id重复也没有关系 &lt;resultMap type=\"UserAlias\" id=\"UserResult\"&gt; //resultMap下面包含2中类型，一个是id一个是result,两者内容是相同的 //数据库中是主键，用id，其余用result //column是数据库中的名字，jdbcType中java.sql.Type中的名字，property是javaBean中的名字 &lt;id column=\"id\" jdbcType=\"INTEGER\" property=\"id\"/&gt; &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\"/&gt; &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password.encrypted\"/&gt; &lt;result column=\"administrator\" jdbcType=\"BOOLEAN\" property=\"administrator\"/&gt; &lt;/resultMap&gt;//每个select的id都不相同，parameterType是参数的类型，resultMap对应上面的id &lt;select id=\"queryMessageList\" parameterType=\"long\" resultMap=\"UserResult\"&gt; SELECT * FROM user WHERE id = #&#123;id:INTEGER&#125; &lt;/select&gt; &lt;select id=\"version\" parameterType=\"long\" resultType=\"int\"&gt; SELECT version FROM user WHERE id = #&#123;id,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;delete id=\"delete\" parameterType=\"UserAlias\"&gt; DELETE FROM user WHERE id = #&#123;id:INTEGER&#125; &lt;/delete&gt; &lt;insert id=\"insert\" parameterType=\"UserAlias\" useGeneratedKeys=\"false\"&gt; INSERT INTO user ( id, username, password, administrator ) VALUES ( #&#123;id&#125;, #&#123;username,jdbcType=VARCHAR&#125;, #&#123;password.encrypted:VARCHAR&#125;, #&#123;administrator,jdbcType=BOOLEAN&#125; ) &lt;/insert&gt; &lt;update id=\"update\" parameterType=\"UserAlias\"&gt; UPDATE user SET username = #&#123;username,jdbcType=VARCHAR&#125;, password = #&#123;password.encrypted,jdbcType=VARCHAR&#125;, administrator = #&#123;administrator,jdbcType=BOOLEAN&#125; WHERE id = #&#123;id,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;!-- Unique constraint check --&gt; &lt;select id=\"isUniqueUsername\" parameterType=\"map\" resultType=\"boolean\"&gt; SELECT (count(*) = 0) FROM user WHERE ((#&#123;userId,jdbcType=BIGINT&#125; IS NOT NULL AND id != #&#123;userId,jdbcType=BIGINT&#125;) OR #&#123;userId,jdbcType=BIGINT&#125; IS NULL) &lt;!-- other than me --&gt; AND (username = #&#123;username,jdbcType=VARCHAR&#125;) &lt;/select&gt;&lt;/mapper&gt;","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://duyao.github.io/tags/Mybatis/"}]},{"title":"git 笔记","slug":"git使用","date":"2015-10-01T06:54:34.000Z","updated":"2015-11-12T07:26:58.000Z","comments":true,"path":"2015/10/01/git使用/","link":"","permalink":"http://duyao.github.io/2015/10/01/git使用/","excerpt":"","text":"安装及初始设置12$ git config --global user.name \"Amy\"$ git config --global user.email \"duyao_dy@163.com\" 设置邮箱及姓名 创建仓库及添加文件 切换到代码所在的目录下面 创建仓库 1git init 添加文件到仓库3.1 git add *添加所有文件 git add test.txt添加单个文件3.2 git commit -m &quot;first commit&quot;提交到stage区中 查看git statue查看工作区状态 git revert head删除","categories":[{"name":"note","slug":"note","permalink":"http://duyao.github.io/categories/note/"}],"tags":[{"name":"git","slug":"git","permalink":"http://duyao.github.io/tags/git/"}]}]}