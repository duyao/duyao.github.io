<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>juc之同步工具和并发容器 | Du Yao&#39;s blog | Make progress step by step</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="jvm">
    <meta name="description" content="同步工具http://watchmen.cn/portal.php?mod=view&amp;amp;aid=513 ReentrantLock可中断public void lockInterruptibly() throws InterruptedException调用lockInterruptibly()声明可中断 可限时public boolean tryLock()public boolean t">
<meta name="keywords" content="jvm">
<meta property="og:type" content="article">
<meta property="og:title" content="juc之同步工具和并发容器">
<meta property="og:url" content="http://duyao.github.io/2017/03/24/juc之同步工具和并发容器/index.html">
<meta property="og:site_name" content="Du Yao&#39;s blog">
<meta property="og:description" content="同步工具http://watchmen.cn/portal.php?mod=view&amp;amp;aid=513 ReentrantLock可中断public void lockInterruptibly() throws InterruptedException调用lockInterruptibly()声明可中断 可限时public boolean tryLock()public boolean t">
<meta property="og:image" content="http://7xilc8.com1.z0.glb.clouddn.com/segment.jpg">
<meta property="og:image" content="http://7xilc8.com1.z0.glb.clouddn.com/concurrenthashmapremove.png">
<meta property="og:image" content="http://7xilc8.com1.z0.glb.clouddn.com/allblockingqueue.png">
<meta property="og:updated_time" content="2017-06-17T04:17:01.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="juc之同步工具和并发容器">
<meta name="twitter:description" content="同步工具http://watchmen.cn/portal.php?mod=view&amp;amp;aid=513 ReentrantLock可中断public void lockInterruptibly() throws InterruptedException调用lockInterruptibly()声明可中断 可限时public boolean tryLock()public boolean t">
<meta name="twitter:image" content="http://7xilc8.com1.z0.glb.clouddn.com/segment.jpg">
    
        <link rel="alternative" href="/atom.xml" title="Du Yao&#39;s blog" type="application/atom+xml">
    
    <link rel="shortcut icon" href="/img/favicon.png">
    <link rel="stylesheet" href="/css/style.css?v=1.4.8">
    <script>window.lazyScripts=[]</script>
</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/yao.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Du Yao</h5>
          <a href="mailto:duyao_dy@163.com" title="duyao_dy@163.com" class="mail">duyao_dy@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/duyao" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about" target="_blank" >
                <i class="icon icon-lg icon-link"></i>
                About
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">juc之同步工具和并发容器</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">juc之同步工具和并发容器</h1>
        <h5 class="subtitle">
            
                <time datetime="2017-03-24T05:40:21.000Z" itemprop="datePublished" class="page-time">
  2017-03-24
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/note/">note</a></li></ul>

            
        </h5>
    </div>

    

</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#同步工具"><span class="post-toc-number">1.</span> <span class="post-toc-text">同步工具</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ReentrantLock"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">ReentrantLock</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可中断"><span class="post-toc-number">1.1.1.</span> <span class="post-toc-text">可中断</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可限时"><span class="post-toc-number">1.1.2.</span> <span class="post-toc-text">可限时</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#公平锁"><span class="post-toc-number">1.1.3.</span> <span class="post-toc-text">公平锁</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#可绑定条件"><span class="post-toc-number">1.1.4.</span> <span class="post-toc-text">可绑定条件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#与synchronized区别"><span class="post-toc-number">1.1.5.</span> <span class="post-toc-text">与synchronized区别</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#实现原理"><span class="post-toc-number">1.1.6.</span> <span class="post-toc-text">实现原理</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ReadWriteLock"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">ReadWriteLock</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#StampedLock"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">StampedLock</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Condition"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">Condition</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#主要方法"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">主要方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Semaphore信号量"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">Semaphore信号量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#主要接口"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">主要接口</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CountDownLatch"><span class="post-toc-number">1.5.</span> <span class="post-toc-text">CountDownLatch</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用"><span class="post-toc-number">1.5.1.</span> <span class="post-toc-text">使用</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CyclicBarrier"><span class="post-toc-number">1.6.</span> <span class="post-toc-text">CyclicBarrier</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#主要接口-1"><span class="post-toc-number">1.6.1.</span> <span class="post-toc-text">主要接口</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#区别"><span class="post-toc-number">1.6.2.</span> <span class="post-toc-text">区别</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#LockSupport"><span class="post-toc-number">1.7.</span> <span class="post-toc-text">LockSupport</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#主要接口-2"><span class="post-toc-number">1.7.1.</span> <span class="post-toc-text">主要接口</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#线程之间的通信"><span class="post-toc-number">1.8.</span> <span class="post-toc-text">线程之间的通信</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#并发容器"><span class="post-toc-number">2.</span> <span class="post-toc-text">并发容器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ConcurrentHashMap"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">ConcurrentHashMap</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#java1-7实现方法"><span class="post-toc-number">2.1.1.</span> <span class="post-toc-text">java1.7实现方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#get操作"><span class="post-toc-number">2.1.1.1.</span> <span class="post-toc-text">get操作</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#put操作"><span class="post-toc-number">2.1.1.2.</span> <span class="post-toc-text">put操作</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#remove操作"><span class="post-toc-number">2.1.1.3.</span> <span class="post-toc-text">remove操作</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#java1-8实现方法"><span class="post-toc-number">2.1.2.</span> <span class="post-toc-text">java1.8实现方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#BlockingQueue"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">BlockingQueue</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ArrayBlockingQueue"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">ArrayBlockingQueue</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Disruptor"><span class="post-toc-number">2.2.1.1.</span> <span class="post-toc-text">Disruptor</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#LinkedBlockingQueue"><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">LinkedBlockingQueue</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ConcurrentLinkedQueue"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">ConcurrentLinkedQueue</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#常见的BlockingQueue"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">常见的BlockingQueue</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#CopyOnWrite容器"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">CopyOnWrite容器</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#CopyOnWriteArrayList的实现原理"><span class="post-toc-number">2.5.1.</span> <span class="post-toc-text">CopyOnWriteArrayList的实现原理</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用场景"><span class="post-toc-number">2.5.2.</span> <span class="post-toc-text">使用场景</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#缺点"><span class="post-toc-number">2.5.3.</span> <span class="post-toc-text">缺点</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#volatile-final"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">volatile final</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#同步更新、互斥同步、非阻塞同步"><span class="post-toc-number">2.7.</span> <span class="post-toc-text">同步更新、互斥同步、非阻塞同步</span></a></li></ol></li></ol>
        </nav>
    </aside>
    
<article id="post-juc之同步工具和并发容器"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">juc之同步工具和并发容器</h1>
        <div class="post-meta">
            <time class="post-time" title="2017年03月24日 13:40" datetime="2017-03-24T05:40:21.000Z"  itemprop="datePublished">2017-03-24</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/note/">note</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="同步工具"><a href="#同步工具" class="headerlink" title="同步工具"></a>同步工具</h1><p><a href="http://watchmen.cn/portal.php?mod=view&amp;aid=513" target="_blank" rel="external">http://watchmen.cn/portal.php?mod=view&amp;aid=513</a></p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="可中断"><a href="#可中断" class="headerlink" title="可中断"></a>可中断</h3><p>public void lockInterruptibly() throws InterruptedException<br>调用<code>lockInterruptibly()</code>声明可中断</p>
<h3 id="可限时"><a href="#可限时" class="headerlink" title="可限时"></a>可限时</h3><p>public boolean tryLock()<br>public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException<br>超时不能获得锁，就返回false，不会永久等待构成死锁</p>
<h3 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h3><p>先来先得<br>public ReentrantLock(boolean fair)<br>public static ReentrantLock fairLock = new ReentrantLock(true);</p>
<h3 id="可绑定条件"><a href="#可绑定条件" class="headerlink" title="可绑定条件"></a>可绑定条件</h3><p>ReentrantLock可以和多个condition一起使用</p>
<h3 id="与synchronized区别"><a href="#与synchronized区别" class="headerlink" title="与synchronized区别"></a>与synchronized区别</h3><p>主要区别就是ReentrantLock的四个特性：可中断、可限时、公平锁、可绑定多个条件<br>synchronized比较简单，通常与一个对象相关联，悲观锁，<br>ReentrantLock更高级，但是比较复杂，可以与多个对象相关联，乐观锁<br>他们都是可重入的，synchronized子程序调用父类，不会产生死锁的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingWidget</span> <span class="keyword">extends</span> <span class="title">Widget</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(toString() + <span class="string">": calling doSomething"</span>);</div><div class="line">        <span class="keyword">super</span>.doSomething();<span class="comment">//若内置锁是不可重入的，则发生死锁</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="http://topmanopensource.iteye.com/blog/1736739" target="_blank" rel="external">http://topmanopensource.iteye.com/blog/1736739</a><br><a href="http://www.importnew.com/20472.html" target="_blank" rel="external">http://www.importnew.com/20472.html</a></p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>应用层面的锁，基本上使用java实现的，很少有很底层的东西</p>
<ul>
<li>CAS原理</li>
<li>等待队列</li>
<li>LockSupport.park();</li>
</ul>
<p>基于AQS的锁(比如ReentrantLock)原理大体是这样:<br>有一个state变量，初始值为0，假设当前线程为A,每当A获取一次锁，status++. 释放一次，status–.锁会记录当前持有的线程。<br>当A线程拥有锁的时候，status&gt;0. B线程尝试获取锁的时候会对这个status有一个CAS(0,1)的操作，尝试几次失败后就挂起线程，进入一个等待队列。<br>如果A线程恰好释放，–status==0, A线程会去唤醒等待队列中第一个线程，即刚刚进入等待队列的B线程，B线程被唤醒之后回去检查这个status的值，尝试CAS(0,1),而如果这时恰好C线程也尝试去争抢这把锁</p>
<p>非公平锁实现：<br>C直接尝试对这个status CAS(0,1)操作，并成功改变了status的值，B线程获取锁失败，再次挂起，这就是非公平锁，B在C之前尝试获取锁，而最终是C抢到了锁。<br>公平锁：<br>C发现有线程在等待队列，直接将自己进入等待队列并挂起,B获取锁</p>
<p><a href="http://www.cnblogs.com/xrq730/p/4979021.html" target="_blank" rel="external">http://www.cnblogs.com/xrq730/p/4979021.html</a><br><a href="http://www.importnew.com/19472.html" target="_blank" rel="external">http://www.importnew.com/19472.html</a><br><a href="http://blog.csdn.net/ns_code/article/details/17487337" target="_blank" rel="external">http://blog.csdn.net/ns_code/article/details/17487337</a><br><a href="https://www.zhihu.com/question/36964449/answer/69790971?utm_source=com.youdao.note&amp;utm_medium=social" target="_blank" rel="external">https://www.zhihu.com/question/36964449/answer/69790971?utm_source=com.youdao.note&amp;utm_medium=social</a><br><a href="http://www.cnblogs.com/maxmys/p/5181775.html" target="_blank" rel="external">http://www.cnblogs.com/maxmys/p/5181775.html</a></p>
<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p>条件对象：进入临界区时发现必须满足一定的条件才能执行，那么就可以使用一个条件对象管理那些已经获得锁但是不能工作的线程<br>类似于 Object.wait()和Object.notify()<br>与ReentrantLock结合使用，一个ReentrantLock可以有多个Condition，习惯上给条件对象命名为可以反应它所表达的条件的名字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public void transfer(int from, int amount)&#123;</div><div class="line">  ReentrantLock bank = new ReentrantLock();</div><div class="line">  Condition sufficient = bank.newCondition();</div><div class="line"></div><div class="line">  bank.lock();//如果使用锁就不能使用带资源的try语句</div><div class="line">  try &#123;</div><div class="line">    while(!account[from] &lt; account)&#123;</div><div class="line">      sufficient.await();//await调用必须方法while(!ok to proceed)中，阻塞线程</div><div class="line">      //transfer funds</div><div class="line"></div><div class="line">      sufficient.signalAll();//解除等待线程的阻塞</div><div class="line">  &#125;</div><div class="line">  &#125;finally &#123;</div><div class="line">    bank.lock();//解锁一定要放在finally中</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><ul>
<li><p>void await() throws InterruptedException;<br>await()方法会使当前线程等待，同时释放当前锁，当其他线程中使用signal()时或者signalAll()方法时，线程会重新获得锁并继续执行。或者当线程被中断时，也能跳出等待。这和Object.wait()方法很相似。</p>
</li>
<li><p>void awaitUninterruptibly();<br>awaitUninterruptibly()方法与await()方法基本相同，但是它并不会再等待过程中响应中断。</p>
</li>
<li><p>void signal();<br>singal()方法用于唤醒一个在等待中的线程。</p>
</li>
<li><p>void signalAll();<br>相对的singalAll()方法会唤醒所有在等待中的线程。这和Obejct.notify()方法很类似。</p>
</li>
</ul>
<p>await、signal、signalAll必须抛异常</p>
<h2 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h2><p>共享锁，运行多个线程同时临界</p>
<h3 id="主要接口"><a href="#主要接口" class="headerlink" title="主要接口"></a>主要接口</h3><p>public void acquire()<br>public void acquireUninterruptibly()<br>public boolean tryAcquire()<br>public boolean tryAcquire(long timeout, TimeUnit unit)<br>public void release()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">//只有两个信号量</span></div><div class="line">    <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</div><div class="line">    <span class="keyword">static</span> SemaphoreDemo demo = <span class="keyword">new</span> SemaphoreDemo();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">//有10个线程去抢夺</span></div><div class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">10</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">            executor.submit(demo);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">//获得</span></div><div class="line">            semaphore.acquire();</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">            System.out.println(<span class="string">"Thread "</span> + Thread.currentThread().getId() + <span class="string">" done!"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="comment">//释放</span></div><div class="line">            semaphore.release();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>倒数计时器<br>一种典型的场景就是火箭发射。在火箭发射前，为了保证万无一失，往往还要进行各项设备、仪器的检查。<br>只有等所有检查完毕后，引擎才能点火。这种场景就非常适合使用CountDownLatch。它可以使得点火线程，等待所有检查线程全部完工后，再执行</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>static final CountDownLatch end = new CountDownLatch(10);<br>end.countDown();<br>end.await();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="comment">//5个任务需要检查</span></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatch end = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> CountDownLatchDemo demo = <span class="keyword">new</span> CountDownLatchDemo();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        <span class="comment">//执行5个线程完成检查，如果没有完成，所有线程就会阻塞，等待完成</span></div><div class="line">        <span class="comment">// 所以线程的个数必须要与倒计时个数相同</span></div><div class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">5</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            executorService.submit(demo);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//等待通知</span></div><div class="line">        end.await();</div><div class="line">        System.out.println(<span class="string">"Fired"</span>);</div><div class="line">        executorService.shutdown();</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        Random r = <span class="keyword">new</span> Random();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(r.nextInt(<span class="number">5</span>) * <span class="number">1000</span>);</div><div class="line">            end.countDown();</div><div class="line">            System.out.println(<span class="string">"chenk over, remaining "</span>+end.getCount() );</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>循环栅栏<br>Cyclic意为循环，也就是说这个计数器可以反复使用。比如，假设我们将计数器设置为10。那么凑齐第一批10个线程后，计数器就会归零，然后接着凑齐下一批10个线程</p>
<h3 id="主要接口-1"><a href="#主要接口-1" class="headerlink" title="主要接口"></a>主要接口</h3><ul>
<li><p>public CyclicBarrier(int parties, Runnable barrierAction)<br>barrierAction就是当计数器一次计数完成后，系统会执行的动作，必须是实现Runnable接口</p>
</li>
<li><p>public int await() throws InterruptedException, BrokenBarrierException<br>抛出InterruptedException中断异常的目的是避免线程中断，而一直阻塞，产生永久性的异常<br>抛出BrokenBarrierException的原因是一批线程中只有凑够了个数才会执行。<br>事实上，有可能出现其中一个线程出问题，那么导致其他线程阻塞无法执行，这时候其他线程就会抛出BrokenBarrierException，表示自己永远不能执行了</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Soldier</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> String soldier;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier cyclic;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Soldier</span><span class="params">(CyclicBarrier cyclic, String soldier)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.soldier = soldier;</div><div class="line">            <span class="keyword">this</span>.cyclic = cyclic;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//复用栅栏</span></div><div class="line">                <span class="comment">//等待所有士兵到齐</span></div><div class="line">                cyclic.await();</div><div class="line">                doWork();</div><div class="line">                <span class="comment">//等待所有士兵完成工作</span></div><div class="line">                cyclic.await();</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;<span class="comment">//在等待过程中,线程被中断</span></div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;<span class="comment">//表示当前CyclicBarrier已经损坏.系统无法等到所有线程到齐了.</span></div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread.sleep(Math.abs(<span class="keyword">new</span> Random().nextInt() % <span class="number">10000</span>));</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">            System.out.println(soldier + <span class="string">":任务完成"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BarrierRun</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> flag;</div><div class="line">        <span class="keyword">int</span> N;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BarrierRun</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">int</span> N)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.flag = flag;</div><div class="line">            <span class="keyword">this</span>.N = N;</div><div class="line">        &#125;</div><div class="line"></div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">if</span> (flag) &#123;</div><div class="line">                System.out.println(<span class="string">"司令:[士兵"</span> + N + <span class="string">"个,任务完成!]"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                System.out.println(<span class="string">"司令:[士兵"</span> + N + <span class="string">"个,集合完毕!]"</span>);</div><div class="line">                flag = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10</span>;</div><div class="line">        Thread[] allSoldier = <span class="keyword">new</span> Thread[N];</div><div class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</div><div class="line">        <span class="comment">//第二个参数就是当计数器一次计数完成后，系统会执行的动作</span></div><div class="line">        CyclicBarrier cyclic = <span class="keyword">new</span> CyclicBarrier(N, <span class="keyword">new</span> BarrierRun(flag, N));</div><div class="line">        <span class="comment">//设置屏障点,主要为了执行这个方法</span></div><div class="line">        System.out.println(<span class="string">"集合队伍! "</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</div><div class="line">            System.out.println(<span class="string">"士兵"</span> + i + <span class="string">"报道! "</span>);</div><div class="line">            allSoldier[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Soldier(cyclic, <span class="string">"士兵"</span> + i));</div><div class="line">            allSoldier[i].start();</div><div class="line"></div><div class="line"><span class="comment">//            if(i == 5)&#123;</span></div><div class="line"><span class="comment">//               allSoldier[i].interrupt();</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>CyclicBarrier是支持复用的，协调的是多个线程之间的顺序，即<strong>线程之间要互相等待</strong>，比如abc分别执行任务，然后等三个都完成之后才能继续执行新的任务<br>CountDownLatch是<strong>一个线程等待其他多个线程的完成</strong></p>
<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>提供线程阻塞原语<br>与suspend()比较，不容易引起线程冻结</p>
<p>同时能够响应中断，但不抛出异常。<br>中断响应的结果是，park()函数的返回，可以从Thread.interrupted()得到中断标志</p>
<p>使用的比较底层的操作，类似于被广泛的应用在其他类的是实现中</p>
<h3 id="主要接口-2"><a href="#主要接口-2" class="headerlink" title="主要接口"></a>主要接口</h3><p>LockSupport.park();<br>LockSupport.unpark(Thread thread);</p>
<h2 id="线程之间的通信"><a href="#线程之间的通信" class="headerlink" title="线程之间的通信"></a>线程之间的通信</h2><p><a href="http://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/" target="_blank" rel="external">http://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/</a></p>
<h1 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h1><p>对于容器map、set、list等，如果要实现同步，可以使用<code>Collections.synchronizedMap(map)</code>,<code>Collections.synchronizedList(list)</code>d等方法但是这仅仅适合并发量小的情况。<br>因为在其内部，使用<code>synchronized</code>控制<code>final Object mutex</code>变量的获取。<br>每个方法在执行前，都会先获取mutex然后再执行，也就是这个map每次只能被一个线程操作，这样每个方法的执行过程相对就串行化，比如两个get完全不用获得锁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;     <span class="comment">// Backing Map</span></div><div class="line">    <span class="keyword">final</span> Object      mutex;        <span class="comment">// Object on which to synchronize</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">       <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.get(key);&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">       <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">       <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.remove(key);&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>高性能HashMap<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/segment.jpg" alt="ConcurrentHashMap" title="">
                </div>
                <div class="image-caption">ConcurrentHashMap</div>
            </figure><br>ConcurrentHashMap将hash表分为16个桶（默认值），诸如get,put,remove等常用操作只锁当前需要用到的桶。<br>试想，原来只能一个线程进入，现在却能同时16个写线程进入（写线程才需要锁定，而读线程几乎不受限制，之后会提到），并发性的提升是显而易见的。<br>更令人惊讶的是ConcurrentHashMap的读取并发，因为在<strong>读取的大多数时候都没有用到锁定，所以读取操作几乎是完全的并发操作</strong>，而<strong>写操作锁定的粒度又非常细</strong>，比起之前又更加快速（这一点在桶更多时表现得更明显些）。<br><strong>ConcurrentHashMap只有在求size等操作时才需要锁定整个表</strong></p>
<h3 id="java1-7实现方法"><a href="#java1-7实现方法" class="headerlink" title="java1.7实现方法"></a>java1.7实现方法</h3><blockquote>
<p>锁分离 (Lock Stripping)</p>
</blockquote>
<p>ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术。它使用了多个锁来控制对hash表的不同部分进行的修改。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，每个段其实就是一个小的hash table，它们有自己的锁。只要多个修改操作发生在不同的段上，它们就可以并发进行。</p>
<blockquote>
<p>不变(Immutable)和易变(Volatile)</p>
</blockquote>
<p>ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。如果使用传统的技术，如HashMap中的实现，如果允许可以在hash链的中间添加或删除元素，读操作不加锁将得到不一致的数据。ConcurrentHashMap实现技术是保证HashEntry几乎是不可变的。HashEntry代表每个hash链中的一个节点，其结构如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </div><div class="line">    <span class="keyword">final</span> K key;  </div><div class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  </div><div class="line">    <span class="keyword">volatile</span> V value;  </div><div class="line">    <span class="keyword">final</span> HashEntry&lt;K,V&gt; next;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到除了value不是final的，其它值都是final的，这意味着不能从hash链的中间或尾部添加或删除节点，因为这需要修改next引用值，所有的节点的修改只能从头部开始。对于put操作，可以一律添加到Hash链的头部。但是对于remove操作，可能需要从中间删除一个节点，这就需要将要删除节点的前面所有节点整个复制一遍，最后一个节点指向要删除结点的下一个结点。这在讲解删除操作时还会详述。为了确保读操作能够看到最新的值，将value设置成volatile，这避免了加锁。</p>
<p>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。<br>Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;  </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2249069246763182397L</span>;  </div><div class="line">     <span class="comment">/**</span></div><div class="line">      * The number of elements in this segment's region.</div><div class="line">      */  </div><div class="line">     <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count;  </div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line">      * Number of updates that alter the size of the table. This is</div><div class="line">      * used during bulk-read methods to make sure they see a</div><div class="line">      * consistent snapshot: If modCounts change during a traversal</div><div class="line">      * of segments computing size or checking containsValue, then</div><div class="line">      * we might have an inconsistent view of state so (usually)</div><div class="line">      * must retry.</div><div class="line">      */  </div><div class="line">     <span class="keyword">transient</span> <span class="keyword">int</span> modCount;  </div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line">      * The table is rehashed when its size exceeds this threshold.</div><div class="line">      * (The value of this field is always &lt;tt&gt;(int)(capacity *</div><div class="line">      * loadFactor)&lt;/tt&gt;.)</div><div class="line">      */  </div><div class="line">     <span class="keyword">transient</span> <span class="keyword">int</span> threshold;  </div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line">      * The per-segment table.</div><div class="line">      */  </div><div class="line">     <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;  </div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line">      * The load factor for the hash table.  Even though this value</div><div class="line">      * is same for all segments, it is replicated to avoid needing</div><div class="line">      * links to outer object.</div><div class="line">      * <span class="doctag">@serial</span></div><div class="line">      */  </div><div class="line">     <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
<h4 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">V <span class="title">get</span><span class="params">(Object key, <span class="keyword">int</span> hash)</span> </span>&#123;  </div><div class="line">    <span class="keyword">if</span> (count != <span class="number">0</span>) &#123; <span class="comment">// read-volatile  </span></div><div class="line">        HashEntry&lt;K,V&gt; e = getFirst(hash);  </div><div class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;  </div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;  </div><div class="line">                V v = e.value;  </div><div class="line">                <span class="keyword">if</span> (v != <span class="keyword">null</span>)  </div><div class="line">                    <span class="keyword">return</span> v;  </div><div class="line">                <span class="keyword">return</span> readValueUnderLock(e); <span class="comment">// recheck  </span></div><div class="line">            &#125;  </div><div class="line">            e = e.next;  </div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>get操作不需要锁。<br>第一步是访问count变量，这是一个volatile变量，由于所有的修改操作在进行结构修改时都会在最后一步写count变量，通过这种机制保证get操作能够得到几乎最新的结构更新。对于非结构更新，也就是结点值的改变，由于HashEntry的value变量是volatile的，也能保证读取到最新的值。<br>接下来就是对hash链进行遍历找到要获取的结点，如果没有找到，直接访回null。</p>
<p>对hash链进行遍历不需要加锁的原因在于链指针next是final的。<br>但是头指针却不是final的，这是通过getFirst(hash)方法返回，也就是存在table数组中的值。这使得getFirst(hash)可能返回过时的头结点，例如，当执行get方法时，刚执行完getFirst(hash)之后，另一个线程执行了删除操作并更新头结点，这就导致get方法中返回的头结点不是最新的。这是可以允许，通过对count变量的协调机制，get能读取到几乎最新的数据，虽然可能不是最新的。要得到最新的数据，只有采用完全的同步。</p>
<p>最后，如果找到了所求的结点，判断它的值如果非空就直接返回，否则在有锁的状态下再读一次。</p>
<h4 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function">V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;  </div><div class="line">    lock();  </div><div class="line">    <span class="keyword">try</span> &#123;  </div><div class="line">        <span class="keyword">int</span> c = count;  </div><div class="line">        <span class="keyword">if</span> (c++ &gt; threshold) <span class="comment">// ensure capacity  </span></div><div class="line">            rehash();  </div><div class="line">        HashEntry&lt;K,V&gt;[] tab = table;  </div><div class="line">        <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);  </div><div class="line">        HashEntry&lt;K,V&gt; first = tab[index];  </div><div class="line">        HashEntry&lt;K,V&gt; e = first;  </div><div class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key)))  </div><div class="line">            e = e.next;  </div><div class="line"></div><div class="line">        V oldValue;  </div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;  </div><div class="line">            oldValue = e.value;  </div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent)  </div><div class="line">                e.value = value;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">else</span> &#123;  </div><div class="line">            oldValue = <span class="keyword">null</span>;  </div><div class="line">            ++modCount;  </div><div class="line">            tab[index] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(key, hash, first, value);  </div><div class="line">            count = c; <span class="comment">// write-volatile  </span></div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> oldValue;  </div><div class="line">    &#125; <span class="keyword">finally</span> &#123;  </div><div class="line">        unlock();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法也是在持有段锁的情况下执行的，首先判断是否需要rehash，需要就先rehash。<br>接着是找是否存在同样一个key的结点，如果存在就直接替换这个结点的值。否则创建一个新的结点并添加到hash链的头部，这时一定要修改modCount和count的值，同样修改count的值一定要放在最后一步。put方法调用了rehash方法，reash方法实现得也很精巧，主要利用了table的大小为2^n，这里就不介绍了。</p>
<h4 id="remove操作"><a href="#remove操作" class="headerlink" title="remove操作"></a>remove操作</h4><p>整个操作是在持有段锁的情况下执行的，空白行之前的行主要是定位到要删除的节点e。<br>接下来，如果不存在这个节点就直接返回null，否则就要将<strong>e前面的结点复制一遍</strong>，尾结点指向e的下一个结点。<strong>e后面的结点不需要复制</strong>，它们可以重用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="function">V <span class="title">remove</span><span class="params">(Object key, <span class="keyword">int</span> hash, Object value)</span> </span>&#123;  </div><div class="line">    lock();  </div><div class="line">    <span class="keyword">try</span> &#123;  </div><div class="line">        <span class="keyword">int</span> c = count - <span class="number">1</span>;  </div><div class="line">        HashEntry&lt;K,V&gt;[] tab = table;  </div><div class="line">        <span class="keyword">int</span> index = hash &amp; (tab.length - <span class="number">1</span>);  </div><div class="line">        HashEntry&lt;K,V&gt; first = tab[index];  </div><div class="line">        HashEntry&lt;K,V&gt; e = first;  </div><div class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key)))  </div><div class="line">            e = e.next;  </div><div class="line"></div><div class="line">        V oldValue = <span class="keyword">null</span>;  </div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;  </div><div class="line">            V v = e.value;  </div><div class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span> || value.equals(v)) &#123;  </div><div class="line">                oldValue = v;  </div><div class="line">                <span class="comment">// All entries following removed node can stay  </span></div><div class="line">                <span class="comment">// in list, but all preceding ones need to be  </span></div><div class="line">                <span class="comment">// cloned.  </span></div><div class="line">                ++modCount;  </div><div class="line">                HashEntry&lt;K,V&gt; newFirst = e.next;  </div><div class="line">                <span class="comment">//复制</span></div><div class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = first; p != e; p = p.next)  </div><div class="line">                    newFirst = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(p.key, p.hash,  </div><div class="line">                                                  newFirst, p.value);  </div><div class="line">                tab[index] = newFirst;  </div><div class="line">                count = c; <span class="comment">// write-volatile  </span></div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">        <span class="keyword">return</span> oldValue;  </div><div class="line">    &#125; <span class="keyword">finally</span> &#123;  </div><div class="line">        unlock();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/concurrenthashmapremove.png" alt="remove方法" title="">
                </div>
                <div class="image-caption">remove方法</div>
            </figure>
<p>参考：</p>
<p><a href="http://www.iteye.com/topic/344876" target="_blank" rel="external">http://www.iteye.com/topic/344876</a><br><a href="http://www.infoq.com/cn/articles/ConcurrentHashMap" target="_blank" rel="external">http://www.infoq.com/cn/articles/ConcurrentHashMap</a></p>
<h3 id="java1-8实现方法"><a href="#java1-8实现方法" class="headerlink" title="java1.8实现方法"></a>java1.8实现方法</h3><p>改进一：取消segments字段，直接采用transient volatile HashEntry<k,v>[] table保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。</k,v></p>
<p>改进二：将原先table数组＋单向链表的数据结构，变更为table数组＋单向链表＋红黑树的结构。对于hash表来说，最核心的能力在于将key hash之后能均匀的分布在数组中。如果hash之后散列的很均匀，那么table数组中的每个队列长度主要为0或者1。但实际情况并非总是如此理想，虽然ConcurrentHashMap类默认的加载因子为0.75，但是在数据量过大或者运气不佳的情况下，还是会存在一些队列长度过长的情况，如果还是采用单向列表方式，那么查询某个节点的时间复杂度为O(n)；因此，对于个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)，可以改进性能。</p>
<p><a href="http://blog.csdn.net/u010412719/article/details/52145145" target="_blank" rel="external">http://blog.csdn.net/u010412719/article/details/52145145</a><br><a href="http://www.cnblogs.com/everSeeker/p/5601861.html" target="_blank" rel="external">http://www.cnblogs.com/everSeeker/p/5601861.html</a></p>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>阻塞队列，不是高性能，接口<br>可以用于生产者消费者模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue queue;</div><div class="line">  Producer(BlockingQueue q) &#123; queue = q; &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; queue.put(produce()); &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ...&#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function">Object <span class="title">produce</span><span class="params">()</span> </span>&#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue queue;</div><div class="line">  Consumer(BlockingQueue q) &#123; queue = q; &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123; consume(queue.take()); &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ...&#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">(Object x)</span> </span>&#123; ... &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Setup</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    BlockingQueue q = <span class="keyword">new</span> SomeQueueImplementation();</div><div class="line">    Producer p = <span class="keyword">new</span> Producer(q);</div><div class="line">    Consumer c1 = <span class="keyword">new</span> Consumer(q);</div><div class="line">    Consumer c2 = <span class="keyword">new</span> Consumer(q);</div><div class="line">    <span class="keyword">new</span> Thread(p).start();</div><div class="line">    <span class="keyword">new</span> Thread(c1).start();</div><div class="line">    <span class="keyword">new</span> Thread(c2).start();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>1、入队列就将尾索引往右移动一个，新元素加入尾索引的位置；<br>2、出队列就将头索引往尾索引方向移动一个，同时将旧头索引元素设为null，返回旧头索引的元素。<br>3、一旦数组已满，那么就不允许添加新元素（除非扩充容量）<br>4、如果尾索引移到了数组的最后（最大索引处），那么就从索引0开始，形成一个“闭合”的数组。<br>5、由于头索引和尾索引之间的元素都不能为空（因为为空不知道take出来的元素为空还是队列为空），所以删除一个头索引和尾索引之间的元素的话，需要移动删除索引前面或者后面的所有元素，以便填充删除索引的位置。<br>6、由于是阻塞队列，那么显然需要一个锁，另外由于只是一份数据（一个数组），所以只能有一个锁，也就是同时只能有一个线程操作队列。</p>
<p>主要通过ReentrantLock和Condition实现加锁、阻塞的功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Main lock guarding all access */</span></div><div class="line"><span class="keyword">final</span> ReentrantLock lock;</div><div class="line"><span class="comment">/** Condition for waiting takes */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</div><div class="line"><span class="comment">/** Condition for waiting puts */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</div><div class="line"><span class="comment">/** The queued items */</span></div><div class="line"><span class="keyword">final</span> Object[] items;</div></pre></td></tr></table></figure></p>
<p>put方法，先加锁，这里就证实了它并不是一个高性能容器，因为这里毫无分析的就加锁，性能一定不高<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    checkNotNull(e);</div><div class="line">    <span class="comment">//加锁</span></div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    <span class="comment">//响应阻塞</span></div><div class="line">    lock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">while</span> (count == items.length)</div><div class="line">            <span class="comment">//队列满就等待</span></div><div class="line">            notFull.await();</div><div class="line">        enqueue(e);</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      <span class="comment">//释放锁</span></div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line">* Inserts element at current put position, advances, and signals.</div><div class="line">* Call only when holding lock.</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></div><div class="line">    <span class="comment">// assert items[putIndex] == null;</span></div><div class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</div><div class="line">    items[putIndex] = x;</div><div class="line">    <span class="keyword">if</span> (++putIndex == items.length)</div><div class="line">        putIndex = <span class="number">0</span>;</div><div class="line">    count++;</div><div class="line">    <span class="comment">//通知不空</span></div><div class="line">    notEmpty.signal();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在java中可以使用BlockingQueue来实现消息队列，但是效率不是非常高，因为其内部不是无锁方式。</p>
<h4 id="Disruptor"><a href="#Disruptor" class="headerlink" title="Disruptor"></a>Disruptor</h4><p>Disruptor可以实现高性能生产者和消费者模式<br>Disruptor通过以下设计来解决队列速度慢的问题：</p>
<ul>
<li><p>环形数组结构<br>为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好。</p>
</li>
<li><p>元素位置定位<br>数组长度2^n，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。</p>
</li>
<li><p>无锁设计<br>每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据。</p>
</li>
</ul>
<p>Diruptor 页面：<a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="external">https://github.com/LMAX-Exchange/disruptor</a><br>待完成<br><a href="https://zhuanlan.zhihu.com/p/21355046" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/21355046</a><br><a href="https://www.bittiger.io/classpage/QHkP5QobvhNWGZv9f" target="_blank" rel="external">https://www.bittiger.io/classpage/QHkP5QobvhNWGZv9f</a><br><a href="http://tech.meituan.com/disruptor.html" target="_blank" rel="external">http://tech.meituan.com/disruptor.html</a></p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue有两个ReentrantLock和两个Condition以及用于AtomicInteger的count<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Current number of elements */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</div><div class="line"><span class="comment">/** Lock held by take, poll, etc */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="comment">/** Lock held by put, offer, etc */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"><span class="comment">/** Wait queue for waiting takes */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</div><div class="line"><span class="comment">/** Wait queue for waiting puts */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</div><div class="line"><span class="comment">/** Linked list node class */</span></div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E item;</div><div class="line">    Node&lt;E&gt; next;</div><div class="line">    Node(E x) &#123; item = x; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是整体上讲，LinkedBlockingQueue和ConcurrentLinkedQueue的结构类似，都是采用头尾节点，每个节点指向下一个节点的结构，这表示它们在操作上应该类似。<br>1、LinkedBlockingQueue引入了AtomicInteger的count，这意味着获取队列大小size()已经是常量时间了，不再需要遍历队列。每次队列长度有变更时只需要修改count即可。<br>2、有了修改Node指向有了锁，所以不需要volatile特性了。<br>3、引入了两个锁，一个入队列锁，一个出队列锁。当然同时有一个队列不满的Condition和一个队列不空的Condition。</p>
<p>参照锁机制的生产者-消费者模型就知道，入队列就代表生产者，出队列就代表消费者。<br>为什么需要两个锁？一个锁行不行？其实一个锁完全可以，但是一个锁意味着入队列和出队列同时只能有一个在进行，另一个必须等待其释放锁。<br>而从ConcurrentLinkedQueue的实现原理来看，事实上head和last (ConcurrentLinkedQueue中是tail)是分离的，互相独立的，这意味着入队列实际上是不会修改出队列的数据的，同时出队列也不会修改入队列，也就是说这两个操作是互不干扰的。<br>更通俗的将，这个锁相当于两个写入锁，入队列是一种写操作，操作head，出队列是一种写操作，操作tail。可见它们是无关的。但是并非完全无关，后面详细分析。</p>
<p>入队列的阻塞过程大概是这样的：<br>获取入队列的锁putLock，检测队列大小，如果队列已满，那么就挂起线程，等待队列不满信号notFull的唤醒。<br>将元素加入到队列尾部，同时修改队列尾部引用last。<br>队列大小加1。<br>释放锁putLock。<br>唤醒notEmpty线程（如果有挂起的出队列线程），告诉消费者，已经有了新的产品。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></div><div class="line">    <span class="comment">// holding count negative to indicate failure unless set.</span></div><div class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</div><div class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</div><div class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</div><div class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</div><div class="line">    putLock.lockInterruptibly();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Note that count is used in wait guard even though it is</div><div class="line">         * not protected by lock. This works because count can</div><div class="line">         * only decrease at this point (all other puts are shut</div><div class="line">         * out by lock), and we (or some other waiting put) are</div><div class="line">         * signalled if it ever changes from capacity. Similarly</div><div class="line">         * for all other uses of count in other wait guards.</div><div class="line">         */</div><div class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</div><div class="line">            notFull.await();</div><div class="line">        &#125;</div><div class="line">        enqueue(node);</div><div class="line">        c = count.getAndIncrement();</div><div class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</div><div class="line">            notFull.signal();</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        putLock.unlock();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</div><div class="line">        signalNotEmpty();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对比入队列，出队列的阻塞过程大概是这样的：</p>
<p>获取出队列的锁takeLock，检测队列大小，如果队列为空，那么就挂起线程，等待队列不为空notEmpty的唤醒。<br>将元素从头部移除，同时修改队列头部引用head。<br>队列大小减1。<br>释放锁takeLock。<br>唤醒notFull线程（如果有挂起的入队列线程），告诉生产者，现在还有空闲的空间。</p>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><blockquote>
<p>一个基于链接节点的无界线程安全队列。此队列按照 FIFO（先进先出）原则对元素进行排序。<br>队列的头部 是队列中时间最长的元素。<br>队列的尾部 是队列中时间最短的元素。<br>新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。<br>当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue 是一个恰当的选择。此队列不允许使用 null 元素。</p>
</blockquote>
<p>主要使用cas原理<br>ConcurrentLinkedQueue只有头结点、尾节点两个元素，而对于一个节点Node而言除了保存队列元素item外，还有一个指向下一个节点的引用next。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">      <span class="keyword">volatile</span> E item;</div><div class="line">      <span class="keyword">volatile</span> Node&lt;E&gt; next;</div><div class="line">      ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>1、所有结构（head/tail/item/next）都是volatile类型。 这是因为ConcurrentLinkedQueue是非阻塞的，所以只有volatile才能使变量的写操作对后续读操作是可见的（这个是有happens-before法则保证的）。同样也不会导致指令的重排序。<br>2、由于队列中任何一个节点（Node）只有下一个节点的引用，所以这个队列是单向的，根据FIFO特性，也就是说出队列在头部(head)，入队列在尾部(tail)。头部保存有进入队列最长时间的元素，尾部是最近进入的元素。<br>3、没有对队列长度进行计数，所以队列的长度是无限的，同时获取队列的长度的时间不是固定的，这<strong>需要遍历整个队列，并且这个计数也可能是不精确的</strong>。<br>4、初始情况下队列头和队列尾都指向一个空节点，但是非null，这是为了方便操作，不需要每次去判断head/tail是否为空。但是head却不作为存取元素的节点，tail在不等于head情况下保存一个节点元素。也就是说head.item这个应该一直是空，但是tail.item却不一定是空（如果head!=tail，那么tail.item!=null）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public boolean offer(E e) &#123;</div><div class="line">    checkNotNull(e);</div><div class="line">    final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e);</div><div class="line"></div><div class="line">    for (Node&lt;E&gt; t = tail, p = t;;) &#123;</div><div class="line">        Node&lt;E&gt; q = p.next;</div><div class="line">        if (q == null) &#123;</div><div class="line">            // p is last node</div><div class="line">            if (p.casNext(null, newNode)) &#123;</div><div class="line">                // Successful CAS is the linearization point</div><div class="line">                // for e to become an element of this queue,</div><div class="line">                // and for newNode to become &quot;live&quot;.</div><div class="line">                if (p != t) // hop two nodes at a time</div><div class="line">                    casTail(t, newNode);  // Failure is OK.</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">            // Lost CAS race to another thread; re-read next</div><div class="line">        &#125;</div><div class="line">        else if (p == q)</div><div class="line">            // We have fallen off list.  If tail is unchanged, it</div><div class="line">            // will also be off-list, in which case we need to</div><div class="line">            // jump to head, from which all live nodes are always</div><div class="line">            // reachable.  Else the new tail is a better bet.</div><div class="line">            p = (t != (t = tail)) ? t : head;</div><div class="line">        else</div><div class="line">            // Check for tail updates after two hops.</div><div class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="http://www.infoq.com/cn/articles/ConcurrentLinkedQueue" target="_blank" rel="external">http://www.infoq.com/cn/articles/ConcurrentLinkedQueue</a><br><a href="http://www.blogjava.net/xylz/archive/2010/07/23/326934.html" target="_blank" rel="external">http://www.blogjava.net/xylz/archive/2010/07/23/326934.html</a></p>
<h2 id="常见的BlockingQueue"><a href="#常见的BlockingQueue" class="headerlink" title="常见的BlockingQueue"></a>常见的BlockingQueue</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://7xilc8.com1.z0.glb.clouddn.com/allblockingqueue.png" alt="各种" title="">
                </div>
                <div class="image-caption">各种</div>
            </figure>
<h2 id="CopyOnWrite容器"><a href="#CopyOnWrite容器" class="headerlink" title="CopyOnWrite容器"></a>CopyOnWrite容器</h2><p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。<br>其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。<br>从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是<code>CopyOnWriteArrayList</code>和<code>CopyOnWriteArraySet</code>。<br>CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>
<p>CopyOnWrite容器即写时复制的容器。<br>通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。<br>这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<h3 id="CopyOnWriteArrayList的实现原理"><a href="#CopyOnWriteArrayList的实现原理" class="headerlink" title="CopyOnWriteArrayList的实现原理"></a>CopyOnWriteArrayList的实现原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt;</span></div><div class="line">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</div><div class="line">  <span class="comment">/** The lock protecting all mutators */</span></div><div class="line">  <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line"></div><div class="line">  <span class="comment">/** The array, accessed only via getArray/setArray. */</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ArrayList里添加元素，可以发现在添加的时候是需要加锁的，否则多线程写的时候会Copy出N个副本出来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</div><div class="line">    lock.lock();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Object[] elements = getArray();</div><div class="line">        <span class="keyword">int</span> len = elements.length;</div><div class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</div><div class="line">        newElements[len] = e;</div><div class="line">        setArray(newElements);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>读的时候不需要加锁，如果读的时候有多个线程正在向ArrayList添加数据，读还是会读到旧的数据，因为写的时候不会锁住旧的ArrayList。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">         <span class="keyword">return</span> (E) a[index];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>CopyOnWrite的应用场景</p>
<p>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，假如我们有一个搜索网站，用户在这个网站的搜索框中，输入关键字搜索内容，但是某些关键字不允许被搜索。这些不能被搜索的关键字会被放在一个黑名单当中，黑名单每天晚上更新一次。当用户搜索时，会检查当前关键字在不在黑名单当中，如果在，则提示不能搜索。</p>
<p>使用CopyOnWriteMap需要注意两件事情：<br>1.减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。<br>2.使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>CopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下。</p>
<p>内存占用问题。<br>因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存，旧的对象和新写入的对象（注意:在复制的时候只是复制容器里的引用，只是在写的时候会创建新对象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。<br>如果这些对象占用的内存比较大，比如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的Yong GC和Full GC。</p>
<p>针对内存占用问题，可以通过压缩容器中的元素的方法来减少大对象的内存消耗，比如，如果元素全是10进制的数字，可以考虑把它压缩成36进制或64进制。或者不使用CopyOnWrite容器，而使用其他的并发容器，如ConcurrentHashMap。</p>
<p>数据一致性问题。<br>CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。</p>
<p><a href="http://ifeve.com/java-copy-on-write/" target="_blank" rel="external">http://ifeve.com/java-copy-on-write/</a></p>
<h2 id="volatile-final"><a href="#volatile-final" class="headerlink" title="volatile final"></a>volatile final</h2><p>不可变一定是线程安全的</p>
<h2 id="同步更新、互斥同步、非阻塞同步"><a href="#同步更新、互斥同步、非阻塞同步" class="headerlink" title="同步更新、互斥同步、非阻塞同步"></a>同步更新、互斥同步、非阻塞同步</h2>
        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2017-06-17T04:17:01.000Z" itemprop="dateUpdated">2017年6月17日 12:17</time>
</span><br>


        转载请注明来自于:<a href="/2017/03/24/juc之同步工具和并发容器/" target="_blank" rel="external">http://duyao.github.io/2017/03/24/juc之同步工具和并发容器/</a>
    </div>
    <footer>
        <a href="http://duyao.github.io">
            <img src="/img/yao.png" alt="Du Yao">
            Du Yao
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/">jvm</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://duyao.github.io/2017/03/24/juc之同步工具和并发容器/&title=《juc之同步工具和并发容器》 — Du Yao's blog&pic=http://duyao.github.io/img/yao.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://duyao.github.io/2017/03/24/juc之同步工具和并发容器/&title=《juc之同步工具和并发容器》 — Du Yao's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://duyao.github.io/2017/03/24/juc之同步工具和并发容器/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《juc之同步工具和并发容器》 — Du Yao's blog&url=http://duyao.github.io/2017/03/24/juc之同步工具和并发容器/&via=http://duyao.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://duyao.github.io/2017/03/24/juc之同步工具和并发容器/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2017/03/25/反射和类加载/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">反射和类加载</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2017/03/22/395-Longest-Substring-with-At-Least-K-Repeating-Characters/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">395. Longest Substring with At Least K Repeating Characters</h4>
      </a>
    </div>
  
</nav>



    

<div class="comments" id="comments">
    <div class="ds-thread" data-thread-key="juc之同步工具和并发容器" data-title="juc之同步工具和并发容器" data-url="http://duyao.github.io/2017/03/24/juc之同步工具和并发容器/"></div>
</div>
<script>
lazyScripts.push('//cdn.bootcss.com/marked/0.3.6/marked.min.js');

var duoshuoQuery = {short_name:'ysblog', theme: 'none'};
lazyScripts.push('/js/embed.min.js?v=1.4.8');


</script>







</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            <span>博客内容遵循 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p>
            <span>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></span>
            <span>Du Yao's blog &copy; 2015 - 2017</span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://duyao.github.io/2017/03/24/juc之同步工具和并发容器/&title=《juc之同步工具和并发容器》 — Du Yao's blog&pic=http://duyao.github.io/img/yao.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://duyao.github.io/2017/03/24/juc之同步工具和并发容器/&title=《juc之同步工具和并发容器》 — Du Yao's blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://duyao.github.io/2017/03/24/juc之同步工具和并发容器/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《juc之同步工具和并发容器》 — Du Yao's blog&url=http://duyao.github.io/2017/03/24/juc之同步工具和并发容器/&via=http://duyao.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://duyao.github.io/2017/03/24/juc之同步工具和并发容器/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACuElEQVR42u3aQW7DQAgFUN//0qnUVaU2zgeGNpWeV1ES2fNmMWDguuLr8Xl9/fz9m/zzs/vkazh84eHh4bWW/uy6X0oVc//E6oYm98HDw8Pb4+XB4P6AngSDR3Dla8bDw8N7B17voE+2KdkyPDw8vP/Lu6fmKfi8IIKHh4f3t7yzh3vv6M+DwUqtBQ8PDy/mTQ7lv/q83t/Dw8PDa3XVkwZVtX1Vvc9otXh4eHgLvF5ptZo6z2HVKHAlj8HDw8Mb8HoliXtedUQgKUz8ajEXDw8P7wkvP+LvGXkSPBlESNbwwxsDHh4e3gKv2mTK0+vegEKSgkcBAw8PD2+NV3iljweq8tJDdSihUMjAw8PDW+ZVi629caikXJsXMl6sEw8PD2+NlxRGJ8lxXibuDQ0U9gkPDw/vKG9SLOg1qKr/LL8A4OHh4S3wqkMDk6O8Ws7Iv7nmUQUPDw9vzEsaYPkWVMschwMSHh4e3lHepM1fbVlNFl1NzfHw8PD2ePmie2GgOjjV28QX98TDw8M7yqs2wHr/z0cNklS+HPfw8PDwjvIm7f+EUb3/Rj0WDw8Pb4NXTWqrxdkcn9+5MBCGh4eHd5TXa3r1Eug8Lc4368VK8PDw8BZ41Z+rpYr5SMG8zYaHh4e3wasOP1Xz1SRlzxPu6hbg4eHhneXNSwzJEECvrpxvd7m/h4eHh3eU1ysH9MLA/XKrKXU0dIWHh4c35p1q6ucl4LzZdp298PDw8A7xHsUr34h5C60aNqICLh4eHt6Ydyps9Ia0eoXjlXCCh4eHV+TlwaCXaleHDPIMOQoweHh4eGu8JBgkaW5vrCoPOfk68fDw8N6B12tBTYYDDpSe8fDw8N6Sl4wXJM/qhZAXT8fDw8Nb4/WS4zzJzgezJht0oNaCh4eHF7+z58nrdvngVBDCw8PDW+B9AMUHAycay+f6AAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };



</script>

<script src="/js/main.min.js?v=1.4.8"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.4.8" async></script>






<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


</body>
</html>
